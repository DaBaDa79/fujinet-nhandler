mads 2.1.0
Source: nos.s
     1 				        ;; nos FujiNet Operating System
     2 				        ;; Compile with MADS
     3
     4 				        ;; Authors: Thomas Cherryhomes
     5 				        ;;   <thom.cherryhomes@gmail.com>
     6
     7 				        ;; Michael Sternberg
     8 				        ;;   <mhsternberg@gmail.com>
     9
    10
    11 				        ;; Optimizations being done by djaybee!
    12 				        ;; Thank you so much!
    13
    14 				        ;; If SYNCALC is defined, then holes for Syncalc are inserted
    15 				;SYNCALC	=	1
    16 				        ;; If SYNCALD is defined, then CLI commands are removed
    17 				;SYNCALD	=	1
    18
    19 = 000A			DOSVEC  =   $0A         ; DOSVEC
    20 = 000C			DOSINI  =   $0C         ; DOSINI
    21
    22 				        ;; CURRENT IOCB IN ZERO PAGE
    23 = 0020			ZIOCB   =   $20         ; ZP IOCB
    24 = 0020			ZICHID  =   ZIOCB       ; ID
    25 = 0021			ZICDNO  =   ZIOCB+1     ; UNIT #
    26 = 0022			ZICCOM  =   ZIOCB+2     ; COMMAND
    27 = 0023			ZICSTA  =   ZIOCB+3     ; STATUS
    28 = 0024			ZICBAL  =   ZIOCB+4     ; BUF ADR LOW
    29 = 0025			ZICBAH  =   ZIOCB+5     ; BUF ADR HIGH
    30 = 0026			ZICPTL  =   ZIOCB+6     ; PUT ADDR L
    31 = 0027			ZICPTH  =   ZIOCB+7     ; PUT ADDR H
    32 = 0028			ZICBLL  =   ZIOCB+8     ; BUF LEN LOW
    33 = 0029			ZICBLH  =   ZIOCB+9     ; BUF LEN HIGH
    34 = 002A			ZICAX1  =   ZIOCB+10    ; AUX 1
    35 = 002B			ZICAX2  =   ZIOCB+11    ; AUX 2
    36 = 002C			ZICAX3  =   ZIOCB+12    ; AUX 3
    37 = 002D			ZICAX4  =   ZIOCB+13    ; AUX 4
    38 = 002E			ZICAX5  =   ZIOCB+14    ; AUX 5
    39 = 002F			ZICAX6  =   ZIOCB+15    ; AUX 6
    40
    41 = 0052			LMARGN  =   $52         ; Left margin
    42 = 00D4			FR0     =   $D4         ; Floating Point register 0 (used during Hex->ASCII conversion)
    43 = 00F2			CIX     =   $F2         ; Inbuff cursor
    44 = 00F3			INBUFF  =   $F3         ; Ptr to input buffer ($0580)
    45
    46 				;---------------------------------------
    47 				; INTERRUPT VECTORS
    48 				; AND OTHER PAGE 2 VARS
    49 				;---------------------------------------
    50
    51 = 0202			VPRCED  =   $0202       ; PROCEED VCTR
    52 = 02C6			COLOR2  =   $02C6       ; MODEF BKG C
    53 = 02E0			RUNAD   =   $02E0       ; RUN ADDRESS
    54 = 02E2			INITAD  =   $02E2       ; INIT ADDRESS
    55 = 02E7			MEMLO   =   $02E7       ; MEM LO
    56 = 02EA			DVSTAT  =   $02EA       ; 4 BYTE STATS
    57
    58 				;---------------------------------------
    59 				; PAGE 3
    60 				; DEVICE CONTROL BLOCK (DCB)
    61 				;---------------------------------------
    62
    63 = 0300			DCB     =   $0300       ; BASE
    64 = 0300			DDEVIC  =   DCB         ; DEVICE #
    65 = 0301			DUNIT   =   DCB+1       ; UNIT #
    66 = 0302			DCOMND  =   DCB+2       ; COMMAND
    67 = 0303			DSTATS  =   DCB+3       ; STATUS/DIR
    68 = 0304			DBUFL   =   DCB+4       ; BUF ADR L
    69 = 0305			DBUFH   =   DCB+5       ; BUF ADR H
    70 = 0306			DTIMLO  =   DCB+6       ; TIMEOUT (S)
    71 = 0307			DRSVD   =   DCB+7       ; NOT USED
    72 = 0308			DBYTL   =   DCB+8       ; BUF LEN L
    73 = 0309			DBYTH   =   DCB+9       ; BUF LEN H
    74 = 030A			DAUXL   =   DCB+10      ; AUX BYTE L
    75 = 030B			DAUXH   =   DCB+11      ; AUX BYTE H
    76
    77 = 031A			HATABS  =   $031A       ; HANDLER TBL
    78
    79 				;---------------------------------------
    80 				; IOCB'S * 8
    81 				;---------------------------------------
    82
    83 = 0340			IOCB    =   $0340       ; IOCB BASE
    84 = 0340			ICHID   =   IOCB        ; ID
    85 = 0341			ICDNO   =   IOCB+1      ; UNIT #
    86 = 0342			ICCOM   =   IOCB+2      ; COMMAND
    87 = 0343			ICSTA   =   IOCB+3      ; STATUS
    88 = 0344			ICBAL   =   IOCB+4      ; BUF ADR LOW
    89 = 0345			ICBAH   =   IOCB+5      ; BUF ADR HIGH
    90 = 0346			ICPTL   =   IOCB+6      ; PUT ADDR L
    91 = 0347			ICPTH   =   IOCB+7      ; PUT ADDR H
    92 = 0348			ICBLL   =   IOCB+8      ; BUF LEN LOW
    93 = 0349			ICBLH   =   IOCB+9      ; BUF LEN HIGH
    94 = 034A			ICAX1   =   IOCB+10     ; AUX 1
    95 = 034B			ICAX2   =   IOCB+11     ; AUX 2
    96 = 034C			ICAX3   =   IOCB+12     ; AUX 3
    97 = 034D			ICAX4   =   IOCB+13     ; AUX 4
    98 = 034E			ICAX5   =   IOCB+14     ; AUX 5
    99 = 034F			ICAX6   =   IOCB+15     ; AUX 6
   100
   101 = 0054			ROWCRS  =   $0054
   102 = 02BB			SCRFLG  =   $02BB       ; Scroll flag
   103 = 02FC			CH      =   $02FC       ; Hardware code for last key pressed
   104 = 02F2			CH1     =   $02F2       ; Prior keyboard character code
   105 = 0582			LNBUF   =   $0582       ; Line Buffer (128 bytes)
   106
   107 				;---------------------------------------
   108 				; HARDWARE REGISTERS
   109 				;---------------------------------------
   110
   111 = D301			PORTB   =   $D301       ; On XL/XE, used to enable/disable BASIC
   112 = D302			PACTL   =   $D302       ; PIA CTRL A
   113
   114 				;---------------------------------------
   115 				; MATH PACK VECTORS
   116 				;---------------------------------------
   117 = D8E6			FASC    =   $D8E6       ; Floating point to ASCII
   118 = D9AA			IFP     =   $D9AA       ; Integer to floating point
   119
   120 				;---------------------------------------
   121 				; OS ROM VECTORS
   122 				;---------------------------------------
   123
   124 = E456			CIOV    =   $E456       ; CIO ENTRY
   125 = E459			SIOV    =   $E459       ; SIO ENTRY
   126 = E474			WARMSV  =   $E474       ; Warmstart entry point
   127 = E477			COLDSV  =   $E477       ; Coldstart entry point
   128
   129 				;---------------------------------------
   130 				; CONSTANTS
   131 				;---------------------------------------
   132
   133 = 0005			GETREC  =   $05         ; CIO CMD TO GET RECORD
   134 = 0009			PUTREC  =   $09         ; CIO CMD TO PUT RECORD
   135 = 000B			PUTCHR  =   $0B         ; CIO CMD TO PUT CHAR
   136
   137 = 0071			DEVIDN  =   $71         ; SIO DEVID
   138 = 0040			DSREAD  =   $40         ; FUJI->ATARI
   139 = 0080			DSWRIT  =   $80         ; ATARI->FUJI
   140 = 0004			MAXDEV  =   4           ; # OF N: DEVS
   141 = 0088			EOF     =   $88         ; ERROR 136
   142
   143 = 009B			EOL     =   $9B         ; EOL CHAR
   144 = 000D			CR      =   $0D         ; Carrige Return
   145 = 000A			LF      =   $0A         ; Linefeed
   146
   147 = 001C			ESC_KEY =   $1C         ; Hardware code for ESC
   148 = 0021			SPC_KEY =   $21         ; Hardware code for SPACE
   149
   150 = 0004			OINPUT  =   $04         ; CIO/SIO direction
   151 = 0008			OOUTPUT =   $08         ; CIO/SIO direction
   152
   153 				; FujiNet SIO command bytes
   154 = 0001			CMD_DRIVE_CHG       = $01
   155 = 002C			CMD_CD              = $2C
   156 = 00A1			CMD_COPY            = $A1
   157 = 0002			CMD_DIR             = $02
   158 = 0021			CMD_DEL             = $21
   159 = 0028			CMD_LOAD            = $28
   160 = 0023			CMD_LOCK            = $23
   161 = 002A			CMD_MKDIR           = $2A
   162 = 0030			CMD_NPWD            = $30
   163 = 0054			CMD_NTRANS          = 'T'
   164 = 0020			CMD_RENAME          = $20
   165 = 002B			CMD_RMDIR           = $2B
   166 = 00F0			CMD_SOURCE          = $F0
   167 = 00F0			CMD_TYPE            = $F0
   168 = 0024			CMD_UNLOCK          = $24
   169 = 00F0			CMD_CAR             = $F0
   170 = 00F0			CMD_CLS             = $F0
   171 = 00F0			CMD_COLD            = $F0
   172 = 00F0			CMD_HELP            = $F0
   173 = 00F0			CMD_NOBASIC         = $F0
   174 = 00F0			CMD_NOSCREEN        = $F0
   175 = 00F0			CMD_PRINT           = $F0
   176 = 00F0			CMD_REENTER         = $F0
   177 = 00F0			CMD_REM             = $F0
   178 = 00F0			CMD_RUN             = $F0
   179 = 00F0			CMD_SCREEN          = $F0
   180 = 00F0			CMD_WARM            = $F0
   181
   182 				;;; Macros ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   183
   184 				        .MACRO DCBC
   185 				        .LOCAL
   186 				        LDY     #$0C
   187 				?DCBL   LDA     %%1,Y
   188 				        STA     DCB,Y
   189 				        DEY
   190 				        BPL     ?DCBL
   191 				        .ENDL
   192 				        .ENDM
   193
   194 				; ATR Header
   195 					ORG	$6f0
   196 				        OPT     h-
   197 				;        ORG     $0700
   198 06F0 96 02 80 16 80		DTA	$96,$02,$80,$16,$80
   199 06F5 00 00 00 00 00 00 + 	:11 DTA	$00
   200
   201 				;;; Initialization ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   202
   203 				;        ORG     $0700
   204 				;        OPT     h-
   205
   206 0700 00			HDR:    .BYTE   $00                 ; BLFAG: Boot flag equals zero (unused)
   207 0701 1E			        .BYTE   [BOOTEND-HDR]/128   ; BRCNT: Number of consecutive sectors to read
   208 0702 00 07		        .WORD   HDR                 ; BLDADR: Boot sector load address ($700).
   209 0704 C0 E4		        .WORD   $E4C0               ; BIWTARR: Init addr (addr of RTS in ROM)
   210
   211 				;HDR:    .BYTE   $00                 ; BLFAG: Boot flag equals zero (unused)
   212 				;        .BYTE   [PGEND-HDR]/128-2   ; BRCNT: Number of consecutive sectors to read
   213 				;        .WORD   $0700               ; BLDADR: Boot sector load address ($700).
   214 				;        .WORD   $E4C0               ; BIWTARR: Init addr (addr of RTS in ROM)
   215
   216 0706 4C 09 07			JMP	START
   217 				;	ORG	*+$64
   218
   219 				.ifdef SYNCALC
   220 					:($076B-*) DTA $00
   221 				.endif
   222
   223 0709 A5 0C		START:  LDA     DOSINI
   224 070B 8D 27 07		        STA     RESET+1
   225 070E A5 0D		        LDA     DOSINI+1
   226 0710 8D 28 07		        STA     RESET+2
   227
   228 0713 A9 26		        LDA     #<RESET
   229 0715 85 0C		        STA     DOSINI
   230 0717 A9 07		        LDA     #>RESET
   231 0719 85 0D		        STA     DOSINI+1
   232 071B A9 CE		        LDA     #<DOS       ; Point to DOS & CP below
   233 071D 85 0A		        STA     DOSVEC
   234 071F A9 0A		        LDA     #>DOS
   235 0721 85 0B		        STA     DOSVEC+1
   236
   237 0723 4C 39 07		        JMP     ALTMEML     ; Alter MEMLO
   238
   239 0726 20 FF FF		RESET:  JSR     $FFFF       ; Jump to extant DOSINI
   240
   241 0729 A9 4E		        LDA     #'N'
   242 072B 8D 00 16		        STA     RBUF
   243 072E 20 44 07		        JSR     IHTBS       ; Insert into HATABS
   244
   245 0731 A9 44		        LDA     #'D'
   246 0733 8D 00 16		        STA     RBUF
   247 0736 20 44 07		        JSR     IHTBS       ; Clone N: as D: for compatibility
   248
   249 				;---------------------------------------
   250 				;  Alter MEMLO
   251 				;---------------------------------------
   252 0739			ALTMEML:
   253 0739 A9 00		        LDA     #<PGEND
   254 073B 8D E7 02		        STA     MEMLO
   255 073E A9 17		        LDA     #>PGEND
   256 0740 8D E8 02		        STA     MEMLO+1
   257
   258 				        ;; Back to DOS
   259
   260 0743 60			        RTS
   261
   262 				;---------------------------------------
   263 				; Insert entry into HATABS
   264 				;---------------------------------------
   265
   266 0744			IHTBS:
   267 0744 A0 00		        LDY     #$00
   268 0746 B9 1A 03		IH1     LDA     HATABS,Y
   269 0749 F0 0C		        BEQ     HFND
   270 				        ;CMP     #'N'
   271 074B CD 00 16		        CMP     RBUF
   272 074E F0 07		        BEQ     HFND
   273 0750 C8			        INY
   274 0751 C8			        INY
   275 0752 C8			        INY
   276 0753 C0 21		        CPY     #11*3
   277 0755 90 EF		        BCC     IH1
   278
   279 				        ;; Found a slot
   280
   281 0757			HFND:
   282 				        ;LDA     #'N'
   283 				;--
   284 0757 AD 00 16		        LDA     RBUF
   285 075A AA			        TAX
   286 				;--
   287 075B 99 1A 03		        STA     HATABS,Y
   288 075E A9 46		        LDA     #<CIOHND
   289 0760 99 1B 03		        STA     HATABS+1,Y
   290 0763 A9 15		        LDA     #>CIOHND
   291 0765 99 1C 03		        STA     HATABS+2,Y
   292
   293 0768 E0 44		        CPX     #'D'
   294 076A F0 01		        BEQ     HATABS_CONT
   295 076C 60			        RTS
   296
   297 076D			HATABS_CONT:
   298 				        ;; And we're done with HATABS
   299
   300 				        ;; Query FUJINET
   301
   302 076D 20 24 09		        JSR     STPOLL
   303
   304 				        ;; Output Ready/Error
   305
   306 0770			OBANR:
   307 0770 A2 00		        LDX     #$00        ; IOCB #0
   308 0772 A9 09		        LDA     #PUTREC
   309 0774 9D 42 03		        STA     ICCOM,X
   310 0777 A9 28		        LDA     #$28        ; 40 CHARS Max
   311 0779 9D 48 03		        STA     ICBLL,X
   312 077C 8A			        TXA
   313 077D 9D 49 03		        STA     ICBLH,X
   314 0780 AD 03 03		        LDA     DSTATS      ; Check DSTATS
   315 0783 10 06		        BPL     OBRDY       ; < 128 = Ready
   316
   317 				        ;; Status returned error.
   318
   319 0785			OBERR:
   320 0785 A9 6C		        LDA     #<BERROR
   321 0787 A0 15		        LDY     #>BERROR
   322 0789 50 04		        BVC     OBCIO
   323
   324 				        ;; Status returned ready.
   325
   326 078B			OBRDY:
   327 078B A9 52		        LDA     #<BREADY
   328 078D A0 15		        LDY     #>BREADY
   329
   330 078F			OBCIO:
   331 078F 9D 44 03		        STA     ICBAL,X
   332 0792 98			        TYA
   333 0793 9D 45 03		        STA     ICBAH,X
   334
   335 0796 20 56 E4		        JSR     CIOV
   336
   337 				        ;; Vector in proceed interrupt
   338
   339 0799			SPRCED:
   340 0799 A9 5D		        LDA     #<PRCVEC
   341 079B 8D 02 02		        STA     VPRCED
   342 079E A9 0A		        LDA     #>PRCVEC
   343 07A0 8D 03 02		        STA     VPRCED+1
   344
   345 				        ;; And we are done, back to DOS.
   346 07A3 18			        CLC
   347 07A4 60			        RTS
   348
   349 				;;; End Initialization Code ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   350
   351 				; Copy command's template DCB struct to OS's DCB struct (12 bytes)
   352 07A5			DOSIOV:
   353 07A5 8D AE 07		        STA     DODCBL+1
   354 07A8 8C AF 07		        STY     DODCBL+2
   355 07AB A0 0C		        LDY     #$0C
   356 07AD B9 FF FF		DODCBL  LDA     $FFFF,Y
   357 07B0 99 00 03		        STA     DCB,Y
   358 07B3 88			        DEY
   359 07B4 10 F7		        BPL     DODCBL
   360
   361 07B6			SIOVDST:
   362 07B6 20 59 E4		        JSR     SIOV
   363 07B9 AC 03 03		        LDY     DSTATS
   364 07BC 98			        TYA
   365 07BD 60			        RTS
   366
   367
   368 				;---------------------------------------
   369 				; CIO OPEN
   370 				;---------------------------------------
   371
   372 07BE			OPEN:
   373 				        ;; Prepare DCB
   374
   375 07BE 20 59 0A		        JSR     GDIDX       ; Get Device ID in X (0-3)
   376 07C1 A5 21		        LDA     ZICDNO      ; IOCB UNIT # (1-4)
   377 07C3 8D 01 08		        STA     OPNDCB+1    ; Store in DUNIT
   378 07C6 A5 24		        LDA     ZICBAL      ; Get filename buffer
   379 07C8 8D 04 08		        STA     OPNDCB+4    ; stuff in DBUF
   380 07CB A5 25		        LDA     ZICBAH      ; ...
   381 07CD 8D 05 08		        STA     OPNDCB+5    ; ...
   382 07D0 A5 2A		        LDA     ZICAX1      ; Get desired AUX1/AUX2
   383 07D2 8D 0A 08		        STA     OPNDCB+10   ; Save them, and store in DAUX1/DAUX2
   384 07D5 A5 2B		        LDA     ZICAX2      ; ...
   385 07D7 8D 0B 08		        STA     OPNDCB+11   ; ...
   386
   387 				        ;;  Copy DCB template to DCB
   388
   389 07DA A9 00		        LDA     #<OPNDCB
   390 07DC A0 08		        LDY     #>OPNDCB
   391
   392 				        ;;  Send to #FujiNet
   393
   394 07DE 20 A5 07		        JSR     DOSIOV
   395
   396 				        ;; Return DSTATS, unless 144, then get extended error
   397
   398 07E1			OPCERR:
   399 07E1 C0 90		        CPY     #$90        ; ERR 144?
   400 07E3 D0 06		        BNE     OPDONE      ; NOPE. RETURN DSTATS
   401
   402 				        ;; 144 - get extended error
   403
   404 07E5 20 24 09		        JSR     STPOLL      ; POLL FOR STATUS
   405 07E8 AC ED 02		        LDY     DVSTAT+3
   406
   407 				       ; RESET BUFFER LENGTH + OFFSET
   408
   409 07EB			OPDONE:
   410 07EB A9 01		        LDA     #$01
   411 07ED 8D 89 15		        STA     TRIP
   412 07F0 20 59 0A		        JSR     GDIDX
   413 07F3 A9 00		        LDA     #$00
   414 07F5 9D 8A 15		        STA     RLEN,X
   415 07F8 9D 92 15		        STA     TOFF,X
   416 07FB 9D 8E 15		        STA     ROFF,X
   417 07FE 98			        TYA
   418 07FF 60			        RTS                ; AY = ERROR
   419
   420 0800			OPNDCB:
   421 0800 71			        .BYTE   DEVIDN  ; DDEVIC
   422 0801 FF			        .BYTE   $FF     ; DUNIT
   423 0802 4F			        .BYTE   'O'     ; DCOMND
   424 0803 80			        .BYTE   $80     ; DSTATS
   425 0804 FF			        .BYTE   $FF     ; DBUFL
   426 0805 FF			        .BYTE   $FF     ; DBUFH
   427 0806 0F			        .BYTE   $0F     ; DTIMLO
   428 0807 00			        .BYTE   $00     ; DRESVD
   429 0808 00			        .BYTE   $00     ; DBYTL
   430 0809 01			        .BYTE   $01     ; DBYTH
   431 080A FF			        .BYTE   $FF     ; DAUX1
   432 080B FF			        .BYTE   $FF     ; DAUX2
   433
   434 				; End CIO OPEN
   435 				;---------------------------------------
   436
   437 				;---------------------------------------
   438 				; CIO CLOSE 
   439 				;---------------------------------------
   440
   441 080C			CLOSE:
   442 080C 20 50 0A		        JSR     DIPRCD      ; Disable Interrupts
   443 080F 20 59 0A		        JSR     GDIDX
   444 0812 20 AF 08		        JSR     PFLUSH      ; Do a Put Flush if needed.
   445
   446 0815 A5 21		        LDA     ZICDNO      ; IOCB Unit #
   447 0817 8D 22 08		        STA     CLODCB+1    ; to DCB...
   448
   449 081A A9 21		        LDA     #<CLODCB
   450 081C A0 08		        LDY     #>CLODCB
   451
   452 081E 4C A5 07		        JMP     DOSIOV
   453
   454 0821 71			CLODCB .BYTE    DEVIDN      ; DDEVIC
   455 0822 FF			       .BYTE    $FF         ; DUNIT
   456 0823 43			       .BYTE    'C'         ; DCOMND
   457 0824 00			       .BYTE    $00         ; DSTATS
   458 0825 00			       .BYTE    $00         ; DBUFL
   459 0826 00			       .BYTE    $00         ; DBUFH
   460 0827 0F			       .BYTE    $0F         ; DTIMLO
   461 0828 00			       .BYTE    $00         ; DRESVD
   462 0829 00			       .BYTE    $00         ; DBYTL
   463 082A 00			       .BYTE    $00         ; DBYTH
   464 082B 00			       .BYTE    $00         ; DAUX1
   465 082C 00			       .BYTE    $00         ; DAUX2
   466
   467 				; End CIO CLOSE
   468 				;---------------------------------------
   469
   470 				;---------------------------------------
   471 				; CIO GET
   472 				;---------------------------------------
   473
   474 082D 20 59 0A		GET:    JSR     GDIDX       ; IOCB UNIT #-1 into X
   475 0830 BD 8A 15		        LDA     RLEN,X      ; Get # of RX chars waiting
   476 0833 D0 2B		        BNE     GETDISC     ; LEN > 0?
   477
   478 				        ;; If RX buffer is empty, get # of chars waiting...
   479
   480 0835 20 24 09		        JSR     STPOLL      ; Status Poll
   481 0838 20 59 0A		        JSR     GDIDX       ; IOCB UNIT -1 into X (because Poll trashes X)
   482 083B AD EA 02		        LDA     DVSTAT      ; # of bytes waiting (0-127)
   483 083E 9D 8A 15		        STA     RLEN,X      ; Store in RX Len
   484 0841 F0 22		        BEQ     RETEOF
   485
   486 0843 A5 21		GETDO:  LDA     ZICDNO      ; Get IOCB UNIT #
   487 0845 8D 83 08		        STA     GETDCB+1    ; Store into DUNIT
   488 0848 AD EA 02		        LDA     DVSTAT      ; # of bytes waiting
   489 084B 8D 8A 08		        STA     GETDCB+8    ; Store into DBYT...
   490 084E 8D 8C 08		        STA     GETDCB+10   ; and DAUX1...
   491
   492 0851 A9 82		        LDA     #<GETDCB
   493 0853 A0 08		        LDY     #>GETDCB
   494
   495 0855 20 A5 07		        JSR     DOSIOV
   496
   497 				        ;; Clear the Receive buffer offset.
   498
   499 0858 20 59 0A		        JSR     GDIDX       ; IOCB UNIT #-1 into X
   500 085B A9 00		        LDA     #$00
   501 085D 9D 8E 15		        STA     ROFF,X
   502
   503 0860			GETDISC:
   504 				        ;LDA     DVSTAT+2    ; Did we disconnect?
   505 0860 AD ED 02		        LDA     DVSTAT+3    ; Did we disconnect?
   506 0863 D0 04		        BNE     GETUPDP     ; nope, update the buffer cursor.
   507
   508 				        ;; We disconnected, emit an EOF.
   509
   510 0865			RETEOF:
   511 0865 A0 88		        LDY     #EOF
   512 0867 98			        TYA
   513 0868 60			        RTS                 ; buh-bye.
   514
   515 0869			GETUPDP:
   516 0869 DE 8A 15		        DEC     RLEN,X      ; Decrement RX length.
   517 086C BC 8E 15		        LDY     ROFF,X      ; Get RX offset cursor.
   518
   519 				        ;; Return Next char from appropriate RX buffer.
   520
   521 086F B9 00 16		        LDA     RBUF,Y
   522
   523 				        ;; Increment RX offset
   524
   525 0872 FE 8E 15		GX:     INC     ROFF,X      ; Increment RX offset.
   526 0875 A8			        TAY                 ; stuff returned val into Y temporarily.
   527
   528 				        ;; If requested RX buffer is empty, reset TRIP.
   529
   530 0876 BD 8A 15		        LDA     RLEN,X
   531 0879 D0 03		        BNE     GETDONE
   532 087B 8D 89 15		        STA     TRIP
   533
   534 				        ;; Return byte back to CIO.
   535
   536 087E			GETDONE:
   537 087E 98			        TYA                 ; Move returned val back.
   538 087F A0 01		        LDY     #$01        ; SUCCESS
   539
   540 0881 60			        RTS                 ; DONE...
   541
   542 0882			GETDCB:
   543 0882 71			       .BYTE    DEVIDN      ; DDEVIC
   544 0883 FF			       .BYTE    $FF         ; DUNIT
   545 0884 52			       .BYTE    'R'         ; DCOMND
   546 0885 40			       .BYTE    $40         ; DSTATS
   547 0886 00			       .BYTE    <RBUF       ; DBUFL
   548 0887 16			       .BYTE    >RBUF       ; DBUFH
   549 0888 0F			       .BYTE    $0F         ; DTIMLO
   550 0889 00			       .BYTE    $00         ; DRESVD
   551 088A FF			       .BYTE    $FF         ; DBYTL
   552 088B 00			       .BYTE    $00         ; DBYTH
   553 088C FF			       .BYTE    $FF         ; DAUX1
   554 088D 00			       .BYTE    $00         ; DAUX2
   555
   556 				; End CIO GET
   557 				;---------------------------------------
   558
   559 				;---------------------------------------
   560 				; CIO PUT
   561 				;---------------------------------------
   562
   563 088E			PUT:    ;; Add to TX buffer.
   564
   565 088E 20 59 0A		        JSR     GDIDX
   566 0891 BC 92 15		        LDY     TOFF,X      ; GET TX cursor.
   567 0894 99 80 16		        STA     TBUF,Y      ; TX Buffer
   568
   569 0897 FE 92 15		POFF:   INC     TOFF,X      ; Increment TX cursor
   570 089A A0 01		        LDY     #$01        ; SUCCESSFUL
   571
   572 				        ;; Do a PUT FLUSH if EOL or buffer full.
   573
   574 089C C9 9B		        CMP     #EOL        ; EOL?
   575 089E F0 0B		        BEQ     FLUSH       ; FLUSH BUFFER
   576 08A0 20 59 0A		        JSR     GDIDX       ; GET OFFSET
   577 08A3 BD 92 15		        LDA     TOFF,X
   578 08A6 C9 7F		        CMP     #$7F        ; LEN = $FF?
   579 08A8 F0 01		        BEQ     FLUSH       ; FLUSH BUFFER
   580 08AA 60			        RTS
   581
   582 				       ; FLUSH BUFFER, IF ASKED.
   583
   584 08AB 20 AF 08		FLUSH:  JSR     PFLUSH      ; FLUSH BUFFER
   585 08AE 60			        RTS
   586
   587 08AF			PFLUSH:
   588
   589 				       ; CHECK CONNECTION, AND EOF
   590 				       ; IF DISCONNECTED.
   591
   592 08AF 20 24 09		        JSR     STPOLL      ; GET STATUS
   593 08B2 AD ED 02		        LDA     DVSTAT+3
   594 08B5 F0 AE		        BEQ     RETEOF
   595
   596 08B7 20 59 0A		PF1:    JSR     GDIDX       ; GET DEV X
   597 08BA BD 92 15		        LDA     TOFF,X
   598 08BD D0 03		        BNE     PF2
   599 08BF 4C DF 08		        JMP     PDONE
   600
   601 				       ; FILL OUT DCB FOR PUT FLUSH
   602
   603 08C2 A5 21		PF2:    LDA     ZICDNO
   604 08C4 8D E3 08		        STA     PUTDCB+1
   605
   606 				       ; FINISH DCB AND DO SIOV
   607
   608 08C7 BD 92 15		TBX:    LDA     TOFF,X
   609 08CA 8D EA 08		        STA     PUTDCB+8
   610 08CD 8D EC 08		        STA     PUTDCB+10
   611
   612 08D0 A9 E2		        LDA     #<PUTDCB
   613 08D2 A0 08		        LDY     #>PUTDCB
   614 08D4 20 A5 07		        JSR     DOSIOV
   615
   616 				        ; CLEAR THE OFFSET CURSOR
   617 				        ; AND LENGTH
   618
   619 08D7 20 59 0A		        JSR     GDIDX
   620 08DA A9 00		        LDA     #$00
   621 08DC 9D 92 15		        STA     TOFF,X
   622
   623 08DF A0 01		PDONE:  LDY     #$01
   624 08E1 60			        RTS
   625
   626 08E2 71			PUTDCB .BYTE    DEVIDN      ; DDEVIC
   627 08E3 FF			       .BYTE    $FF         ; DUNIT
   628 08E4 57			       .BYTE    'W'         ; DCOMND
   629 08E5 80			       .BYTE    $80         ; DSTATS
   630 08E6 80			       .BYTE    $80         ; DBUFL
   631 08E7 16			       .BYTE    >TBUF       ; DBUFH
   632 08E8 0F			       .BYTE    $0F         ; DTIMLO
   633 08E9 00			       .BYTE    $00         ; DRESVD
   634 08EA FF			       .BYTE    $FF         ; DBYTL
   635 08EB 00			       .BYTE    $00         ; DBYTH
   636 08EC FF			       .BYTE    $FF         ; DAUX1
   637 08ED 00			       .BYTE    $00         ; DAUX2
   638
   639 				; End CIO PUT
   640 				;---------------------------------------
   641
   642 				;---------------------------------------
   643 				; CIO STATUS 
   644 				;---------------------------------------
   645
   646 08EE 20 47 0A		STATUS: JSR     ENPRCD      ; ENABLE PRCD
   647 08F1 20 59 0A		        JSR     GDIDX       ; GET DEVICE#
   648 08F4 BD 8A 15		        LDA     RLEN,X      ; GET RLEN
   649 08F7 D0 05		        BNE     STSLEN      ; RLEN > 0?
   650 08F9 AD 89 15		        LDA     TRIP
   651 08FC D0 15		        BNE     STTRI1      ; TRIP = 1?
   652
   653 				        ; NO TRIP, RETURN SAVED LEN
   654
   655 08FE BD 8A 15		STSLEN: LDA     RLEN,X      ; GET RLEN
   656 0901 8D EA 02		        STA     DVSTAT      ; RET IN DVSTAT
   657
   658 				        ; If you don't need to preserve Y then use it instead of A
   659 0904 A9 00		        LDA     #$00
   660 0906 8D EB 02		        STA     DVSTAT+1
   661
   662 				        ; and INY here
   663 0909 A9 01		        LDA     #$01
   664 090B 8D EC 02		        STA     DVSTAT+2
   665 090E 8D ED 02		        STA     DVSTAT+3
   666
   667 0911 D0 0B		        BNE     STDONE
   668
   669 				        ; DO POLL AND UPDATE RCV LEN
   670
   671 0913 20 24 09		STTRI1: JSR     STPOLL      ; POLL FOR ST
   672 0916 9D 8A 15		        STA     RLEN,X
   673
   674 				        ; UPDATE TRIP FLAG
   675
   676 0919 D0 03		STTRIU: BNE     STDONE
   677 091B 8D 89 15		        STA     TRIP        ; RLEN = 0
   678
   679 				        ; RETURN CONNECTED? FLAG.
   680
   681 091E AD EC 02		STDONE: LDA     DVSTAT+2
   682 0921 A0 01		        LDY     #$01
   683 0923 60			        RTS
   684
   685 				       ; ASK FUJINET FOR STATUS
   686
   687 0924			STPOLL:
   688 0924 A5 21		        LDA     ZICDNO      ; IOCB #
   689 0926 8D 49 09		        STA     STADCB+1
   690
   691 0929 A9 48		        LDA     #<STADCB
   692 092B A0 09		        LDY     #>STADCB
   693
   694 092D 20 A5 07		        JSR     DOSIOV
   695
   696 				        ;; > 127 bytes? make it 127 bytes.
   697
   698 0930 AD EB 02		        LDA     DVSTAT+1
   699 0933 D0 07		        BNE     STADJ
   700 0935 AD EA 02		        LDA     DVSTAT
   701 0938 30 02		        BMI     STADJ
   702 093A 50 08		        BVC     STP2        ; <= 127 bytes...
   703
   704 093C A9 7F		STADJ   LDA     #$7F
   705 093E 8D EA 02		        STA     DVSTAT
   706 				        
   707 0941 8D EB 02		        STA     DVSTAT+1
   708
   709 				       ; A = CONNECTION STATUS
   710
   711 0944 AD EC 02		STP2:   LDA     DVSTAT+2
   712 0947 60			        RTS
   713
   714 0948 71			STADCB: .BYTE   DEVIDN      ; DDEVIC
   715 0949 FF			        .BYTE   $FF         ; DUNIT
   716 094A 53			        .BYTE   'S'         ; DCOMND
   717 094B 40			        .BYTE   $40         ; DSTATS
   718 094C EA			        .BYTE   <DVSTAT     ; DBUFL
   719 094D 02			        .BYTE   >DVSTAT     ; DBUFH
   720 094E 0F			        .BYTE   $0F         ; DTIMLO
   721 094F 00			        .BYTE   $00         ; DRESVD
   722 0950 04			        .BYTE   $04         ; DBYTL
   723 0951 00			        .BYTE   $00         ; DBYTH
   724 0952 00			        .BYTE   $00         ; DAUX1
   725 0953 00			        .BYTE   $00         ; DAUX2
   726
   727 				; End CIO STATUS
   728 				;---------------------------------------
   729
   730 				;---------------------------------------
   731 				; CIO SPECIAL
   732 				;---------------------------------------
   733
   734 0954			SPEC:   ; HANDLE LOCAL COMMANDS.
   735
   736 0954 A5 22		        LDA     ZICCOM
   737 0956 C9 0F		        CMP     #$0F        ; 15 = FLUSH
   738 0958 D0 06		        BNE     S1          ; NO.
   739 095A 20 AF 08		        JSR     PFLUSH      ; DO FLUSH
   740 095D A0 01		        LDY     #$01        ; SUCCESS
   741 095F 60			        RTS
   742
   743 0960 C9 28		S1:     CMP     #40         ; 40 = LOAD AND EXECUTE
   744 0962 F0 03		        BEQ     S2          ; YES.
   745 0964 4C 68 09		        JMP     S3          ; NO. SKIP OVER spec40
   746
   747 0967 60			S2:     RTS
   748 				       ; HANDLE SIO COMMANDS.
   749 				       ; GET DSTATS FOR COMMAND
   750 0968			S3:
   751 0968 A5 21		        LDA     ZICDNO
   752 096A 8D B0 09		        STA     SPEDCB+1
   753 096D A5 22		        LDA     ZICCOM
   754 096F 8D B9 09		        STA     SPEDCB+10
   755
   756 0972 A9 AF		        LDA     #<SPEDCB
   757 0974 A0 09		        LDY     #>SPEDCB
   758 0976 20 A5 07		        JSR     DOSIOV
   759
   760 0979 30 0A		        BMI     :DSERR
   761
   762 				       ; WE GOT A DSTATS INQUIRY
   763 				       ; IF $FF, THE COMMAND IS
   764 				       ; INVALID
   765
   766 097B AD 96 15		DSOK:   LDA     INQDS
   767 097E C9 FF		        CMP     #$FF        ; INVALID?
   768 0980 D0 04		        BNE     DSGO        ; DO THE CMD
   769 0982 A0 92		        LDY     #$92        ; UNIMP CMD
   770 0984 98			        TYA
   771 0985			DSERR:
   772 0985 60			        RTS
   773
   774 				        ;; Do the special, since we want to pass in all the IOCB
   775 				        ;; Parameters to the DCB, This is being done long-hand.
   776
   777 0986 A5 22		DSGO:   LDA     ZICCOM
   778 0988 48			        PHA
   779 0989 A9 00		        LDA     #$00
   780 098B 48			        PHA
   781 098C AD 96 15		        LDA     INQDS
   782 098F 48			        PHA
   783 0990 A9 01		        LDA     #$01
   784 0992 48			        PHA
   785 0993 A5 24		        LDA     ZICBAL
   786 0995 48			        PHA
   787 0996 A5 2A		        LDA     ZICAX1
   788 0998 48			        PHA
   789 0999 A5 25		        LDA     ZICBAH
   790 099B 48			        PHA
   791 099C A5 2B		        LDA     ZICAX2
   792 099E 48			        PHA
   793 099F A0 03		        LDY     #$03
   794 09A1			DSGOL:
   795 09A1 68			        PLA
   796 09A2 99 08 03		        STA     DBYTL,Y
   797 09A5 68			        PLA
   798 09A6 99 02 03		        STA     DCOMND,Y
   799 09A9 88			        DEY
   800 09AA 10 F5		        BPL     DSGOL
   801
   802 09AC 4C B6 07		        JMP     SIOVDST
   803
   804 				        ;; Return DSTATS in Y and A
   805
   806 09AF 71			SPEDCB  .BYTE   DEVIDN      ; DDEVIC
   807 09B0 FF			        .BYTE   $FF         ; DUNIT
   808 09B1 FF			        .BYTE   $FF         ; DCOMND ; inq
   809 09B2 40			        .BYTE   $40         ; DSTATS
   810 09B3 96			        .BYTE   <INQDS      ; DBUFL
   811 09B4 15			        .BYTE   >INQDS      ; DBUFH
   812 09B5 0F			        .BYTE   $0F         ; DTIMLO
   813 09B6 00			        .BYTE   $00         ; DRESVD
   814 09B7 01			        .BYTE   $01         ; DBYTL
   815 09B8 00			        .BYTE   $00         ; DBYTH
   816 09B9 FF			        .BYTE   $FF         ; DAUX1
   817 09BA FF			        .BYTE   $FF         ; DAUX2
   818
   819 				; End CIO SPECIAL
   820 				;---------------------------------------
   821
   822 				.ifdef SYNCALC
   823 					:($0ABD-*) DTA $00
   824 				.endif
   825
   826 				;#######################################
   827 				;#                                     #
   828 				;#             CIO Functions           # 
   829 				;#                                     #
   830 				;#######################################
   831
   832
   833 				;---------------------------------------
   834 09BB			CIOCLOSE:
   835 				;---------------------------------------
   836 				    ; X must contain IOCB offset ($10,$20,..)
   837 09BB A9 0C		        LDA     #$0C            ; Close #1 first
   838 09BD 9D 42 03		        STA     ICCOM,X
   839 09C0 4C 56 E4		        JMP     CIOV
   840
   841 				;---------------------------------------
   842 09C3			CIOOPEN:
   843 				;---------------------------------------
   844 				    ; Input: 
   845 				    ; X = IOCB offset ($10,$20,..)
   846 				    ; Y = data direction (4=inp,8=out,12=i/o)
   847 				    ; INBUFF contains ICBAL/H
   848 09C3 A9 03		        LDA     #$03            ; 3 = CIO 'OPEN FILE'
   849 09C5 9D 42 03		        STA     ICCOM,X
   850 09C8 A5 F3		        LDA     INBUFF          ; Pointer to filename
   851 09CA 9D 44 03		        STA     ICBAL,X
   852 09CD A5 F4		        LDA     INBUFF+1        ; Pointer to filename
   853 09CF 9D 45 03		        STA     ICBAH,X
   854 09D2 98			        TYA
   855 09D3 9D 4A 03		        STA     ICAX1,X         ; Data direction
   856 09D6 A9 00		        LDA     #$00
   857 09D8 9D 4B 03		        STA     ICAX2,X         ; Unused
   858 09DB 20 56 E4		        JSR     CIOV            ; Call CIO
   859
   860 09DE			CIOOPEN_DONE:
   861 09DE 60			        RTS
   862
   863 				;---------------------------------------
   864 09DF			CIOSTATUS:
   865 				;---------------------------------------
   866 09DF A9 0D		        LDA     #$0D
   867 09E1 9D 42 03		        STA     ICCOM,X
   868 09E4 20 56 E4		        JSR     CIOV
   869 09E7 10 03		        BPL     CIOSTATUS_DONE
   870 09E9 20 96 0A		        JSR     PRINT_ERROR
   871
   872 09EC			CIOSTATUS_DONE:
   873 09EC 60			        RTS
   874 				        
   875
   876 				;---------------------------------------
   877 09ED			CIOGET:
   878 				;---------------------------------------
   879 				    ; Input: 
   880 				    ; X = IOCB offset ($10,$20,..)
   881 				    ; A = ICBLL
   882 				    ; Y = ICBLH
   883 				    ; INBUFF contains ICBAL/H
   884 09ED 48			        PHA                 ; Stash Buffer length Lo
   885 09EE A9 07		        LDA     #$07        ; GET BYTES command
   886 09F0 9D 42 03		        STA     ICCOM,X
   887 09F3 A5 F3		        LDA     INBUFF      ; Get buffer addr from pointer
   888 09F5 9D 44 03		        STA     ICBAL,X
   889 09F8 A5 F4		        LDA     INBUFF+1
   890 09FA 9D 45 03		        STA     ICBAH,X
   891 09FD 68			        PLA                 ; Retrieve Buffer length Lo
   892 09FE 9D 48 03		        STA     ICBLL,X
   893 0A01 98			        TYA                 ; Get Buffer length Hi
   894 0A02 9D 49 03		        STA     ICBLH,X
   895 0A05 20 56 E4		        JSR     CIOV        ; Bon voyage
   896 0A08 10 00		        BPL     CIOGET_DONE
   897 				;        JMP     PRINT_ERROR
   898
   899 0A0A			CIOGET_DONE:
   900 0A0A 60			        RTS
   901
   902 				;---------------------------------------
   903 0A0B			CIOPUT:
   904 				;---------------------------------------
   905 				    ; Input: 
   906 				    ; X = IOCB offset ($10,$20,..)
   907 				    ; A = ICBLL
   908 				    ; Y = ICBLH
   909 				    ; INBUFF contains ICBAL/H
   910 0A0B 48			        PHA                 ; Stash Buffer length Lo
   911 0A0C A9 0B		        LDA     #$0B        ; PUT BYTES command
   912 0A0E 9D 42 03		        STA     ICCOM,X
   913 0A11 A5 F3		        LDA     INBUFF      ; Get buffer addr from pointer
   914 0A13 9D 44 03		        STA     ICBAL,X
   915 0A16 A5 F4		        LDA     INBUFF+1
   916 0A18 9D 45 03		        STA     ICBAH,X
   917 0A1B 68			        PLA                 ; Retrieve Buffer length Lo
   918 0A1C 9D 48 03		        STA     ICBLL,X
   919 0A1F 98			        TYA                 ; Get Buffer length Hi
   920 0A20 9D 49 03		        STA     ICBLH,X
   921 0A23 20 56 E4		        JSR     CIOV        ; Bon voyage
   922 0A26 10 00		        BPL     CIOPUT_DONE
   923 				;        JMP     PRINT_ERROR
   924
   925 0A28			CIOPUT_DONE:
   926 0A28 60			        RTS
   927
   928 				;---------------------------------------
   929 0A29			CIOGETREC:
   930 				;---------------------------------------
   931 				    ; Input: 
   932 				    ; X = IOCB offset ($10,$20,..)
   933 				    ; A = ICBLL
   934 				    ; Y = ICBLH
   935 				    ; INBUFF contains ICBAL/H
   936 0A29 48			        PHA                 ; Stash Buffer length Lo
   937 0A2A A9 05		        LDA     #$05        ; GET RECORD command
   938 0A2C 9D 42 03		        STA     ICCOM,X
   939 0A2F A5 F3		        LDA     INBUFF      ; Get buffer addr from pointer
   940 0A31 9D 44 03		        STA     ICBAL,X
   941 0A34 A5 F4		        LDA     INBUFF+1
   942 0A36 9D 45 03		        STA     ICBAH,X
   943 0A39 68			        PLA                 ; Retrieve Buffer length Lo
   944 0A3A 9D 48 03		        STA     ICBLL,X
   945 0A3D 98			        TYA                 ; Get Buffer length Hi
   946 0A3E 9D 49 03		        STA     ICBLH,X
   947
   948 0A41 20 56 E4		        JSR     CIOV        ; Bon voyage
   949 0A44 10 00		        BPL     CIOGETREC_DONE
   950 				;        JMP     PRINT_ERROR
   951
   952 0A46			CIOGETREC_DONE:
   953 0A46 60			        RTS
   954
   955 				;#######################################
   956 				;#                                     #
   957 				;#          Utility Functions          #
   958 				;#                                     #
   959 				;#######################################
   960 				        ; ENABLE PROCEED INTERRUPT
   961
   962 0A47 AD 02 D3		ENPRCD: LDA     PACTL
   963 0A4A 09 01		        ORA     #$01        ; ENABLE BIT 0
   964 0A4C 8D 02 D3		        STA     PACTL
   965 0A4F 60			        RTS
   966
   967 				       ; DISABLE PROCEED INTERRUPT
   968
   969 0A50 AD 02 D3		DIPRCD: LDA     PACTL
   970 0A53 29 FE		        AND     #$FE        ; DISABLE BIT0
   971 0A55 8D 02 D3		        STA     PACTL
   972 0A58 60			        RTS
   973
   974 				       ; GET ZIOCB DEVNO - 1 INTO X
   975
   976 0A59 A6 21		GDIDX:  LDX     ZICDNO      ; IOCB UNIT #
   977 0A5B CA			        DEX                 ; - 1
   978 0A5C 60			        RTS
   979
   980 				;---------------------------------------
   981 				; Proceed Vector
   982 				;---------------------------------------
   983
   984 0A5D A9 01		PRCVEC: LDA     #$01
   985 0A5F 8D 89 15		        STA     TRIP
   986 0A62 68			        PLA
   987 0A63 40			        RTI
   988
   989 				; End Proceed Vector
   990 				;---------------------------------------
   991
   992 				;---------------------------------------
   993 				; Reset LNBUF
   994 				;---------------------------------------
   995 				; Normally this routine is at $DA51
   996 				; But some programs will bank-switch
   997 				; that portion of ROM to RAM
   998 				;---------------------------------------
   999
  1000 0A64 A9 05		LDBUFA: LDA     #$05
  1001 0A66 85 F4		        STA     INBUFF+1
  1002 				;        LDA     #$80
  1003 0A68 A9 82		        LDA     #$82
  1004 0A6A 85 F3		        STA     INBUFF
  1005 0A6C 60			        RTS
  1006
  1007 				; End Reset LNBUF
  1008 				;---------------------------------------
  1009
  1010 				;---------------------------------------
  1011 				; Skip spaces
  1012 				;---------------------------------------
  1013 				; Normally this routine is at $DBA1
  1014 				; But some programs will bank-switch
  1015 				; that portion of ROM to RAM
  1016 				;---------------------------------------
  1017
  1018 0A6D A4 F2		SKPSPC: LDY     CIX
  1019 0A6F A9 20		        LDA     #$20
  1020 0A71 D1 F3		@:      CMP     (INBUFF),Y
  1021 0A73 D0 03		        BNE     @+
  1022 0A75 C8			        INY
  1023 0A76 D0 F9		        BNE     @-
  1024 0A78 84 F2		@:      STY     CIX
  1025 0A7A 60			        RTS
  1026
  1027 				; End SKPSPC
  1028 				;---------------------------------------
  1029
  1030 				;---------------------------------------
  1031 				; Print EOL-terminated string
  1032 				; A: String Buffer Lo
  1033 				; Y: String Buffer Hi
  1034 				;---------------------------------------
  1035 0A7B			PRINT_STRING:
  1036
  1037 0A7B A2 00		        LDX     #$00
  1038 				    ;---------------------------------------
  1039 				    ; String Buffer
  1040 				    ;---------------------------------------
  1041 0A7D 9D 44 03		        STA     ICBAL,X
  1042 0A80 98			        TYA
  1043 0A81 9D 45 03		        STA     ICBAH,X
  1044
  1045 				    ;---------------------------------------
  1046 				    ; String Length
  1047 				    ;---------------------------------------
  1048 0A84 A9 80		        LDA     #$80
  1049 0A86 9D 48 03		        STA     ICBLL,X
  1050 0A89 A9 00		        LDA     #$00
  1051 0A8B 9D 49 03		        STA     ICBLH,X
  1052
  1053 				    ;---------------------------------------
  1054 				    ; Call to CIO
  1055 				    ;---------------------------------------
  1056 0A8E A9 09		        LDA     #PUTREC
  1057 0A90 9D 42 03		        STA     ICCOM,X
  1058 0A93 4C 56 E4		        JMP     CIOV
  1059
  1060 				;---------------------------------------
  1061 				; Print integer error number from DOSIOV
  1062 				; Y: Return code from DOSIOV
  1063 				;---------------------------------------
  1064 0A96			PRINT_ERROR:
  1065 0A96 C0 01		        CPY     #$01        ; Exit if success (1)
  1066 0A98 F0 33		        BEQ     PRINT_ERROR_DONE
  1067
  1068 				    ;-----------------------------------
  1069 				    ; If error code = 144, then get
  1070 				    ; extended code from DVSTAT
  1071 				    ;-----------------------------------
  1072 0A9A C0 90		        CPY     #144
  1073 0A9C D0 0A		        BNE     PRINT_ERROR_NEXT
  1074
  1075 0A9E A9 48		        LDA     #<STADCB
  1076 0AA0 A0 09		        LDY     #>STADCB
  1077 0AA2 20 A5 07		        JSR     DOSIOV
  1078 0AA5 AC ED 02		        LDY     DVSTAT+3    ;
  1079
  1080 0AA8			PRINT_ERROR_NEXT:
  1081 				    ;-----------------------------------
  1082 				    ; Convert error code to ASCII
  1083 				    ;-----------------------------------
  1084 0AA8 84 D4		        STY     FR0
  1085 0AAA A9 00		        LDA     #$00
  1086 0AAC 85 D5		        STA     FR0+1
  1087 0AAE 20 AA D9		        JSR     IFP         ; Convert error from int to floating point
  1088 0AB1 20 E6 D8		        JSR     FASC        ; Convert floating point to ASCII
  1089
  1090 				    ;---------------------------------------
  1091 				    ; Find last char in ASCII error (noted by high bit)
  1092 				    ; Unset high bit & append EOL
  1093 				    ;---------------------------------------
  1094 0AB4 A0 FF		        LDY     #$FF        ; Init counter = 0
  1095
  1096 0AB6 C8			@       INY
  1097 0AB7 B1 F3		        LDA     (INBUFF),Y
  1098 0AB9 C9 80		        CMP     #$80
  1099 0ABB 90 F9		        BCC     @-
  1100
  1101 0ABD 29 7F		        AND     #$7F        ; Clear high bit
  1102 0ABF 91 F3		        STA     (INBUFF),Y
  1103 0AC1 C8			        INY
  1104 0AC2 A9 9B		        LDA     #EOL        ; Append EOL
  1105 0AC4 91 F3		        STA     (INBUFF),Y
  1106
  1107 0AC6 A5 F3		        LDA     INBUFF
  1108 0AC8 A4 F4		        LDY     INBUFF+1
  1109 0ACA 4C 7B 0A		        JMP     PRINT_STRING
  1110
  1111 0ACD			PRINT_ERROR_DONE:
  1112 0ACD 60			        RTS
  1113
  1114 				; End Utility Functions
  1115 				;---------------------------------------
  1116
  1117
  1118 				;#######################################
  1119 				;#                                     #
  1120 				;#       COMMAND PROCESSOR (CP)        #
  1121 				;#                                     #
  1122 				;#######################################
  1123
  1124 				;---------------------------------------
  1125 				; DOS Entry point
  1126 				;---------------------------------------
  1127
  1128 0ACE 20 D4 0A		DOS:    JSR     CP          ; Command Processor
  1129 0AD1 4C CE 0A		        JMP     DOS         ; Keep looping
  1130
  1131 				;---------------------------------------
  1132 				; Main loop
  1133 				;---------------------------------------
  1134
  1135 0AD4			CP:
  1136 0AD4 A9 FF		        LDA     #$FF        ; Clear command
  1137 0AD6 8D 86 15		        STA     CMD
  1138
  1139 0AD9 20 E8 0A		        JSR     SHOWPROMPT
  1140 0ADC 20 0D 0B		        JSR     GETCMD
  1141 0ADF 20 7C 0B		        JSR     PARSECMD
  1142 0AE2 30 03		        BMI     CP_DONE     ; Skip DOCMD if CMD == $FF
  1143 0AE4 20 F2 0B		        JSR     DOCMD
  1144 0AE7			CP_DONE:
  1145 0AE7 60			        RTS
  1146
  1147 				;---------------------------------------
  1148 				; Show Command Prompt (Nn:)
  1149 				; Leading EOF requires special CIOV call
  1150 				;---------------------------------------
  1151
  1152 				;---------------------------------------
  1153 0AE8			SHOWPROMPT:
  1154 				;---------------------------------------
  1155
  1156 0AE8 AD 85 15		        LDA     DOSDR       ; Get the 1,2,... for N1,N2,...
  1157 0AEB 09 30		        ORA     #'0'        ; Convert, say, 1 to '1'
  1158 0AED 8D 3D 14		        STA     PRMPT+2     ; Store in after EOL and N
  1159
  1160 0AF0 A2 00		        LDX     #$00
  1161 0AF2 A9 0B		        LDA     #PUTCHR
  1162 0AF4 9D 42 03		        STA     ICCOM,X
  1163
  1164 0AF7 A9 3B		        LDA     #<PRMPT
  1165 0AF9 9D 44 03		        STA     ICBAL,X
  1166 0AFC A9 14		        LDA     #>PRMPT
  1167
  1168 0AFE 9D 45 03		        STA     ICBAH,X
  1169 0B01 A9 04		        LDA     #4          ; Prompt length = 4
  1170 0B03 9D 48 03		        STA     ICBLL,X
  1171 0B06 8A			        TXA                 ; Still zero
  1172 0B07 9D 49 03		        STA     ICBLH,X
  1173
  1174 0B0A 4C 56 E4		        JMP     CIOV
  1175
  1176 				;---------------------------------------
  1177 0B0D			GETCMD:
  1178 				;---------------------------------------
  1179 0B0D A2 00		        LDX     #$00
  1180 0B0F A9 05		        LDA     #GETREC
  1181 0B11 9D 42 03		        STA     ICCOM,X
  1182 0B14 A9 82		        LDA     #<LNBUF
  1183 0B16 9D 44 03		        STA     ICBAL,X
  1184 0B19 A9 05		        LDA     #>LNBUF
  1185 0B1B 9D 45 03		        STA     ICBAH,X
  1186 0B1E A9 7F		        LDA     #$7F
  1187 0B20 9D 48 03		        STA     ICBLL,X
  1188 0B23 20 56 E4		        JSR     CIOV
  1189
  1190 0B26			GETCMDTEST:
  1191 0B26 A0 00		        LDY #$00
  1192 0B28 84 F2		        STY CIX
  1193 0B2A 20 64 0A		        JSR LDBUFA      ; Reset LNBUF to $0580
  1194 0B2D 20 6D 0A		        JSR SKPSPC      ; Advance CIX to next space
  1195
  1196 				    ;---------------------------------------
  1197 				    ; CMDSEP is an sequence of bytes contains
  1198 				    ; indexes to chars following spaces
  1199 				    ; Iterate to clear CMDSEP bytes
  1200 				    ;---------------------------------------
  1201 0B30 98			        TYA                 ; A = 0
  1202 0B31 A2 02		        LDX     #$02        ; for X = 2 to 0 step -1
  1203 0B33			GETLOOP:
  1204 0B33 9D 78 0B		        STA     CMDSEP,X
  1205 0B36 CA			        DEX
  1206 0B37 10 FA		        BPL     GETLOOP     ; next X
  1207
  1208 				    ; Initial Delimiter to space
  1209 0B39 A9 20		        LDA     #' '
  1210 0B3B 8D 7B 0B		        STA     DELIM
  1211
  1212 				    ;---------------------------------------
  1213 				    ; Loop until EOL is encountered
  1214 				    ;---------------------------------------
  1215 0B3E E8			        INX                 ; Reset X to 0
  1216 0B3F			GETCMD_LOOP:
  1217 0B3F B1 F3		        LDA     (INBUFF),Y
  1218 0B41 C9 9B		        CMP     #EOL        ; Found EOL?
  1219 0B43 F0 32		        BEQ     GETCMD_DONE ; yes. skip
  1220 0B45 CD 7B 0B		        CMP     DELIM       ; Found space?
  1221 0B48 F0 03		        BEQ     GETCMD_REPL ; yes. Replace it
  1222 0B4A C8			        INY
  1223 0B4B D0 F2		        BNE     GETCMD_LOOP ; "always" non-zero
  1224
  1225 				    ;---------------------------------------
  1226 				    ; March through the cmd line and note
  1227 				    ; the positions of any args as delimited
  1228 				    ; by spaces or quotes. positions saved
  1229 				    ; in CMDSEP,X
  1230 				    ;---------------------------------------
  1231 0B4D			GETCMD_REPL:
  1232 0B4D A9 9B		        LDA     #EOL
  1233 0B4F 91 F3		        STA     (INBUFF),Y
  1234 0B51 C8			        INY
  1235 0B52 B1 F3		        LDA     (INBUFF),Y  ; Skip any run of spaces
  1236 0B54 C9 20		        CMP     #' '
  1237 0B56 F0 F5		        BEQ     GETCMD_REPL ; Keep skipping spaces
  1238
  1239 				    ; Here if any run of spaces has ended
  1240 				    ; Are we standing on a double-quote?
  1241 0B58 C9 22		        CMP     #'"'
  1242 0B5A D0 12		        BNE     GETCMD_WR_OFFSET  ; No. Skip ahead
  1243
  1244 				    ; Here if curr char is a double-quote
  1245 0B5C C8			        INY                 ; Advance the command line index
  1246 0B5D A9 22		        LDA     #'"'        ; Is the curr delim a double-quote?
  1247 0B5F CD 7B 0B		        CMP     DELIM       ; If not, change delim to double-quote
  1248 0B62 D0 07		        BNE     GETCMD_DQ_DELIM
  1249
  1250 				    ; Here if curr delim is a double-quote
  1251 				    ; Switch delim to space
  1252 0B64 A9 20		        LDA     #' '
  1253 0B66 8D 7B 0B		        STA     DELIM
  1254 0B69 D0 03		        BNE     GETCMD_WR_OFFSET
  1255
  1256 				    ; Here if curr delim is space
  1257 				    ; Switch delim to double-quote
  1258 0B6B			GETCMD_DQ_DELIM:
  1259 0B6B 8D 7B 0B		        STA     DELIM
  1260
  1261 				    ; Note the position for the curr command-line arg
  1262 0B6E			GETCMD_WR_OFFSET:
  1263 0B6E 98			        TYA
  1264 0B6F 9D 78 0B		        STA     CMDSEP,X
  1265 0B72 E8			        INX
  1266 0B73 E0 03		        CPX     #$03
  1267 0B75 90 C8		        BCC     GETCMD_LOOP ; Continue searching
  1268
  1269 0B77			GETCMD_DONE:
  1270 0B77 60			        RTS
  1271
  1272 				.ifdef SYNCALC
  1273 					:($0D15-*) DTA $00
  1274 				.endif
  1275
  1276 0B78 FF FF FF		CMDSEP: .BYTE $FF,$FF,$FF
  1277 0B7B 20			DELIM:  .BYTE ' '
  1278
  1279 				;---------------------------------------
  1280 0B7C			PARSECMD:
  1281 				;---------------------------------------
  1282 0B7C AD 82 05		        LDA     LNBUF
  1283 0B7F C9 9B		        CMP     #EOL        ; Quit immediately if no cmd
  1284 0B81 F0 09		        BEQ     PARSECMD_DONE
  1285
  1286 0B83 20 A1 0B		        JSR     PARSE_INTRINSIC_COMMAND
  1287 0B86 20 DB 0B		        JSR     PARSE_DRIVE_CHANGE
  1288 0B89 20 8D 0B		        JSR     PRINT_UNK_CMD
  1289 0B8C			PARSECMD_DONE:
  1290 0B8C 60			        RTS
  1291
  1292 0B8D			PRINT_UNK_CMD:
  1293 0B8D AD 86 15		        LDA     CMD
  1294 0B90 C9 FF		        CMP     #$FF
  1295 0B92 D0 07		        BNE     PRINT_UNK_CMD_DONE
  1296 0B94 A9 9C		        LDA     #<UNK_CMD_ERR
  1297 0B96 A0 0B		        LDY     #>UNK_CMD_ERR
  1298 0B98 20 7B 0A		        JSR     PRINT_STRING
  1299 0B9B			PRINT_UNK_CMD_DONE:
  1300 0B9B 60			        RTS
  1301
  1302 0B9C			UNK_CMD_ERR:
  1303 0B9C 43 4D 44 3F 9B	        .BYTE   'CMD?',EOL
  1304
  1305 				;---------------------------------------
  1306 0BA1			PARSE_INTRINSIC_COMMAND:
  1307 				;---------------------------------------
  1308 0BA1 A2 00		        LDX     #$00        ; Initialize X for command code indexing
  1309 0BA3 A0 00		        LDY     #$00
  1310 0BA5 84 F2		        STY     CIX
  1311 0BA7 20 64 0A		        JSR     LDBUFA      ; Set INBUFF to $0580
  1312 0BAA 20 6D 0A		        JSR     SKPSPC      ; Skip whitespace
  1313
  1314 0BAD			PARSE_INTRINSIC_NEXT_CHAR:
  1315 0BAD B1 F3		        LDA     (INBUFF),Y
  1316 0BAF 29 7F		        AND     #$7F
  1317 0BB1 5D 5A 14		        EOR     COMMAND,X   ; X initialized to 0 in caller
  1318 0BB4 C8			        INY
  1319 0BB5 0A			        ASL
  1320 0BB6 F0 0B		        BEQ     PARSE_INTRINSIC_CHAR_OK
  1321
  1322 				        ; Skip to next command
  1323
  1324 0BB8			PARSE_INTRINSIC_NEXT_COMMAND:
  1325 0BB8 BD 5A 14		        LDA     COMMAND,X
  1326 0BBB 0A			        ASL
  1327 0BBC E8			        INX
  1328 0BBD 90 F9		        BCC     PARSE_INTRINSIC_NEXT_COMMAND
  1329 0BBF A4 F2		        LDY     CIX
  1330 0BC1 E0 B4		        CPX     #COMMAND_SIZE
  1331
  1332 0BC3			PARSE_INTRINSIC_CHAR_OK:
  1333 0BC3 E8			        INX
  1334 0BC4 90 E7		        BCC     PARSE_INTRINSIC_NEXT_CHAR
  1335 0BC6 84 F2		        STY     CIX
  1336 0BC8 B1 F3		        LDA     (INBUFF),Y
  1337 0BCA 30 05		        BMI     PARSE_INTRINSIC_RET
  1338
  1339 0BCC 20 6D 0A		        JSR     SKPSPC
  1340
  1341 0BCF			PARSE_INTRINSIC_RET_ERROR:
  1342 0BCF A2 B5		        LDX     #COMMAND_SIZE+1
  1343 0BD1			PARSE_INTRINSIC_RET:
  1344 0BD1 BD 5A 14		        LDA     COMMAND,X
  1345 0BD4 8D 86 15		        STA     CMD
  1346 0BD7 8D 87 15		        STA     CMDPRV
  1347 0BDA			PARSE_INTRINSIC_DONE:
  1348 0BDA 60			        RTS
  1349
  1350 				; End of PARSE_INTRINSIC_COMMAND
  1351 				;---------------------------------------
  1352
  1353 				;---------------------------------------
  1354 0BDB			PARSE_DRIVE_CHANGE:
  1355 				;---------------------------------------
  1356 0BDB A2 03		        LDX     #$03        ; Check for EOL in pos 3
  1357 0BDD BD 82 05		        LDA     LNBUF,X
  1358 0BE0 C9 9B		        CMP     #EOL
  1359 0BE2 D0 0D		        BNE     PARSE_DRIVE_CHANGE_DONE
  1360 0BE4 CA			        DEX                 ; go back one char
  1361 0BE5 BD 82 05		        LDA     LNBUF,X
  1362 0BE8 C9 3A		        CMP     #':'        ; Check for colon.
  1363 0BEA D0 05		        BNE     PARSE_DRIVE_CHANGE_DONE
  1364 0BEC A9 1A		        LDA     #CMD_IDX.DRIVE_CHG
  1365 0BEE 8D 86 15		        STA     CMD
  1366 0BF1			PARSE_DRIVE_CHANGE_DONE:
  1367 0BF1 60			        RTS
  1368
  1369 				;---------------------------------------
  1370 0BF2			DOCMD:
  1371 				;---------------------------------------
  1372 0BF2 AE 86 15		        LDX     CMD
  1373 0BF5 30 08		        BMI     DOCMD_DONE      ; Unassigned command = $FF
  1374 0BF7 BD 2B 15		        LDA     CMD_TAB_H,X     ; Get hi-byte of subroutine's addr
  1375 0BFA 48			        PHA                     ; Push it to the stack
  1376 0BFB BD 10 15		        LDA     CMD_TAB_L,X     ; Get lo-byte of subroutine's addr
  1377 0BFE 48			        PHA                     ; Push it to the stack
  1378 0BFF			DOCMD_DONE:
  1379 0BFF 60			        RTS                     ; Use stack & RTS to jump to subroutine
  1380
  1381 				; End of DOCMD
  1382 				;---------------------------------------
  1383
  1384 				;---------------------------------------
  1385 0C00			DO_DRIVE_CHG:
  1386 				;---------------------------------------
  1387 0C00 AD 82 05		        LDA     LNBUF
  1388 0C03 8D 3C 14		        STA     PRMPT+1
  1389 0C06 AD 83 05		        LDA     LNBUF+1
  1390 0C09 C9 31		        CMP     #'1'        ; Skip if '0' or less
  1391 0C0B 90 0A		        BCC     DO_DRIVE_CHG_ERROR
  1392 0C0D C9 39		        CMP     #'9'        ; Skip if '9' or more
  1393 0C0F B0 06		        BCS     DO_DRIVE_CHG_ERROR
  1394 0C11 29 0F		        AND     #$0F        ; Convert, say, to 1-8
  1395 0C13 8D 85 15		        STA     DOSDR
  1396 0C16 60			        RTS
  1397 0C17			DO_DRIVE_CHG_ERROR:
  1398 0C17 A9 7B		        LDA     #<CDERR
  1399 0C19 A0 15		        LDY     #>CDERR
  1400 0C1B 4C 7B 0A		        JMP     PRINT_STRING
  1401
  1402 				; End of DOCMD
  1403
  1404 				;---------------------------------------
  1405 				; Returns DOSDR in X
  1406 				; If arg1 contains Nn: then reg X = n
  1407 				; Otherwise X = DOSDR (from curr prompt)
  1408 				;---------------------------------------
  1409 0C1E			GET_DOSDR:
  1410 				;---------------------------------------
  1411
  1412 0C1E 20 64 0A		        JSR     LDBUFA      ; Reset INBUFF to LNBUF
  1413 0C21 AE 85 15		        LDX     DOSDR       ; Set DUNIT(X) to curr drive
  1414
  1415 				    ;---------------------------------------
  1416 				    ; Consider arg1 = N2:TNFS://localhost/
  1417 				    ; Check arg1 for ":" in 3rd position
  1418 				    ; if found then use char in 2nd position ('2') as DOSDR
  1419 				    ; First, change INBUFF to point to beg. of 1st arg
  1420 				    ;---------------------------------------
  1421 0C24 AD 78 0B		        LDA     CMDSEP              ; arg offset
  1422 0C27 F0 17		        BEQ     GET_DOSDR_DONE      ; first, if arg1 not pop, leave X as-is & quit
  1423
  1424 0C29 18			        CLC                         ; Advance pointer to LNBUF
  1425 0C2A 65 F3		        ADC     INBUFF
  1426 0C2C 85 F3		        STA     INBUFF
  1427 0C2E 90 02		        BCC     GET_DOSDR_NEXT
  1428 0C30 E6 F4		        INC     INBUFF+1
  1429
  1430 0C32			GET_DOSDR_NEXT:
  1431 0C32 A0 02		        LDY     #$02            ; Check for ':' in 3rd pos
  1432 0C34 B1 F3		        LDA     (INBUFF),Y
  1433 0C36 C9 3A		        CMP     #':'
  1434 0C38 D0 06		        BNE     GET_DOSDR_DONE  ; Not found, skip & use default
  1435 0C3A 88			        DEY
  1436 0C3B B1 F3		        LDA     (INBUFF),Y
  1437 0C3D 29 0F		        AND     #$0F            ; Convert, say, '2' to 2
  1438 0C3F AA			        TAX                     ; Return DOSDR in X
  1439
  1440 0C40			GET_DOSDR_DONE:
  1441 0C40 60			        RTS
  1442
  1443 				;---------------------------------------
  1444 0C41			DO_GENERIC:
  1445 				;---------------------------------------
  1446
  1447 				    ;---------------------------------------
  1448 				    ; SIO call for NCD,{MK,RM}DIR,DEL,RENAME
  1449 				    ;---------------------------------------
  1450
  1451 				    ;---------------------------------------
  1452 				    ; Get Fujinet SIO command (~ $21 for DEL)
  1453 				    ; X = table index from caller
  1454 				    ;---------------------------------------
  1455 0C41 BD 3F 14		        LDA     CMD_DCOMND,X
  1456 0C44 8D A4 0C		        STA     GENDCB+2
  1457
  1458 				    ;---------------------------------------
  1459 				    ; Get DOSDR from either arg1 or curr drive
  1460 				    ;---------------------------------------
  1461 0C47 20 1E 0C		        JSR     GET_DOSDR    ; X will contain int of n in Nn:
  1462 0C4A 8E A3 0C		        STX     GENDCB+1
  1463 0C4D 20 E7 13		        JSR     PREPEND_DRIVE
  1464
  1465 				    ;---------------------------------------
  1466 				    ; If this is NCD ensure a '/' char is the last char
  1467 				    ;---------------------------------------
  1468 0C50 AD A4 0C		        LDA     GENDCB+2
  1469 0C53 C9 2C		        CMP     #CMD_CD         ; Is this an NCD command?
  1470 0C55 D0 08		        BNE     DO_GENERIC_NEXT ; No. skip
  1471
  1472 0C57 AD 78 0B		        LDA     CMDSEP
  1473 0C5A F0 2C		        BEQ     NCD_ERROR
  1474 0C5C 20 14 14		        JSR     APPEND_SLASH    ; Append '/' to path if missing
  1475
  1476 0C5F			DO_GENERIC_NEXT:
  1477 				    ;---------------------------------------
  1478 				    ; Populate the DCB
  1479 				    ;---------------------------------------
  1480 0C5F AD 85 15		        LDA     DOSDR
  1481 0C62 8D 49 09		        STA     STADCB+1
  1482 0C65 A5 F3		        LDA     INBUFF
  1483 0C67 8D A6 0C		        STA     GENDCB+4
  1484 0C6A A5 F4		        LDA     INBUFF+1
  1485 0C6C 8D A7 0C		        STA     GENDCB+5
  1486
  1487 				    ;---------------------------------------
  1488 				    ; Send the command to FujiNet
  1489 				    ;---------------------------------------
  1490 0C6F A9 A2		        LDA     #<GENDCB
  1491 0C71 A0 0C		        LDY     #>GENDCB
  1492 0C73 20 A5 07		        JSR     DOSIOV
  1493 0C76 20 96 0A		        JSR     PRINT_ERROR
  1494
  1495 0C79			GEN_UNMOUNT:
  1496 				    ;---------------------------------------
  1497 				    ; if DEL or RENAME, then remount drive
  1498 				    ;---------------------------------------
  1499 0C79 AD 87 15		        LDA     CMDPRV
  1500 0C7C C9 03		        CMP     #CMD_IDX.DEL
  1501 0C7E F0 04		        BEQ     GEN_REMOUNT
  1502 0C80 C9 09		        CMP     #CMD_IDX.RENAME
  1503 0C82 D0 03		        BNE     GENDONE
  1504 0C84			GEN_REMOUNT:
  1505 0C84 4C B4 13		        JMP     REMOUNT_DRIVE
  1506
  1507 0C87			GENDONE:
  1508 0C87 60			        RTS
  1509
  1510 				;---------------------------------------
  1511 0C88			NCD_ERROR:
  1512 				;---------------------------------------
  1513 0C88 A9 9C		        LDA     #<NCD_ERROR_STR
  1514 0C8A A0 0C		        LDY     #>NCD_ERROR_STR
  1515 0C8C 20 7B 0A		        JSR     PRINT_STRING
  1516 0C8F A0 01		        LDY     #$01        ; Return error
  1517 0C91 60			        RTS
  1518 				    ;---------------------------------------
  1519 				    ; Close 
  1520 				    ;---------------------------------------
  1521 0C92 A2 10		        LDX     #$10            ; File #1
  1522 0C94 A9 0C		        LDA     #$0C            ; Close #1 first
  1523 0C96 9D 42 03		        STA     ICCOM,X
  1524 0C99 20 56 E4		        JSR     CIOV
  1525
  1526 0C9C			NCD_ERROR_STR:
  1527 0C9C 50 41 54 48 3F 9B	        .BYTE   'PATH?',EOL
  1528
  1529 				;---------------------------------------
  1530 0CA2			GENDCB:
  1531 0CA2 71			        .BYTE      DEVIDN  ; DDEVIC
  1532 0CA3 FF			        .BYTE      $FF     ; DUNIT
  1533 0CA4 FF			        .BYTE      $FF     ; DCOMND
  1534 0CA5 80			        .BYTE      $80     ; DSTATS
  1535 0CA6 FF			        .BYTE      $FF     ; DBUFL
  1536 0CA7 FF			        .BYTE      $FF     ; DBUFH
  1537 0CA8 1F			        .BYTE      $1F     ; DTIMLO
  1538 0CA9 00			        .BYTE      $00     ; DRESVD
  1539 0CAA 00			        .BYTE      $00     ; DBYTL
  1540 0CAB 01			        .BYTE      $01     ; DBYTH
  1541 0CAC 00			        .BYTE      $00     ; DAUX1
  1542 0CAD 00			        .BYTE      $00     ; DAUX2
  1543
  1544 				; End of DO_GENERIC
  1545 				;---------------------------------------
  1546
  1547 				;;---------------------------------------
  1548 				;DO_COPY:
  1549 				;;---------------------------------------
  1550 				;
  1551 				;        LDA     #$20
  1552 				;        STA     COLOR2
  1553 				;
  1554 				;        LDA     #<CPYDCB
  1555 				;        LDY     #>CPYDCB
  1556 				;        JSR     DOSIOV
  1557 				;
  1558 				;        LDA     #$20
  1559 				;        STA     COLOR2
  1560 				;
  1561 				;        RTS
  1562 				;
  1563 				;CPYDCB:
  1564 				;        .BYTE      DEVIDN  ; DDEVIC
  1565 				;        .BYTE      $FF     ; DUNIT
  1566 				;        .BYTE      $D8     ; DCOMND
  1567 				;        .BYTE      $80     ; DSTATS
  1568 				;        .BYTE      <COPYSPEC  ; DBUFL
  1569 				;        .BYTE      >COPYSPEC ; DBUFH
  1570 				;        .BYTE      $FE     ; DTIMLO
  1571 				;        .BYTE      $00     ; DRESVD
  1572 				;        .BYTE      $00     ; DBYTL
  1573 				;        .BYTE      $01     ; DBYTH
  1574 				;        .BYTE      3       ; DAUX1
  1575 				;        .BYTE      2       ; DAUX2
  1576 				;
  1577 				;COPYSPEC:
  1578 				;        .BYTE 'iss.po|iss.po',$00
  1579
  1580 				;---------------------------------------
  1581 0CAE			DO_COPY:
  1582 				;---------------------------------------
  1583 0CAE A9 B0		        LDA     #$B0
  1584 0CB0 8D C6 02		        STA     COLOR2
  1585 0CB3 60			        RTS
  1586
  1587 				;        JSR     COPY_PARSE_FILES    ; locate comma, replace with EOL
  1588 				;        BMI     COPY_DONE
  1589 				;
  1590 				;        LDA     CMDSEP
  1591 				;        STA     CMDSEP+2
  1592 				;
  1593 				;        LDA     CMDSEP+1
  1594 				;        STA     CMDSEP
  1595 				;
  1596 				;        JSR     COPY_OPEN_DEST      ; use CIO to open file 2 for write
  1597 				;        BMI     COPY_DONE
  1598 				;
  1599 				;        LDA     CMDSEP+2
  1600 				;        STA     CMDSEP
  1601 				;        JSR     COPY_OPEN_SRC       ; use CIO to open file 1 for read
  1602 				;        BMI     COPY_DONE
  1603 				;
  1604 				;@:      JSR     COPY_GET_SRC
  1605 				;        JSR     COPY_PUT_DEST
  1606 				;        ;BNE     @-
  1607 				;
  1608 				;COPY_DONE:
  1609 				;    ; Close files
  1610 				;        LDX     #$10
  1611 				;        JSR     CIOCLOSE
  1612 				;        LDX     #$20
  1613 				;        JMP     CIOCLOSE
  1614 				;
  1615 				;;---------------------------------------
  1616 				;COPY_PARSE_FILES:
  1617 				;;---------------------------------------
  1618 				;    ; Find position of comma in line buffer
  1619 				;    ; Return X = position of comma
  1620 				;    ;---------------------------------------
  1621 				;        LDX     CMDSEP
  1622 				;COPY_PARSE_LOOP:
  1623 				;        LDA     LNBUF,X
  1624 				;        CMP     #','
  1625 				;        BEQ     COPY_PARSE_FILES_DONE
  1626 				;        CMP     #EOL
  1627 				;        BEQ     COPY_SHOW_USAGE
  1628 				;        INX
  1629 				;        BNE     COPY_PARSE_LOOP
  1630 				;COPY_PARSE_FILES_DONE:
  1631 				;    ;---------------------------------------
  1632 				;    ; Here if comma found.
  1633 				;    ; Inject EOL where the comma was found
  1634 				;    ;---------------------------------------
  1635 				;        LDA     #EOL
  1636 				;        STA     LNBUF,X
  1637 				;        INX                 ; Advance to start of 2nd arg
  1638 				;        STX     CMDSEP+1    ; Point to 2nd arg now
  1639 				;        RTS
  1640 				;    ;---------------------------------------
  1641 				;    ; Here if no comma found.
  1642 				;    ; Print usage
  1643 				;    ;---------------------------------------
  1644 				;COPY_SHOW_USAGE:
  1645 				;        LDA     #<COPY_SHOW_USAGE_STR
  1646 				;        LDY     #>COPY_SHOW_USAGE_STR
  1647 				;        JSR     PRINT_STRING
  1648 				;        LDY     #$FF
  1649 				;        RTS
  1650 				;
  1651 				;COPY_SHOW_USAGE_STR:
  1652 				;        .BYTE   'COPY SOURCE,DEST',EOL
  1653 				;
  1654 				;; End of COPY_COMMA_POS:
  1655 				;;---------------------------------------
  1656 				;
  1657 				;;---------------------------------------
  1658 				;COPY_OPEN_SRC:
  1659 				;;---------------------------------------
  1660 				;        JSR     GET_DOSDR       ; Get DUNIT
  1661 				;        JSR     PREPEND_DRIVE
  1662 				;
  1663 				;        LDX     #$10            ; File #1
  1664 				;        JSR     CIOCLOSE        ; Assert file #1 is closed
  1665 				;        LDY     #$04            ; Open for input
  1666 				;        JSR     CIOOPEN         ; Open filename @ (INBUFF)
  1667 				;        BPL     COPY_OPEN_SRC_DONE
  1668 				;
  1669 				;        LDA     #<COPY_OPEN_SRC_ERR_STR
  1670 				;        LDY     #>COPY_OPEN_SRC_ERR_STR
  1671 				;        JMP     PRINT_STRING
  1672 				;
  1673 				;COPY_OPEN_SRC_DONE:
  1674 				;        RTS
  1675 				;        
  1676 				;COPY_OPEN_SRC_ERR_STR:
  1677 				;        .BYTE   'UNABLE TO OPEN SOURCE',EOL
  1678 				;
  1679 				;;End of COPY_OPEN_SRC
  1680 				;;---------------------------------------
  1681 				;
  1682 				;;---------------------------------------
  1683 				;COPY_OPEN_DEST:
  1684 				;;---------------------------------------
  1685 				;    ; Advance offset to arg2
  1686 				;        
  1687 				;@:      JSR     GET_DOSDR       ; Get DUNIT
  1688 				;        JSR     PREPEND_DRIVE
  1689 				;
  1690 				;        LDX     #$20            ; Assert file #2 is closed
  1691 				;        JSR     CIOCLOSE
  1692 				;
  1693 				;        LDY     #$08            ; Open for write
  1694 				;        JSR     CIOOPEN
  1695 				;        BPL     COPY_OPEN_DEST_DONE  ; If success, skip ahead
  1696 				;
  1697 				;        LDA     #<COPY_OPEN_DEST_ERR_STR
  1698 				;        LDY     #>COPY_OPEN_DEST_ERR_STR
  1699 				;        JMP     PRINT_STRING
  1700 				;
  1701 				;COPY_OPEN_DEST_DONE:
  1702 				;        RTS
  1703 				;        
  1704 				;COPY_OPEN_DEST_ERR_STR:
  1705 				;        .BYTE   'UNABLE TO OPEN DEST',EOL
  1706 				;
  1707 				;;End of COPY_OPEN_SRC
  1708 				;;---------------------------------------
  1709 				;
  1710 				;;---------------------------------------
  1711 				;COPY_GET_SRC:
  1712 				;;---------------------------------------
  1713 				;        ;LDX     #$10
  1714 				;        ;JSR     CIOSTATUS
  1715 				;
  1716 				;        LDX     #$10
  1717 				;        LDA     #<TBUF
  1718 				;        STA     INBUFF      ; Buffer addr Lo
  1719 				;        LDA     #>TBUF
  1720 				;        STA     INBUFF+1    ; Buffer addr Hi
  1721 				;        LDA     #$80        ; Buffer size Lo
  1722 				;        LDY     #$00        ; Buffer size Hi
  1723 				;        JSR     CIOGET
  1724 				;        BPL     COPY_GET_SRC_DONE
  1725 				;        CPY     #EOF
  1726 				;        BEQ     COPY_GET_SRC_DONE
  1727 				; 
  1728 				;        LDA     #<COPY_GET_SRC_STR
  1729 				;        LDY     #>COPY_GET_SRC_STR
  1730 				;        JMP     PRINT_STRING
  1731 				;
  1732 				;COPY_GET_SRC_DONE:
  1733 				;        RTS
  1734 				;
  1735 				;COPY_GET_SRC_STR:
  1736 				;        .BYTE   'ERROR READING FROM SOURCE',EOL
  1737 				;
  1738 				;;---------------------------------------
  1739 				;COPY_PUT_DEST:
  1740 				;;---------------------------------------
  1741 				;        ;LDX     #$20
  1742 				;        ;JSR     CIOSTATUS
  1743 				;
  1744 				;        LDX     #$20
  1745 				;        LDA     #<TBUF
  1746 				;        STA     INBUFF      ; Buffer addr Lo
  1747 				;        LDA     #>TBUF
  1748 				;        STA     INBUFF+1    ; Buffer addr Hi
  1749 				;        LDA     #$06        ; Buffer size Lo
  1750 				;        LDY     #$00        ; Buffer size Hi
  1751 				;        JSR     CIOPUT
  1752 				;        BPL     COPY_PUT_DEST_DONE
  1753 				;        CPY     #EOF
  1754 				;        BEQ     COPY_PUT_DEST_DONE
  1755 				; 
  1756 				;        LDA     #<COPY_PUT_DEST_STR
  1757 				;        LDY     #>COPY_PUT_DEST_STR
  1758 				;        JMP     PRINT_STRING
  1759 				;
  1760 				;COPY_PUT_DEST_DONE:
  1761 				;        RTS
  1762 				;
  1763 				;COPY_PUT_DEST_STR:
  1764 				;        .BYTE   'ERROR WRITING TO DEST',EOL
  1765 				;
  1766
  1767 				;---------------------------------------
  1768 0CB4			DO_DIR:
  1769 				;---------------------------------------
  1770 0CB4 20 14 0D		        JSR     DIR_INIT    ; set dunits
  1771 0CB7 20 24 0D		        JSR     DIR_OPEN    ; open with dir request
  1772 0CBA C0 01		        CPY     #$01        ; success (1) ?
  1773 0CBC F0 03		        BEQ     DIR_LOOP    ; if success, jump ahead
  1774 0CBE 4C 96 0A		        JMP     PRINT_ERROR ; exit
  1775
  1776 0CC1			DIR_LOOP:
  1777
  1778 				    ;---------------------------------------
  1779 				    ; Send Status request to SIO
  1780 				    ;---------------------------------------
  1781 0CC1 A9 48		        LDA     #<STADCB
  1782 0CC3 A0 09		        LDY     #>STADCB
  1783 0CC5 20 A5 07		        JSR     DOSIOV
  1784
  1785 				    ;---------------------------------------
  1786 				    ; Status returns DVSTAT
  1787 				    ;---------------------------------------
  1788 0CC8 A2 00		        LDX     #$00
  1789 0CCA EC EB 02		        CPX     DVSTAT+1    ; if byte count < 255 (that is, hi=0)
  1790 0CCD F0 09		        BEQ     DIR_LT_255  ; then skip
  1791
  1792 				    ;---------------------------------------
  1793 				    ; Branch 1: Read 255 bytes (max)
  1794 				    ;---------------------------------------
  1795 0CCF CA			        DEX                 ; X now 255 (Read FF Bytes)
  1796 0CD0 8E 10 0D		        STX     DIRRDCB+8   ; DBYTL
  1797 0CD3 8E 12 0D		        STX     DIRRDCB+10  ; DAUX1
  1798 0CD6 30 0B		        BMI     DIR_NEXT1   ; "always" true. skip down SIO call
  1799
  1800 				    ;---------------------------------------
  1801 				    ; Branch 2: Read < 255 bytes
  1802 				    ;---------------------------------------
  1803 0CD8			DIR_LT_255:
  1804 0CD8 AD EA 02		        LDA     DVSTAT      ; Get count of bytes remaining
  1805 0CDB F0 6C		        BEQ     DIR_ERROR   ; If here then DVSTAT = $0000 (error)
  1806 0CDD 8D 10 0D		        STA     DIRRDCB+8   ; DBYTL
  1807 0CE0 8D 12 0D		        STA     DIRRDCB+10  ; DAUX1
  1808
  1809 				    ;-------------------------
  1810 				    ; Send Read request to SIO
  1811 				    ;-------------------------
  1812 0CE3			DIR_NEXT1:
  1813 0CE3 A9 08		        LDA     #<DIRRDCB
  1814 0CE5 A0 0D		        LDY     #>DIRRDCB
  1815 0CE7 20 A5 07		        JSR     DOSIOV      ; Fetch directory listing
  1816 0CEA 20 79 0D		        JSR     DIR_PRINT   ; xfer payload to screen
  1817
  1818 				    ;---------------------------------------
  1819 				    ; Pause output if SPACE key code found
  1820 				    ;---------------------------------------
  1821 0CED			DIR_WAIT:
  1822 0CED AE FC 02		        LDX     CH
  1823 0CF0 E0 21		        CPX     #SPC_KEY
  1824 0CF2 F0 F9		        BEQ     DIR_WAIT
  1825
  1826 				    ;---------------------------------------
  1827 				    ; Exit loop if ESC key code found
  1828 				    ;---------------------------------------
  1829 0CF4 AD FC 02		        LDA     CH
  1830 0CF7 C9 1C		        CMP     #ESC_KEY    ; hardware code for ESC key
  1831 0CF9 F0 05		        BEQ     DIR_NEXT
  1832
  1833 				    ;---------------------------------------
  1834 				    ; Loop if more data to read
  1835 				    ;---------------------------------------
  1836 0CFB AD EB 02		        LDA     DVSTAT+1    ; Was there more to read (that is, was hi>0)?
  1837 0CFE D0 C1		        BNE     DIR_LOOP    ; If yes, then do it again
  1838
  1839 0D00			DIR_NEXT:
  1840 0D00 A9 FF		        LDA     #$FF        ; Clear key
  1841 0D02 8D FC 02		        STA     CH
  1842 0D05 4C 97 0D		        JMP     DIR_CLOSE
  1843
  1844 0D08			DIRRDCB:
  1845 0D08 71			        .BYTE   DEVIDN      ; DDEVIC
  1846 0D09 FF			        .BYTE   $FF         ; DUNIT
  1847 0D0A 52			        .BYTE   'R'         ; DCOMND
  1848 0D0B 40			        .BYTE   $40         ; DSTATS
  1849 0D0C 00			        .BYTE   <RBUF       ; DBUFL
  1850 0D0D 16			        .BYTE   >RBUF       ; DBUFH
  1851 0D0E 1F			        .BYTE   $1F         ; DTIMLO
  1852 0D0F 00			        .BYTE   $00         ; DRESVD
  1853 0D10 00			        .BYTE   $00         ; DBYTL
  1854 0D11 00			        .BYTE   $00         ; DBYTH
  1855 0D12 00			        .BYTE   $00         ; DAUX1
  1856 0D13 00			        .BYTE   $00         ; DAUX2
  1857
  1858 				;---------------------------------------
  1859 				; Set DUNITs in all DCBs used by DIR
  1860 				;---------------------------------------
  1861 0D14			DIR_INIT:
  1862 				;---------------------------------------
  1863 0D14 20 1E 0C		        JSR     GET_DOSDR   ; On return, X <- n in Nn:
  1864 0D17 8E 6E 0D		        STX     DIRODCB+1   ; DUNIT for Open
  1865 0D1A 8E 49 09		        STX     STADCB+1    ; DUNIT for Status
  1866 0D1D 8E 09 0D		        STX     DIRRDCB+1   ; DUNIT for Read
  1867 0D20 8E 22 08		        STX     CLODCB+1    ; DUNIT for Close
  1868 0D23 60			        RTS
  1869
  1870 				;---------------------------------------
  1871 0D24			DIR_OPEN:
  1872 				;---------------------------------------
  1873 0D24 20 E7 13		        JSR     PREPEND_DRIVE
  1874
  1875 				    ;-----------------------------------
  1876 				    ; Default to arg1
  1877 				    ;-----------------------------------
  1878 0D27 A6 F3		        LDX     INBUFF
  1879 0D29 A4 F4		        LDY     INBUFF+1
  1880
  1881 				    ;-----------------------------------
  1882 				    ; But use Nn:*.* if no arg1
  1883 				    ;-----------------------------------
  1884 0D2B AD 78 0B		        LDA     CMDSEP          ; 0 means no arg1
  1885 0D2E D0 0C		        BNE     DIR_OPEN_NEXT   ; If arg1 present then skip
  1886
  1887 				    ;-----------------------------------
  1888 				    ; Here if no arg1
  1889 				    ;-----------------------------------
  1890 0D30 A2 66		        LDX     #<DIR_OPEN_STR
  1891 0D32 A0 0D		        LDY     #>DIR_OPEN_STR
  1892
  1893 0D34 AD 85 15		        LDA     DOSDR
  1894 0D37 09 30		        ORA     #'0'            ; Convert, say, 1 to '1'
  1895 0D39 8D 67 0D		        STA     DIR_OPEN_STR+1  ; Inject DOSDR into string
  1896
  1897 0D3C			DIR_OPEN_NEXT:
  1898 0D3C 8E 71 0D		        STX     DIRODCB+4       ; DBUFL
  1899 0D3F 8C 72 0D		        STY     DIRODCB+5       ; DBUFH
  1900
  1901 0D42 A9 6D		        LDA     #<DIRODCB
  1902 0D44 A0 0D		        LDY     #>DIRODCB
  1903 0D46 4C A5 07		        JMP     DOSIOV
  1904
  1905 				;---------------------------------------
  1906 0D49			DIR_ERROR:
  1907 				;---------------------------------------
  1908 0D49 A9 53		        LDA     #<DIR_ERROR_STR
  1909 0D4B A0 0D		        LDY     #>DIR_ERROR_STR
  1910 0D4D 20 7B 0A		        JSR     PRINT_STRING
  1911 0D50 A0 01		        LDY     #$01            ; Return error
  1912 0D52 60			        RTS
  1913
  1914 0D53			DIR_ERROR_STR:
  1915 0D53 55 4E 41 42 4C 45 +         .BYTE   'UNABLE TO READ DIR',EOL
  1916
  1917 0D66			DIR_OPEN_STR:
  1918 0D66 4E 20 3A 2A 2E 2A +         .BYTE   'N :*.*',EOL
  1919
  1920 0D6D			DIRODCB:
  1921 0D6D 71			        .BYTE   DEVIDN          ; DDEVIC
  1922 0D6E FF			        .BYTE   $FF             ; DUNIT
  1923 0D6F 4F			        .BYTE   'O'             ; DCOMND
  1924 0D70 80			        .BYTE   $80             ; DSTATS
  1925 0D71 FF			        .BYTE   $FF             ; DBUFL
  1926 0D72 FF			        .BYTE   $FF             ; DBUFH
  1927 0D73 1F			        .BYTE   $1F             ; DTIMLO
  1928 0D74 00			        .BYTE   $00             ; DRESVD
  1929 0D75 00			        .BYTE   $00             ; DBYTL
  1930 0D76 01			        .BYTE   $01             ; DBYTH
  1931 0D77 06			        .BYTE   $06             ; DAUX1
  1932 0D78 80			        .BYTE   $80             ; DAUX2 (Long Dir)
  1933
  1934 				; End of DIR_OPEN
  1935 				;---------------------------------------
  1936
  1937 				;---------------------------------------
  1938 0D79			DIR_PRINT:
  1939 				;---------------------------------------
  1940 				        ; Print results using CIO
  1941 0D79 A2 00		        LDX     #$00
  1942 0D7B A9 0B		        LDA     #PUTCHR
  1943 0D7D 9D 42 03		        STA     ICCOM,X
  1944
  1945 				        ; Fill out buffer loc
  1946 0D80 A9 00		        LDA     #<RBUF
  1947 0D82 9D 44 03		        STA     ICBAL,X
  1948 0D85 A9 16		        LDA     #>RBUF
  1949 0D87 9D 45 03		        STA     ICBAH,X
  1950
  1951 				        ; Fill out size loc
  1952 0D8A AD 10 0D		        LDA     DIRRDCB+8
  1953 0D8D 9D 48 03		        STA     ICBLL,X
  1954 0D90 8A			        TXA
  1955 0D91 9D 49 03		        STA     ICBLH,X
  1956 0D94 4C 56 E4		        JMP     CIOV
  1957
  1958 				;---------------------------------------
  1959 0D97			DIR_CLOSE:
  1960 				;---------------------------------------
  1961 				        ; Close
  1962 0D97 A9 21		        LDA     #<CLODCB
  1963 0D99 A0 08		        LDY     #>CLODCB
  1964 0D9B 4C A5 07		        JMP     DOSIOV
  1965
  1966 				;---------------------------------------
  1967 0D9E			DO_LOAD:
  1968 				;---------------------------------------
  1969 				    ; Binary Loader based on work by Richard J. Kalagher 07-AUG-1983
  1970
  1971 				    ; Open file
  1972 0D9E AD 78 0B		        LDA     CMDSEP          ; Quit if no arg1
  1973 0DA1 D0 03		        BNE     LOAD_NEXT1
  1974 0DA3 4C FF 0F		        JMP     LOAD_ERROR
  1975
  1976 0DA6			LOAD_NEXT1:
  1977 				    ; Point INBUFF to start of filename
  1978 0DA6 18			        CLC
  1979 0DA7 65 F3		        ADC     INBUFF          ; [A] contains offset to arg1
  1980 0DA9 85 F3		        STA     INBUFF
  1981 0DAB 90 02		        BCC     LOAD_NEXT2
  1982 0DAD E6 F4		        INC     INBUFF+1
  1983
  1984 0DAF			LOAD_NEXT2:
  1985 0DAF 20 2C 0E		        JSR     LOAD_NTRANS     ; Disable any EOL transation
  1986 0DB2 20 E8 0D		        JSR     LOAD_SETUP      ; Set up run and init to RTS
  1987 0DB5 A9 04		        LDA     #OINPUT         ; A arg needed in LOAD_OPEN
  1988 0DB7 20 FE 0D		        JSR     LOAD_OPEN       ; Open the file
  1989 0DBA C0 01		        CPY     #$01            ; Quit if unable to open
  1990 0DBC D0 29		        BNE     R
  1991 0DBE 20 3A 0E		GETFIL: JSR     LOAD_READ2      ; Get two bytes (binary header)
  1992 0DC1 20 F3 0D		        JSR     LOAD_INIT       ; Set init default
  1993 0DC4 20 61 0E		        JSR     LOAD_CHKFF      ; Check if header (and start addr, too)
  1994 0DC7 20 84 0E		        JSR     LOAD_STRAD      ; Put start address in
  1995 0DCA 20 3A 0E		        JSR     LOAD_READ2      ; Get to more butes (end addr)
  1996 0DCD 20 91 0E		        JSR     LOAD_ENDAD      ; Put end address in
  1997 0DD0 20 9E 0E		        JSR     LOAD_BUFLEN     ; Calculate buffer length
  1998 0DD3 20 C3 0E		        JSR     LOAD_GETDAT     ; Get the data record
  1999 0DD6 10 03		        BPL     @+
  2000 0DD8 20 E4 0D		        JSR     JSTART
  2001 0DDB 20 E1 0D		@:      JSR     JINIT           ; Attempt initialization
  2002 0DDE 4C BE 0D		        JMP     GETFIL
  2003 0DE1 6C E2 02		JINIT:  JMP     (INITAD)        ; Will either RTS or perform INIT
  2004 0DE4			JSTART: ;JSR     JINIT           ; Some binfiles launch from INITAD
  2005 0DE4 6C E0 02		        JMP     (RUNAD)         ; Godspeed.
  2006
  2007 0DE7 60			R:      RTS                     ; Stunt-double for (INITAD),(RUNAD)
  2008
  2009 				;---------------------------------------
  2010 0DE8			LOAD_SETUP:
  2011 				;---------------------------------------
  2012 0DE8 A9 E7		        LDA     #<R
  2013 0DEA 8D E0 02		        STA     RUNAD
  2014 0DED A9 0D		        LDA     #>R
  2015 0DEF 8D E1 02		        STA     RUNAD+1
  2016 0DF2 60			        RTS
  2017
  2018 				;---------------------------------------
  2019 0DF3			LOAD_INIT:
  2020 				;---------------------------------------
  2021 0DF3 A9 E7		        LDA     #<R
  2022 0DF5 8D E2 02		        STA     INITAD
  2023 0DF8 A9 0D		        LDA     #>R
  2024 0DFA 8D E3 02		        STA     INITAD+1
  2025 0DFD 60			        RTS
  2026
  2027
  2028 				;---------------------------------------
  2029 0DFE			LOAD_OPEN:
  2030 				;---------------------------------------
  2031 0DFE 48			        PHA                     ; A = data direction (4=in, 8=out)
  2032 0DFF 20 1E 0C		        JSR     GET_DOSDR       ; Get DUNIT
  2033 0E02 8E 01 08		        STX     OPNDCB+1        ; Set DUNIT
  2034 0E05 8E 83 08		        STX     GETDCB+1        ; Set DUNIT FOR READ
  2035 0E08 20 E7 13		        JSR     PREPEND_DRIVE
  2036
  2037 0E0B A5 F3		        LDA     INBUFF          ; Register location of filename
  2038 0E0D 8D 04 08		        STA     OPNDCB+4
  2039 0E10 A5 F4		        LDA     INBUFF+1
  2040 0E12 8D 05 08		        STA     OPNDCB+5
  2041
  2042 0E15 68			        PLA                     ; A = data direction (4=in, 8=out)
  2043 0E16 8D 0A 08		        STA     OPNDCB+10
  2044 0E19 A9 00		        LDA     #$00            ; AUX2: No translation
  2045 0E1B 8D 0B 08		        STA     OPNDCB+11
  2046
  2047 0E1E A9 00		        LDA     #<OPNDCB
  2048 0E20 A0 08		        LDY     #>OPNDCB
  2049
  2050 0E22 20 A5 07		        JSR     DOSIOV
  2051 0E25 48			        PHA
  2052 0E26 20 96 0A		        JSR     PRINT_ERROR
  2053 0E29 68			        PLA
  2054 0E2A A8			        TAY
  2055
  2056 0E2B 60			        RTS
  2057
  2058 				;---------------------------------------
  2059 0E2C			LOAD_NTRANS:
  2060 				;---------------------------------------
  2061 				    ; Disable any EOL transation otherwise
  2062 				    ; binary data will be corrupted during load
  2063 				    ;---------------------------------------
  2064 0E2C 20 1E 0C		        JSR     GET_DOSDR       ; Get DUNIT
  2065 0E2F 8E C7 10		        STX     NTRDCB+1        ; Set DUNIT
  2066 0E32 A9 00		        LDA     #$00
  2067 0E34 8D D1 10		        STA     NTRDCB+11       ; Translation mode (0 = NONE)
  2068 0E37 4C 93 10		        JMP     NTRANS_CALL     ; Reuse code in DO_NTRANS
  2069
  2070 				;---------------------------------------
  2071 0E3A			LOAD_READ2:
  2072 				;---------------------------------------
  2073
  2074 0E3A A9 02		        LDA     #$02
  2075 0E3C 8D 8A 08		        STA     GETDCB+8
  2076 0E3F 8D 8C 08		        STA     GETDCB+10
  2077
  2078 0E42 A9 00		        LDA     #$00
  2079 0E44 8D 8B 08		        STA     GETDCB+9
  2080 0E47 8D 8D 08		        STA     GETDCB+11
  2081
  2082 0E4A A9 82		        LDA     #<GETDCB
  2083 0E4C A0 08		        LDY     #>GETDCB
  2084
  2085 0E4E 20 A5 07		        JSR     DOSIOV
  2086 0E51 20 96 0A		        JSR     PRINT_ERROR
  2087
  2088 0E54 AD 83 08		        LDA     GETDCB+1
  2089 0E57 8D 49 09		        STA     STADCB+1
  2090 0E5A A9 48		        LDA     #<STADCB
  2091 0E5C A0 09		        LDY     #>STADCB
  2092 0E5E 4C A5 07		        JMP     DOSIOV
  2093
  2094 				;---------------------------------------
  2095 0E61			LOAD_CHKFF:
  2096 				;---------------------------------------
  2097 				    ; Check for binary file signature ($FF $FF)
  2098 0E61 AE 00 16		        LDX     BAL
  2099 0E64 E8			        INX
  2100 0E65 F0 01		        BEQ     TEST2
  2101 0E67 60			        RTS
  2102 0E68 AE 01 16		TEST2:  LDX     BAH
  2103 0E6B E8			        INX
  2104 0E6C F0 01		        BEQ     ITSFF
  2105 0E6E 60			        RTS
  2106 0E6F 4C 3A 0E		ITSFF:  JMP     LOAD_READ2  ; Get start address and return
  2107
  2108 				;        LDA     #<LOAD_ERROR_STR2
  2109 				;        LDY     #>LOAD_ERROR_STR2
  2110 				;        JMP     PRINT_STRING
  2111
  2112 0E72			LOAD_ERROR_STR2:
  2113 0E72 4E 4F 54 20 41 20 +         .BYTE   'NOT A BINARY FILE',EOL
  2114
  2115 				;---------------------------------------
  2116 0E84			LOAD_STRAD:
  2117 				;---------------------------------------
  2118 				    ; Save payload start address
  2119 0E84 AD 00 16		        LDA     RBUF
  2120 0E87 8D 80 16		        STA     STL
  2121 0E8A AD 01 16		        LDA     RBUF+1
  2122 0E8D 8D 81 16		        STA     STH
  2123 0E90 60			        RTS
  2124
  2125 				;---------------------------------------
  2126 0E91			LOAD_ENDAD:
  2127 				;---------------------------------------
  2128 				    ; Save payload end address
  2129 0E91 AD 00 16		        LDA     RBUF
  2130 0E94 8D 82 16		        STA     ENL
  2131 0E97 AD 01 16		        LDA     RBUF+1
  2132 0E9A 8D 83 16		        STA     ENH
  2133 0E9D 60			        RTS
  2134
  2135 				;---------------------------------------
  2136 0E9E			LOAD_BUFLEN:
  2137 				;---------------------------------------
  2138 				    ; Calculate buffer length (end-start+1)
  2139
  2140 				    ; Calc buffer size Lo
  2141 0E9E AD 82 16		        LDA     ENL
  2142 0EA1 38			        SEC
  2143 0EA2 ED 80 16		        SBC     STL
  2144 0EA5 8D 84 16		        STA     BLL     ; Buffer Length Lo
  2145
  2146 				    ; Calc buffer size Hi
  2147 0EA8 AD 83 16		        LDA     ENH     ; Calc buffer size Hi
  2148 0EAB ED 81 16		        SBC     STH
  2149 0EAE 8D 85 16		        STA     BLH     ; Buffer Length Hi
  2150
  2151 				    ; Add 1
  2152 0EB1 18			        CLC
  2153 0EB2 AD 84 16		        LDA     BLL
  2154 0EB5 69 01		        ADC     #$01
  2155 0EB7 8D 84 16		        STA     BLL
  2156
  2157 0EBA AD 85 16		        LDA     BLH
  2158 0EBD 69 00		        ADC     #$00    ; Take care of any carry
  2159 0EBF 8D 85 16		        STA     BLH
  2160
  2161 0EC2 60			        RTS
  2162
  2163 				;---------------------------------------
  2164 0EC3			LOAD_GETDAT:
  2165 				;---------------------------------------
  2166 				    ; Definitions:
  2167 				    ; HEAD = requested bytes that will be found in current cache (< 512 bytes)
  2168 				    ; BODY = contiguous 512 byte sections. BODY = n * 512 bytes)
  2169 				    ; TAIL = any bytes remaining after BODY (< 512 bytes)
  2170
  2171 0EC3 20 1E 0C		        JSR     GET_DOSDR
  2172 0EC6 8E E7 0F		        STX     BINDCB+1
  2173
  2174 				    ; Check if bytes requested BL < DVSTAT (bytes waiting in cache)
  2175 0EC9 AD EA 02		        LDA     DVSTAT
  2176 0ECC CD 84 16		        CMP     BLL
  2177 0ECF AD EB 02		        LDA     DVSTAT+1
  2178 0ED2 ED 85 16		        SBC     BLH
  2179 0ED5 B0 4C		        BCS     GETDAT_OPT2     ; BL <= BW (bytes waiting)
  2180
  2181 0ED7			GETDAT_OPT1:
  2182 				    ;--------------------------------
  2183 				    ; Here if bytes requested > bytes 
  2184 				    ; remaining in cache
  2185 				    ;--------------------------------
  2186
  2187 				    ;-------------------------------
  2188 				    ; Head = BW (bytes waiting)
  2189 				    ;-------------------------------
  2190 0ED7 AD EA 02		        LDA     DVSTAT
  2191 0EDA 8D 86 16		        STA     HEADL
  2192 0EDD AD EB 02		        LDA     DVSTAT+1
  2193 0EE0 8D 87 16		        STA     HEADH
  2194
  2195 				    ;-------------------------------
  2196 				    ; Tail = (BL - HEAD) mod 512
  2197 				    ;-------------------------------
  2198 0EE3 38			        SEC
  2199 0EE4 AD 84 16		        LDA     BLL
  2200 0EE7 ED 86 16		        SBC     HEADL
  2201 0EEA 29 FF		        AND     #$FF
  2202 0EEC 8D 8A 16		        STA     TAILL
  2203 0EEF AD 85 16		        LDA     BLH
  2204 0EF2 ED 87 16		        SBC     HEADH
  2205 0EF5 29 01		        AND     #$01
  2206 0EF7 8D 8B 16		        STA     TAILH
  2207
  2208 				    ;-----------------------------------
  2209 				    ; Body = BL - HEAD - TAIL
  2210 				    ;-----------------------------------
  2211 				        ; 1. Body = BL - HEAD
  2212 				        ;-------------------------------
  2213 0EFA 38			        SEC
  2214 0EFB AD 84 16		        LDA     BLL
  2215 0EFE ED 86 16		        SBC     HEADL
  2216 0F01 8D 88 16		        STA     BODYL
  2217 0F04 AD 85 16		        LDA     BLH
  2218 0F07 ED 87 16		        SBC     HEADH
  2219 0F0A 8D 89 16		        STA     BODYH
  2220
  2221 				        ;-------------------------------
  2222 				        ; 2. Body = Body - HEAD
  2223 				        ;-------------------------------
  2224 0F0D 38			        SEC
  2225 0F0E AD 88 16		        LDA     BODYL
  2226 0F11 ED 8A 16		        SBC     TAILL
  2227 0F14 8D 88 16		        STA     BODYL
  2228 0F17 AD 89 16		        LDA     BODYH
  2229 0F1A ED 8B 16		        SBC     TAILH
  2230 0F1D 8D 89 16		        STA     BODYH
  2231
  2232 0F20 4C 3D 0F		        JMP     GETDAT_READ
  2233
  2234 0F23			GETDAT_OPT2:
  2235 				    ;--------------------------------
  2236 				    ; Here if bytes requested <= bytes 
  2237 				    ; remaining in cache
  2238 				    ;--------------------------------
  2239 				    ; Head = BL, TAIL = BODY = 0
  2240 				    ;--------------------------------
  2241 0F23 AD 84 16		        LDA     BLL
  2242 0F26 8D 86 16		        STA     HEADL
  2243 0F29 AD 85 16		        LDA     BLH
  2244 0F2C 8D 87 16		        STA     HEADH
  2245 0F2F A9 00		        LDA     #$00
  2246 0F31 8D 8A 16		        STA     TAILL
  2247 0F34 8D 8B 16		        STA     TAILH
  2248 0F37 8D 88 16		        STA     BODYL
  2249 0F3A 8D 89 16		        STA     BODYH
  2250
  2251 				;---------------------------------------
  2252 0F3D			GETDAT_READ:
  2253 				;---------------------------------------
  2254 				    ;---------------------------------------
  2255 				    ; Read HEAD bytes
  2256 				    ;---------------------------------------
  2257 0F3D AD 86 16		        LDA     HEADL
  2258 0F40 8D 84 16		        STA     BLL
  2259 0F43 AD 87 16		        LDA     HEADH
  2260 0F46 8D 85 16		        STA     BLH
  2261 0F49 20 7D 0F		        JSR     GETDAT_DOSIOV
  2262 0F4C 10 01		        BPL     GETDAT_BODY ; Skip ahead if no problems
  2263 0F4E 60			        RTS                 ; Bail if error
  2264
  2265 				    ;---------------------------------------
  2266 				    ; Read BODY bytes
  2267 				    ;---------------------------------------
  2268 0F4F			GETDAT_BODY:
  2269 0F4F AE 89 16		        LDX     BODYH
  2270 0F52			GETDAT_BODY_LOOP:
  2271 0F52 F0 1A		        BEQ     GETDAT_TAIL ; Skip if less than a page to read
  2272
  2273 0F54 A9 00		        LDA     #$00
  2274 0F56 8D 84 16		        STA     BLL         ; Buffer length
  2275 0F59 A9 02		        LDA     #$02        ; 512 bytes at a time
  2276 0F5B 8D 85 16		        STA     BLH
  2277
  2278 0F5E 8A			        TXA                 ; Stash our loop index (X)
  2279 0F5F 48			        PHA                 ; onto the stack
  2280 0F60 20 7D 0F		        JSR     GETDAT_DOSIOV   
  2281 0F63 10 03		        BPL     @+          ; Skip ahead if no problems
  2282 0F65 68			        PLA                 ; Here if problem. Clean up stack
  2283 0F66 98			        TYA                 ; Reset N status flag before returning
  2284 0F67 60			        RTS                 ; Bail if error
  2285
  2286 0F68 68			@:      PLA                 ; Retrieve our loop index
  2287 0F69 AA			        TAX                 ; and xfer it back into X
  2288 0F6A CA			        DEX                 ; -2 (we pull 0200 bytes at a time)
  2289 0F6B CA			        DEX                 ; 
  2290 0F6C D0 E4		        BNE     GETDAT_BODY_LOOP
  2291
  2292 0F6E			GETDAT_TAIL:
  2293 				    ;---------------------------------------
  2294 				    ; Read TAIL bytes
  2295 				    ;---------------------------------------
  2296 0F6E AD 8A 16		        LDA     TAILL
  2297 0F71 8D 84 16		        STA     BLL
  2298 0F74 AD 8B 16		        LDA     TAILH
  2299 0F77 8D 85 16		        STA     BLH
  2300 0F7A 4C 7D 0F		        JMP     GETDAT_DOSIOV
  2301
  2302 				;---------------------------------------
  2303 0F7D			GETDAT_DOSIOV:
  2304 				;---------------------------------------
  2305 				    ; Bail if BL = 0
  2306 0F7D AD 84 16		        LDA     BLL
  2307 0F80 D0 05		        BNE     @+
  2308 0F82 AD 85 16		        LDA     BLH
  2309 0F85 F0 5C		        BEQ     GETDAT_DONE
  2310
  2311 0F87			@:
  2312 				    ; SIO READ
  2313 0F87 AD 80 16		        LDA     STL
  2314 0F8A 8D EA 0F		        STA     BINDCB+4    ; Start Address Lo
  2315 0F8D AD 81 16		        LDA     STH
  2316 0F90 8D EB 0F		        STA     BINDCB+5    ; Start Address Hi
  2317 0F93 AD 84 16		        LDA     BLL
  2318 0F96 8D EE 0F		        STA     BINDCB+8    ; Buffer Size Lo
  2319 0F99 8D F0 0F		        STA     BINDCB+10
  2320 0F9C AD 85 16		        LDA     BLH
  2321 0F9F 8D EF 0F		        STA     BINDCB+9    ; Buffer Size Hi
  2322 0FA2 8D F1 0F		        STA     BINDCB+11
  2323
  2324 				    ;---------------------------------------
  2325 				    ; Send Read request to SIO
  2326 				    ;---------------------------------------
  2327 0FA5 A9 E6		        LDA     #<BINDCB
  2328 0FA7 A0 0F		        LDY     #>BINDCB
  2329 0FA9 20 A5 07		        JSR     DOSIOV
  2330 0FAC 20 96 0A		        JSR     PRINT_ERROR
  2331
  2332 				        ; Note: STADCB+1 SET DURING READ2
  2333 0FAF A9 48		        LDA     #<STADCB
  2334 0FB1 A0 09		        LDY     #>STADCB
  2335 0FB3 20 A5 07		        JSR     DOSIOV
  2336
  2337 				    ; Advance Starting Address
  2338 				    ; ST = ST + PAYLOAD
  2339 0FB6 18			        CLC
  2340 0FB7 AD 80 16		        LDA     STL
  2341 0FBA 6D 84 16		        ADC     BLL
  2342 0FBD 8D 80 16		        STA     STL
  2343
  2344 0FC0 AD 81 16		        LDA     STH
  2345 0FC3 6D 85 16		        ADC     BLH
  2346 0FC6 8D 81 16		        STA     STH
  2347
  2348 0FC9			GETDAT_DOSIOV_DONE:
  2349 				    ; Skip if no bytes left to read
  2350 0FC9 AD EA 02		        LDA     DVSTAT
  2351 0FCC D0 15		        BNE     GETDAT_DONE
  2352 0FCE AD EB 02		        LDA     DVSTAT+1
  2353 0FD1 F0 06		        BEQ     @+
  2354
  2355 				    ; If at the start of a new case (Bytes waiting = 0200)
  2356 0FD3 C9 02		        CMP     #$02
  2357 0FD5 F0 02		        BEQ     @+
  2358 0FD7 D0 0A		        BNE     GETDAT_DONE
  2359 0FD9 A9 88		@:      LDA     #EOF        ; 
  2360 0FDB CD ED 02		        CMP     DVSTAT+3    ; Is status EOF?
  2361 0FDE D0 03		        BNE     GETDAT_DONE ; No?  Return 1
  2362 0FE0 A0 FF		        LDY     #$FF        ; Yes? Return -1
  2363 0FE2			GETDAT_RTS:
  2364 0FE2 60			        RTS
  2365
  2366 0FE3			GETDAT_DONE:        
  2367 0FE3 A0 01		        LDY     #$01        ; Return 0
  2368 0FE5 60			        RTS
  2369
  2370 0FE6			BINDCB:
  2371 0FE6 71			       .BYTE    DEVIDN      ; DDEVIC
  2372 0FE7 FF			       .BYTE    $FF         ; DUNIT
  2373 0FE8 52			       .BYTE    'R'         ; DCOMND
  2374 0FE9 40			       .BYTE    $40         ; DSTATS
  2375 0FEA FF			       .BYTE    $FF         ; DBUFL
  2376 0FEB FF			       .BYTE    $FF         ; DBUFH
  2377 0FEC 0F			       .BYTE    $0F         ; DTIMLO
  2378 0FED 00			       .BYTE    $00         ; DRESVD
  2379 0FEE FF			       .BYTE    $FF         ; DBYTL
  2380 0FEF FF			       .BYTE    $FF         ; DBYTH
  2381 0FF0 FF			       .BYTE    $FF         ; DAUX1
  2382 0FF1 FF			       .BYTE    $FF         ; DAUX2
  2383
  2384
  2385 				;---------------------------------------
  2386 0FF2			LOAD_CLOSE
  2387 				;---------------------------------------
  2388 0FF2 AD E7 0F		        LDA     BINDCB+1
  2389 0FF5 8D 22 08		        STA     CLODCB+1
  2390 0FF8 A9 21		        LDA     #<CLODCB
  2391 0FFA A0 08		        LDY     #>CLODCB
  2392 0FFC 4C A5 07		        JMP     DOSIOV
  2393
  2394 				;---------------------------------------
  2395 0FFF			LOAD_ERROR:
  2396 				;---------------------------------------
  2397 0FFF A9 7F		        LDA     #<MISSING_FILE_STR
  2398 1001 A0 15		        LDY     #>MISSING_FILE_STR
  2399 1003 4C 7B 0A		        JMP     PRINT_STRING
  2400
  2401 				;---------------------------------------
  2402 1006			DO_LOCK:
  2403 				;---------------------------------------
  2404 1006 A9 60		        LDA     #$60
  2405 1008 8D C6 02		        STA     COLOR2
  2406 100B 60			        RTS
  2407
  2408 				;---------------------------------------
  2409 100C			DO_NPWD:
  2410 				;---------------------------------------
  2411 100C A9 9B		        LDA     #EOL        ; Truncate buffer
  2412 100E 8D 00 16		        STA     RBUF
  2413
  2414 1011 20 1E 0C		        JSR     GET_DOSDR   ; X will contain n in Nn:
  2415 1014 8E 44 10		        STX     PWDDCB+1
  2416
  2417 1017 A9 43		        LDA     #<PWDDCB
  2418 1019 A0 10		        LDY     #>PWDDCB
  2419 101B 20 A5 07		        JSR     DOSIOV
  2420 101E 20 96 0A		        JSR     PRINT_ERROR
  2421
  2422 				    ;---------------------------------------
  2423 				    ; If we entered DO_NPWD from REMOUNT_DRIVE
  2424 				    ; then scipt printing output
  2425 				    ;---------------------------------------
  2426 1021 AD 87 15		        LDA     CMDPRV
  2427 1024 C9 03		        CMP     #CMD_IDX.DEL
  2428 1026 F0 1A		        BEQ     NPWD_DONE
  2429 1028 C9 09		        CMP     #CMD_IDX.RENAME
  2430 102A F0 16		        BEQ     NPWD_DONE
  2431
  2432 102C			NPWD_LOOP:
  2433 102C A9 00		        LDA     #<RBUF
  2434 102E A0 16		        LDY     #>RBUF
  2435 1030 20 7B 0A		        JSR     PRINT_STRING
  2436
  2437 1033 A9 48		        LDA     #<STADCB
  2438 1035 A0 09		        LDY     #>STADCB
  2439 1037 20 A5 07		        JSR     DOSIOV
  2440 103A 20 96 0A		        JSR     PRINT_ERROR
  2441
  2442 				    ;---------------------------------------
  2443 				    ; Loop if more data to read
  2444 				    ;---------------------------------------
  2445 103D AD EB 02		        LDA     DVSTAT+1    ; Was there more to read (that is, was hi>0)?
  2446 1040 D0 EA		        BNE     NPWD_LOOP   ; If yes, then do it again
  2447
  2448 1042			NPWD_DONE:
  2449 1042 60			        RTS
  2450
  2451 1043			PWDDCB:
  2452 1043 71			        .BYTE      DEVIDN  ; DDEVIC
  2453 1044 FF			        .BYTE      $FF     ; DUNIT
  2454 1045 30			        .BYTE      $30     ; DCOMND
  2455 1046 40			        .BYTE      $40     ; DSTATS
  2456 1047 00			        .BYTE      <RBUF   ; DBUFL
  2457 1048 16			        .BYTE      >RBUF   ; DBUFH
  2458 1049 1F			        .BYTE      $1F     ; DTIMLO
  2459 104A 00			        .BYTE      $00     ; DRESVD
  2460 104B 00			        .BYTE      $00     ; DBYTL
  2461 104C 01			        .BYTE      $01     ; DBYTH
  2462 104D 00			        .BYTE      $00     ; DAUX1
  2463 104E 00			        .BYTE      $00     ; DAUX2
  2464
  2465 				; End of DO_NPWD
  2466 				;---------------------------------------
  2467
  2468 				.ifdef SYNCALC
  2469 					:($129B-*) DTA $00
  2470 				.endif
  2471
  2472 				.ifndef SYNCALD
  2473 				;---------------------------------------
  2474 104F			DO_NTRANS:
  2475 				;---------------------------------------
  2476 104F AE 78 0B		        LDX     CMDSEP          ; Check if there's any args
  2477 1052 F0 49		        BEQ     NTRANS_ERROR    ; No. Show usage and quit
  2478
  2479 1054 AD 85 15		        LDA     DOSDR           ; Go with current drive for now
  2480 1057 8D C7 10		        STA     NTRDCB+1        ; it'll be overwritten later if req'd
  2481
  2482 				    ;---------------------------------------
  2483 				    ; Check for argc = 2
  2484 				    ;---------------------------------------
  2485 105A AC 78 0B		        LDY     CMDSEP          ; Stash offset to arg1 in Y
  2486 105D AE 79 0B		        LDX     CMDSEP+1        ; Is there an arg2?
  2487 1060 F0 21		        BEQ     PARSE_MODE      ; No. parse arg1 as mode (0-3)
  2488
  2489 				    ;---------------------------------------
  2490 				    ; Here if argc = 2 (arg1 = Nn: arg2 = mode)
  2491 				    ;---------------------------------------
  2492 1062 AE 78 0B		        LDX     CMDSEP          ; Get offset to arg1 (Nn:)
  2493 1065 BD 82 05		        LDA     LNBUF,X         ; Is arg1's (N[n]:) 1st char = 'N'?
  2494 1068 C9 4E		        CMP     #'N'            ;
  2495 106A D0 31		        BNE     NTRANS_ERROR    ; No? Then quit
  2496 106C BD 83 05		        LDA     LNBUF+1,X
  2497 106F C9 3A		        CMP     #':'            ; Is arg1's (N[n]:) 2nd char = ':'?
  2498 1071 F0 10		        BEQ     PARSE_MODE      ; Yes, stick with default drive
  2499
  2500 				    ;---------------------------------------
  2501 				    ; Parse drive number
  2502 				    ;---------------------------------------
  2503 1073 C9 31		        CMP     #'1'            ; Quit if n in Nn not 1..4
  2504 1075 90 26		        BCC     NTRANS_ERROR    ; Quit if < '1'
  2505 1077 C9 39		        CMP     #'9'
  2506 1079 B0 22		        BCS     NTRANS_ERROR    ; Quit if >= '9'
  2507 107B 49 30		        EOR     #%00110000
  2508 107D 8D C7 10		        STA     NTRDCB+1
  2509 1080 AC 79 0B		        LDY     CMDSEP+1
  2510
  2511 				    ;---------------------------------------
  2512 				    ; Confirm valid parameter
  2513 				    ;---------------------------------------
  2514 1083			PARSE_MODE:
  2515 1083 B9 82 05		        LDA     LNBUF,Y         ; Quit if mode not 0..3
  2516 1086 C9 30		        CMP     #'0'
  2517 1088 90 13		        BCC     NTRANS_ERROR
  2518 108A C9 34		        CMP     #'4'
  2519 108C B0 0F		        BCS     NTRANS_ERROR
  2520 108E 49 30		        EOR     #%00110000      ; Here if valid parameter
  2521 1090 8D D1 10		        STA     NTRDCB+11       ; Assign parameter to DCB
  2522 				.endif
  2523 				; SYNCALD
  2524
  2525 				    ;---------------------------------------
  2526 				    ; Call SIO
  2527 				    ;---------------------------------------
  2528 1093			NTRANS_CALL:
  2529 1093 A9 C6		        LDA     #<NTRDCB
  2530 1095 A0 10		        LDY     #>NTRDCB
  2531 1097 20 A5 07		        JSR     DOSIOV
  2532 109A 4C 96 0A		        JMP     PRINT_ERROR
  2533
  2534 109D			NTRANS_ERROR:
  2535 109D A9 A4		        LDA     #<NTRANS_ERROR_STR
  2536 109F A0 10		        LDY     #>NTRANS_ERROR_STR
  2537 10A1 4C 7B 0A		        JMP     PRINT_STRING
  2538
  2539 10A4			NTRANS_ERROR_STR:
  2540 10A4 4D 4F 44 45 3F 20 +         .BYTE   'MODE? 0=NONE, 1=CR, 2=LF, 3=CR/LF',EOL
  2541
  2542 10C6			NTRDCB:
  2543 10C6 71			        .BYTE      DEVIDN  ; DDEVIC
  2544 10C7 FF			        .BYTE      $FF     ; DUNIT
  2545 10C8 54			        .BYTE      'T'     ; DCOMND
  2546 10C9 00			        .BYTE      $00     ; DSTATS
  2547 10CA 00			        .BYTE      $00     ; DBUFL
  2548 10CB 00			        .BYTE      $00     ; DBUFH
  2549 10CC 1F			        .BYTE      $1F     ; DTIMLO
  2550 10CD 00			        .BYTE      $00     ; DRESVD
  2551 10CE 00			        .BYTE      $00     ; DBYTL
  2552 10CF 00			        .BYTE      $00     ; DBYTH
  2553 10D0 00			        .BYTE      $00     ; DAUX1
  2554 10D1 00			        .BYTE      $00     ; DAUX2
  2555
  2556 				; End of DO_NTRANS
  2557 				;---------------------------------------
  2558
  2559 				.ifndef SYNCALD
  2560 				;---------------------------------------
  2561 10D2			DO_SOURCE:
  2562 				;---------------------------------------
  2563 10D2 AD 78 0B		        LDA     CMDSEP
  2564 10D5 D0 07		        BNE     SOURCE_NEXT1
  2565
  2566 				    ; Filename required
  2567 10D7 A9 7F		        LDA     #<MISSING_FILE_STR
  2568 10D9 A0 15		        LDY     #>MISSING_FILE_STR
  2569 10DB 4C 7B 0A		        JMP     PRINT_STRING
  2570
  2571 10DE			SOURCE_NEXT1:
  2572
  2573 				    ; Default to NOSCREEN
  2574 10DE A9 00		        LDA     #$00
  2575 10E0 8D 88 15		        STA     CURSCR
  2576
  2577 				    ; Prep file path
  2578 10E3 20 1E 0C		        JSR     GET_DOSDR       ; Get DUNIT
  2579 10E6 20 E7 13		        JSR     PREPEND_DRIVE
  2580
  2581 				    ; Assert FILE #1 is closed
  2582 10E9 A2 10		        LDX     #$10
  2583 10EB 20 BB 09		        JSR     CIOCLOSE
  2584 				        
  2585 				    ; OPEN #1, 4, 0, file path
  2586 10EE A2 10		        LDX     #$10            ; File #1
  2587 10F0 A0 04		        LDY     #$04            ; Open for input
  2588 10F2 20 C3 09		        JSR     CIOOPEN         ; Open filename @ (INBUFF)
  2589 10F5 10 03		        BPL     SOURCE_NEXT2
  2590 10F7 4C 96 0A		        JMP     PRINT_ERROR
  2591
  2592 10FA			SOURCE_NEXT2:
  2593 10FA 20 64 0A		        JSR     LDBUFA      ; Reset INBUFF to $0580
  2594 10FD A9 FF		        LDA     #$FF        ; Clear command
  2595 10FF 8D 86 15		        STA     CMD
  2596
  2597 				    ; INPUT #1, INBUFF
  2598 1102 A2 10		        LDX     #$10
  2599 1104 A0 04		        LDY     #$04
  2600 1106 20 29 0A		        JSR     CIOGETREC
  2601
  2602 				    ; Check for error
  2603 1109 A2 10		        LDX     #$10
  2604 110B BD 43 03		        LDA     ICSTA,X
  2605 110E C9 88		        CMP     #EOF
  2606 1110 F0 1F		        BEQ     SOURCE_DONE ; No error, try parsing cmd
  2607
  2608 1112			SOURCE_NEXT3:
  2609 1112 AD 88 15		        LDA     CURSCR      ; Skip echo if SCREEN is disabled
  2610 1115 F0 0E		        BEQ     SOURCE_NEXT4
  2611 1117 AD 82 05		        LDA     LNBUF
  2612 111A C9 40		        CMP     #'@'
  2613 111C F0 07		        BEQ     SOURCE_NEXT4
  2614
  2615 				    ; Echo commands
  2616 111E A5 F3		        LDA     INBUFF
  2617 1120 A4 F4		        LDY     INBUFF+1
  2618 1122 20 7B 0A		        JSR     PRINT_STRING
  2619
  2620 1125			SOURCE_NEXT4:
  2621 1125 20 26 0B		        JSR     GETCMDTEST
  2622 1128 20 7C 0B		        JSR     PARSECMD
  2623 112B 20 F2 0B		        JSR     DOCMD
  2624 112E 38			        SEC
  2625 112F B0 C9		        BCS     SOURCE_NEXT2
  2626
  2627 1131			SOURCE_DONE
  2628 1131 A2 10		        LDX     #$10
  2629 1133 4C BB 09		        JMP     CIOCLOSE
  2630
  2631 				; End of DO_SOURCE
  2632 				;---------------------------------------
  2633
  2634 				;---------------------------------------
  2635 1136			DO_TYPE:
  2636 				;---------------------------------------
  2637 1136 AD 78 0B		        LDA     CMDSEP
  2638 1139 D0 07		        BNE     TYPE_SKIP
  2639
  2640 113B			TYPE_USAGE:
  2641 113B A9 7F		        LDA     #<MISSING_FILE_STR
  2642 113D A0 15		        LDY     #>MISSING_FILE_STR
  2643 113F 4C 7B 0A		        JMP     PRINT_STRING
  2644
  2645 1142			TYPE_SKIP:
  2646 1142 20 1E 0C		        JSR     GET_DOSDR       ; Get DUNIT
  2647 1145 20 E7 13		        JSR     PREPEND_DRIVE
  2648
  2649 				    ; Assert input file closed
  2650 1148 A2 10		        LDX     #$10            ; File #1
  2651 114A 20 BB 09		        JSR     CIOCLOSE        ; Assert file #1 is closed
  2652
  2653 				    ; Open input file
  2654 114D A2 10		        LDX     #$10            ; File #1
  2655 114F A0 04		        LDY     #$04            ; Open for input
  2656 1151 20 C3 09		        JSR     CIOOPEN         ; Open filename @ (INBUFF)
  2657 1154 10 08		        BPL     TYPE_NEXT
  2658
  2659 				    ; If open failed, Print error
  2660 1156 A2 10		        LDX     #$10            ; File #1
  2661 1158 BC 43 03		        LDY     ICSTA,X
  2662 115B 4C 96 0A		        JMP     PRINT_ERROR
  2663
  2664 115E			TYPE_NEXT:
  2665
  2666 				    ; Initialize pagination
  2667 115E 20 03 12		        JSR     DO_CLS
  2668 1161 A9 15		        LDA     #21
  2669 1163 8D BB 02		        STA     SCRFLG
  2670
  2671 1166			TYPE_LOOP:
  2672 				    ; Bail if ESC key is pressed
  2673 1166 AD FC 02		        LDA     CH
  2674 1169 C9 1C		        CMP     #ESC_KEY
  2675 116B F0 49		        BEQ     TYPE_DONE
  2676
  2677 				    ; Check if page is full
  2678 116D AD BB 02		        LDA     SCRFLG
  2679 1170 C9 16		        CMP     #22         ; if SCRFLG < 21
  2680 1172 90 14		        BCC     TYPE_READ   ; then skip to read
  2681
  2682 				    ; Here if page is full
  2683 				    ; Wait for keypress
  2684 1174 A9 FF		        LDA     #$FF    ; Clear keypress
  2685 1176 8D FC 02		        STA     CH
  2686
  2687 1179			TYPE_WAIT:
  2688 1179 AE FC 02		        LDX     CH
  2689 117C E8			        INX
  2690 117D F0 FA		        BEQ     TYPE_WAIT
  2691
  2692 117F E0 1C		        CPX     #ESC_KEY
  2693 1181 F0 33		        BEQ     TYPE_DONE
  2694
  2695 				    ; Reset pagination
  2696 1183 A9 00		        LDA     #$00
  2697 1185 8D BB 02		        STA     SCRFLG
  2698
  2699 1188			TYPE_READ:
  2700 				    ; Read from file
  2701 1188 A2 10		        LDX     #$10
  2702 118A A9 01		        LDA     #$01
  2703 118C A0 00		        LDY     #$00
  2704 118E 20 ED 09		        JSR     CIOGET
  2705
  2706 				    ; Quit if EOF
  2707 1191 A2 10		        LDX     #$10
  2708 1193 BD 43 03		        LDA     ICSTA,X
  2709 1196 C9 88		        CMP     #EOF
  2710 1198 F0 1C		        BEQ     TYPE_DONE
  2711
  2712 				    ; Convert CRLF or LF --> EOL
  2713 119A A0 00		        LDY     #$00
  2714 119C B1 F3		        LDA     (INBUFF),Y
  2715 119E C9 0D		        CMP     #CR     ; Skip CR
  2716 11A0 F0 11		        BEQ     TYPE_NEXT3
  2717 11A2 C9 0A		        CMP     #LF     ; Convert LF --> EOL
  2718 11A4 D0 04		        BNE     TYPE_NEXT2
  2719 11A6 A9 9B		        LDA     #EOL
  2720 11A8 91 F3		        STA     (INBUFF),Y
  2721
  2722 11AA			TYPE_NEXT2:
  2723 				    ; Write to screen
  2724 11AA A2 00		        LDX     #$00
  2725 11AC A9 01		        LDA     #$01
  2726 11AE A0 00		        LDY     #$00
  2727 11B0 20 0B 0A		        JSR     CIOPUT
  2728
  2729 11B3			TYPE_NEXT3:
  2730 				    ; Do next
  2731 11B3 4C 66 11		        JMP     TYPE_LOOP
  2732 				        
  2733 11B6			TYPE_DONE:
  2734 11B6 A9 FF		        LDA     #$FF
  2735 11B8 8D FC 02		        STA     CH
  2736 11BB A2 10		        LDX     #$10            ; Close File #1
  2737 11BD 4C BB 09		        JMP     CIOCLOSE        ; 
  2738
  2739 11C0			TYPE_OPEN_ERR_STR:
  2740 11C0 55 4E 41 42 4C 45 +         .BYTE   'UNABLE TO OPEN FILE',EOL
  2741
  2742 				;---------------------------------------
  2743 11D4			DO_UNLOCK:
  2744 				;---------------------------------------
  2745 11D4 A9 90		        LDA     #$90
  2746 11D6 8D C6 02		        STA     COLOR2
  2747 11D9 60			        RTS
  2748
  2749 				;---------------------------------------
  2750 11DA			DO_CAR:
  2751 				;---------------------------------------
  2752
  2753 				    ;---------------------------------------
  2754 				    ; Is cart address space RAM or ROM?
  2755 				    ;---------------------------------------
  2756 11DA AD 00 A0		        LDA     $A000
  2757 11DD EE 00 A0		        INC     $A000
  2758 11E0 CD 00 A0		        CMP     $A000
  2759 11E3 F0 0A		        BEQ     DO_CAR_NEXT
  2760
  2761 				    ;---------------------------------------
  2762 				    ; RAM found
  2763 				    ;---------------------------------------
  2764 11E5 8D 00 A0		        STA     $A000
  2765 11E8 A9 F6		        LDA     #<DO_CAR_ERR
  2766 11EA A0 11		        LDY     #>DO_CAR_ERR
  2767 11EC 4C 7B 0A		        JMP     PRINT_STRING
  2768
  2769 11EF			DO_CAR_NEXT
  2770 11EF A9 FF		        LDA     #$FF
  2771 11F1 85 08		        STA     $08         ; Warmstart
  2772 11F3 6C FA BF		        JMP     ($BFFA)
  2773
  2774 11F6			DO_CAR_ERR:
  2775 11F6 4E 4F 20 43 41 52 +         .BYTE   'NO CARTRIDGE',EOL
  2776
  2777 				;---------------------------------------
  2778 1203			DO_CLS:
  2779 				;---------------------------------------
  2780 1203 A9 0A		        LDA     #<CLS_STR
  2781 1205 A0 12		        LDY     #>CLS_STR
  2782 1207 4C 7B 0A		        JMP     PRINT_STRING
  2783
  2784 120A			CLS_STR:
  2785 120A 7D 9B		        .BYTE   125,EOL
  2786
  2787 				;---------------------------------------
  2788 120C			DO_COLD:
  2789 				;---------------------------------------
  2790 120C 4C 77 E4		        JMP     COLDSV
  2791
  2792 				.endif
  2793 				; SYNCALD
  2794 				.ifndef SYNCALC
  2795
  2796 				;---------------------------------------
  2797 120F			DO_HELP:
  2798 				;---------------------------------------
  2799 				    ; Append either "HELP" or arg1 to URL
  2800 120F A2 00		        LDX     #$00        ; index to start of article buf
  2801 1211 AC 78 0B		        LDY     CMDSEP      ; index to cmd line arg
  2802 				        
  2803 1214			HELP_LOOP1:
  2804 1214 B1 F3		        LDA     (INBUFF),Y
  2805 1216 C9 9B		        CMP     #EOL
  2806 1218 F0 11		        BEQ     HELP_NEXT1  ; Exit loop at end of arg
  2807 121A E0 16		        CPX     #22
  2808 121C 10 2B		        BPL     HELP_DONE   ; Exit if arg is too long
  2809 121E 9D A5 12		        STA     HELP_ARTICLE,X
  2810 1221 E8			        INX
  2811 1222 C8			        INY
  2812 1223 D0 EF		        BNE     HELP_LOOP1  ; Always true
  2813
  2814 				    ; Append .DOC extension to article name
  2815 1225			HELP_EXT:
  2816 1225 2E 44 4F 43 9B 00	        .BYTE   '.DOC',EOL,$00
  2817
  2818 122B			HELP_NEXT1:
  2819 122B A0 00		        LDY     #$00
  2820
  2821 122D			HELP_LOOP2:
  2822 122D B9 25 12		        LDA     HELP_EXT,Y
  2823 1230 9D A5 12		        STA     HELP_ARTICLE,X  ; Store null term too
  2824 1233 F0 04		        BEQ     HELP_NEXT2      ; Skip ahead if terminator
  2825 1235 E8			        INX
  2826 1236 C8			        INY
  2827 1237 D0 F4		        BNE     HELP_LOOP2  ; Always true
  2828
  2829 1239			HELP_NEXT2:
  2830 				    ; Copy URL to LNBUFF
  2831 1239 A2 00		        LDX     #$00    ; Index to start of HELP_URL
  2832 123B A0 05		        LDY     #$05    ; Index to start at arg1 for "TYPE "
  2833 				    
  2834 123D			HELP_LOOP3:
  2835 123D BD 51 12		        LDA     HELP_URL,X  ; Get source byte
  2836 1240 99 82 05		        STA     LNBUF,Y     ; Write to target location
  2837 1243 F0 04		        BEQ     HELP_DONE   ; Exit loop on null terminator
  2838 1245 E8			        INX                 ; Advance indices
  2839 1246 C8			        INY
  2840 1247 D0 F4		        BNE     HELP_LOOP3  ; Always true
  2841 				        
  2842 1249			HELP_DONE:        
  2843 1249 A9 05		        LDA     #$05        ; Trick TYPE to look for URL in arg1
  2844 124B 8D 78 0B		        STA     CMDSEP
  2845 124E 4C 36 11		        JMP     DO_TYPE
  2846
  2847 1251			HELP_URL:
  2848 				;        .BYTE   'N8:HTTP://localhost:6502/'
  2849 1251 4E 38 3A 48 54 54 +         .BYTE   'N8:HTTPS://raw.githubusercontent.com/michaelsternberg/fujinet-nhandler/nos/nos/HELP/'
  2850 12A5			HELP_ARTICLE:
  2851 12A5 00 00 00 00 00 00 +         .BYTE   $00,$00,$00,$00, $00,$00,$00,$00
  2852 12AD 00 00 00 00 00 00 +         .BYTE   $00,$00,$00,$00, $00,$00,$00,$00
  2853 12B5 00 00 00 00 00 00 +         .BYTE   $00,$00,$00,$00, $00,$00,$00,$00
  2854
  2855 				.endif
  2856 				;SYNCALC
  2857 				.ifndef SYNCALD
  2858
  2859 				;---------------------------------------
  2860 12BD			DO_NOBASIC:
  2861 				;---------------------------------------
  2862 				    ; Quit if 400/800
  2863 12BD AD F7 FF		        LDA     $FFF7
  2864 12C0 C9 FF		        CMP     #$FF        ; ????
  2865 12C2 F0 21		        BEQ     NOBASIC_ERROR
  2866 12C4 C9 DD		        CMP     #$DD        ; OSA NTSC
  2867 12C6 F0 1D		        BEQ     NOBASIC_ERROR
  2868 12C8 C9 F3		        CMP     #$F3        ; OSB NTSC
  2869 12CA F0 19		        BEQ     NOBASIC_ERROR
  2870 12CC C9 D6		        CMP     #$D6        ; OSA PAL
  2871 12CE F0 15		        BEQ     NOBASIC_ERROR
  2872 12D0 C9 22		        CMP     #$22        ; OSB PAL
  2873 12D2 F0 11		        BEQ     NOBASIC_ERROR
  2874 12D4 C9 0A		        CMP     #$0A        ; OSA 1200XL
  2875 12D6 F0 0D		        BEQ     NOBASIC_ERROR
  2876 12D8 C9 0B		        CMP     #$0B        ; OSB 1200XL
  2877 12DA F0 09		        BEQ     NOBASIC_ERROR
  2878 				        
  2879 				    ; Disable BASIC
  2880 12DC AD 01 D3		        LDA     PORTB
  2881 12DF 09 02		        ORA     #%00000010  ; if Bit 1 = 1 then BASIC is disabled
  2882 12E1 8D 01 D3		        STA     PORTB
  2883 12E4 60			        RTS
  2884
  2885 				;---------------------------------------
  2886 12E5			NOBASIC_ERROR:
  2887 				;---------------------------------------
  2888 12E5 A9 EC		        LDA     #<NOBASIC_ERROR_STR
  2889 12E7 A0 12		        LDY     #>NOBASIC_ERROR_STR
  2890 12E9 4C 7B 0A		        JMP     PRINT_STRING
  2891
  2892 12EC			NOBASIC_ERROR_STR:
  2893 12EC 4E 4F 20 42 55 49 +         .BYTE   'NO BUILT-IN BASIC',EOL
  2894
  2895 				;---------------------------------------
  2896 12FE			DO_NOSCREEN:
  2897 				;---------------------------------------
  2898 12FE A9 00		        LDA     #$00
  2899 1300 8D 88 15		        STA     CURSCR
  2900 1303 60			        RTS
  2901
  2902 				;---------------------------------------
  2903 1304			DO_SCREEN:
  2904 				;---------------------------------------
  2905 1304 A9 01		        LDA     #$01
  2906 1306 8D 88 15		        STA     CURSCR
  2907 1309 60			        RTS
  2908
  2909 				;---------------------------------------
  2910 130A			DO_PRINT:
  2911 				;---------------------------------------
  2912 130A AD 78 0B		        LDA     CMDSEP
  2913 130D F0 08		        BEQ     PRINT_DONE
  2914
  2915 130F 18			        CLC
  2916 1310 65 F3		        ADC     INBUFF
  2917 1312 A4 F4		        LDY     INBUFF+1
  2918 1314 4C 7B 0A		        JMP     PRINT_STRING
  2919
  2920 1317			PRINT_DONE:
  2921 1317 60			        RTS
  2922
  2923 				;---------------------------------------
  2924 1318			DO_REENTER:
  2925 				;---------------------------------------
  2926 				    ; Jump to the address stored in RUNAD or INITAD
  2927 				    ; Do the one that isn't pointing to R (RUNAD first)
  2928
  2929 				    ; Skip it all if both contain $0000
  2930 1318 AD E2 02		        LDA     INITAD
  2931 131B D0 16		        BNE     DO_REENTER_CONT
  2932 131D AD E3 02		        LDA     INITAD+1
  2933 1320 D0 11		        BNE     DO_REENTER_CONT
  2934 1322 AD E0 02		        LDA     RUNAD
  2935 1325 D0 0C		        BNE     DO_REENTER_CONT
  2936 1327 AD E1 02		        LDA     RUNAD+1
  2937 132A D0 07		        BNE     DO_REENTER_CONT
  2938
  2939 132C A9 47		        LDA     #<DO_REENTER_ERR
  2940 132E A0 13		        LDY     #>DO_REENTER_ERR
  2941 1330 4C 7B 0A		        JMP     PRINT_STRING
  2942
  2943 1333			DO_REENTER_CONT:
  2944 1333 AD E0 02		        LDA     RUNAD
  2945 1336 C9 0D		        CMP     #>R
  2946 1338 D0 07		        BNE     DO_REENTER_RUNAD
  2947 133A AD E1 02		        LDA     RUNAD+1
  2948 133D C9 0D		        CMP     #>R
  2949 133F F0 03		        BEQ     DO_REENTER_INITAD
  2950
  2951 1341			DO_REENTER_RUNAD:
  2952 1341 6C E0 02		        JMP     (RUNAD)     ; Godspeed
  2953
  2954 1344			DO_REENTER_INITAD:
  2955 1344 6C E2 02		        JMP     (INITAD)    ; Godspeed
  2956
  2957 1347			DO_REENTER_ERR:
  2958 1347 4E 4F 20 41 44 44 +         .BYTE   'NO ADDR IN INITAD OR RUNAD',EOL
  2959
  2960 				;---------------------------------------
  2961 1362			DO_REM:
  2962 				;---------------------------------------
  2963 1362 60			        RTS
  2964
  2965 				;---------------------------------------
  2966 1363			DO_RUN:
  2967 				;---------------------------------------
  2968 1363 AD 78 0B		        LDA     CMDSEP      ; Get position for address arg
  2969 1366 A8			        TAY                 ; Offset to arg used later
  2970 1367 18			        CLC
  2971 1368 69 04		        ADC     #$04
  2972 136A 8D 00 16		        STA     RBUF
  2973
  2974 				    ;---------------------------------------
  2975 				    ; ASCII hex char to integer conversion
  2976 				    ; algorithm borrowed from Apple II Monitor
  2977 				    ;---------------------------------------
  2978 136D A9 00		        LDA     #$00
  2979 136F 85 F3		        STA     INBUFF      ; L
  2980 1371 85 F4		        STA     INBUFF+1    ; H
  2981 1373			NEXTHEX:
  2982 1373 B9 82 05		        LDA     LNBUF,Y     ; Get character for hex test.
  2983 1376 49 30		        EOR     #%00110000  ; Maps digits to $0-$9
  2984 1378 C9 0A		        CMP     #$0A        ; Digit?
  2985 137A 90 06		        BCC     DIG         ; Yes.
  2986 137C 69 88		        ADC     #$88        ; Map letter "A"-"F" to $FA-FF.
  2987 137E C9 FA		        CMP     #$FA        ; Hex letter?
  2988 1380 90 17		        BCC     NOTHEX      ; No, character not hex.
  2989
  2990 1382 0A			DIG:    ASL
  2991 1383 0A			        ASL
  2992 1384 0A			        ASL
  2993 1385 0A			        ASL
  2994 1386 A2 04		        LDX     #$04        ; Shift count.
  2995
  2996 1388			HEXSHIFT:
  2997 1388 0A			        ASL
  2998 1389 26 F3		        ROL     INBUFF      ; Rotate into LSD.
  2999 138B 26 F4		        ROL     INBUFF+1    ; Rotate into MSD's.
  3000 138D CA			        DEX                 ; Done 4 shifts?
  3001 138E D0 F8		        BNE     HEXSHIFT    ; No, loop.
  3002 1390 C8			        INY                 ; Advance text index
  3003 1391 CC 00 16		        CPY     RBUF        ; Processed 4 characters?
  3004 1394 D0 DD		        BNE     NEXTHEX     ; No, get next character.
  3005
  3006 1396 6C F3 00		        JMP     (INBUFF)    ; Goto requested address. Godspeed.
  3007
  3008 1399			NOTHEX:
  3009 1399 A9 A0		        LDA     #<RUN_ERROR_STR
  3010 139B A0 13		        LDY     #>RUN_ERROR_STR
  3011 139D 4C 7B 0A		        JMP     PRINT_STRING
  3012
  3013 13A0			RUN_ERROR_STR:
  3014 13A0 41 44 44 52 3F 20 +         .BYTE   'ADDR? 0000..FFFF',EOL
  3015
  3016 				;---------------------------------------
  3017 13B1			DO_WARM:
  3018 				;---------------------------------------
  3019 13B1 4C 74 E4		        JMP     WARMSV
  3020 				.endif
  3021 				; SYNCALD
  3022
  3023 				;---------------------------------------
  3024 13B4			REMOUNT_DRIVE:
  3025 				;---------------------------------------
  3026
  3027 				    ;---------------------------------------
  3028 				    ; Workaround for timeout issue regarding idempotent commands that
  3029 				    ; unmount the server.  So far, these are DEL and RENAME. This
  3030 				    ; routine, remounts the TNFS URL by calling NPWD and attempts
  3031 				    ; a MKDIR on the returned mount point. Hopefully this is an
  3032 				    ; non-consequential operation since the directory already exists.
  3033 				    ;---------------------------------------
  3034
  3035 13B4 20 0C 10		        JSR     DO_NPWD         ; Curr dir for drive now in RBUF
  3036
  3037 13B7 AD 00 16		        LDA     RBUF            ; Quit if not TNFS. Only TNFS is affected.
  3038 13BA C9 54		        CMP     #'T'            ; TODO More letters needed if...
  3039 13BC D0 28		        BNE     REMOUNT_DONE    ; ...another Txxx protocol exists
  3040
  3041 13BE A9 4E		        LDA     #'N'
  3042 13C0 8D 00 16		        STA     RBUF+0
  3043 13C3 AD 85 15		        LDA     DOSDR           ; Get drive number
  3044 13C6 09 30		        ORA     #'0'            ; Convert, say, 1 to '1'
  3045 13C8 8D 01 16		        STA     RBUF+1
  3046 13CB A9 3A		        LDA     #':'
  3047 13CD 8D 02 16		        STA     RBUF+2
  3048
  3049 13D0 A9 2A		        LDA     #CMD_MKDIR
  3050 13D2 8D A4 0C		        STA     GENDCB+2
  3051 13D5 A9 00		        LDA     #<RBUF          ; TODO Is this needed
  3052 13D7 8D A6 0C		        STA     GENDCB+4        ; TODO or is it hardcoded in DO_GENERIC?
  3053 13DA A9 16		        LDA     #>RBUF
  3054 13DC 8D A7 0C		        STA     GENDCB+5
  3055
  3056 13DF A9 A2		        LDA     #<GENDCB
  3057 13E1 A0 0C		        LDY     #>GENDCB
  3058 13E3 4C A5 07		        JMP     DOSIOV
  3059
  3060 13E6			REMOUNT_DONE:
  3061 13E6 60			        RTS
  3062
  3063 				;---------------------------------------
  3064 13E7			PREPEND_DRIVE:
  3065 				;---------------------------------------
  3066 				        ; Inject "Nn:" in front of a plain filename
  3067 				        ; before passing it to the FujiNet
  3068 13E7 A0 00		        LDY     #$00
  3069 13E9 A9 4E		        LDA     #'N'
  3070 13EB D1 F3		        CMP     (INBUFF),Y  ; Does arg1 already begin with N?
  3071
  3072 13ED A0 02		        LDY     #$02
  3073 13EF A9 3A		        LDA     #':'
  3074 13F1 D1 F3		        CMP     (INBUFF),Y
  3075 13F3 F0 1C		        BEQ     PREPEND_DRIVE_DONE
  3076 13F5 88			        DEY
  3077 13F6 D1 F3		        CMP     (INBUFF),Y
  3078 13F8 F0 17		        BEQ     PREPEND_DRIVE_DONE
  3079
  3080 				        ; Move input buffer pointer back 3 bytes
  3081 13FA 38			        SEC
  3082 13FB A5 F3		        LDA     INBUFF
  3083 13FD E9 03		        SBC     #$03
  3084 13FF 85 F3		        STA     INBUFF
  3085 1401 A5 F4		        LDA     INBUFF+1
  3086 1403 E9 00		        SBC     #$00
  3087 1405 85 F4		        STA     INBUFF+1
  3088
  3089 				        ; Inject PRMPT to front of arg1
  3090 1407 A0 03		        LDY     #$03
  3091 1409			PREPEND_DRIVE_LOOP:
  3092 1409 B9 3B 14		        LDA     PRMPT,Y
  3093 140C 88			        DEY
  3094 140D 91 F3		        STA     (INBUFF),Y
  3095 140F D0 F8		        BNE     PREPEND_DRIVE_LOOP
  3096
  3097 1411			PREPEND_DRIVE_DONE:
  3098 1411 A0 01		        LDY     #$01
  3099 1413 60			        RTS             ; Y = $00 here
  3100
  3101 				;---------------------------------------
  3102 1414			APPEND_SLASH:
  3103 				;---------------------------------------
  3104 				    ;---------------------------------------
  3105 				    ; Skip if relative path (..)
  3106 				    ;---------------------------------------
  3107 1414 A0 00		        LDY     #$00
  3108 1416 A9 2E		        LDA     #'.'
  3109 1418 D1 F3		        CMP     (INBUFF),Y
  3110 141A F0 1E		        BEQ     APPEND_SLASH_DONE
  3111
  3112 141C A0 FF		        LDY     #$FF        ; Iterate thru arg2 until EOF
  3113 141E			APPEND_SLASH_LOOP:
  3114 141E C8			        INY                 ; Zero on 1st pass
  3115 141F B1 F3		        LDA     (INBUFF),Y
  3116 1421 C9 9B		        CMP     #EOL
  3117 1423 D0 F9		        BNE     APPEND_SLASH_LOOP
  3118
  3119 1425 88			        DEY                 ; Move pointer back one character
  3120 1426 B1 F3		        LDA     (INBUFF),Y
  3121 1428 C9 2F		        CMP     #'/'        ; If already slash then skip rest
  3122 142A F0 0E		        BEQ     APPEND_SLASH_DONE
  3123 142C C9 3A		        CMP     #':'        ; If a drive, skip
  3124 142E F0 0A		        BEQ     APPEND_SLASH_DONE
  3125
  3126 1430 C8			        INY                 ; Else inject '/' + EOL
  3127 1431 A9 2F		        LDA     #'/'
  3128 1433 91 F3		        STA     (INBUFF),Y
  3129 1435 C8			        INY
  3130 1436 A9 9B		        LDA     #EOL
  3131 1438 91 F3		        STA     (INBUFF),Y
  3132
  3133 143A			APPEND_SLASH_DONE:
  3134 143A 60			        RTS
  3135
  3136 143B			PRMPT:
  3137 143B 9B 4E 20 3A		        .BYTE   EOL,'N :'
  3138
  3139 				;;; End CP ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  3140 				;;; Variables
  3141
  3142 143F			        .ENUM   CMD_IDX
  3143 				        ;---------------
  3144 = 0000			                NCD                 ;  0
  3145 = 0001			                COPY                ;  1
  3146 = 0002			                DIR                 ;  2
  3147 = 0003			                DEL                 ;  3
  3148 = 0004			                LOAD                ;  4
  3149 = 0005			                LOCK                ;  5
  3150 = 0006			                MKDIR               ;  6
  3151 = 0007			                NPWD                ;  7
  3152 				.ifndef SYNCALD
  3153 = 0008			                NTRANS              ;  8
  3154 = 0009			                RENAME              ;  9
  3155 = 000A			                RMDIR               ; 10
  3156 = 000B			                SOURCE              ; 11
  3157 = 000C			                TYPE                ; 12
  3158 = 000D			                UNLOCK              ; 13
  3159 = 000E			                CAR                 ; 14
  3160 = 000F			                CLS                 ; 15
  3161 = 0010			                COLD                ; 16
  3162 				.endif
  3163 				.ifndef SYNCALC
  3164 = 0011			                HELP                ; 17
  3165 				.endif
  3166 				.ifndef SYNCALD
  3167 = 0012			                NOBASIC             ; 18
  3168 = 0013			                NOSCREEN            ; 19
  3169 = 0014			                PRINT               ; 20
  3170 = 0015			                REENTER             ; 21
  3171 = 0016			                REM                 ; 22
  3172 = 0017			                RUN                 ; 23
  3173 = 0018			                SCREEN              ; 24
  3174 = 0019			                WARM                ; 25
  3175 				.endif
  3176 = 001A			                DRIVE_CHG           ; 26
  3177 				        .ENDE
  3178
  3179 143F			CMD_DCOMND:
  3180 143F 2C			        .BYTE   CMD_CD              ;  0 NCD
  3181 1440 A1			        .BYTE   CMD_COPY            ;  1 COPY
  3182 1441 02			        .BYTE   CMD_DIR             ;  2 DIR
  3183 1442 21			        .BYTE   CMD_DEL             ;  3 DEL
  3184 1443 28			        .BYTE   CMD_LOAD            ;  4 LOAD
  3185 1444 23			        .BYTE   CMD_LOCK            ;  5 LOCK
  3186 1445 2A			        .BYTE   CMD_MKDIR           ;  6 MKDIR
  3187 1446 30			        .BYTE   CMD_NPWD            ;  7 NPWD
  3188 				.ifndef SYNCALD
  3189 1447 54			        .BYTE   CMD_NTRANS          ;  8 NTRANS
  3190 1448 20			        .BYTE   CMD_RENAME          ;  9 RENAME
  3191 1449 2B			        .BYTE   CMD_RMDIR           ; 10 RMDIR
  3192 144A F0			        .BYTE   CMD_SOURCE          ; 11 SOURCE
  3193 144B F0			        .BYTE   CMD_TYPE            ; 12 TYPE
  3194 144C 24			        .BYTE   CMD_UNLOCK          ; 13 UNLOCK
  3195 144D F0			        .BYTE   CMD_CAR             ; 14 CAR
  3196 144E F0			        .BYTE   CMD_CLS             ; 15 CLS
  3197 144F F0			        .BYTE   CMD_COLD            ; 16 COLD
  3198 				.endif
  3199 				.ifndef SYNCALC
  3200 1450 F0			        .BYTE   CMD_HELP            ; 17 HELP
  3201 				.endif
  3202 				.ifndef SYNCALD
  3203 1451 F0			        .BYTE   CMD_NOBASIC         ; 18 NOBASIC
  3204 1452 F0			        .BYTE   CMD_NOSCREEN        ; 19 NOSCREEN
  3205 1453 F0			        .BYTE   CMD_PRINT           ; 20 PRINT
  3206 1454 F0			        .BYTE   CMD_REENTER         ; 21 REENTER
  3207 1455 F0			        .BYTE   CMD_REM             ; 22 REM
  3208 1456 F0			        .BYTE   CMD_RUN             ; 23 RUN
  3209 1457 F0			        .BYTE   CMD_SCREEN          ; 24 SCREEN
  3210 1458 F0			        .BYTE   CMD_WARM            ; 25 WARM
  3211 				.endif
  3212 1459 01			        .BYTE   CMD_DRIVE_CHG       ; 26
  3213
  3214 145A			COMMAND:
  3215 145A 4E 43 C4		        .CB     "NCD"               ;  0 NCD
  3216 145D 00			        .BYTE   CMD_IDX.NCD            
  3217
  3218 145E 43 4F 50 D9		        .CB     "COPY"              ;  1 COPY
  3219 1462 01			        .BYTE   CMD_IDX.COPY           
  3220
  3221 1463 44 49 D2		        .CB     "DIR"               ;  2 DIR
  3222 1466 02			        .BYTE   CMD_IDX.DIR              
  3223
  3224 1467 44 45 CC		        .CB     "DEL"               ;  3 DEL
  3225 146A 03			        .BYTE   CMD_IDX.DEL              
  3226
  3227 146B 4C 4F 41 C4		        .CB     "LOAD"              ;  4 LOAD
  3228 146F 04			        .BYTE   CMD_IDX.LOAD             
  3229
  3230 1470 4C 4F 43 CB		        .CB     "LOCK"              ;  5 LOCK
  3231 1474 05			        .BYTE   CMD_IDX.LOCK             
  3232
  3233 1475 4D 4B 44 49 D2	        .CB     "MKDIR"             ;  6 MKDIR
  3234 147A 06			        .BYTE   CMD_IDX.MKDIR            
  3235
  3236 147B 4E 50 57 C4		        .CB     "NPWD"              ;  7 NPWD
  3237 147F 07			        .BYTE   CMD_IDX.NPWD             
  3238
  3239 				.ifndef SYNCALD
  3240 1480 4E 54 52 41 4E D3	        .CB     "NTRANS"            ;  8 NTRANS
  3241 1486 08			        .BYTE   CMD_IDX.NTRANS          
  3242
  3243 1487 52 45 4E 41 4D C5	        .CB     "RENAME"            ;  9 RENAME
  3244 148D 09			        .BYTE   CMD_IDX.RENAME          
  3245
  3246 148E 52 4D 44 49 D2	        .CB     "RMDIR"             ; 10 RMDIR
  3247 1493 0A			        .BYTE   CMD_IDX.RMDIR           
  3248
  3249 1494 53 4F 55 52 43 C5	        .CB     "SOURCE"            ; 11 SOURCE
  3250 149A 0B			        .BYTE   CMD_IDX.SOURCE             
  3251
  3252 149B 54 59 50 C5		        .CB     "TYPE"              ; 12 SOURCE
  3253 149F 0C			        .BYTE   CMD_IDX.TYPE              
  3254
  3255 14A0 55 4E 4C 4F 43 CB	        .CB     "UNLOCK"            ; 13 UNLOCK
  3256 14A6 0D			        .BYTE   CMD_IDX.UNLOCK            
  3257
  3258 14A7 43 41 D2		        .CB     "CAR"               ; 14 CAR
  3259 14AA 0E			        .BYTE   CMD_IDX.CAR             
  3260
  3261 14AB 43 4C D3		        .CB     "CLS"               ; 15 CLS
  3262 14AE 0F			        .BYTE   CMD_IDX.CLS             
  3263
  3264 14AF 43 4F 4C C4		        .CB     "COLD"              ; 16 COLD
  3265 14B3 10			        .BYTE   CMD_IDX.COLD              
  3266
  3267 				.endif
  3268 				.ifndef SYNCALC
  3269 14B4 48 45 4C D0		        .CB     "HELP"              ; 17 HELP
  3270 14B8 11			        .BYTE   CMD_IDX.HELP                
  3271 				.endif
  3272 				.ifndef SYNCALD
  3273 				                                        
  3274 14B9 4E 4F 42 41 53 49 +         .CB     "NOBASIC"           ; 18 NOBASIC
  3275 14C0 12			        .BYTE   CMD_IDX.NOBASIC         
  3276 				                                        
  3277 14C1 40 4E 4F 53 43 52 +         .CB     "@NOSCREEN"         ; 19 @NOSCREEN
  3278 14CA 13			        .BYTE   CMD_IDX.NOSCREEN         
  3279 				                                        
  3280 14CB 50 52 49 4E D4	        .CB     "PRINT"             ; 20 PRINT
  3281 14D0 14			        .BYTE   CMD_IDX.PRINT           
  3282 				                                        
  3283 14D1 52 45 45 4E 54 45 +         .CB     "REENTER"           ; 21 REENTER
  3284 14D8 15			        .BYTE   CMD_IDX.REENTER         
  3285 				                                        
  3286 14D9 52 45 CD		        .CB     "REM"               ; 22 REM
  3287 14DC 16			        .BYTE   CMD_IDX.REM             
  3288 				                                        
  3289 14DD 52 55 CE		        .CB     "RUN"               ; 23 RUN
  3290 14E0 17			        .BYTE   CMD_IDX.RUN             
  3291 				                                        
  3292 14E1 40 53 43 52 45 45 +         .CB     "@SCREEN"           ; 24 @SCREEN
  3293 14E8 18			        .BYTE   CMD_IDX.SCREEN
  3294
  3295 14E9 57 41 52 CD		        .CB     "WARM"              ; 25 WARM
  3296 14ED 19			        .BYTE   CMD_IDX.WARM
  3297
  3298 				; Aliases
  3299 14EE 43 C4		        .CB     "CD"                ; CD = NCD
  3300 14F0 00			        .BYTE   CMD_IDX.NCD           
  3301
  3302 14F1 43 57 C4		        .CB     "CWD"               ; CWD = NCD
  3303 14F4 00			        .BYTE   CMD_IDX.NCD           
  3304
  3305 14F5 45 52 41 53 C5	        .CB     "ERASE"             ; ERASE = DEL
  3306 14FA 03			        .BYTE   CMD_IDX.DEL           
  3307
  3308 14FB 45 52 C1		        .CB     "ERA"               ; ERA = DEL
  3309 14FE 03			        .BYTE   CMD_IDX.DEL           
  3310
  3311 14FF D8			        .CB     "X"                 ; X = LOAD
  3312 1500 04			        .BYTE   CMD_IDX.LOAD
  3313
  3314 1501 50 57 C4		        .CB     "PWD"               ; PWD = NPWD
  3315 1504 07			        .BYTE   CMD_IDX.NPWD             
  3316
  3317 1505 52 45 C5		        .CB     "REE"               ; R = REENTER
  3318 1508 15			        .BYTE   CMD_IDX.REENTER             
  3319
  3320 1509 52 45 CE		        .CB     "REN"               ; REN = RENAME
  3321 150C 09			        .BYTE   CMD_IDX.RENAME
  3322
  3323 150D C0			        .CB     "@"                 ; @ = SOURCE
  3324 150E 0B			        .BYTE   CMD_IDX.SOURCE
  3325 				.endif
  3326 				;SYNCALD
  3327
  3328 				        ; Drive Change intentionally omitted
  3329
  3330 = 00B4			COMMAND_SIZE = * - COMMAND - 1
  3331 150F FF			        .BYTE   $FF
  3332
  3333 1510			CMD_TAB_L:
  3334 1510 40			        .BYTE   <(DO_GENERIC-1)     ;  0 NCD
  3335 1511 AD			        .BYTE   <(DO_COPY-1)        ;  1 COPY
  3336 1512 B3			        .BYTE   <(DO_DIR-1)         ;  2 DIR
  3337 1513 40			        .BYTE   <(DO_GENERIC-1)     ;  3 DEL
  3338 1514 9D			        .BYTE   <(DO_LOAD-1)        ;  4 LOAD
  3339 1515 05			        .BYTE   <(DO_LOCK-1)        ;  5 LOCK
  3340 1516 40			        .BYTE   <(DO_GENERIC-1)     ;  6 MKDIR
  3341 1517 0B			        .BYTE   <(DO_NPWD-1)        ;  7 NPWD
  3342 				.ifndef SYNCALD
  3343 1518 4E			        .BYTE   <(DO_NTRANS-1)      ;  8 NTRANS
  3344 1519 40			        .BYTE   <(DO_GENERIC-1)     ;  9 RENAME
  3345 151A 40			        .BYTE   <(DO_GENERIC-1)     ; 10 RMDIR
  3346 151B D1			        .BYTE   <(DO_SOURCE-1)      ; 11 SOURCE
  3347 151C 35			        .BYTE   <(DO_TYPE-1)        ; 12 TYPE
  3348 151D D3			        .BYTE   <(DO_UNLOCK-1)      ; 13 UNLOCK
  3349 151E D9			        .BYTE   <(DO_CAR-1)         ; 14 CAR
  3350 151F 02			        .BYTE   <(DO_CLS-1)         ; 15 CLS
  3351 1520 0B			        .BYTE   <(DO_COLD-1)        ; 16 COLD
  3352 				.endif
  3353 				.ifndef SYNCALC
  3354 1521 0E			        .BYTE   <(DO_HELP-1)        ; 17 HELP
  3355 				.endif
  3356 				.ifndef SYNCALD
  3357 1522 BC			        .BYTE   <(DO_NOBASIC-1)     ; 18 NOBASIC
  3358 1523 FD			        .BYTE   <(DO_NOSCREEN-1)    ; 19 NOSCREEN
  3359 1524 09			        .BYTE   <(DO_PRINT-1)       ; 20 PRINT
  3360 1525 17			        .BYTE   <(DO_REENTER-1)     ; 21 REENTER
  3361 1526 61			        .BYTE   <(DO_REM-1)         ; 22 REM
  3362 1527 62			        .BYTE   <(DO_RUN-1)         ; 22 RUN
  3363 1528 03			        .BYTE   <(DO_SCREEN-1)      ; 23 SCREEN
  3364 1529 B0			        .BYTE   <(DO_WARM-1)        ; 24 WARM
  3365 152A FF			        .BYTE   <(DO_DRIVE_CHG-1)   ; 25
  3366 				.endif
  3367
  3368 152B			CMD_TAB_H:
  3369 152B 0C			        .BYTE   >(DO_GENERIC-1)     ;  0 NCD
  3370 152C 0C			        .BYTE   >(DO_COPY-1)        ;  1 COPY
  3371 152D 0C			        .BYTE   >(DO_DIR-1)         ;  2 DIR
  3372 152E 0C			        .BYTE   >(DO_GENERIC-1)     ;  3 DEL
  3373 152F 0D			        .BYTE   >(DO_LOAD-1)        ;  4 LOAD
  3374 1530 10			        .BYTE   >(DO_LOCK-1)        ;  5 LOCK
  3375 1531 0C			        .BYTE   >(DO_GENERIC-1)     ;  6 MKDIR
  3376 1532 10			        .BYTE   >(DO_NPWD-1)        ;  7 NPWD
  3377 				.ifndef SYNCALD
  3378 1533 10			        .BYTE   >(DO_NTRANS-1)      ;  8 NTRANS
  3379 1534 0C			        .BYTE   >(DO_GENERIC-1)     ;  9 RENAME
  3380 1535 0C			        .BYTE   >(DO_GENERIC-1)     ; 10 RMDIR
  3381 1536 10			        .BYTE   >(DO_SOURCE-1)      ; 11 SOURCE
  3382 1537 11			        .BYTE   >(DO_TYPE-1)        ; 12 TYPE
  3383 1538 11			        .BYTE   >(DO_UNLOCK-1)      ; 13 UNLOCK
  3384 1539 11			        .BYTE   >(DO_CAR-1)         ; 14 CAR
  3385 153A 12			        .BYTE   >(DO_CLS-1)         ; 15 CLS
  3386 153B 12			        .BYTE   >(DO_COLD-1)        ; 16 COLD
  3387 				.endif
  3388 				.ifndef SYNCALC
  3389 153C 12			        .BYTE   >(DO_HELP-1)        ; 17 HELP
  3390 				.endif
  3391 				.ifndef SYNCALD
  3392 153D 12			        .BYTE   >(DO_NOBASIC-1)     ; 18 NOBASIC
  3393 153E 12			        .BYTE   >(DO_NOSCREEN-1)    ; 19 NOSCREEN
  3394 153F 13			        .BYTE   >(DO_PRINT-1)       ; 20 PRINT
  3395 1540 13			        .BYTE   >(DO_REENTER-1)     ; 21 REENTER
  3396 1541 13			        .BYTE   >(DO_REM-1)         ; 22 REM
  3397 1542 13			        .BYTE   >(DO_RUN-1)         ; 23 RUN
  3398 1543 13			        .BYTE   >(DO_SCREEN-1)      ; 24 SCREEN
  3399 1544 13			        .BYTE   >(DO_WARM-1)        ; 25 WARM
  3400 1545 0B			        .BYTE   >(DO_DRIVE_CHG-1)   ; 26
  3401 				.endif
  3402
  3403 				        ; DEVHDL TABLE FOR N:
  3404
  3405 1546 BD 07		CIOHND  .WORD   OPEN-1
  3406 1548 0B 08		        .WORD   CLOSE-1
  3407 154A 2C 08		        .WORD   GET-1
  3408 154C 8D 08		        .WORD   PUT-1
  3409 154E ED 08		        .WORD   STATUS-1
  3410 1550 53 09		        .WORD   SPEC-1
  3411
  3412 				       ; BANNERS
  3413
  3414 				.ifdef SYNCALC
  3415 				BREADY  .BYTE   '#FUJI NOS-SC5a 0.3.2',EOL
  3416 				BERROR  .BYTE   '#FUJI ERR',EOL
  3417 				.else
  3418 1552 23 46 55 4A 49 4E + BREADY  .BYTE   '#FUJINET NOS v0.3.2-alpha',EOL
  3419 156C 23 46 55 4A 49 4E + BERROR  .BYTE   '#FUJINET ERROR',EOL
  3420 				.endif
  3421
  3422 				        ; MESSAGES
  3423
  3424 157B 4E 23 3F 9B		CDERR   .BYTE   'N#?',EOL
  3425
  3426 				        ; STRING CONSTANTS
  3427
  3428 157F			MISSING_FILE_STR:
  3429 157F 46 49 4C 45 3F 9B	        .BYTE   'FILE?',EOL
  3430
  3431 				        ; VARIABLES
  3432
  3433 1585 01			DOSDR   .BYTE   $01         ; DOS DRIVE
  3434 1586 01			CMD     .BYTE   $01
  3435 1587 01			CMDPRV  .BYTE   $01
  3436 1588 01			CURSCR  .BYTE   $01         ; echo batch cmds (1=enabled,0=disabled)
  3437
  3438 1589 01			TRIP    .BYTE   $01         ; INTR FLAG
  3439 158A 00 00 00 00		RLEN    :MAXDEV .BYTE $00   ; RCV LEN
  3440 158E 00 00 00 00		ROFF    :MAXDEV .BYTE $00   ; RCV OFFSET
  3441 1592 00 00 00 00		TOFF    :MAXDEV .BYTE $00   ; TRX OFFSET
  3442 1596 01			INQDS   .BYTE   $01         ; DSTATS INQ
  3443
  3444 1597 00 00 00 00		DVS2    :MAXDEV .BYTE $00   ; DVSTAT+2 SAVE
  3445 159B 00 00 00 00		DVS3    :MAXDEV .BYTE $00   ; DVSTAT+3 SAVE
  3446
  3447 				       ; BUFFERS (PAGE ALIGNED)
  3448 159F 00 00 00 00 00 00 +         .ALIGN  $100, $00
  3449 1600			BOOTEND:
  3450
  3451 1600 00 00 00 00 00 00 + RBUF    :$80 .BYTE $00      ; 128 bytes
  3452 1680 00 00 00 00 00 00 + TBUF    :$80 .BYTE $00      ; 128 bytes
  3453
  3454 				; Binary loader working variables
  3455 = 1600			BAL     = RBUF
  3456 = 1601			BAH     = RBUF+1    ;
  3457 = 1680			STL     = TBUF      ; Payload Start address
  3458 = 1681			STH     = TBUF+1
  3459 = 1682			ENL     = TBUF+2    ; Payload End address
  3460 = 1683			ENH     = TBUF+3
  3461 = 1684			BLL     = TBUF+4    ; Payload Buffer Length
  3462 = 1685			BLH     = TBUF+5
  3463 = 1686			HEADL   = TBUF+6    ; Bytes read from existing cache
  3464 = 1687			HEADH   = TBUF+7
  3465 = 1688			BODYL   = TBUF+8    ; Total bytes read in contiguous 512-byte blocks
  3466 = 1689			BODYH   = TBUF+9
  3467 = 168A			TAILL   = TBUF+10   ; Bytes read from last cache
  3468 = 168B			TAILH   = TBUF+11
  3469 = 168C			BODYSZL = TBUF+12   ; # Bytes to read at a time in Body
  3470 = 168D			BODYSZH = TBUF+13
  3471
  3472 = 1700			PGEND   = *
  3473
  3474 				; =================================================================
  3475 				; VTOC and Directory
  3476 				;
  3477
  3478 				; $10 is the added ATR-header
  3479 1700 00 00 00 00 00 00 + 	:($B390-*+HDR-$10) DTA $00
  3480 BA80			VTOCSTA
  3481 BA80 02 BD 02			DTA $02,$BD,$02
  3482 BA83			VTOCEND
  3483 				; Fill the remaining bytes of the VTOC sector
  3484 BA83 00 00 00 00 00 00 + 	:($80+VTOCSTA-VTOCEND) DTA $00
  3485
  3486 BB00			DIRSTA
  3487 BB00 42 00 00 00 00 2A + 	DTA $42,$00,$00,$00,$00,c"***********"
  3488 BB10 42 00 00 00 00 2A + 	DTA $42,$00,$00,$00,$00,c"* FujiNet *"
  3489 BB20 42 00 00 00 00 2A + 	DTA $42,$00,$00,$00,$00,c"* Network *"
  3490 BB30 42 00 00 00 00 2A + 	DTA $42,$00,$00,$00,$00,c"*   OS    *"
  3491 BB40 42 00 00 00 00 2A + 	DTA $42,$00,$00,$00,$00,c"*         *"
  3492 BB50 42 00 00 00 00 2A + 	DTA $42,$00,$00,$00,$00,c"* v0.3.2  *"
  3493 BB60 42 00 00 00 00 2A + 	DTA $42,$00,$00,$00,$00,c"*  alpha  *"
  3494 BB70 42 00 00 00 00 2A + 	DTA $42,$00,$00,$00,$00,c"***********"
  3495 BB80			DIREND
  3496 				; Fill the remaining sectors of the directory
  3497 BB80 00 00 00 00 00 00 + 	:($400+DIRSTA-DIREND) DTA $00
  3498 					
  3499 				; Sectors behind directory
  3500 BF00 00 00 00 00 00 00 + 	:($80*352) DTA $00
  3501
  3502 				       END
