mads 2.1.5
Source: nos.s
     1 				        
     2 				        ;; Compile with MADS
     3
     4 				        ;; Authors: Thomas Cherryhomes
     5 				        ;;   <thom.cherryhomes@gmail.com>
     6
     7 				        ;; Michael Sternberg
     8 				        ;;   <mhsternberg@gmail.com>
     9
    10
    11 				        ;; Optimizations being done by djaybee!
    12 				        ;; Thank you so much!
    13
    14
    15 = 000A			DOSVEC  =   $0A         ; DOSVEC
    16 = 000C			DOSINI  =   $0C         ; DOSINI
    17
    18 				        ;; CURRENT IOCB IN ZERO PAGE
    19 = 0020			ZIOCB   =   $20         ; ZP IOCB
    20 = 0020			ZICHID  =   ZIOCB       ; ID
    21 = 0021			ZICDNO  =   ZIOCB+1     ; UNIT #
    22 = 0022			ZICCOM  =   ZIOCB+2     ; COMMAND
    23 = 0023			ZICSTA  =   ZIOCB+3     ; STATUS
    24 = 0024			ZICBAL  =   ZIOCB+4     ; BUF ADR LOW
    25 = 0025			ZICBAH  =   ZIOCB+5     ; BUF ADR HIGH
    26 = 0026			ZICPTL  =   ZIOCB+6     ; PUT ADDR L
    27 = 0027			ZICPTH  =   ZIOCB+7     ; PUT ADDR H
    28 = 0028			ZICBLL  =   ZIOCB+8     ; BUF LEN LOW
    29 = 0029			ZICBLH  =   ZIOCB+9     ; BUF LEN HIGH
    30 = 002A			ZICAX1  =   ZIOCB+10    ; AUX 1
    31 = 002B			ZICAX2  =   ZIOCB+11    ; AUX 2
    32 = 002C			ZICAX3  =   ZIOCB+12    ; AUX 3
    33 = 002D			ZICAX4  =   ZIOCB+13    ; AUX 4
    34 = 002E			ZICAX5  =   ZIOCB+14    ; AUX 5
    35 = 002F			ZICAX6  =   ZIOCB+15    ; AUX 6
    36
    37 = 0052			LMARGN  =   $52         ; Left margin
    38 = 00D4			FR0     =   $D4         ; Floating Point register 0 (used during Hex->ASCII conversion)
    39 = 00F2			CIX     =   $F2         ; Inbuff cursor
    40 = 00F3			INBUFF  =   $F3         ; Ptr to input buffer ($0580)
    41 = 0040			MAX_APPKEY_LEN = $40    ; Used with appkey files
    42
    43 				;---------------------------------------
    44 				; INTERRUPT VECTORS
    45 				; AND OTHER PAGE 2 VARS
    46 				;---------------------------------------
    47
    48 = 0202			VPRCED  =   $0202       ; PROCEED VCTR
    49 = 02C4			COLOR0  =   $02C4       ; 
    50 = 02C5			COLOR1  =   $02C5       ; 
    51 = 02C6			COLOR2  =   $02C6       ; MODEF BKG C
    52 = 02C7			COLOR3  =   $02C7       ; 
    53 = 02C8			COLOR4  =   $02C8       ; 
    54 = 02E0			RUNAD   =   $02E0       ; RUN ADDRESS
    55 = 02E2			INITAD  =   $02E2       ; INIT ADDRESS
    56 = 02E7			MEMLO   =   $02E7       ; MEM LO
    57 = 02EA			DVSTAT  =   $02EA       ; 4 BYTE STATS
    58
    59 				;---------------------------------------
    60 				; PAGE 3
    61 				; DEVICE CONTROL BLOCK (DCB)
    62 				;---------------------------------------
    63
    64 = 0300			DCB     =   $0300       ; BASE
    65 = 0300			DDEVIC  =   DCB         ; DEVICE #
    66 = 0301			DUNIT   =   DCB+1       ; UNIT #
    67 = 0302			DCOMND  =   DCB+2       ; COMMAND
    68 = 0303			DSTATS  =   DCB+3       ; STATUS/DIR
    69 = 0304			DBUFL   =   DCB+4       ; BUF ADR L
    70 = 0305			DBUFH   =   DCB+5       ; BUF ADR H
    71 = 0306			DTIMLO  =   DCB+6       ; TIMEOUT (S)
    72 = 0307			DRSVD   =   DCB+7       ; NOT USED
    73 = 0308			DBYTL   =   DCB+8       ; BUF LEN L
    74 = 0309			DBYTH   =   DCB+9       ; BUF LEN H
    75 = 030A			DAUXL   =   DCB+10      ; AUX BYTE L
    76 = 030B			DAUXH   =   DCB+11      ; AUX BYTE H
    77
    78 = 031A			HATABS  =   $031A       ; HANDLER TBL
    79
    80 				;---------------------------------------
    81 				; IOCB'S * 8
    82 				;---------------------------------------
    83
    84 = 0340			IOCB    =   $0340       ; IOCB BASE
    85 = 0340			ICHID   =   IOCB        ; ID
    86 = 0341			ICDNO   =   IOCB+1      ; UNIT #
    87 = 0342			ICCOM   =   IOCB+2      ; COMMAND
    88 = 0343			ICSTA   =   IOCB+3      ; STATUS
    89 = 0344			ICBAL   =   IOCB+4      ; BUF ADR LOW
    90 = 0345			ICBAH   =   IOCB+5      ; BUF ADR HIGH
    91 = 0346			ICPTL   =   IOCB+6      ; PUT ADDR L
    92 = 0347			ICPTH   =   IOCB+7      ; PUT ADDR H
    93 = 0348			ICBLL   =   IOCB+8      ; BUF LEN LOW
    94 = 0349			ICBLH   =   IOCB+9      ; BUF LEN HIGH
    95 = 034A			ICAX1   =   IOCB+10     ; AUX 1
    96 = 034B			ICAX2   =   IOCB+11     ; AUX 2
    97 = 034C			ICAX3   =   IOCB+12     ; AUX 3
    98 = 034D			ICAX4   =   IOCB+13     ; AUX 4
    99 = 034E			ICAX5   =   IOCB+14     ; AUX 5
   100 = 034F			ICAX6   =   IOCB+15     ; AUX 6
   101
   102 = 0054			ROWCRS  =   $0054
   103 = 006A			RAMTOP  =   $006A
   104 = 02BB			SCRFLG  =   $02BB       ; Scroll flag
   105 = 02FC			CH      =   $02FC       ; Hardware code for last key pressed
   106 = 02F2			CH1     =   $02F2       ; Prior keyboard character code
   107 = 03F8			BASICF  =   $03F8
   108 = 0582			LNBUF   =   $0582       ; Line Buffer (128 bytes)
   109 				;LNBUF   =   $1880       ; Line Buffer (128 bytes)
   110
   111 				;---------------------------------------
   112 				; HARDWARE REGISTERS
   113 				;---------------------------------------
   114
   115 = D01F			CONSOL  =   $D01F       ; Console switches
   116 = D301			PORTB   =   $D301       ; On XL/XE, used to enable/disable BASIC
   117 = D302			PACTL   =   $D302       ; PIA CTRL A
   118
   119 				;---------------------------------------
   120 				; MATH PACK VECTORS
   121 				;---------------------------------------
   122 = D8E6			FASC    =   $D8E6       ; Floating point to ASCII
   123 = D9AA			IFP     =   $D9AA       ; Integer to floating point
   124
   125 				;---------------------------------------
   126 				; OS ROM VECTORS
   127 				;---------------------------------------
   128
   129 = E456			CIOV    =   $E456       ; CIO ENTRY
   130 = E459			SIOV    =   $E459       ; SIO ENTRY
   131 = E474			WARMSV  =   $E474       ; Warmstart entry point
   132 = E477			COLDSV  =   $E477       ; Coldstart entry point
   133
   134 				;---------------------------------------
   135 				; CONSTANTS
   136 				;---------------------------------------
   137
   138 = 0005			GETREC  =   $05         ; CIO CMD TO GET RECORD
   139 = 0009			PUTREC  =   $09         ; CIO CMD TO PUT RECORD
   140 = 000B			PUTCHR  =   $0B         ; CIO CMD TO PUT CHAR
   141
   142 = 0071			DEVIDN  =   $71         ; SIO DEVID
   143 = 0040			DSREAD  =   $40         ; FUJI->ATARI
   144 = 0080			DSWRIT  =   $80         ; ATARI->FUJI
   145 = 0004			MAXDEV  =   4           ; # OF N: DEVS
   146 = 0088			EOF     =   $88         ; ERROR 136
   147
   148 = 009B			EOL     =   $9B         ; EOL CHAR
   149 = 000D			CR      =   $0D         ; Carrige Return
   150 = 000A			LF      =   $0A         ; Linefeed
   151
   152 = 0003			OPTION  =   $03
   153 = 001C			ESC_KEY =   $1C         ; Hardware code for ESC
   154 = 0021			SPC_KEY =   $21         ; Hardware code for SPACE
   155
   156 = 0004			OINPUT  =   $04         ; CIO/SIO direction
   157 = 0008			OOUTPUT =   $08         ; CIO/SIO direction
   158 = 00F0			BOGUS   =   $F0         ; Bogus FujiNet SIO command byte
   159
   160 				;ROM_BORDER = $92        ; Border color when program in ROM
   161 = 0006			ROM_BORDER = $06        ; Border color when program in ROM
   162
   163 				; FujiNet SIO command bytes.
   164 = 0001			CMD_DRIVE_CHG       = $01
   165 = 002C			CMD_CD              = $2C
   166 				;CMD_COPY            = $A1
   167 = 0002			CMD_DIR             = $02
   168 = 0021			CMD_DEL             = $21
   169 = 0028			CMD_LOAD            = $28
   170 = 0023			CMD_LOCK            = $23
   171 = 00F0			CMD_LPR             = BOGUS
   172 = 002A			CMD_MKDIR           = $2A
   173 = 0030			CMD_NPWD            = $30
   174 = 0054			CMD_NTRANS          = 'T'
   175 = 00FE			CMD_PASS            = $FE
   176 = 0020			CMD_RENAME          = $20
   177 = 002B			CMD_RMDIR           = $2B
   178 = 00F0			CMD_SAVE            = BOGUS
   179 = 00F0			CMD_SUBMIT          = BOGUS
   180 = 00F0			CMD_TYPE            = BOGUS
   181 = 00FD			CMD_USER            = $FD
   182 = 0024			CMD_UNLOCK          = $24
   183 = 00F0			CMD_CAR             = BOGUS
   184 = 00F0			CMD_CLS             = BOGUS
   185 = 00F0			CMD_COLD            = BOGUS
   186 = 00F0			CMD_HELP            = BOGUS
   187 = 00F0			CMD_BASIC           = BOGUS
   188 = 00F0			CMD_NOSCREEN        = BOGUS
   189 = 00F0			CMD_PRINT           = BOGUS
   190 = 00F0			CMD_REENTER         = BOGUS
   191 = 00F0			CMD_REM             = BOGUS
   192 = 00F0			CMD_RUN             = BOGUS
   193 = 00F0			CMD_SCREEN          = BOGUS
   194 = 00F0			CMD_WARM            = BOGUS
   195 = 00F0			CMD_XEP             = BOGUS
   196 = 00F0			CMD_AUTORUN         = BOGUS
   197
   198 				;;; Macros ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   199
   200 				        .MACRO DCBC
   201 				        .LOCAL
   202 				        LDY     #$0C
   203 				?DCBL   LDA     %%1,Y
   204 				        STA     DCB,Y
   205 				        DEY
   206 				        BPL     ?DCBL
   207 				        .ENDL
   208 				        .ENDM
   209
   210 				; ATR Header
   211 					    ORG	    $06f0
   212 				        OPT     h-
   213 06F0 96 02 80 16 80		    DTA	    $96,$02,$80,$16,$80
   214 06F5 00 00 00 00 00 00 + :11     DTA	    $00
   215
   216 				;;; Initialization ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   217
   218 0700 00			HDR:    .BYTE   $00                 ; BLFAG: Boot flag equals zero (unused)
   219 0701 24			        .BYTE   [BOOTEND-HDR]/128   ; BRCNT: Number of consecutive sectors to read
   220 0702 00 07		        .WORD   HDR                 ; BLDADR: Boot sector load address ($700).
   221 0704 C0 E4		        .WORD   $E4C0               ; BIWTARR: Init addr (addr of RTS in ROM)
   222
   223 0706 4C 09 07			    JMP	    START
   224
   225 0709 A5 0C		START:  LDA     DOSINI
   226 070B 8D 27 07		        STA     RESET+1
   227 070E A5 0D		        LDA     DOSINI+1
   228 0710 8D 28 07		        STA     RESET+2
   229
   230 0713 A9 26		        LDA     #<RESET
   231 0715 85 0C		        STA     DOSINI
   232 0717 A9 07		        LDA     #>RESET
   233 0719 85 0D		        STA     DOSINI+1
   234 071B A9 A2		        LDA     #<DOS       ; Point to DOS & CP below
   235 071D 85 0A		        STA     DOSVEC
   236 071F A9 0B		        LDA     #>DOS
   237 0721 85 0B		        STA     DOSVEC+1
   238
   239 0723 4C 39 07		        JMP     ALTMEML     ; Alter MEMLO
   240
   241 0726 20 FF FF		RESET:  JSR     $FFFF       ; Jump to extant DOSINI
   242
   243 0729 A9 4E		        LDA     #'N'
   244 072B 8D 00 19		        STA     RBUF
   245 072E 20 44 07		        JSR     IHTBS       ; Insert into HATABS
   246
   247 0731 A9 44		        LDA     #'D'
   248 0733 8D 00 19		        STA     RBUF
   249 0736 20 44 07		        JSR     IHTBS       ; Clone N: as D: for compatibility
   250
   251 				;---------------------------------------
   252 				;  Alter MEMLO
   253 				;---------------------------------------
   254 0739			ALTMEML:
   255 0739 A9 00		        LDA     #<PGEND
   256 073B 8D E7 02		        STA     MEMLO
   257 073E A9 1A		        LDA     #>PGEND
   258 0740 8D E8 02		        STA     MEMLO+1
   259
   260 				        ;; Back to DOS
   261
   262 0743 60			        RTS
   263
   264 				;---------------------------------------
   265 				; Insert entry into HATABS
   266 				;---------------------------------------
   267
   268 0744			IHTBS:
   269 0744 A0 00		        LDY     #$00
   270 0746 B9 1A 03		IH1     LDA     HATABS,Y
   271 0749 F0 0C		        BEQ     HFND
   272 074B CD 00 19		        CMP     RBUF        ; RBUF contains 'N' or 'D'
   273 074E F0 07		        BEQ     HFND
   274 0750 C8			        INY
   275 0751 C8			        INY
   276 0752 C8			        INY
   277 0753 C0 21		        CPY     #11*3
   278 0755 90 EF		        BCC     IH1
   279
   280 				        ;; Found a slot
   281
   282 0757			HFND:
   283 0757 AD 00 19		        LDA     RBUF        ; RBUF contains 'N' or 'D'
   284 075A AA			        TAX
   285 075B 99 1A 03		        STA     HATABS,Y
   286 075E A9 50		        LDA     #<CIOHND
   287 0760 99 1B 03		        STA     HATABS+1,Y
   288 0763 A9 18		        LDA     #>CIOHND
   289 0765 99 1C 03		        STA     HATABS+2,Y
   290
   291 0768 E0 44		        CPX     #'D'
   292 076A F0 01		        BEQ     HATABS_CONT
   293 076C 60			        RTS
   294
   295 076D			HATABS_CONT:
   296 				        ;; And we're done with HATABS
   297
   298 				        ;; Query FUJINET
   299
   300 076D 20 24 09		        JSR     STPOLL
   301
   302 				        ;; Output Ready/Error
   303
   304 0770			OBANR:
   305 0770 A2 00		        LDX     #$00        ; IOCB #0
   306 0772 A9 09		        LDA     #PUTREC
   307 0774 9D 42 03		        STA     ICCOM,X
   308 0777 A9 28		        LDA     #$28        ; 40 CHARS Max
   309 0779 9D 48 03		        STA     ICBLL,X
   310 077C 8A			        TXA
   311 077D 9D 49 03		        STA     ICBLH,X
   312 0780 AD 03 03		        LDA     DSTATS      ; Check DSTATS
   313 0783 10 06		        BPL     OBRDY       ; < 128 = Ready
   314
   315 				        ;; Status returned error.
   316
   317 0785			OBERR:
   318 0785 A9 76		        LDA     #<BERROR
   319 0787 A0 18		        LDY     #>BERROR
   320 0789 50 04		        BVC     OBCIO
   321
   322 				        ;; Status returned ready.
   323
   324 078B			OBRDY:
   325 078B A9 5C		        LDA     #<BREADY
   326 078D A0 18		        LDY     #>BREADY
   327
   328 078F			OBCIO:
   329 078F 9D 44 03		        STA     ICBAL,X
   330 0792 98			        TYA
   331 0793 9D 45 03		        STA     ICBAH,X
   332
   333 0796 20 56 E4		        JSR     CIOV
   334
   335 				        ;; Vector in proceed interrupt
   336
   337 0799			SPRCED:
   338 0799 A9 6B		        LDA     #<PRCVEC
   339 079B 8D 02 02		        STA     VPRCED
   340 079E A9 0A		        LDA     #>PRCVEC
   341 07A0 8D 03 02		        STA     VPRCED+1
   342
   343 				        ;; And we are done, back to DOS.
   344 07A3 18			        CLC
   345 07A4 60			        RTS
   346
   347 				;;; End Initialization Code ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   348
   349 				; Copy command's template DCB struct to OS's DCB struct (12 bytes)
   350 07A5			DOSIOV:
   351 07A5 8D AE 07		        STA     DODCBL+1
   352 07A8 8C AF 07		        STY     DODCBL+2
   353 07AB A0 0C		        LDY     #$0C
   354 07AD B9 FF FF		DODCBL  LDA     $FFFF,Y
   355 07B0 99 00 03		        STA     DCB,Y
   356 07B3 88			        DEY
   357 07B4 10 F7		        BPL     DODCBL
   358
   359 07B6			SIOVDST:
   360 07B6 20 59 E4		        JSR     SIOV
   361 07B9 AC 03 03		        LDY     DSTATS
   362 07BC 98			        TYA
   363 07BD 60			        RTS
   364
   365
   366 				;---------------------------------------
   367 				; CIO OPEN
   368 				;---------------------------------------
   369
   370 07BE			OPEN:
   371 				        ;; Prepare DCB
   372
   373 07BE 20 5C 0A		        JSR     GDIDX       ; Get Device ID in X (0-3)
   374 07C1 A5 21		        LDA     ZICDNO      ; IOCB UNIT # (1-4)
   375 07C3 8D 01 08		        STA     OPNDCB+1    ; Store in DUNIT
   376 07C6 A5 24		        LDA     ZICBAL      ; Get filename buffer
   377 07C8 8D 04 08		        STA     OPNDCB+4    ; stuff in DBUF
   378 07CB A5 25		        LDA     ZICBAH      ; ...
   379 07CD 8D 05 08		        STA     OPNDCB+5    ; ...
   380 07D0 A5 2A		        LDA     ZICAX1      ; Get desired AUX1/AUX2
   381 07D2 8D 0A 08		        STA     OPNDCB+10   ; Save them, and store in DAUX1/DAUX2
   382 07D5 A5 2B		        LDA     ZICAX2      ; ...
   383 07D7 8D 0B 08		        STA     OPNDCB+11   ; ...
   384
   385 				        ;;  Copy DCB template to DCB
   386
   387 07DA A9 00		        LDA     #<OPNDCB
   388 07DC A0 08		        LDY     #>OPNDCB
   389
   390 				        ;;  Send to #FujiNet
   391
   392 07DE 20 A5 07		        JSR     DOSIOV
   393
   394 				        ;; Return DSTATS, unless 144, then get extended error
   395
   396 07E1			OPCERR:
   397 07E1 C0 90		        CPY     #$90        ; ERR 144?
   398 07E3 D0 06		        BNE     OPDONE      ; NOPE. RETURN DSTATS
   399
   400 				        ;; 144 - get extended error
   401
   402 07E5 20 24 09		        JSR     STPOLL      ; POLL FOR STATUS
   403 07E8 AC ED 02		        LDY     DVSTAT+3
   404
   405 				       ; RESET BUFFER LENGTH + OFFSET
   406
   407 07EB			OPDONE:
   408 07EB A9 01		        LDA     #$01
   409 07ED 8D 94 18		        STA     TRIP
   410 07F0 20 5C 0A		        JSR     GDIDX
   411 07F3 A9 00		        LDA     #$00
   412 07F5 9D 95 18		        STA     RLEN,X
   413 07F8 9D 9D 18		        STA     TOFF,X
   414 07FB 9D 99 18		        STA     ROFF,X
   415 07FE 98			        TYA
   416 07FF 60			        RTS                ; AY = ERROR
   417
   418 0800			OPNDCB:
   419 0800 71			        .BYTE   DEVIDN  ; DDEVIC
   420 0801 FF			        .BYTE   $FF     ; DUNIT
   421 0802 4F			        .BYTE   'O'     ; DCOMND
   422 0803 80			        .BYTE   $80     ; DSTATS
   423 0804 FF			        .BYTE   $FF     ; DBUFL
   424 0805 FF			        .BYTE   $FF     ; DBUFH
   425 0806 0F			        .BYTE   $0F     ; DTIMLO
   426 0807 00			        .BYTE   $00     ; DRESVD
   427 0808 00			        .BYTE   $00     ; DBYTL
   428 0809 01			        .BYTE   $01     ; DBYTH
   429 080A FF			        .BYTE   $FF     ; DAUX1
   430 080B FF			        .BYTE   $FF     ; DAUX2
   431
   432 				; End CIO OPEN
   433 				;---------------------------------------
   434
   435 				;---------------------------------------
   436 				; CIO CLOSE 
   437 				;---------------------------------------
   438
   439 080C			CLOSE:
   440 080C 20 53 0A		        JSR     DIPRCD      ; Disable Interrupts
   441 080F 20 5C 0A		        JSR     GDIDX
   442 0812 20 AF 08		        JSR     PFLUSH      ; Do a Put Flush if needed.
   443
   444 0815 A5 21		        LDA     ZICDNO      ; IOCB Unit #
   445 0817 8D 22 08		        STA     CLODCB+1    ; to DCB...
   446
   447 081A A9 21		        LDA     #<CLODCB
   448 081C A0 08		        LDY     #>CLODCB
   449
   450 081E 4C A5 07		        JMP     DOSIOV
   451
   452 0821 71			CLODCB .BYTE    DEVIDN      ; DDEVIC
   453 0822 FF			       .BYTE    $FF         ; DUNIT
   454 0823 43			       .BYTE    'C'         ; DCOMND
   455 0824 00			       .BYTE    $00         ; DSTATS
   456 0825 00			       .BYTE    $00         ; DBUFL
   457 0826 00			       .BYTE    $00         ; DBUFH
   458 0827 0F			       .BYTE    $0F         ; DTIMLO
   459 0828 00			       .BYTE    $00         ; DRESVD
   460 0829 00			       .BYTE    $00         ; DBYTL
   461 082A 00			       .BYTE    $00         ; DBYTH
   462 082B 00			       .BYTE    $00         ; DAUX1
   463 082C 00			       .BYTE    $00         ; DAUX2
   464
   465 				; End CIO CLOSE
   466 				;---------------------------------------
   467
   468 				;---------------------------------------
   469 				; CIO GET
   470 				;---------------------------------------
   471
   472 082D 20 5C 0A		GET:    JSR     GDIDX       ; IOCB UNIT #-1 into X
   473 0830 BD 95 18		        LDA     RLEN,X      ; Get # of RX chars waiting
   474 0833 D0 2B		        BNE     GETDISC     ; LEN > 0?
   475
   476 				        ;; If RX buffer is empty, get # of chars waiting...
   477
   478 0835 20 24 09		        JSR     STPOLL      ; Status Poll
   479 0838 20 5C 0A		        JSR     GDIDX       ; IOCB UNIT -1 into X (because Poll trashes X)
   480 083B AD EA 02		        LDA     DVSTAT      ; # of bytes waiting (0-127)
   481 083E 9D 95 18		        STA     RLEN,X      ; Store in RX Len
   482 0841 F0 22		        BEQ     RETEOF
   483
   484 0843 A5 21		GETDO:  LDA     ZICDNO      ; Get IOCB UNIT #
   485 0845 8D 83 08		        STA     GETDCB+1    ; Store into DUNIT
   486 0848 AD EA 02		        LDA     DVSTAT      ; # of bytes waiting
   487 084B 8D 8A 08		        STA     GETDCB+8    ; Store into DBYT...
   488 084E 8D 8C 08		        STA     GETDCB+10   ; and DAUX1...
   489
   490 0851 A9 82		        LDA     #<GETDCB
   491 0853 A0 08		        LDY     #>GETDCB
   492
   493 0855 20 A5 07		        JSR     DOSIOV
   494
   495 				        ;; Clear the Receive buffer offset.
   496
   497 0858 20 5C 0A		        JSR     GDIDX       ; IOCB UNIT #-1 into X
   498 085B A9 00		        LDA     #$00
   499 085D 9D 99 18		        STA     ROFF,X
   500
   501 0860			GETDISC:
   502 				        ;LDA     DVSTAT+2    ; Did we disconnect?
   503 0860 AD ED 02		        LDA     DVSTAT+3    ; Did we disconnect?
   504 0863 D0 04		        BNE     GETUPDP     ; nope, update the buffer cursor.
   505
   506 				        ;; We disconnected, emit an EOF.
   507
   508 0865			RETEOF:
   509 0865 A0 88		        LDY     #EOF
   510 0867 98			        TYA
   511 0868 60			        RTS                 ; buh-bye.
   512
   513 0869			GETUPDP:
   514 0869 DE 95 18		        DEC     RLEN,X      ; Decrement RX length.
   515 086C BC 99 18		        LDY     ROFF,X      ; Get RX offset cursor.
   516
   517 				        ;; Return Next char from appropriate RX buffer.
   518
   519 086F B9 00 19		        LDA     RBUF,Y
   520
   521 				        ;; Increment RX offset
   522
   523 0872 FE 99 18		GX:     INC     ROFF,X      ; Increment RX offset.
   524 0875 A8			        TAY                 ; stuff returned val into Y temporarily.
   525
   526 				        ;; If requested RX buffer is empty, reset TRIP.
   527
   528 0876 BD 95 18		        LDA     RLEN,X
   529 0879 D0 03		        BNE     GETDONE
   530 087B 8D 94 18		        STA     TRIP
   531
   532 				        ;; Return byte back to CIO.
   533
   534 087E			GETDONE:
   535 087E 98			        TYA                 ; Move returned val back.
   536 087F A0 01		        LDY     #$01        ; SUCCESS
   537
   538 0881 60			        RTS                 ; DONE...
   539
   540 0882			GETDCB:
   541 0882 71			       .BYTE    DEVIDN      ; DDEVIC
   542 0883 FF			       .BYTE    $FF         ; DUNIT
   543 0884 52			       .BYTE    'R'         ; DCOMND
   544 0885 40			       .BYTE    $40         ; DSTATS
   545 0886 00			       .BYTE    <RBUF       ; DBUFL
   546 0887 19			       .BYTE    >RBUF       ; DBUFH
   547 0888 0F			       .BYTE    $0F         ; DTIMLO
   548 0889 00			       .BYTE    $00         ; DRESVD
   549 088A FF			       .BYTE    $FF         ; DBYTL
   550 088B 00			       .BYTE    $00         ; DBYTH
   551 088C FF			       .BYTE    $FF         ; DAUX1
   552 088D 00			       .BYTE    $00         ; DAUX2
   553
   554 				; End CIO GET
   555 				;---------------------------------------
   556
   557 				;---------------------------------------
   558 				; CIO PUT
   559 				;---------------------------------------
   560
   561 088E			PUT:    ;; Add to TX buffer.
   562
   563 088E 20 5C 0A		        JSR     GDIDX
   564 0891 BC 9D 18		        LDY     TOFF,X      ; GET TX cursor.
   565 0894 99 80 19		        STA     TBUF,Y      ; TX Buffer
   566
   567 0897 FE 9D 18		POFF:   INC     TOFF,X      ; Increment TX cursor
   568 089A A0 01		        LDY     #$01        ; SUCCESSFUL
   569
   570 				        ;; Do a PUT FLUSH if EOL or buffer full.
   571
   572 089C C9 9B		        CMP     #EOL        ; EOL?
   573 089E F0 0B		        BEQ     FLUSH       ; FLUSH BUFFER
   574 08A0 20 5C 0A		        JSR     GDIDX       ; GET OFFSET
   575 08A3 BD 9D 18		        LDA     TOFF,X
   576 08A6 C9 7F		        CMP     #$7F        ; LEN = $FF?
   577 08A8 F0 01		        BEQ     FLUSH       ; FLUSH BUFFER
   578 08AA 60			        RTS
   579
   580 				       ; FLUSH BUFFER, IF ASKED.
   581
   582 08AB 20 AF 08		FLUSH:  JSR     PFLUSH      ; FLUSH BUFFER
   583 08AE 60			        RTS
   584
   585 08AF			PFLUSH:
   586
   587 				       ; CHECK CONNECTION, AND EOF
   588 				       ; IF DISCONNECTED.
   589
   590 08AF 20 24 09		        JSR     STPOLL      ; GET STATUS
   591 08B2 AD ED 02		        LDA     DVSTAT+3
   592 08B5 F0 AE		        BEQ     RETEOF
   593
   594 08B7 20 5C 0A		PF1:    JSR     GDIDX       ; GET DEV X
   595 08BA BD 9D 18		        LDA     TOFF,X
   596 08BD D0 03		        BNE     PF2
   597 08BF 4C DF 08		        JMP     PDONE
   598
   599 				       ; FILL OUT DCB FOR PUT FLUSH
   600
   601 08C2 A5 21		PF2:    LDA     ZICDNO
   602 08C4 8D E3 08		        STA     PUTDCB+1
   603
   604 				       ; FINISH DCB AND DO SIOV
   605
   606 08C7 BD 9D 18		TBX:    LDA     TOFF,X
   607 08CA 8D EA 08		        STA     PUTDCB+8
   608 08CD 8D EC 08		        STA     PUTDCB+10
   609
   610 08D0 A9 E2		        LDA     #<PUTDCB
   611 08D2 A0 08		        LDY     #>PUTDCB
   612 08D4 20 A5 07		        JSR     DOSIOV
   613
   614 				        ; CLEAR THE OFFSET CURSOR
   615 				        ; AND LENGTH
   616
   617 08D7 20 5C 0A		        JSR     GDIDX
   618 08DA A9 00		        LDA     #$00
   619 08DC 9D 9D 18		        STA     TOFF,X
   620
   621 08DF A0 01		PDONE:  LDY     #$01
   622 08E1 60			        RTS
   623
   624 08E2 71			PUTDCB .BYTE    DEVIDN      ; DDEVIC
   625 08E3 FF			       .BYTE    $FF         ; DUNIT
   626 08E4 57			       .BYTE    'W'         ; DCOMND
   627 08E5 80			       .BYTE    $80         ; DSTATS
   628 08E6 80			       .BYTE    $80         ; DBUFL
   629 08E7 19			       .BYTE    >TBUF       ; DBUFH
   630 08E8 0F			       .BYTE    $0F         ; DTIMLO
   631 08E9 00			       .BYTE    $00         ; DRESVD
   632 08EA FF			       .BYTE    $FF         ; DBYTL
   633 08EB 00			       .BYTE    $00         ; DBYTH
   634 08EC FF			       .BYTE    $FF         ; DAUX1
   635 08ED 00			       .BYTE    $00         ; DAUX2
   636
   637 				; End CIO PUT
   638 				;---------------------------------------
   639
   640 				;---------------------------------------
   641 				; CIO STATUS 
   642 				;---------------------------------------
   643
   644 08EE 20 4A 0A		STATUS: JSR     ENPRCD      ; ENABLE PRCD
   645 08F1 20 5C 0A		        JSR     GDIDX       ; GET DEVICE#
   646 08F4 BD 95 18		        LDA     RLEN,X      ; GET RLEN
   647 08F7 D0 05		        BNE     STSLEN      ; RLEN > 0?
   648 08F9 AD 94 18		        LDA     TRIP
   649 08FC D0 15		        BNE     STTRI1      ; TRIP = 1?
   650
   651 				        ; NO TRIP, RETURN SAVED LEN
   652
   653 08FE BD 95 18		STSLEN: LDA     RLEN,X      ; GET RLEN
   654 0901 8D EA 02		        STA     DVSTAT      ; RET IN DVSTAT
   655
   656 				        ; If you don't need to preserve Y then use it instead of A
   657 0904 A9 00		        LDA     #$00
   658 0906 8D EB 02		        STA     DVSTAT+1
   659
   660 				        ; and INY here
   661 0909 A9 01		        LDA     #$01
   662 090B 8D EC 02		        STA     DVSTAT+2
   663 090E 8D ED 02		        STA     DVSTAT+3
   664
   665 0911 D0 0B		        BNE     STDONE
   666
   667 				        ; DO POLL AND UPDATE RCV LEN
   668
   669 0913 20 24 09		STTRI1: JSR     STPOLL      ; POLL FOR ST
   670 0916 9D 95 18		        STA     RLEN,X
   671
   672 				        ; UPDATE TRIP FLAG
   673
   674 0919 D0 03		STTRIU: BNE     STDONE
   675 091B 8D 94 18		        STA     TRIP        ; RLEN = 0
   676
   677 				        ; RETURN CONNECTED? FLAG.
   678
   679 091E AD EC 02		STDONE: LDA     DVSTAT+2
   680 0921 A0 01		        LDY     #$01
   681 0923 60			        RTS
   682
   683 				       ; ASK FUJINET FOR STATUS
   684
   685 0924			STPOLL:
   686 0924 A5 21		        LDA     ZICDNO      ; IOCB #
   687 0926 8D 49 09		        STA     STADCB+1
   688
   689 0929 A9 48		        LDA     #<STADCB
   690 092B A0 09		        LDY     #>STADCB
   691
   692 092D 20 A5 07		        JSR     DOSIOV
   693
   694 				        ;; > 127 bytes? make it 127 bytes.
   695
   696 0930 AD EB 02		        LDA     DVSTAT+1
   697 0933 D0 07		        BNE     STADJ
   698 0935 AD EA 02		        LDA     DVSTAT
   699 0938 30 02		        BMI     STADJ
   700 093A 50 08		        BVC     STP2        ; <= 127 bytes...
   701
   702 093C A9 7F		STADJ   LDA     #$7F
   703 093E 8D EA 02		        STA     DVSTAT
   704 				        
   705 0941 8D EB 02		        STA     DVSTAT+1
   706
   707 				       ; A = CONNECTION STATUS
   708
   709 0944 AD EC 02		STP2:   LDA     DVSTAT+2
   710 0947 60			        RTS
   711
   712 0948 71			STADCB: .BYTE   DEVIDN      ; DDEVIC
   713 0949 FF			        .BYTE   $FF         ; DUNIT
   714 094A 53			        .BYTE   'S'         ; DCOMND
   715 094B 40			        .BYTE   $40         ; DSTATS
   716 094C EA			        .BYTE   <DVSTAT     ; DBUFL
   717 094D 02			        .BYTE   >DVSTAT     ; DBUFH
   718 094E 0F			        .BYTE   $0F         ; DTIMLO
   719 094F 00			        .BYTE   $00         ; DRESVD
   720 0950 04			        .BYTE   $04         ; DBYTL
   721 0951 00			        .BYTE   $00         ; DBYTH
   722 0952 00			        .BYTE   $00         ; DAUX1
   723 0953 00			        .BYTE   $00         ; DAUX2
   724
   725 				; End CIO STATUS
   726 				;---------------------------------------
   727
   728 				;---------------------------------------
   729 				; CIO SPECIAL
   730 				;---------------------------------------
   731
   732 0954			SPEC:   ; HANDLE LOCAL COMMANDS.
   733
   734 0954 A5 22		        LDA     ZICCOM
   735 0956 C9 0F		        CMP     #$0F        ; 15 = FLUSH
   736 0958 D0 06		        BNE     S1          ; NO.
   737 095A 20 AF 08		        JSR     PFLUSH      ; DO FLUSH
   738 095D A0 01		        LDY     #$01        ; SUCCESS
   739 095F 60			        RTS
   740
   741 0960 C9 28		S1:     CMP     #40         ; 40 = LOAD AND EXECUTE
   742 0962 F0 03		        BEQ     S2          ; YES.
   743 0964 4C 68 09		        JMP     S3          ; NO. SKIP OVER spec40
   744
   745 0967 60			S2:     RTS
   746 				       ; HANDLE SIO COMMANDS.
   747 				       ; GET DSTATS FOR COMMAND
   748 0968			S3:
   749 0968 A5 21		        LDA     ZICDNO
   750 096A 8D B0 09		        STA     SPEDCB+1
   751 096D A5 22		        LDA     ZICCOM
   752 096F 8D B9 09		        STA     SPEDCB+10
   753
   754 0972 A9 AF		        LDA     #<SPEDCB
   755 0974 A0 09		        LDY     #>SPEDCB
   756 0976 20 A5 07		        JSR     DOSIOV
   757
   758 0979 30 0A		        BMI     :DSERR
   759
   760 				       ; WE GOT A DSTATS INQUIRY
   761 				       ; IF $FF, THE COMMAND IS
   762 				       ; INVALID
   763
   764 097B AD A1 18		DSOK:   LDA     INQDS
   765 097E C9 FF		        CMP     #$FF        ; INVALID?
   766 0980 D0 04		        BNE     DSGO        ; DO THE CMD
   767 0982 A0 92		        LDY     #$92        ; UNIMP CMD
   768 0984 98			        TYA
   769 0985			DSERR:
   770 0985 60			        RTS
   771
   772 				        ;; Do the special, since we want to pass in all the IOCB
   773 				        ;; Parameters to the DCB, This is being done long-hand.
   774
   775 0986 A5 22		DSGO:   LDA     ZICCOM
   776 0988 48			        PHA
   777 0989 A9 00		        LDA     #$00
   778 098B 48			        PHA
   779 098C AD A1 18		        LDA     INQDS
   780 098F 48			        PHA
   781 0990 A9 01		        LDA     #$01
   782 0992 48			        PHA
   783 0993 A5 24		        LDA     ZICBAL
   784 0995 48			        PHA
   785 0996 A5 2A		        LDA     ZICAX1
   786 0998 48			        PHA
   787 0999 A5 25		        LDA     ZICBAH
   788 099B 48			        PHA
   789 099C A5 2B		        LDA     ZICAX2
   790 099E 48			        PHA
   791 099F A0 03		        LDY     #$03
   792 09A1			DSGOL:
   793 09A1 68			        PLA
   794 09A2 99 08 03		        STA     DBYTL,Y
   795 09A5 68			        PLA
   796 09A6 99 02 03		        STA     DCOMND,Y
   797 09A9 88			        DEY
   798 09AA 10 F5		        BPL     DSGOL
   799
   800 09AC 4C B6 07		        JMP     SIOVDST
   801
   802 				        ;; Return DSTATS in Y and A
   803
   804 09AF 71			SPEDCB  .BYTE   DEVIDN      ; DDEVIC
   805 09B0 FF			        .BYTE   $FF         ; DUNIT
   806 09B1 FF			        .BYTE   $FF         ; DCOMND ; inq
   807 09B2 40			        .BYTE   $40         ; DSTATS
   808 09B3 A1			        .BYTE   <INQDS      ; DBUFL
   809 09B4 18			        .BYTE   >INQDS      ; DBUFH
   810 09B5 0F			        .BYTE   $0F         ; DTIMLO
   811 09B6 00			        .BYTE   $00         ; DRESVD
   812 09B7 01			        .BYTE   $01         ; DBYTL
   813 09B8 00			        .BYTE   $00         ; DBYTH
   814 09B9 FF			        .BYTE   $FF         ; DAUX1
   815 09BA FF			        .BYTE   $FF         ; DAUX2
   816
   817 				; End CIO SPECIAL
   818 				;---------------------------------------
   819
   820 				;#######################################
   821 				;#                                     #
   822 				;#             CIO Functions           # 
   823 				;#                                     #
   824 				;#######################################
   825
   826
   827 				;---------------------------------------
   828 09BB			CIOCLOSE:
   829 				;---------------------------------------
   830 				    ; X must contain IOCB offset ($10,$20,..)
   831 09BB A9 0C		        LDA     #$0C            ; Close #1 first
   832 09BD 9D 42 03		        STA     ICCOM,X
   833 09C0 4C 56 E4		        JMP     CIOV
   834
   835 				;---------------------------------------
   836 09C3			CIOOPEN:
   837 				;---------------------------------------
   838 				    ; Input: 
   839 				    ; X = IOCB offset ($10,$20,..)
   840 				    ; Y = data direction (4=inp,8=out,12=i/o)
   841 				    ; INBUFF contains ICBAL/H
   842 09C3 A9 03		        LDA     #$03            ; 3 = CIO 'OPEN FILE'
   843 09C5 9D 42 03		        STA     ICCOM,X
   844 09C8 A5 F3		        LDA     INBUFF          ; Pointer to filename
   845 09CA 9D 44 03		        STA     ICBAL,X
   846 09CD A5 F4		        LDA     INBUFF+1        ; Pointer to filename
   847 09CF 9D 45 03		        STA     ICBAH,X
   848 09D2 98			        TYA
   849 09D3 9D 4A 03		        STA     ICAX1,X         ; Data direction
   850 09D6 A9 00		        LDA     #$00
   851 09D8 9D 4B 03		        STA     ICAX2,X         ; Unused
   852 09DB 20 56 E4		        JSR     CIOV            ; Call CIO
   853 09DE 20 A4 0A		        JSR     PRINT_ERROR
   854
   855 09E1			CIOOPEN_DONE:
   856 09E1 60			        RTS
   857
   858 				;---------------------------------------
   859 09E2			CIOSTATUS:
   860 				;---------------------------------------
   861 09E2 A9 0D		        LDA     #$0D
   862 09E4 9D 42 03		        STA     ICCOM,X
   863 09E7 20 56 E4		        JSR     CIOV
   864 09EA 10 03		        BPL     CIOSTATUS_DONE
   865 09EC 20 A4 0A		        JSR     PRINT_ERROR
   866
   867 09EF			CIOSTATUS_DONE:
   868 09EF 60			        RTS
   869 				        
   870
   871 				;---------------------------------------
   872 09F0			CIOGET:
   873 				;---------------------------------------
   874 				    ; Input: 
   875 				    ; X = IOCB offset ($10,$20,..)
   876 				    ; A = ICBLL
   877 				    ; Y = ICBLH
   878 				    ; INBUFF contains ICBAL/H
   879 09F0 48			        PHA                 ; Stash Buffer length Lo
   880 09F1 A9 07		        LDA     #$07        ; GET BYTES command
   881 09F3 9D 42 03		        STA     ICCOM,X
   882 09F6 A5 F3		        LDA     INBUFF      ; Get buffer addr from pointer
   883 09F8 9D 44 03		        STA     ICBAL,X
   884 09FB A5 F4		        LDA     INBUFF+1
   885 09FD 9D 45 03		        STA     ICBAH,X
   886 0A00 68			        PLA                 ; Retrieve Buffer length Lo
   887 0A01 9D 48 03		        STA     ICBLL,X
   888 0A04 98			        TYA                 ; Get Buffer length Hi
   889 0A05 9D 49 03		        STA     ICBLH,X
   890 0A08 20 56 E4		        JSR     CIOV        ; Bon voyage
   891 0A0B 10 00		        BPL     CIOGET_DONE
   892 				;        JMP     PRINT_ERROR
   893
   894 0A0D			CIOGET_DONE:
   895 0A0D 60			        RTS
   896
   897 				;---------------------------------------
   898 0A0E			CIOPUT:
   899 				;---------------------------------------
   900 				    ; Input: 
   901 				    ; X = IOCB offset ($10,$20,..)
   902 				    ; A = ICBLL
   903 				    ; Y = ICBLH
   904 				    ; INBUFF contains ICBAL/H
   905 0A0E 48			        PHA                 ; Stash Buffer length Lo
   906 0A0F A9 0B		        LDA     #$0B        ; PUT BYTES command
   907 0A11 9D 42 03		        STA     ICCOM,X
   908 0A14 A5 F3		        LDA     INBUFF      ; Get buffer addr from pointer
   909 0A16 9D 44 03		        STA     ICBAL,X
   910 0A19 A5 F4		        LDA     INBUFF+1
   911 0A1B 9D 45 03		        STA     ICBAH,X
   912 0A1E 68			        PLA                 ; Retrieve Buffer length Lo
   913 0A1F 9D 48 03		        STA     ICBLL,X
   914 0A22 98			        TYA                 ; Get Buffer length Hi
   915 0A23 9D 49 03		        STA     ICBLH,X
   916 0A26 20 56 E4		        JSR     CIOV        ; Bon voyage
   917 0A29 10 00		        BPL     CIOPUT_DONE
   918 				;        JMP     PRINT_ERROR
   919
   920 0A2B			CIOPUT_DONE:
   921 0A2B 60			        RTS
   922
   923 				;---------------------------------------
   924 0A2C			CIOGETREC:
   925 				;---------------------------------------
   926 				    ; Input: 
   927 				    ; X = IOCB offset ($10,$20,..)
   928 				    ; A = ICBLL
   929 				    ; Y = ICBLH
   930 				    ; INBUFF contains ICBAL/H
   931 0A2C 48			        PHA                 ; Stash Buffer length Lo
   932 0A2D A9 05		        LDA     #$05        ; GET RECORD command
   933 0A2F 9D 42 03		        STA     ICCOM,X
   934 0A32 A5 F3		        LDA     INBUFF      ; Get buffer addr from pointer
   935 0A34 9D 44 03		        STA     ICBAL,X
   936 0A37 A5 F4		        LDA     INBUFF+1
   937 0A39 9D 45 03		        STA     ICBAH,X
   938 0A3C 68			        PLA                 ; Retrieve Buffer length Lo
   939 0A3D 9D 48 03		        STA     ICBLL,X
   940 0A40 98			        TYA                 ; Get Buffer length Hi
   941 0A41 9D 49 03		        STA     ICBLH,X
   942
   943 0A44 20 56 E4		        JSR     CIOV        ; Bon voyage
   944 0A47 10 00		        BPL     CIOGETREC_DONE
   945 				;        JMP     PRINT_ERROR
   946
   947 0A49			CIOGETREC_DONE:
   948 0A49 60			        RTS
   949
   950 				;#######################################
   951 				;#                                     #
   952 				;#          Utility Functions          #
   953 				;#                                     #
   954 				;#######################################
   955 				    ; ENABLE PROCEED INTERRUPT
   956
   957 0A4A AD 02 D3		ENPRCD: LDA     PACTL
   958 0A4D 09 01		        ORA     #$01        ; ENABLE BIT 0
   959 0A4F 8D 02 D3		        STA     PACTL
   960 0A52 60			        RTS
   961
   962 				   ; DISABLE PROCEED INTERRUPT
   963
   964 0A53 AD 02 D3		DIPRCD: LDA     PACTL
   965 0A56 29 FE		        AND     #$FE        ; DISABLE BIT0
   966 0A58 8D 02 D3		        STA     PACTL
   967 0A5B 60			        RTS
   968
   969 				   ; GET ZIOCB DEVNO - 1 INTO X
   970
   971 0A5C A6 21		GDIDX:  LDX     ZICDNO      ; IOCB UNIT #
   972 0A5E CA			        DEX                 ; - 1
   973 0A5F 60			        RTS
   974
   975 				    ; Convert char in A from upper-case to lower-case
   976 0A60			TOUPPER:
   977 0A60 C9 61		        CMP     #'a'        ; SKip if < 'a'
   978 0A62 90 06		        BCC     @+
   979 0A64 C9 7B		        CMP     #'z'+1      ; Skip if > 'z'
   980 0A66 B0 02		        BCS     @+
   981 0A68 29 5F		        AND     #$5F        ; Disable high-bit and convert to lower
   982 0A6A 60			 @:     RTS
   983
   984 				;---------------------------------------
   985 				; Proceed Vector
   986 				;---------------------------------------
   987
   988 0A6B A9 01		PRCVEC: LDA     #$01
   989 0A6D 8D 94 18		        STA     TRIP
   990 0A70 68			        PLA
   991 0A71 40			        RTI
   992
   993 				; End Proceed Vector
   994 				;---------------------------------------
   995
   996 				;---------------------------------------
   997 				; Reset LNBUF
   998 				;---------------------------------------
   999 				; Normally this routine is at $DA51
  1000 				; But some programs will bank-switch
  1001 				; that portion of ROM to RAM
  1002 				;---------------------------------------
  1003
  1004 0A72 A9 05		LDBUFA: LDA     #$05
  1005 0A74 85 F4		        STA     INBUFF+1
  1006 0A76 A9 82		        LDA     #$82        ; Normally $80. 2 for headroom
  1007 0A78 85 F3		        STA     INBUFF
  1008 0A7A 60			        RTS
  1009
  1010 				; End Reset LNBUF
  1011 				;---------------------------------------
  1012
  1013 				;---------------------------------------
  1014 				; Skip spaces
  1015 				;---------------------------------------
  1016 				; Normally this routine is at $DBA1
  1017 				; But some programs will bank-switch
  1018 				; that portion of ROM to RAM
  1019 				;---------------------------------------
  1020
  1021 0A7B A4 F2		SKPSPC: LDY     CIX
  1022 0A7D A9 20		        LDA     #$20
  1023 0A7F D1 F3		@:      CMP     (INBUFF),Y
  1024 0A81 D0 03		        BNE     @+
  1025 0A83 C8			        INY
  1026 0A84 D0 F9		        BNE     @-
  1027 0A86 84 F2		@:      STY     CIX
  1028 0A88 60			        RTS
  1029
  1030 				; End SKPSPC
  1031 				;---------------------------------------
  1032
  1033 				;---------------------------------------
  1034 				; Print EOL-terminated string
  1035 				; A: String Buffer Lo
  1036 				; Y: String Buffer Hi
  1037 				;---------------------------------------
  1038 0A89			PRINT_STRING:
  1039
  1040 0A89 A2 00		        LDX     #$00
  1041 				    ;---------------------------------------
  1042 				    ; String Buffer
  1043 				    ;---------------------------------------
  1044 0A8B 9D 44 03		        STA     ICBAL,X
  1045 0A8E 98			        TYA
  1046 0A8F 9D 45 03		        STA     ICBAH,X
  1047
  1048 				    ;---------------------------------------
  1049 				    ; String Length
  1050 				    ;---------------------------------------
  1051 0A92 A9 80		        LDA     #$80
  1052 0A94 9D 48 03		        STA     ICBLL,X
  1053 0A97 A9 00		        LDA     #$00
  1054 0A99 9D 49 03		        STA     ICBLH,X
  1055
  1056 				    ;---------------------------------------
  1057 				    ; Call to CIO
  1058 				    ;---------------------------------------
  1059 0A9C A9 09		        LDA     #PUTREC
  1060 0A9E 9D 42 03		        STA     ICCOM,X
  1061 0AA1 4C 56 E4		        JMP     CIOV
  1062
  1063 				;---------------------------------------
  1064 				; Print integer error number from DOSIOV
  1065 				; Y: Return code from DOSIOV
  1066 				;---------------------------------------
  1067 0AA4			PRINT_ERROR:
  1068 0AA4 C0 01		        CPY     #$01        ; Exit if success (1)
  1069 0AA6 F0 54		        BEQ     PRINT_ERROR_DONE
  1070
  1071 				    ;-----------------------------------
  1072 				    ; If error code = 144, then get
  1073 				    ; extended code from DVSTAT
  1074 				    ;-----------------------------------
  1075 0AA8 C0 90		        CPY     #144
  1076 0AAA D0 0A		        BNE     PRINT_ERROR_NEXT
  1077
  1078 0AAC A9 48		        LDA     #<STADCB
  1079 0AAE A0 09		        LDY     #>STADCB
  1080 0AB0 20 A5 07		        JSR     DOSIOV
  1081 0AB3 AC ED 02		        LDY     DVSTAT+3    ;
  1082
  1083 0AB6			PRINT_ERROR_NEXT:
  1084 				    ;-----------------------------------
  1085 				    ; Convert error code to ASCII
  1086 				    ;-----------------------------------
  1087
  1088 				    ; Call subroutines in ROM to convert error into to ascii
  1089 0AB6 84 D4		        STY     FR0
  1090 0AB8 A9 00		        LDA     #$00
  1091 0ABA 85 D5		        STA     FR0+1
  1092 0ABC 20 AA D9		        JSR     IFP         ; Convert error from int to floating point
  1093 0ABF 20 E6 D8		        JSR     FASC        ; Convert floating point to ASCII
  1094
  1095 				    ;---------------------------------------
  1096 				    ; Find last char in ASCII error (noted by high bit)
  1097 				    ; Unset high bit & append EOL
  1098 				    ;---------------------------------------
  1099 0AC2 A0 FF		        LDY     #$FF        ; Init counter = 0
  1100 0AC4 A2 0E		        LDX     #$0E        ; Offset (-1) to XXX in PRINT_ERROR_HELP
  1101 0AC6 C8			@       INY
  1102 0AC7 E8			        INX                 ; Now pointing to XXX
  1103 0AC8 B1 F3		        LDA     (INBUFF),Y
  1104 0ACA 9D FD 0A		        STA     PRINT_ERROR_HELP,X  ; Stuff error number into HELP command
  1105 0ACD C9 80		        CMP     #$80
  1106 0ACF 90 F5		        BCC     @-
  1107
  1108 0AD1 29 7F		        AND     #$7F        ; Clear high bit
  1109 0AD3 91 F3		        STA     (INBUFF),Y
  1110 0AD5 9D FD 0A		        STA     PRINT_ERROR_HELP,X  ; Stuff error number into HELP command
  1111 0AD8 C8			        INY
  1112 0AD9 E8			        INX
  1113 0ADA A9 9B		        LDA     #EOL        ; Append EOL
  1114 0ADC 91 F3		        STA     (INBUFF),Y
  1115 0ADE 9D FD 0A		        STA     PRINT_ERROR_HELP,X  ; Stuff error number into HELP command
  1116
  1117 0AE1 A5 F3		        LDA     INBUFF
  1118 0AE3 A4 F4		        LDY     INBUFF+1
  1119 				;        JMP     PRINT_STRING
  1120
  1121 0AE5 A9 05		        LDA     #$05        ; Point to start of path (the 1st 'R' in REF/ERR...)
  1122 0AE7 8D 75 0C		        STA     CMDSEP
  1123 0AEA A9 FD		        LDA     #<PRINT_ERROR_HELP
  1124 0AEC 85 F3		        STA     INBUFF
  1125 0AEE A9 0A		        LDA     #>PRINT_ERROR_HELP
  1126 0AF0 85 F4		        STA     INBUFF+1
  1127 0AF2 A9 FF		        LDA     #$FF
  1128 0AF4 8D AA 18		        STA     PRINT_ERR_FLG  ; Set flag that arrived from PRINT_ERROR. This will skip the CLS
  1129 0AF7 20 84 14		        JSR     DO_HELP
  1130 0AFA A0 FF		        LDY     #$FF
  1131
  1132 0AFC			PRINT_ERROR_DONE:
  1133 0AFC 60			        RTS
  1134
  1135 0AFD			PRINT_ERROR_HELP:
  1136 0AFD 48 45 4C 50 20 52 +         .BYTE   'HELP REF/ERROR/XXX'
  1137
  1138 				; End PRINTSCR
  1139 				;---------------------------------------
  1140
  1141 0B0F			ASCII2ADDR:
  1142 				    ;---------------------------------------
  1143 				    ; Convert 4-char ASCII string found in LNBUF
  1144 				    ; to bytes found at INBUFF. 
  1145 				    ; Ex: "0F1A" --> $1A, $0F
  1146 				    ;
  1147 				    ; Input:
  1148 				    ; LNBUF contains 4-char ASCII string
  1149 				    ; Y contains offset from LNBUF to start 
  1150 				    ; of ASCII string
  1151 				    ;
  1152 				    ; Output:
  1153 				    ; INBUFF contains 2 bytes
  1154 				    ;---------------------------------------
  1155 				    
  1156 				    ;---------------------------------------
  1157 				    ; ASCII hex char to integer conversion
  1158 				    ; algorithm borrowed from Apple II Monitor
  1159 				    ;---------------------------------------
  1160 0B0F A9 00		        LDA     #$00
  1161 0B11 85 F3		        STA     INBUFF      ; L
  1162 0B13 85 F4		        STA     INBUFF+1    ; H
  1163 0B15			NEXTHEX:
  1164 0B15 B9 82 05		        LDA     LNBUF,Y     ; Get character for hex test.
  1165 0B18 49 30		        EOR     #%00110000  ; Maps digits to $0-$9
  1166 0B1A C9 0A		        CMP     #$0A        ; Digit?
  1167 0B1C 90 06		        BCC     DIG         ; Yes.
  1168 0B1E 69 88		        ADC     #$88        ; Map letter "A"-"F" to $FA-FF.
  1169 0B20 C9 FA		        CMP     #$FA        ; Hex letter?
  1170 0B22 90 16		        BCC     NOTHEX      ; No, character not hex.
  1171
  1172 0B24 0A			DIG:    ASL
  1173 0B25 0A			        ASL
  1174 0B26 0A			        ASL
  1175 0B27 0A			        ASL
  1176 0B28 A2 04		        LDX     #$04        ; Shift count.
  1177
  1178 0B2A			HEXSHIFT:
  1179 0B2A 0A			        ASL
  1180 0B2B 26 F3		        ROL     INBUFF      ; Rotate into LSD.
  1181 0B2D 26 F4		        ROL     INBUFF+1    ; Rotate into MSD's.
  1182 0B2F CA			        DEX                 ; Done 4 shifts?
  1183 0B30 D0 F8		        BNE     HEXSHIFT    ; No, loop.
  1184 0B32 C8			        INY                 ; Advance text index
  1185 0B33 CC 00 19		        CPY     RBUF        ; Processed 4 characters?
  1186 0B36 D0 DD		        BNE     NEXTHEX     ; No, get next character.
  1187
  1188 0B38 18			        CLC                 ;
  1189 0B39 60			        RTS                 ; INBUFF contains bytes
  1190
  1191 0B3A			NOTHEX:
  1192 0B3A A9 43		        LDA     #<RUN_ERROR_STR
  1193 0B3C A0 0B		        LDY     #>RUN_ERROR_STR
  1194 0B3E 20 89 0A		        JSR     PRINT_STRING
  1195 0B41 38			        SEC
  1196 0B42 60			        RTS
  1197
  1198 0B43			RUN_ERROR_STR:
  1199 0B43 41 44 44 52 3F 20 +         .BYTE   'ADDR? 0000..FFFF',EOL
  1200
  1201 				;---------------------------------------
  1202 0B54			CHECK_INTERNAL_BASIC:
  1203 				;---------------------------------------
  1204 				    ; Check for internal BASIC found in XL/XEs
  1205 				    ; On return:
  1206 				    ;   CARRY is clear if not found
  1207 				    ;   CARRY is set if found
  1208 				    ;-----------------------------------
  1209 0B54 18			        CLC 
  1210 0B55 AD F7 FF		        LDA     $FFF7
  1211 0B58 C9 FF		        CMP     #$FF        ; ????
  1212 0B5A F0 19		        BEQ     NOBASIC_ERROR
  1213 0B5C C9 DD		        CMP     #$DD        ; OSA NTSC
  1214 0B5E F0 15		        BEQ     NOBASIC_ERROR
  1215 0B60 C9 F3		        CMP     #$F3        ; OSB NTSC
  1216 0B62 F0 11		        BEQ     NOBASIC_ERROR
  1217 0B64 C9 D6		        CMP     #$D6        ; OSA PAL
  1218 0B66 F0 0D		        BEQ     NOBASIC_ERROR
  1219 0B68 C9 22		        CMP     #$22        ; OSB PAL
  1220 0B6A F0 09		        BEQ     NOBASIC_ERROR
  1221 0B6C C9 0A		        CMP     #$0A        ; OSA 1200XL
  1222 0B6E F0 05		        BEQ     NOBASIC_ERROR
  1223 0B70 C9 0B		        CMP     #$0B        ; OSB 1200XL
  1224 0B72 F0 01		        BEQ     NOBASIC_ERROR
  1225 0B74 60			        RTS
  1226
  1227 				;---------------------------------------
  1228 0B75			NOBASIC_ERROR:
  1229 				;---------------------------------------
  1230 0B75 A9 7E		        LDA     #<NOBASIC_ERROR_STR
  1231 0B77 A0 0B		        LDY     #>NOBASIC_ERROR_STR
  1232 0B79 20 89 0A		        JSR     PRINT_STRING
  1233 0B7C 38			        SEC
  1234 0B7D 60			        RTS
  1235
  1236 0B7E			NOBASIC_ERROR_STR:
  1237 0B7E 4E 4F 20 42 55 49 +         .BYTE   'NO BUILT-IN BASIC',EOL
  1238
  1239 				;---------------------------------------
  1240 0B90			CHECK_IF_ROM:
  1241 				;---------------------------------------
  1242 				    ; Checks if cart space is ROM or RAM
  1243 				    ;-----------------------------------
  1244 				    ; On return 
  1245 				    ; If A000 = ROM then Y = 1
  1246 				    ; If A000 = RAM then Y = 0
  1247 				    ;-----------------------------------
  1248 0B90 A0 01		        LDY     #$01        ; Assume ROM -> Y=1
  1249 0B92 AD 00 A0		        LDA     $A000       ; Try altering A000
  1250 0B95 EE 00 A0		        INC     $A000       ; 
  1251 0B98 CD 00 A0		        CMP     $A000       ; If A <> A000 then RAM
  1252 0B9B F0 04		        BEQ     @+          ; If A = A000 then ROM (Y=FF)
  1253 0B9D 88			        DEY                 ; RAM -> Y=0
  1254 0B9E 8D 00 A0		        STA     $A000       ; Restore altered RAM
  1255 0BA1 60			@:      RTS
  1256
  1257 				;#######################################
  1258 				;#                                     #
  1259 				;#       COMMAND PROCESSOR (CP)        #
  1260 				;#                                     #
  1261 				;#######################################
  1262
  1263 				;---------------------------------------
  1264 				; DOS Entry point (DOSVEC points here)
  1265 				;---------------------------------------
  1266 0BA2			DOS:
  1267 				        ; Change border if BASIC (or something else) in ROM
  1268 0BA2 AD C8 02		        LDA     COLOR4
  1269 0BA5 8D AB 18		        STA     COLOR4_ORIG          ; Preserve border
  1270 0BA8 20 90 0B		        JSR     CHECK_IF_ROM
  1271 0BAB 98			        TYA                         ; Y = 1 if ROM
  1272 0BAC F0 05		        BEQ     @+                  ; Skip ahead if A000 is RAM
  1273 0BAE A9 06		        LDA     #ROM_BORDER         ; Change border
  1274 0BB0 8D C8 02		        STA     COLOR4
  1275
  1276 				        ; Bypass Autorun if OPTION switch held
  1277 0BB3 AD 1F D0		@:      LDA     CONSOL
  1278 0BB6 C9 03		        CMP     #OPTION
  1279 0BB8 F0 0D		        BEQ     CPLOOP
  1280
  1281 				        ; Autorun injection
  1282 0BBA A9 11		        LDA     #CMD_IDX.AUTORUN    ; Check for AUTORUN
  1283 0BBC CD 93 18		        CMP     AUTORUN_FLG         ; True only on 1st entry (TODO Is this working?)
  1284 0BBF F0 06		        BEQ     CPLOOP              ; Skip to Command Processor
  1285 0BC1 8D 93 18		        STA     AUTORUN_FLG         ; Change flag
  1286 0BC4 20 D8 12		        JSR     SUBMIT_AUTORUN      ; Attempt to execute autorun file
  1287
  1288 				       
  1289 0BC7			CPLOOP:
  1290 0BC7 20 CD 0B		        JSR     CP          ; Command Processor
  1291 0BCA 4C C7 0B		        JMP     CPLOOP      ; Keep looping
  1292
  1293 				;---------------------------------------
  1294 				; Main loop
  1295 				;---------------------------------------
  1296 0BCD			CP:
  1297 0BCD A2 FF		        LDX     #$FF        ; Clear command
  1298 0BCF 8E 90 18		        STX     CMD
  1299 				    ; NOTE Experiment with PRINT_ERROR
  1300 0BD2 E8			    INX
  1301 0BD3 8E AA 18		    STX     PRINT_ERR_FLG
  1302 				        
  1303
  1304 0BD6 20 E5 0B		        JSR     SHOWPROMPT
  1305 0BD9 20 0A 0C		        JSR     GETCMD
  1306 0BDC			AUTORUN_DO:
  1307 0BDC 20 7B 0C		        JSR     PARSECMD
  1308 0BDF 30 03		        BMI     CP_DONE     ; Skip DOCMD if CMD == $FF
  1309 0BE1 20 2E 0D		        JSR     DOCMD
  1310 0BE4			CP_DONE:
  1311 0BE4 60			        RTS
  1312
  1313 				;---------------------------------------
  1314 				; Show Command Prompt (Nn:)
  1315 				; Leading EOF requires special CIOV call
  1316 				;---------------------------------------
  1317
  1318 				;---------------------------------------
  1319 0BE5			SHOWPROMPT:
  1320 				;---------------------------------------
  1321
  1322 0BE5 AD 8F 18		        LDA     DOSDR       ; Get the 1,2,... for N1,N2,...
  1323 0BE8 09 30		        ORA     #'0'        ; Convert, say, 1 to '1'
  1324 0BEA 8D 11 17		        STA     PRMPT+2     ; Store in after EOL and N
  1325
  1326 0BED A2 00		        LDX     #$00
  1327 0BEF A9 0B		        LDA     #PUTCHR
  1328 0BF1 9D 42 03		        STA     ICCOM,X
  1329
  1330 0BF4 A9 0F		        LDA     #<PRMPT
  1331 0BF6 9D 44 03		        STA     ICBAL,X
  1332 0BF9 A9 17		        LDA     #>PRMPT
  1333
  1334 0BFB 9D 45 03		        STA     ICBAH,X
  1335 0BFE A9 04		        LDA     #4          ; Prompt length = 4
  1336 0C00 9D 48 03		        STA     ICBLL,X
  1337 0C03 8A			        TXA                 ; Still zero
  1338 0C04 9D 49 03		        STA     ICBLH,X
  1339
  1340 0C07 4C 56 E4		        JMP     CIOV
  1341
  1342 				;---------------------------------------
  1343 0C0A			GETCMD:
  1344 				;---------------------------------------
  1345 0C0A A2 00		        LDX     #$00
  1346 0C0C A9 05		        LDA     #GETREC
  1347 0C0E 9D 42 03		        STA     ICCOM,X
  1348 0C11 A9 82		        LDA     #<LNBUF
  1349 0C13 9D 44 03		        STA     ICBAL,X
  1350 0C16 A9 05		        LDA     #>LNBUF
  1351 0C18 9D 45 03		        STA     ICBAH,X
  1352 0C1B A9 7F		        LDA     #$7F
  1353 0C1D 9D 48 03		        STA     ICBLL,X
  1354 0C20 20 56 E4		        JSR     CIOV
  1355
  1356 0C23			GETCMDTEST:
  1357 0C23 A0 00		        LDY     #$00
  1358 0C25 84 F2		        STY     CIX
  1359 0C27 20 72 0A		        JSR     LDBUFA      ; Reset LNBUF to $0580
  1360 0C2A 20 7B 0A		        JSR     SKPSPC      ; Advance CIX to next space
  1361
  1362 				    ;---------------------------------------
  1363 				    ; CMDSEP is an sequence of bytes contains
  1364 				    ; indexes to chars following spaces
  1365 				    ; Iterate to clear CMDSEP bytes
  1366 				    ;---------------------------------------
  1367 0C2D 98			        TYA                 ; A = 0
  1368 0C2E A2 02		        LDX     #$02        ; for X = 2 to 0 step -1
  1369 0C30			GETLOOP:
  1370 0C30 9D 75 0C		        STA     CMDSEP,X
  1371 0C33 CA			        DEX
  1372 0C34 10 FA		        BPL     GETLOOP     ; next X
  1373
  1374 				    ; Initialize Delimiter to space
  1375 0C36 A9 20		        LDA     #' '
  1376 0C38 8D 7A 0C		        STA     DELIM
  1377
  1378 				    ;---------------------------------------
  1379 				    ; Loop until EOL is encountered
  1380 				    ;---------------------------------------
  1381 0C3B E8			        INX                 ; Reset X to 0
  1382 0C3C			GETCMD_LOOP:
  1383 0C3C B1 F3		        LDA     (INBUFF),Y
  1384 0C3E C9 9B		        CMP     #EOL        ; Found EOL?
  1385 0C40 F0 32		        BEQ     GETCMD_DONE ; yes. skip
  1386 0C42 CD 7A 0C		        CMP     DELIM       ; Found space?
  1387 0C45 F0 03		        BEQ     GETCMD_REPL ; yes. Replace it
  1388 0C47 C8			        INY
  1389 0C48 D0 F2		        BNE     GETCMD_LOOP ; "always" non-zero
  1390
  1391 				    ;---------------------------------------
  1392 				    ; March through the cmd line and note
  1393 				    ; the positions of any args as delimited
  1394 				    ; by spaces or quotes. positions saved
  1395 				    ; in CMDSEP,X
  1396 				    ;---------------------------------------
  1397 0C4A			GETCMD_REPL:
  1398 0C4A A9 9B		        LDA     #EOL
  1399 0C4C 91 F3		        STA     (INBUFF),Y
  1400 0C4E C8			        INY
  1401 0C4F B1 F3		        LDA     (INBUFF),Y  ; Skip any run of spaces
  1402 0C51 C9 20		        CMP     #' '
  1403 0C53 F0 F5		        BEQ     GETCMD_REPL ; Keep skipping spaces
  1404
  1405 				    ; Here if any run of spaces has ended
  1406 				    ; Are we standing on a double-quote?
  1407 0C55 C9 22		        CMP     #'"'
  1408 0C57 D0 12		        BNE     GETCMD_WR_OFFSET  ; No. Skip ahead
  1409
  1410 				    ; Here if curr char is a double-quote
  1411 0C59 C8			        INY                 ; Advance the command line index
  1412 0C5A A9 22		        LDA     #'"'        ; Is the curr delim a double-quote?
  1413 0C5C CD 7A 0C		        CMP     DELIM       ; If not, change delim to double-quote
  1414 0C5F D0 07		        BNE     GETCMD_DQ_DELIM
  1415
  1416 				    ; Here if curr delim is a double-quote
  1417 				    ; Switch delim to space
  1418 0C61 A9 20		        LDA     #' '
  1419 0C63 8D 7A 0C		        STA     DELIM
  1420 0C66 D0 03		        BNE     GETCMD_WR_OFFSET
  1421
  1422 				    ; Here if curr delim is space
  1423 				    ; Switch delim to double-quote
  1424 0C68			GETCMD_DQ_DELIM:
  1425 0C68 8D 7A 0C		        STA     DELIM
  1426
  1427 				    ; Note the position for the curr command-line arg
  1428 0C6B			GETCMD_WR_OFFSET:
  1429 0C6B 98			        TYA
  1430 0C6C 9D 75 0C		        STA     CMDSEP,X
  1431 0C6F E8			        INX
  1432 0C70 E0 03		        CPX     #$03
  1433 0C72 90 C8		        BCC     GETCMD_LOOP ; Continue searching
  1434
  1435 0C74			GETCMD_DONE:
  1436 0C74 60			        RTS
  1437
  1438 0C75 FF FF FF FF FF	CMDSEP: .BYTE $FF,$FF,$FF,$FF,$FF
  1439 0C7A 20			DELIM:  .BYTE ' '
  1440
  1441 				;---------------------------------------
  1442 0C7B			PARSECMD:
  1443 				;---------------------------------------
  1444 				        ;LDA     LNBUF
  1445 0C7B A0 00		        LDY     #$00
  1446 0C7D B1 F3		        LDA     (INBUFF),Y
  1447 0C7F C9 9B		        CMP     #EOL        ; Quit immediately if no cmd
  1448 0C81 F0 0C		        BEQ     PARSECMD_DONE
  1449
  1450 0C83 20 A4 0C		        JSR     PARSE_INTRINSIC_COMMAND
  1451 0C86 20 DE 0C		        JSR     PARSE_DRIVE_CHANGE
  1452 0C89 20 F5 0C		        JSR     PARSE_EXTRINSIC_COMMAND
  1453 0C8C 20 90 0C		        JSR     PRINT_UNK_CMD
  1454 0C8F			PARSECMD_DONE:
  1455 0C8F 60			        RTS
  1456
  1457 0C90			PRINT_UNK_CMD:
  1458 0C90 AD 90 18		        LDA     CMD
  1459 0C93 C9 FF		        CMP     #$FF
  1460 0C95 D0 07		        BNE     PRINT_UNK_CMD_DONE
  1461 0C97 A9 9F		        LDA     #<UNK_CMD_ERR
  1462 0C99 A0 0C		        LDY     #>UNK_CMD_ERR
  1463 0C9B 20 89 0A		        JSR     PRINT_STRING
  1464 0C9E			PRINT_UNK_CMD_DONE:
  1465 0C9E 60			        RTS
  1466
  1467 0C9F			UNK_CMD_ERR:
  1468 0C9F 43 4D 44 3F 9B	        .BYTE   'CMD?',EOL
  1469
  1470 				;---------------------------------------
  1471 0CA4			PARSE_INTRINSIC_COMMAND:
  1472 				;---------------------------------------
  1473 0CA4 A2 00		        LDX     #$00        ; Initialize X for command code indexing
  1474 0CA6 A0 00		        LDY     #$00
  1475 0CA8 84 F2		        STY     CIX
  1476 0CAA 20 72 0A		        JSR     LDBUFA      ; Set INBUFF to $0580, er make that TBUF
  1477
  1478 0CAD 20 7B 0A		@:      JSR     SKPSPC      ; Skip whitespace
  1479
  1480 0CB0			PARSE_INTRINSIC_NEXT_CHAR:
  1481 0CB0 B1 F3		        LDA     (INBUFF),Y
  1482 0CB2 29 5F		        AND     #$5F        ; Disable high-bit and convert to upper
  1483 0CB4 5D 33 17		        EOR     COMMAND,X   ; X initialized to 0 in caller
  1484 0CB7 C8			        INY
  1485 0CB8 0A			        ASL
  1486 0CB9 F0 0B		        BEQ     PARSE_INTRINSIC_CHAR_OK
  1487
  1488 				        ; Skip to next command
  1489
  1490 0CBB			PARSE_INTRINSIC_NEXT_COMMAND:
  1491 0CBB BD 33 17		        LDA     COMMAND,X
  1492 0CBE 0A			        ASL
  1493 0CBF E8			        INX
  1494 0CC0 90 F9		        BCC     PARSE_INTRINSIC_NEXT_COMMAND
  1495 0CC2 A4 F2		        LDY     CIX
  1496 0CC4 E0 DB		        CPX     #COMMAND_SIZE
  1497
  1498 0CC6			PARSE_INTRINSIC_CHAR_OK:
  1499 0CC6 E8			        INX
  1500 0CC7 90 E7		        BCC     PARSE_INTRINSIC_NEXT_CHAR
  1501 0CC9 84 F2		        STY     CIX
  1502 0CCB B1 F3		        LDA     (INBUFF),Y
  1503 0CCD 30 05		        BMI     PARSE_INTRINSIC_RET
  1504
  1505 0CCF 20 7B 0A		        JSR     SKPSPC
  1506
  1507 0CD2			PARSE_INTRINSIC_RET_ERROR:
  1508 0CD2 A2 DC		        LDX     #COMMAND_SIZE+1
  1509 0CD4			PARSE_INTRINSIC_RET:
  1510 0CD4 BD 33 17		        LDA     COMMAND,X
  1511 0CD7 8D 90 18		        STA     CMD
  1512 0CDA 8D 91 18		        STA     CMDPRV
  1513 0CDD			PARSE_INTRINSIC_DONE:
  1514 0CDD 60			        RTS
  1515
  1516 				; End of PARSE_INTRINSIC_COMMAND
  1517 				;---------------------------------------
  1518
  1519 				;---------------------------------------
  1520 0CDE			PARSE_DRIVE_CHANGE:
  1521 				;---------------------------------------
  1522 0CDE A2 03		        LDX     #$03        ; Check for EOL in pos 3
  1523 0CE0 BD 82 05		        LDA     LNBUF,X
  1524 0CE3 C9 9B		        CMP     #EOL
  1525 0CE5 D0 0D		        BNE     PARSE_DRIVE_CHANGE_DONE
  1526 0CE7 CA			        DEX                 ; go back one char
  1527 0CE8 BD 82 05		        LDA     LNBUF,X
  1528 0CEB C9 3A		        CMP     #':'        ; Check for colon.
  1529 0CED D0 05		        BNE     PARSE_DRIVE_CHANGE_DONE
  1530 0CEF A9 1F		        LDA     #CMD_IDX.DRIVE_CHG
  1531 0CF1 8D 90 18		        STA     CMD
  1532 0CF4			PARSE_DRIVE_CHANGE_DONE:
  1533 0CF4 60			        RTS
  1534
  1535 				;---------------------------------------
  1536 0CF5			PARSE_EXTRINSIC_COMMAND:
  1537 				;---------------------------------------
  1538 				    ; Quit if CMD has been found earlier
  1539 0CF5 AE 90 18		        LDX     CMD         ; Undefined CMD = $FF
  1540 0CF8 E8			        INX                 ; now 0 if undefined
  1541 0CF9 D0 F9		        BNE     PARSE_DRIVE_CHANGE_DONE ; Exit if defined CMD
  1542
  1543 				    ; Here if  CMD is undefined.
  1544 				    ; From here we'll assume it's a filename for a executable
  1545 				    ; and attempt to LOAD it. But first append a ".COM"
  1546 				    ; and shift the filename to the right
  1547
  1548 				    ; Find offset to EOL
  1549 0CFB A0 FF		        LDY     #$FF
  1550 0CFD C8			@       INY
  1551 0CFE B1 F3		        LDA     (INBUFF),Y
  1552 0D00 C9 9B		        CMP     #EOL
  1553 0D02 D0 F9		        BNE     @-
  1554
  1555 				    ; Y contains offset to last char & stash it
  1556 0D04 98			        TYA
  1557 0D05 48			        PHA
  1558
  1559 				    ; Advance Y to allow the 5 chars of '.COM',EOL
  1560 0D06 18			        CLC
  1561 0D07 69 05		        ADC     #$05
  1562 0D09 A8			        TAY
  1563
  1564 				    ; Append .COM, EOL
  1565 0D0A A2 04		        LDX     #$04
  1566 0D0C BD 29 0D		@:      LDA     CMDEXT,X
  1567 0D0F 91 F3		        STA     (INBUFF),Y
  1568 0D11 88			        DEY
  1569 0D12 CA			        DEX                     ; 
  1570 0D13 10 F7		        BPL     @-
  1571
  1572 				    ; Shift executable name to the right to allow room for PREPEND_DRIVE
  1573 				    ; Stack contains offset to last char
  1574 				    ; Y is still counting down from where '.COM' was appended.
  1575 0D15 68			        PLA                 ; Get offset to last char of executable
  1576 0D16 AA			        TAX                 ; It'll be used for indexing
  1577 0D17 CA			        DEX                 ; Skip original EOF
  1578 0D18			SHIFT_LOOP:
  1579 0D18 BD 82 05		        LDA     LNBUF,X     ; Get source ch
  1580 0D1B 91 F3		@:      STA     (INBUFF),Y  ; Copy ch to new location
  1581 0D1D 88			        DEY                 ; Point to next dest ch
  1582 0D1E CA			        DEX                 ; Point to next source ch
  1583 0D1F 10 F7		        BPL     SHIFT_LOOP  ; Until X = 0
  1584
  1585 				    ; Let DO_LOAD attempt to execute the file
  1586 0D21 A9 01		        LDA     #$01        ; Point to start of filename
  1587 0D23 8D 75 0C		        STA     CMDSEP      ; so DO_LOAD will treat it like
  1588 0D26 4C E2 0E		        JMP     DO_LOAD     ; 'LOAD filename'
  1589
  1590 0D29			CMDEXT:
  1591 0D29 2E 43 4F 4D 9B	        .BYTE   '.COM',EOL
  1592
  1593 				; End of PARSE_EXTRINSIC_COMMAND
  1594 				;---------------------------------------
  1595
  1596 				;---------------------------------------
  1597 0D2E			DOCMD:
  1598 				;---------------------------------------
  1599 0D2E AE 90 18		        LDX     CMD
  1600 0D31 30 08		        BMI     DOCMD_DONE  ; Unassigned command = $FF
  1601 0D33 BD 30 18		        LDA     CMD_TAB_H,X ; Get hi-byte of subroutine's addr
  1602 0D36 48			        PHA                 ; Push it to the stack
  1603 0D37 BD 10 18		        LDA     CMD_TAB_L,X ; Get lo-byte of subroutine's addr
  1604 0D3A 48			        PHA                 ; Push it to the stack
  1605 0D3B			DOCMD_DONE:
  1606 0D3B 60			        RTS                 ; Use stack & RTS to jump to subroutine
  1607
  1608 				; End of DOCMD
  1609 				;---------------------------------------
  1610
  1611 				;---------------------------------------
  1612 0D3C			DO_DRIVE_CHG:
  1613 				;---------------------------------------
  1614 0D3C AD 82 05		        LDA     LNBUF
  1615 0D3F 29 DF		        AND     #%11011111  ; Convert lower to upper
  1616 0D41 C9 4E		        CMP     #'N'
  1617 0D43 D0 14		        BNE     DO_DRIVE_CHG_ERROR
  1618 0D45 8D 10 17		        STA     PRMPT+1
  1619 0D48 AD 83 05		        LDA     LNBUF+1
  1620 0D4B C9 31		        CMP     #'1'        ; Skip if < '1'
  1621 0D4D 90 0A		        BCC     DO_DRIVE_CHG_ERROR
  1622 0D4F C9 39		        CMP     #'9'        ; Skip if >= '9'
  1623 0D51 B0 06		        BCS     DO_DRIVE_CHG_ERROR
  1624 0D53 29 0F		        AND     #$0F        ; Convert, say, to 1-8
  1625 0D55 8D 8F 18		        STA     DOSDR
  1626 0D58 60			        RTS
  1627 0D59			DO_DRIVE_CHG_ERROR:
  1628 0D59 A9 85		        LDA     #<CDERR
  1629 0D5B A0 18		        LDY     #>CDERR
  1630 0D5D 4C 89 0A		        JMP     PRINT_STRING
  1631
  1632 				; End of DOCMD
  1633
  1634 				;---------------------------------------
  1635 				; Returns DOSDR in X
  1636 				; If arg1 contains Nn: then reg X = n
  1637 				; Otherwise X = DOSDR (from curr prompt)
  1638 				;---------------------------------------
  1639 0D60			GET_DOSDR:
  1640 				;---------------------------------------
  1641
  1642 0D60 20 72 0A		        JSR     LDBUFA      ; Reset INBUFF to LNBUF
  1643 0D63 AE 8F 18		        LDX     DOSDR       ; Set DUNIT(X) to curr drive
  1644
  1645 				    ;---------------------------------------
  1646 				    ; Consider arg1 = N2:TNFS://localhost/
  1647 				    ; Check arg1 for ":" in 3rd position
  1648 				    ; if found then use char in 2nd position ('2') as DOSDR
  1649 				    ; First, change INBUFF to point to beg. of 1st arg
  1650 				    ;---------------------------------------
  1651 0D66 AD 75 0C		        LDA     CMDSEP              ; arg offset
  1652 0D69 F0 17		        BEQ     GET_DOSDR_DONE      ; first, if arg1 not pop, leave X as-is & quit
  1653
  1654 0D6B 18			        CLC                         ; Advance pointer to LNBUF
  1655 0D6C 65 F3		        ADC     INBUFF
  1656 0D6E 85 F3		        STA     INBUFF
  1657 0D70 90 02		        BCC     GET_DOSDR_NEXT
  1658 0D72 E6 F4		        INC     INBUFF+1
  1659
  1660 0D74			GET_DOSDR_NEXT:
  1661 0D74 A0 02		        LDY     #$02            ; Check for ':' in 3rd pos
  1662 0D76 B1 F3		        LDA     (INBUFF),Y
  1663 0D78 C9 3A		        CMP     #':'
  1664 0D7A D0 06		        BNE     GET_DOSDR_DONE  ; Not found, skip & use default
  1665 0D7C 88			        DEY
  1666 0D7D B1 F3		        LDA     (INBUFF),Y
  1667 0D7F 29 0F		        AND     #$0F            ; Convert, say, '2' to 2
  1668 0D81 AA			        TAX                     ; Return DOSDR in X
  1669
  1670 0D82			GET_DOSDR_DONE:
  1671 0D82 60			        RTS
  1672
  1673 				;---------------------------------------
  1674 0D83			DO_GENERIC:
  1675 				;---------------------------------------
  1676
  1677 				    ;---------------------------------------
  1678 				    ; SIO call for NCD,{MK,RM}DIR,DEL,RENAME
  1679 				    ;---------------------------------------
  1680
  1681 				    ;---------------------------------------
  1682 				    ; Get Fujinet SIO command (~ $21 for DEL)
  1683 				    ; X = table index from caller
  1684 				    ;---------------------------------------
  1685 0D83 BD 13 17		        LDA     CMD_DCOMND,X
  1686 0D86 8D EE 0D		        STA     GENDCB+2
  1687
  1688 0D89 C9 FD		        CMP     #CMD_USER       ; Skip prepending devspec for SSH
  1689 0D8B F0 1C		        BEQ     DO_GENERIC_NEXT
  1690 0D8D C9 FE		        CMP     #CMD_PASS
  1691 0D8F F0 18		        BEQ     DO_GENERIC_NEXT
  1692
  1693 				    ;---------------------------------------
  1694 				    ; Get DOSDR from either arg1 or curr drive
  1695 				    ;---------------------------------------
  1696 0D91 20 60 0D		        JSR     GET_DOSDR    ; X will contain int of n in Nn:
  1697 0D94 8E ED 0D		        STX     GENDCB+1
  1698 0D97 20 BB 16		        JSR     PREPEND_DRIVE
  1699
  1700 				    ;---------------------------------------
  1701 				    ; If this is NCD ensure a '/' char is the last char
  1702 				    ;---------------------------------------
  1703 0D9A AD EE 0D		        LDA     GENDCB+2
  1704 0D9D C9 2C		        CMP     #CMD_CD         ; Is this an NCD command?
  1705 0D9F D0 08		        BNE     DO_GENERIC_NEXT ; No. skip
  1706
  1707 0DA1 AD 75 0C		        LDA     CMDSEP
  1708 0DA4 F0 2C		        BEQ     NCD_ERROR
  1709 0DA6 20 E8 16		        JSR     APPEND_SLASH    ; Append '/' to path if missing
  1710
  1711 0DA9			DO_GENERIC_NEXT:
  1712 				    ;---------------------------------------
  1713 				    ; Populate the DCB
  1714 				    ;---------------------------------------
  1715 0DA9 AD 8F 18		        LDA     DOSDR
  1716 0DAC 8D 49 09		        STA     STADCB+1        ; Yes. Status (not typo)
  1717 				;        STA     GENDCB+1   ; 20221105 - commented-out. checking for bug...
  1718 0DAF A5 F3		        LDA     INBUFF
  1719 0DB1 8D F0 0D		        STA     GENDCB+4
  1720 0DB4 A5 F4		        LDA     INBUFF+1
  1721 0DB6 8D F1 0D		        STA     GENDCB+5
  1722
  1723 				    ;---------------------------------------
  1724 				    ; Send the command to FujiNet
  1725 				    ;---------------------------------------
  1726 0DB9 A9 EC		        LDA     #<GENDCB
  1727 0DBB A0 0D		        LDY     #>GENDCB
  1728 0DBD 20 A5 07		        JSR     DOSIOV
  1729 0DC0 20 A4 0A		        JSR     PRINT_ERROR
  1730
  1731 0DC3			GEN_UNMOUNT:
  1732 				    ;---------------------------------------
  1733 				    ; if DEL or RENAME, then remount drive
  1734 				    ;---------------------------------------
  1735 0DC3 AD 91 18		        LDA     CMDPRV
  1736 0DC6 C9 02		        CMP     #CMD_IDX.DEL
  1737 0DC8 F0 04		        BEQ     GEN_REMOUNT
  1738 0DCA C9 0A		        CMP     #CMD_IDX.RENAME
  1739 0DCC D0 03		        BNE     GENDONE
  1740 0DCE			GEN_REMOUNT:
  1741 0DCE 4C 88 16		        JMP     REMOUNT_DRIVE
  1742
  1743 0DD1			GENDONE:
  1744 0DD1 60			        RTS
  1745
  1746 				;---------------------------------------
  1747 0DD2			NCD_ERROR:
  1748 				;---------------------------------------
  1749 0DD2 A9 E6		        LDA     #<NCD_ERROR_STR
  1750 0DD4 A0 0D		        LDY     #>NCD_ERROR_STR
  1751 0DD6 20 89 0A		        JSR     PRINT_STRING
  1752 0DD9 A0 01		        LDY     #$01        ; Return error
  1753 0DDB 60			        RTS
  1754 				    ;---------------------------------------
  1755 				    ; Close 
  1756 				    ;---------------------------------------
  1757 0DDC A2 10		        LDX     #$10        ; File #1
  1758 0DDE A9 0C		        LDA     #$0C        ; Close #1 first
  1759 0DE0 9D 42 03		        STA     ICCOM,X
  1760 0DE3 20 56 E4		        JSR     CIOV
  1761
  1762 0DE6			NCD_ERROR_STR:
  1763 0DE6 50 41 54 48 3F 9B	        .BYTE   'PATH?',EOL
  1764
  1765 				;---------------------------------------
  1766 0DEC			GENDCB:
  1767 0DEC 71			        .BYTE   DEVIDN      ; DDEVIC
  1768 0DED FF			        .BYTE   $FF         ; DUNIT
  1769 0DEE FF			        .BYTE   $FF         ; DCOMND
  1770 0DEF 80			        .BYTE   $80         ; DSTATS
  1771 0DF0 FF			        .BYTE   $FF         ; DBUFL
  1772 0DF1 FF			        .BYTE   $FF         ; DBUFH
  1773 0DF2 1F			        .BYTE   $1F         ; DTIMLO
  1774 0DF3 00			        .BYTE   $00         ; DRESVD
  1775 0DF4 00			        .BYTE   $00         ; DBYTL
  1776 0DF5 01			        .BYTE   $01         ; DBYTH
  1777 0DF6 00			        .BYTE   $00         ; DAUX1
  1778 0DF7 00			        .BYTE   $00         ; DAUX2
  1779
  1780 				; End of DO_GENERIC
  1781 				;---------------------------------------
  1782
  1783 				;;---------------------------------------
  1784 				;DO_COPY:
  1785 				;;---------------------------------------
  1786 				;
  1787 				;        LDA     #$20
  1788 				;        STA     COLOR2
  1789 				;
  1790 				;        LDA     #<CPYDCB
  1791 				;        LDY     #>CPYDCB
  1792 				;        JSR     DOSIOV
  1793 				;
  1794 				;        LDA     #$20
  1795 				;        STA     COLOR2
  1796 				;
  1797 				;        RTS
  1798 				;
  1799 				;CPYDCB:
  1800 				;        .BYTE      DEVIDN  ; DDEVIC
  1801 				;        .BYTE      $FF     ; DUNIT
  1802 				;        .BYTE      $D8     ; DCOMND
  1803 				;        .BYTE      $80     ; DSTATS
  1804 				;        .BYTE      <COPYSPEC  ; DBUFL
  1805 				;        .BYTE      >COPYSPEC ; DBUFH
  1806 				;        .BYTE      $FE     ; DTIMLO
  1807 				;        .BYTE      $00     ; DRESVD
  1808 				;        .BYTE      $00     ; DBYTL
  1809 				;        .BYTE      $01     ; DBYTH
  1810 				;        .BYTE      3       ; DAUX1
  1811 				;        .BYTE      2       ; DAUX2
  1812 				;
  1813 				;COPYSPEC:
  1814 				;        .BYTE 'iss.po|iss.po',$00
  1815
  1816 				;;---------------------------------------
  1817 				;DO_COPY:
  1818 				;;---------------------------------------
  1819 				;        LDA     #$B0
  1820 				;        STA     COLOR2
  1821 				;        RTS
  1822
  1823 				;        JSR     COPY_PARSE_FILES    ; locate comma, replace with EOL
  1824 				;        BMI     COPY_DONE
  1825 				;
  1826 				;        LDA     CMDSEP
  1827 				;        STA     CMDSEP+2
  1828 				;
  1829 				;        LDA     CMDSEP+1
  1830 				;        STA     CMDSEP
  1831 				;
  1832 				;        JSR     COPY_OPEN_DEST      ; use CIO to open file 2 for write
  1833 				;        BMI     COPY_DONE
  1834 				;
  1835 				;        LDA     CMDSEP+2
  1836 				;        STA     CMDSEP
  1837 				;        JSR     COPY_OPEN_SRC       ; use CIO to open file 1 for read
  1838 				;        BMI     COPY_DONE
  1839 				;
  1840 				;@:      JSR     COPY_GET_SRC
  1841 				;        JSR     COPY_PUT_DEST
  1842 				;        ;BNE     @-
  1843 				;
  1844 				;COPY_DONE:
  1845 				;    ; Close files
  1846 				;        LDX     #$10
  1847 				;        JSR     CIOCLOSE
  1848 				;        LDX     #$20
  1849 				;        JMP     CIOCLOSE
  1850 				;
  1851 				;;---------------------------------------
  1852 				;COPY_PARSE_FILES:
  1853 				;;---------------------------------------
  1854 				;    ; Find position of comma in line buffer
  1855 				;    ; Return X = position of comma
  1856 				;    ;---------------------------------------
  1857 				;        LDX     CMDSEP
  1858 				;COPY_PARSE_LOOP:
  1859 				;        LDA     LNBUF,X
  1860 				;        CMP     #','
  1861 				;        BEQ     COPY_PARSE_FILES_DONE
  1862 				;        CMP     #EOL
  1863 				;        BEQ     COPY_SHOW_USAGE
  1864 				;        INX
  1865 				;        BNE     COPY_PARSE_LOOP
  1866 				;COPY_PARSE_FILES_DONE:
  1867 				;    ;---------------------------------------
  1868 				;    ; Here if comma found.
  1869 				;    ; Inject EOL where the comma was found
  1870 				;    ;---------------------------------------
  1871 				;        LDA     #EOL
  1872 				;        STA     LNBUF,X
  1873 				;        INX                 ; Advance to start of 2nd arg
  1874 				;        STX     CMDSEP+1    ; Point to 2nd arg now
  1875 				;        RTS
  1876 				;    ;---------------------------------------
  1877 				;    ; Here if no comma found.
  1878 				;    ; Print usage
  1879 				;    ;---------------------------------------
  1880 				;COPY_SHOW_USAGE:
  1881 				;        LDA     #<COPY_SHOW_USAGE_STR
  1882 				;        LDY     #>COPY_SHOW_USAGE_STR
  1883 				;        JSR     PRINT_STRING
  1884 				;        LDY     #$FF
  1885 				;        RTS
  1886 				;
  1887 				;COPY_SHOW_USAGE_STR:
  1888 				;        .BYTE   'COPY SOURCE,DEST',EOL
  1889 				;
  1890 				;; End of COPY_COMMA_POS:
  1891 				;;---------------------------------------
  1892 				;
  1893 				;;---------------------------------------
  1894 				;COPY_OPEN_SRC:
  1895 				;;---------------------------------------
  1896 				;        JSR     GET_DOSDR       ; Get DUNIT
  1897 				;        JSR     PREPEND_DRIVE
  1898 				;
  1899 				;        LDX     #$10            ; File #1
  1900 				;        JSR     CIOCLOSE        ; Assert file #1 is closed
  1901 				;        LDY     #$04            ; Open for input
  1902 				;        JSR     CIOOPEN         ; Open filename @ (INBUFF)
  1903 				;        BPL     COPY_OPEN_SRC_DONE
  1904 				;
  1905 				;        LDA     #<COPY_OPEN_SRC_ERR_STR
  1906 				;        LDY     #>COPY_OPEN_SRC_ERR_STR
  1907 				;        JMP     PRINT_STRING
  1908 				;
  1909 				;COPY_OPEN_SRC_DONE:
  1910 				;        RTS
  1911 				;        
  1912 				;COPY_OPEN_SRC_ERR_STR:
  1913 				;        .BYTE   'UNABLE TO OPEN SOURCE',EOL
  1914 				;
  1915 				;;End of COPY_OPEN_SRC
  1916 				;;---------------------------------------
  1917 				;
  1918 				;;---------------------------------------
  1919 				;COPY_OPEN_DEST:
  1920 				;;---------------------------------------
  1921 				;    ; Advance offset to arg2
  1922 				;        
  1923 				;@:      JSR     GET_DOSDR       ; Get DUNIT
  1924 				;        JSR     PREPEND_DRIVE
  1925 				;
  1926 				;        LDX     #$20            ; Assert file #2 is closed
  1927 				;        JSR     CIOCLOSE
  1928 				;
  1929 				;        LDY     #$08            ; Open for write
  1930 				;        JSR     CIOOPEN
  1931 				;        BPL     COPY_OPEN_DEST_DONE  ; If success, skip ahead
  1932 				;
  1933 				;        LDA     #<COPY_OPEN_DEST_ERR_STR
  1934 				;        LDY     #>COPY_OPEN_DEST_ERR_STR
  1935 				;        JMP     PRINT_STRING
  1936 				;
  1937 				;COPY_OPEN_DEST_DONE:
  1938 				;        RTS
  1939 				;        
  1940 				;COPY_OPEN_DEST_ERR_STR:
  1941 				;        .BYTE   'UNABLE TO OPEN DEST',EOL
  1942 				;
  1943 				;;End of COPY_OPEN_SRC
  1944 				;;---------------------------------------
  1945 				;
  1946 				;;---------------------------------------
  1947 				;COPY_GET_SRC:
  1948 				;;---------------------------------------
  1949 				;        ;LDX     #$10
  1950 				;        ;JSR     CIOSTATUS
  1951 				;
  1952 				;        LDX     #$10
  1953 				;        LDA     #<TBUF
  1954 				;        STA     INBUFF      ; Buffer addr Lo
  1955 				;        LDA     #>TBUF
  1956 				;        STA     INBUFF+1    ; Buffer addr Hi
  1957 				;        LDA     #$80        ; Buffer size Lo
  1958 				;        LDY     #$00        ; Buffer size Hi
  1959 				;        JSR     CIOGET
  1960 				;        BPL     COPY_GET_SRC_DONE
  1961 				;        CPY     #EOF
  1962 				;        BEQ     COPY_GET_SRC_DONE
  1963 				; 
  1964 				;        LDA     #<COPY_GET_SRC_STR
  1965 				;        LDY     #>COPY_GET_SRC_STR
  1966 				;        JMP     PRINT_STRING
  1967 				;
  1968 				;COPY_GET_SRC_DONE:
  1969 				;        RTS
  1970 				;
  1971 				;COPY_GET_SRC_STR:
  1972 				;        .BYTE   'ERROR READING FROM SOURCE',EOL
  1973 				;
  1974 				;;---------------------------------------
  1975 				;COPY_PUT_DEST:
  1976 				;;---------------------------------------
  1977 				;        ;LDX     #$20
  1978 				;        ;JSR     CIOSTATUS
  1979 				;
  1980 				;        LDX     #$20
  1981 				;        LDA     #<TBUF
  1982 				;        STA     INBUFF      ; Buffer addr Lo
  1983 				;        LDA     #>TBUF
  1984 				;        STA     INBUFF+1    ; Buffer addr Hi
  1985 				;        LDA     #$06        ; Buffer size Lo
  1986 				;        LDY     #$00        ; Buffer size Hi
  1987 				;        JSR     CIOPUT
  1988 				;        BPL     COPY_PUT_DEST_DONE
  1989 				;        CPY     #EOF
  1990 				;        BEQ     COPY_PUT_DEST_DONE
  1991 				; 
  1992 				;        LDA     #<COPY_PUT_DEST_STR
  1993 				;        LDY     #>COPY_PUT_DEST_STR
  1994 				;        JMP     PRINT_STRING
  1995 				;
  1996 				;COPY_PUT_DEST_DONE:
  1997 				;        RTS
  1998 				;
  1999 				;COPY_PUT_DEST_STR:
  2000 				;        .BYTE   'ERROR WRITING TO DEST',EOL
  2001 				;
  2002
  2003 				;---------------------------------------
  2004 0DF8			DO_DIR:
  2005 				;---------------------------------------
  2006 0DF8 20 58 0E		        JSR     DIR_INIT    ; set dunits
  2007 0DFB 20 68 0E		        JSR     DIR_OPEN    ; open with dir request
  2008 0DFE C0 01		        CPY     #$01        ; success (1) ?
  2009 0E00 F0 03		        BEQ     DIR_LOOP    ; if success, jump ahead
  2010 0E02 4C A4 0A		        JMP     PRINT_ERROR ; exit
  2011
  2012 0E05			DIR_LOOP:
  2013
  2014 				    ;---------------------------------------
  2015 				    ; Send Status request to SIO
  2016 				    ;---------------------------------------
  2017 0E05 A9 48		        LDA     #<STADCB
  2018 0E07 A0 09		        LDY     #>STADCB
  2019 0E09 20 A5 07		        JSR     DOSIOV
  2020
  2021 				    ;---------------------------------------
  2022 				    ; Status returns DVSTAT
  2023 				    ;---------------------------------------
  2024 0E0C A2 00		        LDX     #$00
  2025 0E0E EC EB 02		        CPX     DVSTAT+1    ; if byte count < 255 (that is, hi=0)
  2026 0E11 F0 09		        BEQ     DIR_LT_255  ; then skip
  2027
  2028 				    ;---------------------------------------
  2029 				    ; Branch 1: Read 255 bytes (max)
  2030 				    ;---------------------------------------
  2031 0E13 CA			        DEX                 ; X now 255 (Read FF Bytes)
  2032 0E14 8E 54 0E		        STX     DIRRDCB+8   ; DBYTL
  2033 0E17 8E 56 0E		        STX     DIRRDCB+10  ; DAUX1
  2034 0E1A 30 0B		        BMI     DIR_NEXT1   ; "always" true. skip down SIO call
  2035
  2036 				    ;---------------------------------------
  2037 				    ; Branch 2: Read < 255 bytes
  2038 				    ;---------------------------------------
  2039 0E1C			DIR_LT_255:
  2040 0E1C AD EA 02		        LDA     DVSTAT      ; Get count of bytes remaining
  2041 0E1F F0 6C		        BEQ     DIR_ERROR   ; If here then DVSTAT = $0000 (error)
  2042 0E21 8D 54 0E		        STA     DIRRDCB+8   ; DBYTL
  2043 0E24 8D 56 0E		        STA     DIRRDCB+10  ; DAUX1
  2044
  2045 				    ;-------------------------
  2046 				    ; Send Read request to SIO
  2047 				    ;-------------------------
  2048 0E27			DIR_NEXT1:
  2049 0E27 A9 4C		        LDA     #<DIRRDCB
  2050 0E29 A0 0E		        LDY     #>DIRRDCB
  2051 0E2B 20 A5 07		        JSR     DOSIOV      ; Fetch directory listing
  2052 0E2E 20 BD 0E		        JSR     DIR_PRINT   ; xfer payload to screen
  2053
  2054 				    ;---------------------------------------
  2055 				    ; Pause output if SPACE key code found
  2056 				    ;---------------------------------------
  2057 0E31			DIR_WAIT:
  2058 0E31 AD FC 02		        LDA     CH
  2059 0E34 C9 21		        CMP     #SPC_KEY
  2060 0E36 F0 F9		        BEQ     DIR_WAIT
  2061
  2062 				    ;---------------------------------------
  2063 				    ; Exit loop if ESC key code found
  2064 				    ;---------------------------------------
  2065 0E38 AD FC 02		        LDA     CH
  2066 0E3B C9 1C		        CMP     #ESC_KEY    ; hardware code for ESC key
  2067 0E3D F0 05		        BEQ     DIR_NEXT
  2068
  2069 				    ;---------------------------------------
  2070 				    ; Loop if more data to read
  2071 				    ;---------------------------------------
  2072 0E3F AD EB 02		        LDA     DVSTAT+1    ; Was there more to read (that is, was hi>0)?
  2073 0E42 D0 C1		        BNE     DIR_LOOP    ; If yes, then do it again
  2074
  2075 0E44			DIR_NEXT:
  2076 0E44 A9 FF		        LDA     #$FF        ; Clear key
  2077 0E46 8D FC 02		        STA     CH
  2078 0E49 4C DB 0E		        JMP     DIR_CLOSE
  2079
  2080 0E4C			DIRRDCB:
  2081 0E4C 71			        .BYTE   DEVIDN      ; DDEVIC
  2082 0E4D FF			        .BYTE   $FF         ; DUNIT
  2083 0E4E 52			        .BYTE   'R'         ; DCOMND
  2084 0E4F 40			        .BYTE   $40         ; DSTATS
  2085 0E50 00			        .BYTE   <RBUF       ; DBUFL
  2086 0E51 19			        .BYTE   >RBUF       ; DBUFH
  2087 0E52 1F			        .BYTE   $1F         ; DTIMLO
  2088 0E53 00			        .BYTE   $00         ; DRESVD
  2089 0E54 00			        .BYTE   $00         ; DBYTL
  2090 0E55 00			        .BYTE   $00         ; DBYTH
  2091 0E56 00			        .BYTE   $00         ; DAUX1
  2092 0E57 00			        .BYTE   $00         ; DAUX2
  2093
  2094 				;---------------------------------------
  2095 				; Set DUNITs in all DCBs used by DIR
  2096 				;---------------------------------------
  2097 0E58			DIR_INIT:
  2098 				;---------------------------------------
  2099 0E58 20 60 0D		        JSR     GET_DOSDR   ; On return, X <- n in Nn:
  2100 0E5B 8E B2 0E		        STX     DIRODCB+1   ; DUNIT for Open
  2101 0E5E 8E 49 09		        STX     STADCB+1    ; DUNIT for Status
  2102 0E61 8E 4D 0E		        STX     DIRRDCB+1   ; DUNIT for Read
  2103 0E64 8E 22 08		        STX     CLODCB+1    ; DUNIT for Close
  2104 0E67 60			        RTS
  2105
  2106 				;---------------------------------------
  2107 0E68			DIR_OPEN:
  2108 				;---------------------------------------
  2109 0E68 20 BB 16		        JSR     PREPEND_DRIVE
  2110
  2111 				    ;-----------------------------------
  2112 				    ; Default to arg1
  2113 				    ;-----------------------------------
  2114 0E6B A6 F3		        LDX     INBUFF
  2115 0E6D A4 F4		        LDY     INBUFF+1
  2116
  2117 				    ;-----------------------------------
  2118 				    ; But use Nn:*.* if no arg1
  2119 				    ;-----------------------------------
  2120 0E6F AD 75 0C		        LDA     CMDSEP          ; 0 means no arg1
  2121 0E72 D0 0C		        BNE     DIR_OPEN_NEXT   ; If arg1 present then skip
  2122
  2123 				    ;-----------------------------------
  2124 				    ; Here if no arg1
  2125 				    ;-----------------------------------
  2126 0E74 A2 AA		        LDX     #<DIR_OPEN_STR
  2127 0E76 A0 0E		        LDY     #>DIR_OPEN_STR
  2128
  2129 0E78 AD 8F 18		        LDA     DOSDR
  2130 0E7B 09 30		        ORA     #'0'            ; Convert, say, 1 to '1'
  2131 0E7D 8D AB 0E		        STA     DIR_OPEN_STR+1  ; Inject DOSDR into string
  2132
  2133 0E80			DIR_OPEN_NEXT:
  2134 0E80 8E B5 0E		        STX     DIRODCB+4       ; DBUFL
  2135 0E83 8C B6 0E		        STY     DIRODCB+5       ; DBUFH
  2136
  2137 0E86 A9 B1		        LDA     #<DIRODCB
  2138 0E88 A0 0E		        LDY     #>DIRODCB
  2139 0E8A 4C A5 07		        JMP     DOSIOV
  2140
  2141 				;---------------------------------------
  2142 0E8D			DIR_ERROR:
  2143 				;---------------------------------------
  2144 0E8D A9 97		        LDA     #<DIR_ERROR_STR
  2145 0E8F A0 0E		        LDY     #>DIR_ERROR_STR
  2146 0E91 20 89 0A		        JSR     PRINT_STRING
  2147 0E94 A0 01		        LDY     #$01            ; Return error
  2148 0E96 60			        RTS
  2149
  2150 0E97			DIR_ERROR_STR:
  2151 0E97 55 4E 41 42 4C 45 +         .BYTE   'UNABLE TO READ DIR',EOL
  2152
  2153 0EAA			DIR_OPEN_STR:
  2154 0EAA 4E 20 3A 2A 2E 2A +         .BYTE   'N :*.*',EOL
  2155
  2156 0EB1			DIRODCB:
  2157 0EB1 71			        .BYTE   DEVIDN          ; DDEVIC
  2158 0EB2 FF			        .BYTE   $FF             ; DUNIT
  2159 0EB3 4F			        .BYTE   'O'             ; DCOMND
  2160 0EB4 80			        .BYTE   $80             ; DSTATS
  2161 0EB5 FF			        .BYTE   $FF             ; DBUFL
  2162 0EB6 FF			        .BYTE   $FF             ; DBUFH
  2163 0EB7 1F			        .BYTE   $1F             ; DTIMLO
  2164 0EB8 00			        .BYTE   $00             ; DRESVD
  2165 0EB9 00			        .BYTE   $00             ; DBYTL
  2166 0EBA 01			        .BYTE   $01             ; DBYTH
  2167 0EBB 06			        .BYTE   $06             ; DAUX1
  2168 0EBC 80			        .BYTE   $80             ; DAUX2 (Long Dir)
  2169
  2170 				; End of DIR_OPEN
  2171 				;---------------------------------------
  2172
  2173 				;---------------------------------------
  2174 0EBD			DIR_PRINT:
  2175 				;---------------------------------------
  2176 				        ; Print results using CIO
  2177 0EBD A2 00		        LDX     #$00
  2178 0EBF A9 0B		        LDA     #PUTCHR
  2179 0EC1 9D 42 03		        STA     ICCOM,X
  2180
  2181 				        ; Fill out buffer loc
  2182 0EC4 A9 00		        LDA     #<RBUF
  2183 0EC6 9D 44 03		        STA     ICBAL,X
  2184 0EC9 A9 19		        LDA     #>RBUF
  2185 0ECB 9D 45 03		        STA     ICBAH,X
  2186
  2187 				        ; Fill out size loc
  2188 0ECE AD 54 0E		        LDA     DIRRDCB+8
  2189 0ED1 9D 48 03		        STA     ICBLL,X
  2190 0ED4 8A			        TXA
  2191 0ED5 9D 49 03		        STA     ICBLH,X
  2192 0ED8 4C 56 E4		        JMP     CIOV
  2193
  2194 				;---------------------------------------
  2195 0EDB			DIR_CLOSE:
  2196 				;---------------------------------------
  2197 				        ; Close
  2198 0EDB A9 21		        LDA     #<CLODCB
  2199 0EDD A0 08		        LDY     #>CLODCB
  2200 0EDF 4C A5 07		        JMP     DOSIOV
  2201
  2202 				;---------------------------------------
  2203 0EE2			DO_LOAD:
  2204 				;---------------------------------------
  2205 				    ; Binary Loader based on work by Richard J. Kalagher 07-AUG-1983
  2206
  2207 				    ; Open file
  2208 0EE2 AD 75 0C		        LDA     CMDSEP          ; Quit if no arg1
  2209 0EE5 D0 03		        BNE     LOAD_NEXT1
  2210 0EE7 4C 76 11		        JMP     LOAD_ERROR
  2211
  2212 0EEA			LOAD_NEXT1:
  2213 				    ; Point INBUFF to start of filename
  2214 0EEA 18			        CLC
  2215 0EEB 65 F3		        ADC     INBUFF          ; [A] contains offset to arg1
  2216 0EED 85 F3		        STA     INBUFF
  2217 0EEF 90 02		        BCC     LOAD_NEXT2
  2218 0EF1 E6 F4		        INC     INBUFF+1
  2219
  2220 0EF3			LOAD_NEXT2:
  2221 0EF3 20 86 0F		        JSR     LOAD_NTRANS     ; Disable any EOL translation
  2222 0EF6 20 42 0F		        JSR     LOAD_SETUP      ; Set up run and init to RTS
  2223 0EF9 A9 04		        LDA     #OINPUT         ; A arg needed in LOAD_OPEN
  2224 0EFB 20 58 0F		        JSR     LOAD_OPEN       ; Open the file
  2225 0EFE C0 01		        CPY     #$01            ; Quit if unable to open
  2226 0F00 D0 3F		        BNE     R
  2227
  2228 0F02 A9 FF		        LDA     #$FF
  2229 0F04 8D 90 19		        STA     BIN_1ST
  2230 0F07 20 94 0F		        JSR     LOAD_READ2
  2231 0F0A 20 B5 0F		        JSR     LOAD_CHKFF
  2232 0F0D C0 01		        CPY     #$01
  2233 0F0F D0 30		        BNE     R
  2234
  2235 0F11 EE 90 19		        INC     BIN_1ST
  2236 				    ; Process each payload
  2237 0F14 20 94 0F		GETFIL: JSR     LOAD_READ2      ; Get two bytes (binary header)
  2238 0F17 30 28		        BMI     R               ; Exit if EOF hit
  2239 0F19 20 4D 0F		        JSR     LOAD_INIT       ; Set init default
  2240 0F1C A2 01		        LDX     #$01
  2241 0F1E 20 B5 0F		        JSR     LOAD_CHKFF      ; Check if header (and start addr, too)
  2242 0F21 20 EC 0F		        JSR     LOAD_STRAD      ; Put start address in
  2243 0F24 20 94 0F		        JSR     LOAD_READ2      ; Get to more butes (end addr)
  2244 0F27 20 F9 0F		        JSR     LOAD_ENDAD      ; Put end address in
  2245 0F2A 20 12 10		        JSR     LOAD_BUFLEN     ; Calculate buffer length
  2246 0F2D 20 37 10		        JSR     LOAD_GETDAT     ; Get the data record
  2247 0F30 10 03		        BPL     @+              ; Was EOF detected?
  2248 0F32 20 3E 0F		        JSR     JSTART          ; Yes. Go to RUNAD
  2249 0F35 20 3B 0F		@:      JSR     JINIT           ; Attempt initialization
  2250 0F38 4C 14 0F		        JMP     GETFIL          ; Process next payload
  2251
  2252 0F3B 6C E2 02		JINIT:  JMP     (INITAD)        ; Will either RTS or perform INIT
  2253 0F3E 6C E0 02		JSTART: JMP     (RUNAD)         ; Godspeed.
  2254 0F41 60			R:      RTS                     ; Stunt-double for (INITAD),(RUNAD)
  2255
  2256 				;---------------------------------------
  2257 0F42			LOAD_SETUP:
  2258 				;---------------------------------------
  2259 0F42 A9 41		        LDA     #<R
  2260 0F44 8D E0 02		        STA     RUNAD
  2261 0F47 A9 0F		        LDA     #>R
  2262 0F49 8D E1 02		        STA     RUNAD+1
  2263 0F4C 60			        RTS
  2264
  2265 				;---------------------------------------
  2266 0F4D			LOAD_INIT:
  2267 				;---------------------------------------
  2268 0F4D A9 41		        LDA     #<R
  2269 0F4F 8D E2 02		        STA     INITAD
  2270 0F52 A9 0F		        LDA     #>R
  2271 0F54 8D E3 02		        STA     INITAD+1
  2272 0F57 60			        RTS
  2273
  2274 				;---------------------------------------
  2275 0F58			LOAD_OPEN:
  2276 				;---------------------------------------
  2277 0F58 48			        PHA                     ; Save data direction passed in A
  2278 0F59 20 60 0D		        JSR     GET_DOSDR       ; Get DUNIT
  2279 0F5C 8E 01 08		        STX     OPNDCB+1        ; Set DUNIT
  2280 0F5F 8E 83 08		        STX     GETDCB+1        ; Set DUNIT FOR READ
  2281 0F62 20 BB 16		        JSR     PREPEND_DRIVE
  2282
  2283 0F65 A5 F3		        LDA     INBUFF          ; Register location of filename
  2284 0F67 8D 04 08		        STA     OPNDCB+4
  2285 0F6A A5 F4		        LDA     INBUFF+1
  2286 0F6C 8D 05 08		        STA     OPNDCB+5
  2287
  2288 0F6F 68			        PLA                     ; A = data direction (4=in, 8=out)
  2289 0F70 8D 0A 08		        STA     OPNDCB+10
  2290 0F73 A9 00		        LDA     #$00            ; AUX2: No translation
  2291 0F75 8D 0B 08		        STA     OPNDCB+11
  2292
  2293 0F78 A9 00		        LDA     #<OPNDCB
  2294 0F7A A0 08		        LDY     #>OPNDCB
  2295 0F7C 20 A5 07		        JSR     DOSIOV
  2296
  2297 0F7F 48			        PHA
  2298 0F80 20 A4 0A		        JSR     PRINT_ERROR
  2299 0F83 68			        PLA
  2300 0F84 A8			        TAY
  2301
  2302 0F85 60			        RTS
  2303
  2304 				;---------------------------------------
  2305 0F86			LOAD_NTRANS:
  2306 				;---------------------------------------
  2307 				    ; Disable any EOL transation otherwise
  2308 				    ; binary data will be corrupted during load
  2309 				    ;---------------------------------------
  2310 0F86 20 60 0D		        JSR     GET_DOSDR       ; Get DUNIT
  2311 0F89 8E 44 12		        STX     NTRDCB+1        ; Set DUNIT
  2312 0F8C A9 00		        LDA     #$00
  2313 0F8E 8D 4E 12		        STA     NTRDCB+11       ; Translation mode (0 = NONE)
  2314 0F91 4C 10 12		        JMP     NTRANS_CALL     ; Reuse code in DO_NTRANS
  2315
  2316 				;---------------------------------------
  2317 0F94			LOAD_READ2:
  2318 				;---------------------------------------
  2319 				    ; Load 2 bytes into Buffer (BAL/H).
  2320 				    ;---------------------------------------
  2321 				    ; This is accomplished by abusing the LOAD_GETDAT
  2322 				    ; routine by stuffing the buffer addr (BAL/H)
  2323 				    ; into the payload Start/End addrs. We're doing
  2324 				    ; this in case a payload  header straddles a
  2325 				    ; cache boundary. LOAD_GETDAT has the logic for
  2326 				    ; dealing with that.
  2327 				    ;---------------------------------------
  2328 0F94 A9 00		        LDA     #<BAL
  2329 0F96 8D 80 19		        STA     STL         ; Payload start address
  2330 0F99 A9 19		        LDA     #>BAL
  2331 0F9B 8D 81 19		        STA     STH
  2332
  2333 0F9E A9 01		        LDA     #<BAH
  2334 0FA0 8D 82 19		        STA     ENL         ; Payload end address
  2335 0FA3 A9 19		        LDA     #>BAH
  2336 0FA5 8D 83 19		        STA     ENH
  2337
  2338 0FA8 A2 02		        LDX     #$02
  2339 0FAA 8E 84 19		        STX     BLL         ; Payload size (2)
  2340 0FAD A9 00		        LDA     #$00
  2341 0FAF 8D 85 19		        STA     BLH
  2342
  2343 0FB2 4C 37 10		        JMP     LOAD_GETDAT ; Read 2 bytes
  2344
  2345 				;---------------------------------------
  2346 0FB5			LOAD_CHKFF:
  2347 				;---------------------------------------
  2348 				    ; On 1st pass, check for binary signature (FF FF)
  2349 				    ; On 2..n passes, Skip FF FF (if found) 
  2350 				    ; and read next 2 bytes
  2351 				    ;---------------------------------------
  2352 				        
  2353 0FB5 A9 FF		        LDA     #$FF
  2354 0FB7 CD 00 19		        CMP     BAL         ; Is 1st byte FF?
  2355 0FBA D0 0D		        BNE     NOTFF       ; If no, skip down.
  2356 0FBC CD 01 19		        CMP     BAH         ; Is 2nd byte FF?
  2357 0FBF D0 08		        BNE     NOTFF       ; If no, skip down.
  2358
  2359 				    ;---------------------------------------
  2360 				    ; Here if FF FF tags found. 
  2361 				    ; On 1st pass, we're done.
  2362 				    ; On 2..n passes, read next 2 bytes and leave.
  2363 				    ;---------------------------------------
  2364 0FC1 CD 90 19		        CMP     BIN_1ST     ; Is this 1st pass?
  2365 0FC4 F0 13		        BEQ     NOTFF_DONE  ; If yes, then we're done here.
  2366 0FC6 4C 94 0F		        JMP     LOAD_READ2  ; 
  2367
  2368 				    ;---------------------------------------
  2369 				    ; Here if FF FF tags NOT found. 
  2370 				    ; On 1st pass, print error.
  2371 				    ; On 2..n passes, the 2 bytes = payload start addr.
  2372 				    ;---------------------------------------
  2373 0FC9 A0 01		NOTFF:  LDY     #$01        ; Preload success return code
  2374 0FCB CD 90 19		        CMP     BIN_1ST     ; A still has FF. BIN_1ST = FF on first pass
  2375 0FCE D0 09		        BNE     NOTFF_DONE  ; Not 1st pass, exit with success.
  2376
  2377 0FD0			NOTFF_ERR:
  2378 0FD0 A9 DA		        LDA     #<LOAD_ERROR_STR2
  2379 0FD2 A0 0F		        LDY     #>LOAD_ERROR_STR2
  2380 0FD4 20 89 0A		        JSR     PRINT_STRING
  2381
  2382 0FD7 A0 FF		        LDY     #$FF        ; Return failure
  2383 0FD9			NOTFF_DONE:
  2384 0FD9 60			        RTS
  2385
  2386 0FDA			LOAD_ERROR_STR2:
  2387 0FDA 4E 4F 54 20 41 20 +         .BYTE   'NOT A BINARY FILE',EOL
  2388
  2389 				;---------------------------------------
  2390 0FEC			LOAD_STRAD:
  2391 				;---------------------------------------
  2392 				    ; Save payload start address into STL2/STLH2.
  2393 				    ; Otherwise it will get clobbered
  2394 				    ; when reading payload end address.
  2395 0FEC AD 00 19		        LDA     RBUF
  2396 0FEF 8D 8E 19		        STA     STL2
  2397 0FF2 AD 01 19		        LDA     RBUF+1
  2398 0FF5 8D 8F 19		        STA     STH2
  2399 0FF8 60			        RTS
  2400
  2401 				;---------------------------------------
  2402 0FF9			LOAD_ENDAD:
  2403 				;---------------------------------------
  2404 				    ; Save payload end address
  2405 0FF9 AD 8E 19		        LDA     STL2
  2406 0FFC 8D 80 19		        STA     STL
  2407 0FFF AD 8F 19		        LDA     STH2
  2408 1002 8D 81 19		        STA     STH
  2409 				    
  2410 1005 AD 00 19		        LDA     RBUF
  2411 1008 8D 82 19		        STA     ENL
  2412 100B AD 01 19		        LDA     RBUF+1
  2413 100E 8D 83 19		        STA     ENH
  2414 1011 60			        RTS
  2415
  2416 				;---------------------------------------
  2417 1012			LOAD_BUFLEN:
  2418 				;---------------------------------------
  2419 				    ; Calculate buffer length (end-start+1)
  2420
  2421 				    ; Calc buffer size Lo
  2422 1012 AD 82 19		        LDA     ENL
  2423 1015 38			        SEC
  2424 1016 ED 80 19		        SBC     STL
  2425 1019 8D 84 19		        STA     BLL     ; Buffer Length Lo
  2426
  2427 				    ; Calc buffer size Hi
  2428 101C AD 83 19		        LDA     ENH     ; Calc buffer size Hi
  2429 101F ED 81 19		        SBC     STH
  2430 1022 8D 85 19		        STA     BLH     ; Buffer Length Hi
  2431
  2432 				    ; Add 1
  2433 1025 18			        CLC
  2434 1026 AD 84 19		        LDA     BLL
  2435 1029 69 01		        ADC     #$01
  2436 102B 8D 84 19		        STA     BLL
  2437
  2438 102E AD 85 19		        LDA     BLH
  2439 1031 69 00		        ADC     #$00    ; Take care of any carry
  2440 1033 8D 85 19		        STA     BLH
  2441
  2442 1036 60			        RTS
  2443
  2444 				;;---------------------------------------
  2445 				;LOAD_GETDAT:
  2446 				;;---------------------------------------
  2447 				;
  2448 				;    ;---------------------------------------
  2449 				;    ; Fill out the DCB
  2450 				;    ;---------------------------------------
  2451 				;        JSR     GET_DOSDR
  2452 				;        STX     BINDCB+1        ; DUNIT
  2453 				;
  2454 				;        LDA     STL
  2455 				;        STA     BINDCB+4        ; DBUFL 
  2456 				;        LDA     STH
  2457 				;        STA     BINDCB+5        ; DBUFH
  2458 				;        LDA     BLL
  2459 				;        STA     BINDCB+8        ; DBYTL
  2460 				;        STA     BINDCB+10
  2461 				;        LDA     BLH
  2462 				;        STA     BINDCB+9        ; DBYTH
  2463 				;        STA     BINDCB+11
  2464 				;
  2465 				;    ;---------------------------------------
  2466 				;    ; Send Read request to SIO
  2467 				;    ;---------------------------------------
  2468 				;        LDA     #<BINDCB
  2469 				;        LDY     #>BINDCB
  2470 				;        JSR     DOSIOV
  2471 				;        JSR     PRINT_ERROR     ; Show any errors
  2472 				;
  2473 				;    ;---------------------------------------
  2474 				;    ; Get status (updates DVSTAT, DSTATS)
  2475 				;    ;---------------------------------------
  2476 				;        LDA     BINDCB+1
  2477 				;        STA     STADCB+1
  2478 				;        LDA     #<STADCB
  2479 				;        LDY     #>STADCB
  2480 				;        JSR     DOSIOV
  2481 				;
  2482 				;    ; Check if EOF (current requested chunk completed?)
  2483 				;        LDA     #EOF
  2484 				;        CMP     DVSTAT+3
  2485 				;        BEQ     LOAD_GETDAT_DONE
  2486 				;        JMP     PRINT_ERROR
  2487 				;
  2488 				;LOAD_GETDAT_DONE:
  2489 				;    ; Check if 0 bytes remaining
  2490 				;        LDA     DVSTAT
  2491 				;        BNE     LOAD_GETDAT_DONE2
  2492 				;        LDA     DVSTAT+1
  2493 				;        BNE     LOAD_GETDAT_DONE2
  2494 				;        LDY     #$FF
  2495 				;        RTS
  2496 				;
  2497 				;LOAD_GETDAT_DONE2:
  2498 				;        LDY     #$01            ; Return success
  2499 				;        RTS
  2500 				;        
  2501 				;BINDCB:
  2502 				;       .BYTE    DEVIDN      ; DDEVIC
  2503 				;       .BYTE    $FF         ; DUNIT
  2504 				;       .BYTE    'R'         ; DCOMND
  2505 				;       .BYTE    $40         ; DSTATS
  2506 				;       .BYTE    $FF         ; DBUFL
  2507 				;       .BYTE    $FF         ; DBUFH
  2508 				;       .BYTE    $0F         ; DTIMLO
  2509 				;       .BYTE    $00         ; DRESVD
  2510 				;       .BYTE    $FF         ; DBYTL
  2511 				;       .BYTE    $FF         ; DBYTH
  2512 				;       .BYTE    $FF         ; DAUX1
  2513 				;       .BYTE    $FF         ; DAUX2
  2514
  2515 				;---------------------------------------
  2516 1037			LOAD_GETDAT:
  2517 				;---------------------------------------
  2518 				    ; Definitions:
  2519 				    ; HEAD = requested bytes that will be found in current cache (< 512 bytes)
  2520 				    ; BODY = contiguous 512 byte sections. BODY = n * 512 bytes)
  2521 				    ; TAIL = any bytes remaining after BODY (< 512 bytes)
  2522
  2523 1037 20 60 0D		        JSR     GET_DOSDR
  2524 103A 8E 5E 11		        STX     BINDCB+1
  2525
  2526 103D 20 39 11		        JSR     GETDAT_CHECK_EOF    ; Check EOF before proceeding
  2527 1040 10 01		        BPL     GETDAT_NEXT1        ; If true, then EOF found. Exit
  2528 1042 60			        RTS
  2529
  2530 				    ; Check if bytes requested BL < DVSTAT (bytes waiting in cache)
  2531 1043			GETDAT_NEXT1:
  2532 1043 AD EA 02		        LDA     DVSTAT
  2533 1046 CD 84 19		        CMP     BLL
  2534 1049 AD EB 02		        LDA     DVSTAT+1
  2535 104C ED 85 19		        SBC     BLH
  2536 104F B0 4C		        BCS     GETDAT_OPT2     ; BL <= BW (bytes waiting)
  2537
  2538 1051			GETDAT_OPT1:
  2539 				    ;--------------------------------
  2540 				    ; Here if bytes requested > bytes 
  2541 				    ; remaining in cache
  2542 				    ;--------------------------------
  2543
  2544 				    ;-------------------------------
  2545 				    ; Head = BW (bytes waiting)
  2546 				    ;-------------------------------
  2547 1051 AD EA 02		        LDA     DVSTAT
  2548 1054 8D 86 19		        STA     HEADL
  2549 1057 AD EB 02		        LDA     DVSTAT+1
  2550 105A 8D 87 19		        STA     HEADH
  2551
  2552 				    ;-------------------------------
  2553 				    ; Tail = (BL - HEAD) mod 512
  2554 				    ;-------------------------------
  2555 105D 38			        SEC
  2556 105E AD 84 19		        LDA     BLL
  2557 1061 ED 86 19		        SBC     HEADL
  2558 1064 29 FF		        AND     #$FF
  2559 1066 8D 8A 19		        STA     TAILL
  2560 1069 AD 85 19		        LDA     BLH
  2561 106C ED 87 19		        SBC     HEADH
  2562 106F 29 01		        AND     #$01
  2563 1071 8D 8B 19		        STA     TAILH
  2564
  2565 				    ;-----------------------------------
  2566 				    ; Body = BL - HEAD - TAIL
  2567 				    ;-----------------------------------
  2568 				        ; 1. Body = BL - HEAD
  2569 				        ;-------------------------------
  2570 1074 38			        SEC
  2571 1075 AD 84 19		        LDA     BLL
  2572 1078 ED 86 19		        SBC     HEADL
  2573 107B 8D 88 19		        STA     BODYL
  2574 107E AD 85 19		        LDA     BLH
  2575 1081 ED 87 19		        SBC     HEADH
  2576 1084 8D 89 19		        STA     BODYH
  2577
  2578 				        ;-------------------------------
  2579 				        ; 2. Body = Body - HEAD
  2580 				        ;-------------------------------
  2581 1087 38			        SEC
  2582 1088 AD 88 19		        LDA     BODYL
  2583 108B ED 8A 19		        SBC     TAILL
  2584 108E 8D 88 19		        STA     BODYL
  2585 1091 AD 89 19		        LDA     BODYH
  2586 1094 ED 8B 19		        SBC     TAILH
  2587 1097 8D 89 19		        STA     BODYH
  2588
  2589 109A 4C B7 10		        JMP     GETDAT_READ
  2590
  2591 109D			GETDAT_OPT2:
  2592 				    ;--------------------------------
  2593 				    ; Here if bytes requested <= bytes 
  2594 				    ; remaining in cache
  2595 				    ;--------------------------------
  2596 				    ; Head = BL, TAIL = BODY = 0
  2597 				    ;--------------------------------
  2598 109D AD 84 19		        LDA     BLL
  2599 10A0 8D 86 19		        STA     HEADL
  2600 10A3 AD 85 19		        LDA     BLH
  2601 10A6 8D 87 19		        STA     HEADH
  2602 10A9 A9 00		        LDA     #$00
  2603 10AB 8D 8A 19		        STA     TAILL
  2604 10AE 8D 8B 19		        STA     TAILH
  2605 10B1 8D 88 19		        STA     BODYL
  2606 10B4 8D 89 19		        STA     BODYH
  2607
  2608 				;---------------------------------------
  2609 10B7			GETDAT_READ:
  2610 				;---------------------------------------
  2611 				    ;---------------------------------------
  2612 				    ; Read HEAD bytes
  2613 				    ;---------------------------------------
  2614 10B7 AD 86 19		        LDA     HEADL
  2615 10BA 8D 84 19		        STA     BLL
  2616 10BD AD 87 19		        LDA     HEADH
  2617 10C0 8D 85 19		        STA     BLH
  2618 10C3 20 F4 10		        JSR     GETDAT_DOSIOV
  2619 10C6 10 01		        BPL     GETDAT_BODY ; Skip ahead if no problems
  2620 10C8 60			        RTS                 ; Bail if error
  2621
  2622 				    ;---------------------------------------
  2623 				    ; Read BODY bytes
  2624 				    ;---------------------------------------
  2625 10C9			GETDAT_BODY:
  2626 10C9 AE 89 19		        LDX     BODYH
  2627 10CC			GETDAT_BODY_LOOP:
  2628 10CC F0 1A		        BEQ     GETDAT_TAIL ; Skip if less than a page to read
  2629
  2630 10CE A9 00		        LDA     #$00
  2631 10D0 8D 84 19		        STA     BLL         ; Buffer length
  2632 10D3 A9 02		        LDA     #$02        ; 512 bytes at a time
  2633 10D5 8D 85 19		        STA     BLH
  2634
  2635 10D8 8A			        TXA                 ; Stash our loop index (X)
  2636 10D9 48			        PHA                 ; onto the stack
  2637 10DA 20 F4 10		        JSR     GETDAT_DOSIOV   
  2638 10DD 10 03		        BPL     @+          ; Skip ahead if no problems
  2639 10DF 68			        PLA                 ; Here if problem. Clean up stack
  2640 10E0 98			        TYA                 ; Reset N status flag before returning
  2641 10E1 60			        RTS                 ; Bail if error
  2642
  2643 10E2 68			@:      PLA                 ; Retrieve our loop index
  2644 10E3 AA			        TAX                 ; and xfer it back into X
  2645 10E4 CA			        DEX                 ; -2 (we pull 0200 bytes at a time)
  2646 10E5 CA			        DEX                 ; 
  2647 10E6 D0 E4		        BNE     GETDAT_BODY_LOOP
  2648
  2649 10E8			GETDAT_TAIL:
  2650 				    ;---------------------------------------
  2651 				    ; Read TAIL bytes
  2652 				    ;---------------------------------------
  2653 10E8 AD 8A 19		        LDA     TAILL
  2654 10EB 8D 84 19		        STA     BLL
  2655 10EE AD 8B 19		        LDA     TAILH
  2656 10F1 8D 85 19		        STA     BLH
  2657
  2658 				;---------------------------------------
  2659 10F4			GETDAT_DOSIOV:
  2660 				;---------------------------------------
  2661 				    ; Bail if BL = 0
  2662 10F4 AD 84 19		        LDA     BLL
  2663 10F7 D0 05		        BNE     @+
  2664 10F9 AD 85 19		        LDA     BLH
  2665 10FC F0 5C		        BEQ     CHECK_EOF_DONE
  2666
  2667 				@:
  2668 				    ; SIO READ
  2669 10FE AD 80 19		        LDA     STL
  2670 1101 8D 61 11		        STA     BINDCB+4    ; Start Address Lo
  2671 1104 AD 81 19		        LDA     STH
  2672 1107 8D 62 11		        STA     BINDCB+5    ; Start Address Hi
  2673 110A AD 84 19		        LDA     BLL
  2674 110D 8D 65 11		        STA     BINDCB+8    ; Buffer Size Lo
  2675 1110 8D 67 11		        STA     BINDCB+10
  2676 1113 AD 85 19		        LDA     BLH
  2677 1116 8D 66 11		        STA     BINDCB+9    ; Buffer Size Hi
  2678 1119 8D 68 11		        STA     BINDCB+11
  2679
  2680 				    ;---------------------------------------
  2681 				    ; Send Read request to SIO
  2682 				    ;---------------------------------------
  2683 111C A9 5D		        LDA     #<BINDCB
  2684 111E A0 11		        LDY     #>BINDCB
  2685 1120 20 A5 07		        JSR     DOSIOV
  2686 1123 20 A4 0A		        JSR     PRINT_ERROR
  2687
  2688 				    ;---------------------------------------
  2689 				    ; Advance start address by buffer length
  2690 				    ;---------------------------------------
  2691 1126 18			        CLC
  2692 1127 AD 80 19		        LDA     STL
  2693 112A 6D 84 19		        ADC     BLL
  2694 112D 8D 80 19		        STA     STL
  2695
  2696 1130 AD 81 19		        LDA     STH
  2697 1133 6D 85 19		        ADC     BLH
  2698 1136 8D 81 19		        STA     STH
  2699
  2700 1139			GETDAT_CHECK_EOF:
  2701 				    ; Get status (updates DVSTAT, DSTATS)
  2702 1139 AD 5E 11		        LDA     BINDCB+1
  2703 113C 8D 49 09		        STA     STADCB+1
  2704 113F A9 48		        LDA     #<STADCB
  2705 1141 A0 09		        LDY     #>STADCB
  2706 1143 20 A5 07		        JSR     DOSIOV
  2707
  2708 				    ; Return -1 if DVSTAT == $0000 and DVSTAT+3 == EOF
  2709 1146 AD EA 02		        LDA     DVSTAT
  2710 1149 D0 0F		        BNE     CHECK_EOF_DONE
  2711
  2712 114B AD EB 02		        LDA     DVSTAT+1
  2713 114E D0 0A		        BNE     CHECK_EOF_DONE
  2714
  2715 1150 A9 88		        LDA     #EOF
  2716 1152 CD ED 02		        CMP     DVSTAT+3        ; Is it EOF
  2717 1155 D0 03		        BNE     CHECK_EOF_DONE  ; No? Go to success
  2718 1157 A0 FF		        LDY     #$FF            ; Yes? Return -1
  2719 1159 60			        RTS
  2720
  2721 115A			CHECK_EOF_DONE:
  2722 115A A0 01		        LDY     #$01        ; Return success
  2723 115C 60			        RTS
  2724
  2725 115D			BINDCB:
  2726 115D 71			       .BYTE    DEVIDN      ; DDEVIC
  2727 115E FF			       .BYTE    $FF         ; DUNIT
  2728 115F 52			       .BYTE    'R'         ; DCOMND
  2729 1160 40			       .BYTE    $40         ; DSTATS
  2730 1161 FF			       .BYTE    $FF         ; DBUFL
  2731 1162 FF			       .BYTE    $FF         ; DBUFH
  2732 1163 0F			       .BYTE    $0F         ; DTIMLO
  2733 1164 00			       .BYTE    $00         ; DRESVD
  2734 1165 FF			       .BYTE    $FF         ; DBYTL
  2735 1166 FF			       .BYTE    $FF         ; DBYTH
  2736 1167 FF			       .BYTE    $FF         ; DAUX1
  2737 1168 FF			       .BYTE    $FF         ; DAUX2
  2738
  2739
  2740 				;---------------------------------------
  2741 1169			LOAD_CLOSE:
  2742 				;---------------------------------------
  2743 1169 AD 5E 11		        LDA     BINDCB+1
  2744 116C 8D 22 08		        STA     CLODCB+1
  2745 116F A9 21		        LDA     #<CLODCB
  2746 1171 A0 08		        LDY     #>CLODCB
  2747 1173 4C A5 07		        JMP     DOSIOV
  2748
  2749 				;---------------------------------------
  2750 1176			LOAD_ERROR:
  2751 				;---------------------------------------
  2752 1176 A9 89		        LDA     #<MISSING_FILE_STR
  2753 1178 A0 18		        LDY     #>MISSING_FILE_STR
  2754 117A 4C 89 0A		        JMP     PRINT_STRING
  2755
  2756 				;---------------------------------------
  2757 117D			DO_LOCK:
  2758 				;---------------------------------------
  2759 117D A9 60		        LDA     #$60
  2760 117F 8D C6 02		        STA     COLOR2
  2761 1182 60			        RTS
  2762
  2763
  2764 				;---------------------------------------
  2765 1183			DO_LPR:
  2766 				;---------------------------------------
  2767 1183 A9 B0		        LDA     #$B0
  2768 1185 8D C6 02		        STA     COLOR2
  2769 1188 60			        RTS
  2770
  2771 				;---------------------------------------
  2772 1189			DO_NPWD:
  2773 				;---------------------------------------
  2774 1189 A9 9B		        LDA     #EOL        ; Truncate buffer
  2775 118B 8D 00 19		        STA     RBUF
  2776
  2777 118E 20 60 0D		        JSR     GET_DOSDR   ; X will contain n in Nn:
  2778 1191 8E C1 11		        STX     PWDDCB+1
  2779
  2780 1194 A9 C0		        LDA     #<PWDDCB
  2781 1196 A0 11		        LDY     #>PWDDCB
  2782 1198 20 A5 07		        JSR     DOSIOV
  2783 119B 20 A4 0A		        JSR     PRINT_ERROR
  2784
  2785 				    ;---------------------------------------
  2786 				    ; If we entered DO_NPWD from REMOUNT_DRIVE
  2787 				    ; then skip printing output
  2788 				    ;---------------------------------------
  2789 119E AD 91 18		        LDA     CMDPRV
  2790 11A1 C9 02		        CMP     #CMD_IDX.DEL
  2791 11A3 F0 1A		        BEQ     NPWD_DONE
  2792 11A5 C9 0A		        CMP     #CMD_IDX.RENAME
  2793 11A7 F0 16		        BEQ     NPWD_DONE
  2794
  2795 11A9			NPWD_LOOP:
  2796 11A9 A9 00		        LDA     #<RBUF
  2797 11AB A0 19		        LDY     #>RBUF
  2798 11AD 20 89 0A		        JSR     PRINT_STRING
  2799
  2800 11B0 A9 48		        LDA     #<STADCB
  2801 11B2 A0 09		        LDY     #>STADCB
  2802 11B4 20 A5 07		        JSR     DOSIOV
  2803 11B7 20 A4 0A		        JSR     PRINT_ERROR
  2804
  2805 				    ;---------------------------------------
  2806 				    ; Loop if more data to read
  2807 				    ;---------------------------------------
  2808 11BA AD EB 02		        LDA     DVSTAT+1    ; Was there more to read (that is, was hi>0)?
  2809 11BD D0 EA		        BNE     NPWD_LOOP   ; If yes, then do it again
  2810
  2811 11BF			NPWD_DONE:
  2812 11BF 60			        RTS
  2813
  2814 11C0			PWDDCB:
  2815 11C0 71			        .BYTE   DEVIDN      ; DDEVIC
  2816 11C1 FF			        .BYTE   $FF         ; DUNIT
  2817 11C2 30			        .BYTE   $30         ; DCOMND
  2818 11C3 40			        .BYTE   $40         ; DSTATS
  2819 11C4 00			        .BYTE   <RBUF       ; DBUFL
  2820 11C5 19			        .BYTE   >RBUF       ; DBUFH
  2821 11C6 1F			        .BYTE   $1F         ; DTIMLO
  2822 11C7 00			        .BYTE   $00         ; DRESVD
  2823 11C8 00			        .BYTE   $00         ; DBYTL
  2824 11C9 01			        .BYTE   $01         ; DBYTH
  2825 11CA 00			        .BYTE   $00         ; DAUX1
  2826 11CB 00			        .BYTE   $00         ; DAUX2
  2827
  2828 				; End of DO_NPWD
  2829 				;---------------------------------------
  2830
  2831 				;---------------------------------------
  2832 11CC			DO_NTRANS:
  2833 				;---------------------------------------
  2834 11CC AE 75 0C		        LDX     CMDSEP          ; Check if there's any args
  2835 11CF F0 49		        BEQ     NTRANS_ERROR    ; No. Show usage and quit
  2836
  2837 11D1 AD 8F 18		        LDA     DOSDR           ; Go with current drive for now
  2838 11D4 8D 44 12		        STA     NTRDCB+1        ; it'll be overwritten later if req'd
  2839
  2840 				    ;---------------------------------------
  2841 				    ; Check for argc = 2
  2842 				    ;---------------------------------------
  2843 11D7 AC 75 0C		        LDY     CMDSEP          ; Stash offset to arg1 in Y
  2844 11DA AE 76 0C		        LDX     CMDSEP+1        ; Is there an arg2?
  2845 11DD F0 21		        BEQ     PARSE_MODE      ; No. parse arg1 as mode (0-3)
  2846
  2847 				    ;---------------------------------------
  2848 				    ; Here if argc = 2 (arg1 = Nn: arg2 = mode)
  2849 				    ;---------------------------------------
  2850 11DF AE 75 0C		        LDX     CMDSEP          ; Get offset to arg1 (Nn:)
  2851 11E2 BD 82 05		        LDA     LNBUF,X         ; Is arg1's (N[n]:) 1st char = 'N'?
  2852 11E5 C9 4E		        CMP     #'N'            ;
  2853 11E7 D0 31		        BNE     NTRANS_ERROR    ; No? Then quit
  2854 11E9 BD 83 05		        LDA     LNBUF+1,X
  2855 11EC C9 3A		        CMP     #':'            ; Is arg1's (N[n]:) 2nd char = ':'?
  2856 11EE F0 10		        BEQ     PARSE_MODE      ; Yes, stick with default drive
  2857
  2858 				    ;---------------------------------------
  2859 				    ; Parse drive number
  2860 				    ;---------------------------------------
  2861 11F0 C9 31		        CMP     #'1'            ; Quit if n in Nn not 1..4
  2862 11F2 90 26		        BCC     NTRANS_ERROR    ; Quit if < '1'
  2863 11F4 C9 39		        CMP     #'9'
  2864 11F6 B0 22		        BCS     NTRANS_ERROR    ; Quit if >= '9'
  2865 11F8 49 30		        EOR     #%00110000
  2866 11FA 8D 44 12		        STA     NTRDCB+1
  2867 11FD AC 76 0C		        LDY     CMDSEP+1
  2868
  2869 				    ;---------------------------------------
  2870 				    ; Confirm valid parameter
  2871 				    ;---------------------------------------
  2872 1200			PARSE_MODE:
  2873 1200 B9 82 05		        LDA     LNBUF,Y         ; Quit if mode not 0..3
  2874 1203 C9 30		        CMP     #'0'
  2875 1205 90 13		        BCC     NTRANS_ERROR
  2876 1207 C9 34		        CMP     #'4'
  2877 1209 B0 0F		        BCS     NTRANS_ERROR
  2878 120B 49 30		        EOR     #%00110000      ; Here if valid parameter
  2879 120D 8D 4E 12		        STA     NTRDCB+11       ; Assign parameter to DCB
  2880
  2881 				    ;---------------------------------------
  2882 				    ; Call SIO
  2883 				    ;---------------------------------------
  2884 1210			NTRANS_CALL:
  2885 1210 A9 43		        LDA     #<NTRDCB
  2886 1212 A0 12		        LDY     #>NTRDCB
  2887 1214 20 A5 07		        JSR     DOSIOV
  2888 1217 4C A4 0A		        JMP     PRINT_ERROR
  2889
  2890 121A			NTRANS_ERROR:
  2891 121A A9 21		        LDA     #<NTRANS_ERROR_STR
  2892 121C A0 12		        LDY     #>NTRANS_ERROR_STR
  2893 121E 4C 89 0A		        JMP     PRINT_STRING
  2894
  2895 1221			NTRANS_ERROR_STR:
  2896 1221 4D 4F 44 45 3F 20 +         .BYTE   'MODE? 0=NONE, 1=CR, 2=LF, 3=CR/LF',EOL
  2897
  2898 1243			NTRDCB:
  2899 1243 71			        .BYTE   DEVIDN  ; DDEVIC
  2900 1244 FF			        .BYTE   $FF     ; DUNIT
  2901 1245 54			        .BYTE   'T'     ; DCOMND
  2902 1246 00			        .BYTE   $00     ; DSTATS
  2903 1247 00			        .BYTE   $00     ; DBUFL
  2904 1248 00			        .BYTE   $00     ; DBUFH
  2905 1249 1F			        .BYTE   $1F     ; DTIMLO
  2906 124A 00			        .BYTE   $00     ; DRESVD
  2907 124B 00			        .BYTE   $00     ; DBYTL
  2908 124C 00			        .BYTE   $00     ; DBYTH
  2909 124D 00			        .BYTE   $00     ; DAUX1
  2910 124E 00			        .BYTE   $00     ; DAUX2
  2911
  2912 				; End of DO_NTRANS
  2913 				;---------------------------------------
  2914
  2915 				;---------------------------------------
  2916 124F			DO_AUTORUN:
  2917 				;---------------------------------------
  2918 				    ; Change URL stored in AUTORUN app key
  2919 				    ;-----------------------------------
  2920 124F AD 75 0C		        LDA     CMDSEP          ; Check if there's any arg
  2921 1252 D0 07		        BNE     AUTORUN_NEXT1   ; If arg found, skip ahead
  2922
  2923 				    ; Here if no command line arg found
  2924 				    ; Print error message and exit
  2925 1254 A9 9C		        LDA     #<AUTORUN_ERROR_STR
  2926 1256 A0 12		        LDY     #>AUTORUN_ERROR_STR
  2927 1258 4C 89 0A		        JMP     PRINT_STRING
  2928
  2929 125B			AUTORUN_NEXT1:
  2930 				    ; Point to start of arg on command line
  2931 125B 18			        CLC
  2932 125C 65 F3		        ADC     INBUFF          ; INBUFF += CMDSEP
  2933 125E 85 F3		        STA     INBUFF
  2934 1260 8D D0 12		        STA     APPKEYWRITEDCB+4
  2935
  2936 				    ; If "AUTORUN ?" Then abuse AUTORUN_SUBMIT to print appkey
  2937 1263 A0 00		        LDY     #$00
  2938 1265 A9 3F		        LDA     #'?'
  2939 1267 8D 91 19		        STA     AUTORUN_QUERY_FLG
  2940 126A D1 F3		        CMP     (INBUFF),Y
  2941 126C F0 6A		        BEQ     SUBMIT_AUTORUN
  2942
  2943 				    ; Open app key
  2944 126E A9 01		        LDA     #$01            ; Open for write (1)
  2945 1270 8D 91 19		        STA     AUTORUN_QUERY_FLG
  2946 1273 8D A6 12		        STA     AUTORUN_APPKEY+4
  2947 1276 A9 B4		        LDA     #<APPKEYOPENDCB
  2948 1278 A0 12		        LDY     #>APPKEYOPENDCB
  2949 127A 20 A5 07		        JSR     DOSIOV
  2950
  2951 				    ; Find length of URL (arg1)
  2952 127D A0 FF		        LDY     #$FF            ; Init strlen
  2953 127F			AUTORUN_LOOP1
  2954 127F C8			        INY                     ; Incr strlen
  2955 1280 B1 F3		        LDA     (INBUFF),Y
  2956 1282 C9 9B		        CMP     #EOL            ; At end of string?
  2957 1284 D0 F9		        BNE     AUTORUN_LOOP1   ; No. Keep counting
  2958
  2959 1286 A9 0A		        LDA     #LF             ; Convert EOL to LF
  2960 1288 91 F3		        STA     (INBUFF),Y
  2961 128A C8			        INY                     ; One more for strlen
  2962
  2963 128B			AUTORUN_NEXT2: 
  2964 				    ; Write app key
  2965 128B 8C D6 12		        STY     APPKEYWRITEDCB+10   ; Y = strlen
  2966 128E A9 CC		        LDA     #<APPKEYWRITEDCB
  2967 1290 A0 12		        LDY     #>APPKEYWRITEDCB
  2968 1292 20 A5 07		        JSR     DOSIOV
  2969
  2970 				    ; Close app key
  2971 1295 A9 A8		        LDA     #<APPKEYCLOSEDCB
  2972 1297 A0 12		        LDY     #>APPKEYCLOSEDCB
  2973 1299 4C A5 07		        JMP     DOSIOV
  2974
  2975 129C			AUTORUN_ERROR_STR:
  2976 129C 50 41 54 48 3F 9B	        .BYTE   'PATH?',EOL
  2977
  2978 12A2			AUTORUN_APPKEY:
  2979 12A2 79 DB		        .WORD   $DB79           ; creator ID
  2980 12A4 00			        .BYTE   $00             ; app ID
  2981 12A5 00			        .BYTE   $00             ; key ID
  2982 12A6 00			        .BYTE   $00             ; read or write mode
  2983 12A7 00			        .BYTE   $00             ; unused
  2984
  2985 12A8			APPKEYCLOSEDCB:
  2986 12A8 70			        .BYTE   $70             ; DDEVIC
  2987 12A9 01			        .BYTE   $01             ; DUNIT
  2988 12AA DB			        .BYTE   $DB             ; DCOMND
  2989 12AB 00			        .BYTE   $00             ; DSTATS
  2990 12AC 00			        .BYTE   $00             ; DBUFL
  2991 12AD 00			        .BYTE   $00             ; DBUFH
  2992 12AE 0F			        .BYTE   $0F             ; DTIMLO
  2993 12AF 00			        .BYTE   $00             ; DRESVD
  2994 12B0 00			        .BYTE   $00             ; DBYTL
  2995 12B1 00			        .BYTE   $00             ; DBYTH
  2996 12B2 00			        .BYTE   $00             ; DAUX1
  2997 12B3 00			        .BYTE   $00             ; DAUX2
  2998
  2999 12B4			APPKEYOPENDCB:
  3000 12B4 70			        .BYTE   $70             ; DDEVIC
  3001 12B5 01			        .BYTE   $01             ; DUNIT
  3002 12B6 DC			        .BYTE   $DC             ; DCOMND
  3003 12B7 80			        .BYTE   $80             ; DSTATS
  3004 12B8 A2			        .BYTE   <AUTORUN_APPKEY ; DBUFL
  3005 12B9 12			        .BYTE   >AUTORUN_APPKEY ; DBUFH
  3006 12BA 0F			        .BYTE   $0F             ; DTIMLO
  3007 12BB 00			        .BYTE   $00             ; DRESVD
  3008 12BC 06			        .BYTE   $06             ; DBYTL
  3009 12BD 00			        .BYTE   $00             ; DBYTH
  3010 12BE 00			        .BYTE   $00             ; DAUX1
  3011 12BF 00			        .BYTE   $00             ; DAUX2
  3012
  3013 12C0			APPKEYREADDCB:
  3014 12C0 70			        .BYTE   $70             ; DDEVIC
  3015 12C1 01			        .BYTE   $01             ; DUNIT
  3016 12C2 DD			        .BYTE   $DD             ; DCOMND
  3017 12C3 40			        .BYTE   $40             ; DSTATS
  3018 12C4 82			        .BYTE   <LNBUF          ; DBUFL
  3019 12C5 05			        .BYTE   >LNBUF          ; DBUFH
  3020 12C6 01			        .BYTE   $01             ; DTIMLO - minimize timeout
  3021 12C7 00			        .BYTE   $00             ; DRESVD
  3022 12C8 40			        .BYTE   MAX_APPKEY_LEN  ; DBYTL
  3023 12C9 00			        .BYTE   $00             ; DBYTH
  3024 12CA 00			        .BYTE   $00             ; DAUX1
  3025 12CB 00			        .BYTE   $00             ; DAUX2
  3026
  3027 12CC			APPKEYWRITEDCB:
  3028 12CC 70			        .BYTE   $70             ; DDEVIC
  3029 12CD 01			        .BYTE   $01             ; DUNIT
  3030 12CE DE			        .BYTE   $DE             ; DCOMND
  3031 12CF 80			        .BYTE   $80             ; DSTATS
  3032 12D0 FF			        .BYTE   $FF             ; DBUFL
  3033 12D1 05			        .BYTE   $05             ; DBUFH (expect page 5)
  3034 12D2 0F			        .BYTE   $0F             ; DTIMLO
  3035 12D3 00			        .BYTE   $00             ; DRESVD
  3036 12D4 40			        .BYTE   MAX_APPKEY_LEN  ; DBYTL
  3037 12D5 00			        .BYTE   $00             ; DBYTH
  3038 12D6 FF			        .BYTE   $FF             ; DAUX1 (# actual bytes)
  3039 12D7 00			        .BYTE   $00             ; DAUX2
  3040
  3041 				;---------------------------------------
  3042 12D8			SUBMIT_AUTORUN:
  3043 				;---------------------------------------
  3044 				    ; At initial DOS boot, read URL for 
  3045 				    ; app key file from SD card's
  3046 				    ; FujiNet folder.
  3047 				    ;
  3048 				    ; filename: db790000.key
  3049 				    ; contents: url to a batch file
  3050 				    ;---------------------------------------
  3051 12D8 20 72 0A		        JSR     LDBUFA
  3052
  3053 				    ; Open app key
  3054 12DB A9 00		        LDA     #$00            ; Open for read
  3055 12DD 8D A6 12		        STA     AUTORUN_APPKEY+4
  3056 12E0 A9 B4		        LDA     #<APPKEYOPENDCB
  3057 12E2 A0 12		        LDY     #>APPKEYOPENDCB
  3058 12E4 20 A5 07		        JSR     DOSIOV
  3059
  3060 12E7 C0 01		        CPY     #$01            ; Was open successful?
  3061 12E9 F0 01		        BEQ     AUTOSUB_NEXT    ; Yes. Continue.
  3062 12EB 60			        RTS                     ; No. Exit
  3063
  3064 12EC			AUTOSUB_NEXT:
  3065 				    ; Read app key
  3066 12EC A9 C0		        LDA     #<APPKEYREADDCB
  3067 12EE A0 12		        LDY     #>APPKEYREADDCB
  3068 12F0 20 A5 07		        JSR     DOSIOV
  3069
  3070 				    ; Close app key
  3071 12F3 A9 A8		        LDA     #<APPKEYCLOSEDCB
  3072 12F5 A0 12		        LDY     #>APPKEYCLOSEDCB
  3073 12F7 20 A5 07		        JSR     DOSIOV
  3074
  3075 				    ; Does the returned URL contain something?
  3076 12FA AE 82 05		        LDX     LNBUF           ; X contains strlen of AUTORUN path
  3077 12FD D0 01		        BNE     AUTORUN_CALL_SUBMIT
  3078
  3079
  3080 12FF			AUTOSUB_DONE:
  3081 12FF 60			        RTS
  3082
  3083 1300			AUTORUN_CALL_SUBMIT:
  3084 				    ; Replace end-of-line in buffer with null terminator
  3085 1300 CA			        DEX                     ; Move index back 1 position
  3086 1301 A9 00		        LDA     #$00            ;
  3087 1303 9D 84 05		        STA     LNBUF+2,X       ; Write null-terminator 
  3088 1306 A9 02		        LDA     #$02            ; Change arg1 location...
  3089 1308 8D 75 0C		        STA     CMDSEP          ;  to point to filename
  3090
  3091 				    ;---------------------------------------
  3092 				    ; If here because of "AUTORUN ?", then
  3093 				    ; print contents of appkey file. But first
  3094 				    ; we have to terminate appkey string with EOL
  3095 				    ;---------------------------------------
  3096 130B AD 91 19		        LDA     AUTORUN_QUERY_FLG
  3097 130E C9 3F		        CMP     #'?'
  3098 1310 D0 18		        BNE     SUBMIT_NEXT1
  3099
  3100 1312 A9 9B		        LDA     #EOL            ; Inject EOL to terminate string
  3101 1314 9D 84 05		        STA     LNBUF+2,X
  3102 1317 A9 84		        LDA     #<(LNBUF+2)
  3103 1319 A0 05		        LDY     #>(LNBUF+2)
  3104 131B 4C 89 0A		        JMP     PRINT_STRING    ; Print AUTORUN path and sneak out
  3105
  3106 				;---------------------------------------
  3107 131E			DO_SUBMIT:
  3108 				;---------------------------------------
  3109 131E AD 75 0C		        LDA     CMDSEP
  3110 1321 D0 07		        BNE     SUBMIT_NEXT1
  3111
  3112 				    ; Filename required
  3113 1323 A9 89		        LDA     #<MISSING_FILE_STR
  3114 1325 A0 18		        LDY     #>MISSING_FILE_STR
  3115 1327 4C 89 0A		        JMP     PRINT_STRING
  3116
  3117 132A			SUBMIT_NEXT1:
  3118
  3119 				    ; Default to NOSCREEN
  3120 132A A9 00		        LDA     #$00
  3121 132C 8D 92 18		        STA     ECHO_FLG
  3122
  3123 				    ; Prep file path
  3124 132F 20 60 0D		        JSR     GET_DOSDR       ; Get DUNIT
  3125 1332 20 BB 16		        JSR     PREPEND_DRIVE
  3126
  3127 				    ; Assert FILE #1 is closed
  3128 1335 A2 10		        LDX     #$10
  3129 1337 20 BB 09		        JSR     CIOCLOSE
  3130 				        
  3131 				    ; OPEN #1, 4, 0, file path
  3132 133A A2 10		        LDX     #$10            ; File #1
  3133 133C A0 04		        LDY     #$04            ; Open for input
  3134 133E 20 C3 09		        JSR     CIOOPEN         ; Open filename @ (INBUFF)
  3135 1341 10 03		        BPL     SUBMIT_NEXT2
  3136 1343 4C A4 0A		        JMP     PRINT_ERROR
  3137
  3138 				    ; Read batch file character by character
  3139 				    ; This allows it be end-of-line agnostic
  3140 				    ; Branch forward when an end-of-line is interpretted.
  3141
  3142 1346			SUBMIT_NEXT2:
  3143 1346 20 72 0A		        JSR     LDBUFA      ; Reset INBUFF to $0580
  3144 1349 C6 F3		        DEC     INBUFF      ; Init 1 byte before buffer
  3145 134B A9 FF		        LDA     #$FF        ; Clear command
  3146 134D 8D 90 18		        STA     CMD
  3147
  3148 1350			SUBMIT_GETCH:
  3149 1350 E6 F3		        INC     INBUFF          ; Advance pointer
  3150 1352 D0 02		        BNE     SUBMIT_NEXT3
  3151 1354 E6 F4		        INC     INBUFF+1
  3152
  3153 1356			SUBMIT_NEXT3:
  3154 1356 A2 10		        LDX     #$10            ; OPEN #1
  3155 1358 A9 01		        LDA     #$01            ; Get 1 byte
  3156 135A A0 00		        LDY     #$00            ; ditto
  3157
  3158 135C 20 F0 09		        JSR     CIOGET          ; Get byte from file
  3159 135F A0 00		        LDY     #$00            ;
  3160 1361 B1 F3		        LDA     (INBUFF),Y      ; byte will be here
  3161 				        
  3162 1363 C9 0D		        CMP     #CR             ; Just skip if Windows CR
  3163 1365 F0 E9		        BEQ     SUBMIT_GETCH
  3164
  3165 1367 C9 0A		        CMP     #LF             ; Convert LF to EOL
  3166 1369 D0 04		        BNE     SUBMIT_EOL
  3167 136B A9 9B		        LDA     #EOL
  3168 136D 91 F3		        STA     (INBUFF),Y
  3169
  3170 136F			SUBMIT_EOL:
  3171 136F C9 9B		        CMP     #EOL            ; At end of command line?
  3172 1371 D0 DD		        BNE     SUBMIT_GETCH    ; No. Get next byte.
  3173
  3174 				    ; Here if we've reached the end of a command line.
  3175 				    ; At end of file?
  3176 1373 A2 10		        LDX     #$10            ; Channel #1
  3177 1375 BD 43 03		        LDA     ICSTA,X         ; Inspect return code
  3178 1378 C9 88		        CMP     #EOF
  3179 137A F0 22		        BEQ     SUBMIT_DONE     ; No error, try parsing cmd
  3180
  3181 137C AD 92 18		        LDA     ECHO_FLG        ; Skip echo if SCREEN is disabled
  3182 137F F0 11		        BEQ     SUBMIT_NEXT4
  3183 1381 AD 82 05		        LDA     LNBUF
  3184 1384 C9 40		        CMP     #'@'            ; Skip lines beginning with @
  3185 1386 F0 0A		        BEQ     SUBMIT_NEXT4
  3186
  3187 				    ; Echo commands
  3188 1388 20 72 0A		        JSR     LDBUFA
  3189 138B A5 F3		        LDA     INBUFF
  3190 138D A4 F4		        LDY     INBUFF+1
  3191 138F 20 89 0A		        JSR     PRINT_STRING
  3192
  3193 1392			SUBMIT_NEXT4:
  3194 1392 20 23 0C		        JSR     GETCMDTEST
  3195 1395 20 7B 0C		        JSR     PARSECMD
  3196 1398 20 2E 0D		        JSR     DOCMD
  3197 139B 38			        SEC
  3198 139C B0 A8		        BCS     SUBMIT_NEXT2
  3199
  3200 139E			SUBMIT_DONE
  3201 139E A2 10		        LDX     #$10
  3202 13A0 4C BB 09		        JMP     CIOCLOSE
  3203
  3204 				; End of DO_SUBMIT
  3205 				;---------------------------------------
  3206
  3207 				; Open Nn: for read
  3208 				; Open E: or P: for write
  3209 				; Read byte
  3210 				; Write byte
  3211
  3212 				;---------------------------------------
  3213 13A3			DO_TYPE:
  3214 				;---------------------------------------
  3215 13A3 AD 75 0C		        LDA     CMDSEP
  3216 13A6 D0 07		        BNE     TYPE_SKIP
  3217
  3218 13A8			TYPE_USAGE:
  3219 13A8 A9 89		        LDA     #<MISSING_FILE_STR
  3220 13AA A0 18		        LDY     #>MISSING_FILE_STR
  3221 13AC 4C 89 0A		        JMP     PRINT_STRING
  3222
  3223 13AF			TYPE_SKIP:
  3224 13AF 20 60 0D		        JSR     GET_DOSDR       ; Get DUNIT
  3225 13B2 20 BB 16		        JSR     PREPEND_DRIVE
  3226
  3227 				    ; Assert input file closed
  3228 13B5 A2 10		        LDX     #$10            ; File #1
  3229 13B7 20 BB 09		        JSR     CIOCLOSE        ; Assert file #1 is closed
  3230
  3231 				    ; Open input file
  3232 13BA A9 FF		        LDA     #$FF
  3233 13BC 8D FC 02		        STA     CH
  3234 13BF A2 10		        LDX     #$10            ; File #1
  3235 13C1 A0 04		        LDY     #$04            ; Open for input
  3236 13C3 20 C3 09		        JSR     CIOOPEN         ; Open filename @ (INBUFF)
  3237 13C6 10 08		        BPL     TYPE_NEXT
  3238
  3239 				    ; If open failed, Print error
  3240 13C8 A2 10		        LDX     #$10            ; File #1
  3241 13CA BC 43 03		        LDY     ICSTA,X
  3242 13CD 4C A4 0A		        JMP     PRINT_ERROR
  3243
  3244 13D0			TYPE_NEXT:
  3245
  3246 				    ; Initialize pagination
  3247 13D0 EE AA 18		    INC PRINT_ERR_FLG         ; Are we here from PRINT_ERROR (CMD will now be $00)
  3248 13D3 F0 2A		    BEQ TYPE_READ
  3249 13D5 20 78 14		        JSR     DO_CLS
  3250 13D8 A9 15		        LDA     #21
  3251 13DA 8D BB 02		        STA     SCRFLG
  3252
  3253 13DD			TYPE_LOOP:
  3254 				    ; Bail if ESC key is pressed
  3255 13DD AD FC 02		        LDA     CH
  3256 13E0 C9 1C		        CMP     #ESC_KEY
  3257 13E2 F0 49		        BEQ     TYPE_DONE
  3258
  3259 				    ; Check if page is full
  3260 13E4 AD BB 02		        LDA     SCRFLG
  3261 13E7 C9 16		        CMP     #22             ; if SCRFLG < 21
  3262 13E9 90 14		        BCC     TYPE_READ       ; then skip to read
  3263
  3264 				    ; Here if page is full
  3265 				    ; Wait for keypress
  3266 13EB A9 FF		        LDA     #$FF            ; Clear keypress
  3267 13ED 8D FC 02		        STA     CH
  3268
  3269 13F0			TYPE_WAIT:
  3270 13F0 AE FC 02		        LDX     CH              ; Will be $FF if no keypress
  3271 13F3 E8			        INX                     ; $FF --> $00
  3272 13F4 F0 FA		        BEQ     TYPE_WAIT       ; Keep waiting if $00
  3273
  3274 13F6 E0 1C		        CPX     #ESC_KEY        ; Leave if ESC key pressed
  3275 13F8 F0 33		        BEQ     TYPE_DONE
  3276
  3277 				    ; Reset pagination
  3278 13FA A9 00		        LDA     #$00
  3279 13FC 8D BB 02		        STA     SCRFLG
  3280
  3281 13FF			TYPE_READ:
  3282 				    ; Read from file
  3283 13FF A2 10		        LDX     #$10            ; IOCB offset (channel)
  3284 1401 A9 01		        LDA     #$01            ; ICBLL (buffer length lo) Request 1 byte
  3285 1403 A0 00		        LDY     #$00            ; ICBLH (buffer length hi)
  3286 1405 20 F0 09		        JSR     CIOGET
  3287
  3288 				    ; Quit if EOF
  3289 1408 A2 10		        LDX     #$10
  3290 140A BD 43 03		        LDA     ICSTA,X
  3291 140D C9 88		        CMP     #EOF
  3292 140F F0 1C		        BEQ     TYPE_DONE
  3293
  3294 				    ; Convert CRLF or LF --> EOL
  3295 1411 A0 00		        LDY     #$00
  3296 1413 B1 F3		        LDA     (INBUFF),Y
  3297 1415 C9 0D		        CMP     #CR     ; Skip CR
  3298 1417 F0 11		        BEQ     TYPE_NEXT3
  3299 1419 C9 0A		        CMP     #LF     ; Convert LF --> EOL
  3300 141B D0 04		        BNE     TYPE_NEXT2
  3301 141D A9 9B		        LDA     #EOL
  3302 141F 91 F3		        STA     (INBUFF),Y
  3303
  3304 1421			TYPE_NEXT2:
  3305 				    ; Write to screen
  3306 1421 A2 00		        LDX     #$00
  3307 1423 A9 01		        LDA     #$01
  3308 1425 A0 00		        LDY     #$00
  3309 1427 20 0E 0A		        JSR     CIOPUT
  3310
  3311 142A			TYPE_NEXT3:
  3312 				    ; Do next
  3313 142A 4C DD 13		        JMP     TYPE_LOOP
  3314 				        
  3315 142D			TYPE_DONE:
  3316 142D A9 FF		        LDA     #$FF
  3317 142F 8D FC 02		        STA     CH
  3318 1432 A2 10		        LDX     #$10            ; Close File #1
  3319 1434 4C BB 09		        JMP     CIOCLOSE        ; 
  3320
  3321 1437			TYPE_OPEN_ERR_STR:
  3322 1437 55 4E 41 42 4C 45 +         .BYTE   'UNABLE TO OPEN FILE',EOL
  3323
  3324 				;---------------------------------------
  3325 144B			DO_UNLOCK:
  3326 				;---------------------------------------
  3327 144B A9 90		        LDA     #$90
  3328 144D 8D C6 02		        STA     COLOR2
  3329 1450 60			        RTS
  3330
  3331 				;---------------------------------------
  3332 1451			DO_CAR:
  3333 				;---------------------------------------
  3334
  3335 				    ;---------------------------------------
  3336 				    ; Is cart address space RAM or ROM?
  3337 				    ;---------------------------------------
  3338 1451 20 90 0B		        JSR     CHECK_IF_ROM    ; returns Y=1 -> ROM. Y=0 -> RAM.
  3339 1454 98			        TYA                     ; Xfer affects Z flag
  3340 1455 D0 07		        BNE     DO_CAR_NEXT     ; if Y=1 (ROM) skip ahead
  3341
  3342 				    ;---------------------------------------
  3343 				    ; RAM found
  3344 				    ;---------------------------------------
  3345 1457 A9 6B		        LDA     #<DO_CAR_ERR
  3346 1459 A0 14		        LDY     #>DO_CAR_ERR
  3347 145B 4C 89 0A		        JMP     PRINT_STRING    ; Print error and bail
  3348
  3349 145E			DO_CAR_NEXT:
  3350 				    ;---------------------------------------
  3351 				    ; Border used to indicate program in ROM
  3352 				    ; Revert border before returning to ROM
  3353 				    ;---------------------------------------
  3354 145E AD AB 18		        LDA     COLOR4_ORIG     
  3355 1461 8D C8 02		        STA     COLOR4          ; Reset border to orig color
  3356
  3357 				    ;---------------------------------------
  3358 				    ; Warmstart
  3359 				    ;---------------------------------------
  3360 1464 A9 FF		        LDA     #$FF
  3361 1466 85 08		        STA     $08
  3362 1468 6C FA BF		        JMP     ($BFFA)         ; Bye
  3363
  3364 146B			DO_CAR_ERR:
  3365 146B 4E 4F 20 43 41 52 +         .BYTE   'NO CARTRIDGE',EOL
  3366
  3367 				;---------------------------------------
  3368 1478			DO_CLS:
  3369 				;---------------------------------------
  3370 1478 A9 7F		        LDA     #<CLS_STR
  3371 147A A0 14		        LDY     #>CLS_STR
  3372 147C 4C 89 0A		        JMP     PRINT_STRING
  3373
  3374 147F			CLS_STR:
  3375 147F 7D 9B		        .BYTE   125,EOL
  3376
  3377 				;---------------------------------------
  3378 1481			DO_COLD:
  3379 				;---------------------------------------
  3380 1481 4C 77 E4		        JMP     COLDSV
  3381
  3382 				;---------------------------------------
  3383 1484			DO_HELP:
  3384 				;---------------------------------------
  3385 				    ; Append either "HELP" or arg1 to URL
  3386 1484 A2 00		        LDX     #$00        ; index to start of article buf
  3387 1486 AC 75 0C		        LDY     CMDSEP      ; index to cmd line arg
  3388 				        
  3389 1489			HELP_LOOP1:
  3390 1489 B1 F3		        LDA     (INBUFF),Y
  3391 148B C9 9B		        CMP     #EOL
  3392 148D F0 14		        BEQ     HELP_NEXT1  ; Exit loop at end of arg
  3393 148F E0 16		        CPX     #22
  3394 1491 10 2E		        BPL     HELP_DONE   ; Exit if arg is too long
  3395
  3396 				    ; Convert lower-case to upper-case
  3397 1493 20 60 0A		        JSR     TOUPPER
  3398 1496 9D 1D 15		        STA     HELP_ARTICLE,X
  3399 1499 E8			        INX
  3400 149A C8			        INY
  3401 149B D0 EC		        BNE     HELP_LOOP1  ; Always true
  3402
  3403 				    ; Append .DOC extension to article name
  3404 149D			HELP_EXT:
  3405 149D 2E 44 4F 43 9B 00	        .BYTE   '.DOC',EOL,$00
  3406
  3407 14A3			HELP_NEXT1:
  3408 14A3 A0 00		        LDY     #$00
  3409
  3410 14A5			HELP_LOOP2:
  3411 14A5 B9 9D 14		        LDA     HELP_EXT,Y
  3412 14A8 9D 1D 15		        STA     HELP_ARTICLE,X  ; Store null term too
  3413 14AB F0 04		        BEQ     HELP_NEXT2      ; Skip ahead if terminator
  3414 14AD E8			        INX
  3415 14AE C8			        INY
  3416 14AF D0 F4		        BNE     HELP_LOOP2  ; Always true
  3417
  3418 14B1			HELP_NEXT2:
  3419 				    ; Copy URL to LNBUF
  3420 14B1 A2 00		        LDX     #$00    ; Index to start of HELP_URL
  3421 14B3 A0 05		        LDY     #$05    ; Index to start at arg1 for "TYPE "
  3422 				    
  3423 14B5			HELP_LOOP3:
  3424 14B5 BD C9 14		        LDA     HELP_URL,X  ; Get source byte
  3425 14B8 99 82 05		        STA     LNBUF,Y     ; Write to target location
  3426 14BB F0 04		        BEQ     HELP_DONE   ; Exit loop on null terminator
  3427 14BD E8			        INX                 ; Advance indices
  3428 14BE C8			        INY
  3429 14BF D0 F4		        BNE     HELP_LOOP3  ; Always true
  3430 				        
  3431 14C1			HELP_DONE:        
  3432 14C1 A9 05		        LDA     #$05        ; Trick TYPE to look for URL in arg1
  3433 14C3 8D 75 0C		        STA     CMDSEP
  3434 14C6 4C A3 13		        JMP     DO_TYPE
  3435
  3436 14C9			HELP_URL:
  3437 14C9 4E 38 3A 48 54 54 +         .BYTE   'N8:HTTPS://raw.githubusercontent.com/michaelsternberg/fujinet-nhandler/nos/nos/HELP/'
  3438
  3439 151D			HELP_ARTICLE:
  3440 151D 00 00 00 00 00 00 +     :24 .BYTE   $00
  3441
  3442 				;---------------------------------------
  3443 1535			DO_BASIC:
  3444 				;---------------------------------------
  3445 				    ; Enable or disable BASIC (or, say, U1MB ROM)
  3446 				    ; Usage: [BASIC|ROM] [ON|OFF]
  3447 				    
  3448 				    ; Quit if no internal BASIC
  3449 1535 20 54 0B		        JSR     CHECK_INTERNAL_BASIC
  3450 1538 B0 46		        BCS     BASIC_QUIT
  3451
  3452 				    ; Check for usage. arg (BASIC ON|OFF)
  3453 153A AE 75 0C		        LDX     CMDSEP
  3454 153D BD 82 05		        LDA     LNBUF,X
  3455 1540 29 DF		        AND     #%11011111  ; Convert lower to upper
  3456 1542 C9 4F		        CMP     #'O'        ; Is 1st char O? as in ON|OFF
  3457 1544 D0 3B		        BNE     BASIC_USAGE
  3458 1546 E8			        INX
  3459 1547 BD 82 05		        LDA     LNBUF,X
  3460 154A 29 DF		        AND     #%11011111  ; Convert lower to upper
  3461 154C C9 46		        CMP     #'F'        ; Is 2nd char F? as in OFF?
  3462 154E F0 22		        BEQ     BASIC_OFF
  3463 1550 C9 4E		        CMP     #'N'        ; Is 2nd char N? as in ON?
  3464 1552 D0 2D		        BNE     BASIC_USAGE
  3465
  3466 				    ;---------------------------------------
  3467 				    ; We are here if BASIC ON or ROM ON was the command. 
  3468 				    ; Do a favor and jump to CAR if ROM is already enabled
  3469 				    ;---------------------------------------
  3470 1554 AD 01 D3		        LDA     PORTB
  3471 1557 29 02		        AND     #%00000010
  3472 1559 D0 03		        BNE     BASIC_ON
  3473 155B 4C 51 14		        JMP     DO_CAR
  3474
  3475 155E			BASIC_ON:
  3476 				    ;---------------------------------------
  3477 				    ; Source: ANTIC Volume 4 #10 Feb 1986
  3478 				    ; BASIC ON/OFF Switcher [Chadwick]
  3479
  3480 				    ;---------------------------------------
  3481 				    ; Enable BASIC in XL/XE
  3482 				    ;---------------------------------------
  3483 155E A9 00		        LDA     #$00
  3484 1560 8D F8 03		        STA     BASICF      ; BASIC RAM FLAG
  3485 1563 A9 52		        LDA     #$52
  3486 1565 8D EB 03		        STA     $03EB       ; CARTRIDGE CHECKSUM
  3487
  3488 1568 AD 01 D3		        LDA     PORTB
  3489 156B 29 FD		        AND     #%11111101  ; If Bit 1 = 0 then BASIC is enabled
  3490 156D 8D 01 D3		        STA     PORTB       ; BASIC ROM FLAG
  3491 1570 D0 0B		        BNE     BASIC_WARM  ; Always jump
  3492
  3493 1572			BASIC_OFF:
  3494 				    ;---------------------------------------
  3495 				    ; Disable BASIC in XL/XE
  3496 				    ;---------------------------------------
  3497 1572 A9 01		        LDA     #$01
  3498 1574 8D F8 03		        STA     BASICF
  3499 				    ;---------------------------------------
  3500 				    ; Change border color as reminder that
  3501 				    ; we're working with limited addr space
  3502 				    ;---------------------------------------
  3503 1577 AD AB 18		        LDA     COLOR4_ORIG
  3504 157A 8D C8 02		        STA     COLOR4      
  3505
  3506 157D			BASIC_WARM:
  3507 157D 4C 74 E4		        JMP     WARMSV  ; XL/XE WARMSTART
  3508
  3509 1580			BASIC_QUIT:
  3510 1580 60			        RTS
  3511
  3512 1581			BASIC_USAGE:
  3513 1581 A9 88		        LDA     #<BASIC_ERROR
  3514 1583 A0 15		        LDY     #>BASIC_ERROR
  3515 1585 4C 89 0A		        JMP     PRINT_STRING
  3516
  3517 1588			BASIC_ERROR:
  3518 1588 5B 42 41 53 49 43 +         .BYTE   '[BASIC|ROM] [ON|OFF]',EOL
  3519
  3520 				;;---------------------------------------
  3521 				;DO_NOBASIC:
  3522 				;;---------------------------------------
  3523 				;        JSR     CHECK_INTERNAL_BASIC
  3524 				;        BCS     NOBASIC_QUIT
  3525
  3526
  3527 				;---------------------------------------
  3528 159D			DO_NOSCREEN:
  3529 				;---------------------------------------
  3530 159D A9 00		        LDA     #$00
  3531 159F 8D 92 18		        STA     ECHO_FLG    ; Disable echo in batch processing
  3532 15A2 60			        RTS
  3533
  3534 				;---------------------------------------
  3535 15A3			DO_SCREEN:
  3536 				;---------------------------------------
  3537 15A3 A9 01		        LDA     #$01
  3538 15A5 8D 92 18		        STA     ECHO_FLG    ; Enable echo in batch processing
  3539 15A8 60			        RTS
  3540
  3541 				;---------------------------------------
  3542 15A9			DO_PRINT:
  3543 				;---------------------------------------
  3544 15A9 AD 75 0C		        LDA     CMDSEP
  3545 15AC F0 08		        BEQ     PRINT_DONE
  3546
  3547 15AE 18			        CLC
  3548 15AF 65 F3		        ADC     INBUFF
  3549 15B1 A4 F4		        LDY     INBUFF+1
  3550 15B3 4C 89 0A		        JMP     PRINT_STRING
  3551
  3552 15B6			PRINT_DONE:
  3553 15B6 60			        RTS
  3554
  3555 				;---------------------------------------
  3556 15B7			DO_REENTER:
  3557 				;---------------------------------------
  3558 				    ; Jump to the address stored in RUNAD or INITAD
  3559 				    ; Do the one that isn't pointing to R (RUNAD first)
  3560
  3561 				    ; Skip it all if both contain $0000
  3562 15B7 AD E2 02		        LDA     INITAD
  3563 15BA D0 16		        BNE     DO_REENTER_CONT
  3564 15BC AD E3 02		        LDA     INITAD+1
  3565 15BF D0 11		        BNE     DO_REENTER_CONT
  3566 15C1 AD E0 02		        LDA     RUNAD
  3567 15C4 D0 0C		        BNE     DO_REENTER_CONT
  3568 15C6 AD E1 02		        LDA     RUNAD+1
  3569 15C9 D0 07		        BNE     DO_REENTER_CONT
  3570
  3571 15CB A9 E6		        LDA     #<DO_REENTER_ERR
  3572 15CD A0 15		        LDY     #>DO_REENTER_ERR
  3573 15CF 4C 89 0A		        JMP     PRINT_STRING
  3574
  3575 15D2			DO_REENTER_CONT:
  3576 15D2 AD E0 02		        LDA     RUNAD
  3577 15D5 C9 0F		        CMP     #>R
  3578 15D7 D0 07		        BNE     DO_REENTER_RUNAD
  3579 15D9 AD E1 02		        LDA     RUNAD+1
  3580 15DC C9 0F		        CMP     #>R
  3581 15DE F0 03		        BEQ     DO_REENTER_INITAD
  3582
  3583 15E0			DO_REENTER_RUNAD:
  3584 15E0 6C E0 02		        JMP     (RUNAD)     ; Godspeed
  3585
  3586 15E3			DO_REENTER_INITAD:
  3587 15E3 6C E2 02		        JMP     (INITAD)    ; Godspeed
  3588
  3589 15E6			DO_REENTER_ERR:
  3590 15E6 4E 4F 20 41 44 44 +         .BYTE   'NO ADDR IN INITAD OR RUNAD',EOL
  3591
  3592 				;---------------------------------------
  3593 1601			DO_REM:
  3594 				;---------------------------------------
  3595 1601 60			        RTS
  3596
  3597 				;---------------------------------------
  3598 1602			DO_RUN:
  3599 				;---------------------------------------
  3600 1602 AD 75 0C		        LDA     CMDSEP      ; Get position for address arg
  3601 1605 A8			        TAY                 ; Offset to arg used later
  3602 1606 18			        CLC
  3603 1607 69 04		        ADC     #$04
  3604 1609 8D 00 19		        STA     RBUF
  3605
  3606 160C 20 0F 0B		        JSR     ASCII2ADDR  ; Convert text to an addr
  3607 160F B0 F0		        BCS     DO_REM      ; Re-use nearby RTS
  3608 				        
  3609 1611 6C F3 00		        JMP     (INBUFF)    ;
  3610
  3611 				;---------------------------------------
  3612 1614			DO_SAVE:
  3613 				;---------------------------------------
  3614 				    ; INBUFF points to Filename
  3615 				    ; LNBUF,Y is start of 4 char ASCII hex string
  3616
  3617 1614 A9 B0		        LDA     #$B0
  3618 1616 8D C6 02		        STA     COLOR2
  3619
  3620 				    ; Store address of INBUFF + CMDSEP in STL, STH
  3621 1619 18			        CLC
  3622 161A A5 F3		        LDA     INBUFF
  3623 161C 6D 75 0C		        ADC     CMDSEP
  3624 161F 8D 80 19		        STA     STL
  3625 1622 A5 F4		        LDA     INBUFF+1
  3626 1624 69 00		        ADC     #$00
  3627 1626 8D 81 19		        STA     STH
  3628
  3629 1629 60			        RTS
  3630 				    ; Loop until comma found, replace it with EOL,
  3631 				    ; and store address in STL, STH
  3632
  3633 				;        LDY     CMDSEP
  3634 				;        DEY
  3635 				;@:      INY
  3636 				;        LDA     #EOL
  3637 				;        INY
  3638 				;        CMP     (INBUFF),Y
  3639 				;        BEQ     SAVE_USAGE
  3640 				;        BNE     @-
  3641 				;        STA
  3642 				;        RTS
  3643 				;
  3644 				;    ; Loop until EOL is found
  3645 				;    ; Move addr args to STL, STH, ..
  3646 				;        LDX     #$00        ; X will hold number of addr args
  3647 				;        LDY     CMDSEP
  3648 				;        CLC
  3649 				;SAVE_LOOP0:
  3650 				;        LDA     (INBUFF),Y
  3651 				;
  3652 				;        CMP     #EOL        ; If EOL then skip ahead
  3653 				;        BEQ     @++
  3654 				;
  3655 				;        CMP     #','
  3656 				;        BNE     @+
  3657 				;        
  3658 				;        INX
  3659 				;        CPX     #$05        ; If number of commas >= 5
  3660 				;        BCS     SAVE_USAGE  ; Then quit
  3661 				;       
  3662 				;        INY
  3663 				;        TYA
  3664 				;        STA     CMPSEP,X
  3665 				;@:      BNE     SAVE_LOOP0  ; Always true
  3666 				;
  3667 				;
  3668 				;    ; Check # of args
  3669 				;@:      CPX     #$03
  3670 				;
  3671 				;    ; Save addresses to TBUF 
  3672 				;    ; Save lo bytes in 1st list
  3673 				;    ; Save hi bytes in 2nd list
  3674 				;SAVE_LOOP1:
  3675 				;        INX
  3676 				;        LDA     CMDSEP,X
  3677 				;        BEQ     SAVE_SKIP1
  3678 				;        JSR     ASCII2ADDR
  3679 				;        LDA     INBUFF          ; Lo byte
  3680 				;        STA     TBUF,X
  3681 				;        LDA     INBUFF+1        ; Hi byte
  3682 				;        STA     TBUF+4,X
  3683 				;SAVE_SKIP1:
  3684 				;        DEX
  3685 				;        DEX
  3686 				;        BNE     SAVE_LOOP1
  3687 				;
  3688 				;        RTS
  3689 162A			SAVE_USAGE:
  3690 162A A9 31		        LDA     #<SAVE_ERROR_STR
  3691 162C A0 16		        LDY     #>SAVE_ERROR_STR
  3692 162E 4C 89 0A		        JMP     PRINT_STRING
  3693
  3694 1631			SAVE_ERROR_STR:
  3695 1631 53 41 56 45 20 4E +         .BYTE   'SAVE Nn:FILE,START,END(,INIT)(,RUN)',EOL
  3696 				;
  3697 				; End of DO_SAVE
  3698 				;---------------------------------------
  3699
  3700 				;---------------------------------------
  3701 1655			DO_WARM:
  3702 				;---------------------------------------
  3703 1655 4C 74 E4		        JMP     WARMSV
  3704
  3705 				;---------------------------------------
  3706 1658			DO_XEP:
  3707 				;---------------------------------------
  3708 1658 A0 19		        LDY     #$19        ; CMD = $19 (enter 40 col)
  3709 165A AE 75 0C		        LDX     CMDSEP
  3710 165D BD 82 05		        LDA     LNBUF,X
  3711 1660 C9 34		        CMP     #'4'
  3712 1662 F0 01		        BEQ     @+
  3713 1664 88			        DEY                 ; CMD = $18 (enter 80 col)
  3714 				@:      
  3715 1665 A2 00		        LDX     #$00
  3716 1667 98			        TYA
  3717 1668 9D 42 03		        STA     ICCOM,X
  3718 166B A9 85		        LDA     #<EDEV
  3719 166D 9D 44 03		        STA     ICBAL,X
  3720 1670 A9 16		        LDA     #>EDEV
  3721 1672 9D 45 03		        STA     ICBAH,X
  3722 1675 A9 2C		        LDA     #$2C
  3723 1677 9D 4A 03		        STA     ICAX1,X
  3724 167A A9 00		        LDA     #$00
  3725 167C 9D 4B 03		        STA     ICAX2,X
  3726 167F 20 56 E4		        JSR     CIOV
  3727 1682 4C 78 14		        JMP     DO_CLS
  3728
  3729 1685 25 1A 9B		EDEV:   .BYTE   "E:",EOL
  3730 				        
  3731 				;---------------------------------------
  3732 1688			REMOUNT_DRIVE:
  3733 				;---------------------------------------
  3734
  3735 				    ;---------------------------------------
  3736 				    ; Workaround for timeout issue regarding idempotent commands that
  3737 				    ; unmount the server.  So far, these are DEL and RENAME. This
  3738 				    ; routine, remounts the TNFS URL by calling NPWD and attempts
  3739 				    ; a MKDIR on the returned mount point. Hopefully this is an
  3740 				    ; non-consequential operation since the directory already exists.
  3741 				    ;---------------------------------------
  3742
  3743 1688 20 89 11		        JSR     DO_NPWD         ; Curr dir for drive now in RBUF
  3744
  3745 168B AD 00 19		        LDA     RBUF            ; Quit if not TNFS. Only TNFS is affected.
  3746 168E C9 54		        CMP     #'T'            ; TODO More letters needed if...
  3747 1690 D0 28		        BNE     REMOUNT_DONE    ; ...another Txxx protocol exists
  3748
  3749 1692 A9 4E		        LDA     #'N'
  3750 1694 8D 00 19		        STA     RBUF+0
  3751 1697 AD 8F 18		        LDA     DOSDR           ; Get drive number
  3752 169A 09 30		        ORA     #'0'            ; Convert, say, 1 to '1'
  3753 169C 8D 01 19		        STA     RBUF+1
  3754 169F A9 3A		        LDA     #':'
  3755 16A1 8D 02 19		        STA     RBUF+2
  3756
  3757 16A4 A9 2A		        LDA     #CMD_MKDIR
  3758 16A6 8D EE 0D		        STA     GENDCB+2
  3759 16A9 A9 00		        LDA     #<RBUF          ; TODO Is this needed
  3760 16AB 8D F0 0D		        STA     GENDCB+4        ; TODO or is it hardcoded in DO_GENERIC?
  3761 16AE A9 19		        LDA     #>RBUF
  3762 16B0 8D F1 0D		        STA     GENDCB+5
  3763
  3764 16B3 A9 EC		        LDA     #<GENDCB
  3765 16B5 A0 0D		        LDY     #>GENDCB
  3766 16B7 4C A5 07		        JMP     DOSIOV
  3767
  3768 16BA			REMOUNT_DONE:
  3769 16BA 60			        RTS
  3770
  3771 				;---------------------------------------
  3772 16BB			PREPEND_DRIVE:
  3773 				;---------------------------------------
  3774 				        ; Inject "Nn:" in front of a plain filename
  3775 				        ; before passing it to the FujiNet
  3776 16BB A0 00		        LDY     #$00
  3777 16BD A9 4E		        LDA     #'N'
  3778 16BF D1 F3		        CMP     (INBUFF),Y  ; Does arg1 already begin with N?
  3779
  3780 16C1 A0 02		        LDY     #$02
  3781 16C3 A9 3A		        LDA     #':'
  3782 16C5 D1 F3		        CMP     (INBUFF),Y
  3783 16C7 F0 1C		        BEQ     PREPEND_DRIVE_DONE
  3784 16C9 88			        DEY
  3785 16CA D1 F3		        CMP     (INBUFF),Y
  3786 16CC F0 17		        BEQ     PREPEND_DRIVE_DONE
  3787
  3788 				        ; Move input buffer pointer back 3 bytes
  3789 16CE 38			        SEC
  3790 16CF A5 F3		        LDA     INBUFF
  3791 16D1 E9 03		        SBC     #$03
  3792 16D3 85 F3		        STA     INBUFF
  3793 16D5 A5 F4		        LDA     INBUFF+1
  3794 16D7 E9 00		        SBC     #$00
  3795 16D9 85 F4		        STA     INBUFF+1
  3796
  3797 				        ; Inject PRMPT to front of arg1
  3798 16DB A0 03		        LDY     #$03
  3799 16DD			PREPEND_DRIVE_LOOP:
  3800 16DD B9 0F 17		        LDA     PRMPT,Y
  3801 16E0 88			        DEY
  3802 16E1 91 F3		        STA     (INBUFF),Y
  3803 16E3 D0 F8		        BNE     PREPEND_DRIVE_LOOP
  3804
  3805 16E5			PREPEND_DRIVE_DONE:
  3806 16E5 A0 01		        LDY     #$01
  3807 16E7 60			        RTS             ; Y = $00 here
  3808
  3809 				;---------------------------------------
  3810 16E8			APPEND_SLASH:
  3811 				;---------------------------------------
  3812 				    ;---------------------------------------
  3813 				    ; Skip if relative path (..)
  3814 				    ;---------------------------------------
  3815 16E8 A0 00		        LDY     #$00
  3816 16EA A9 2E		        LDA     #'.'
  3817 16EC D1 F3		        CMP     (INBUFF),Y
  3818 16EE F0 1E		        BEQ     APPEND_SLASH_DONE
  3819
  3820 16F0 A0 FF		        LDY     #$FF        ; Iterate thru arg2 until EOF
  3821 16F2			APPEND_SLASH_LOOP:
  3822 16F2 C8			        INY                 ; Zero on 1st pass
  3823 16F3 B1 F3		        LDA     (INBUFF),Y
  3824 16F5 C9 9B		        CMP     #EOL
  3825 16F7 D0 F9		        BNE     APPEND_SLASH_LOOP
  3826
  3827 16F9 88			        DEY                 ; Move pointer back one character
  3828 16FA B1 F3		        LDA     (INBUFF),Y
  3829 16FC C9 2F		        CMP     #'/'        ; If already slash then skip rest
  3830 16FE F0 0E		        BEQ     APPEND_SLASH_DONE
  3831 1700 C9 3A		        CMP     #':'        ; If a drive, skip
  3832 1702 F0 0A		        BEQ     APPEND_SLASH_DONE
  3833
  3834 1704 C8			        INY                 ; Else inject '/' + EOL
  3835 1705 A9 2F		        LDA     #'/'
  3836 1707 91 F3		        STA     (INBUFF),Y
  3837 1709 C8			        INY
  3838 170A A9 9B		        LDA     #EOL
  3839 170C 91 F3		        STA     (INBUFF),Y
  3840
  3841 170E			APPEND_SLASH_DONE:
  3842 170E 60			        RTS
  3843
  3844 170F			PRMPT:
  3845 170F 9B 4E 20 3A		        .BYTE   EOL,'N :'
  3846
  3847 				;;; End CP ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  3848 				;;; Variables
  3849
  3850 1713			        .ENUM   CMD_IDX
  3851 				        ;---------------
  3852 = 0000			                NCD                 ;  0
  3853 				;               COPY                ;  1
  3854 = 0001			                DIR                 ;  2
  3855 = 0002			                DEL                 ;  3
  3856 = 0003			                LOAD                ;  4
  3857 = 0004			                LOCK                ;  5
  3858 = 0005			                LPR                 ;  6
  3859 = 0006			                MKDIR               ;  7
  3860 = 0007			                NPWD                ;  8
  3861 = 0008			                NTRANS              ;  9
  3862 = 0009			                PASS                ; 10
  3863 = 000A			                RENAME              ; 11
  3864 = 000B			                RMDIR               ; 12
  3865 = 000C			                SAVE                ; 13
  3866 = 000D			                SUBMIT              ; 14
  3867 = 000E			                TYPE                ; 15
  3868 = 000F			                USER                ; 16
  3869 = 0010			                UNLOCK              ; 17
  3870 = 0011			                AUTORUN             ; 18
  3871 = 0012			                CAR                 ; 19
  3872 = 0013			                CLS                 ; 20
  3873 = 0014			                COLD                ; 21
  3874 = 0015			                HELP                ; 22
  3875 = 0016			                BASIC               ; 23
  3876 = 0017			                NOSCREEN            ; 24
  3877 = 0018			                PRINT               ; 25
  3878 = 0019			                REENTER             ; 26
  3879 = 001A			                REM                 ; 27
  3880 = 001B			                RUN                 ; 28
  3881 = 001C			                SCREEN              ; 29
  3882 = 001D			                WARM                ; 20
  3883 = 001E			                XEP                 ; 31
  3884 = 001F			                DRIVE_CHG           ; 32
  3885 				        .ENDE
  3886
  3887 1713			CMD_DCOMND:
  3888 1713 2C			        .BYTE   CMD_CD              ;  0 NCD
  3889 				;       .BYTE   CMD_COPY            ;  1 COPY
  3890 1714 02			        .BYTE   CMD_DIR             ;  2 DIR
  3891 1715 21			        .BYTE   CMD_DEL             ;  3 DEL
  3892 1716 28			        .BYTE   CMD_LOAD            ;  4 LOAD
  3893 1717 23			        .BYTE   CMD_LOCK            ;  5 LOCK
  3894 1718 F0			        .BYTE   CMD_LPR             ;  6 LPR
  3895 1719 2A			        .BYTE   CMD_MKDIR           ;  7 MKDIR
  3896 171A 30			        .BYTE   CMD_NPWD            ;  8 NPWD
  3897 171B 54			        .BYTE   CMD_NTRANS          ;  9 NTRANS
  3898 171C FE			        .BYTE   CMD_PASS            ; 10 PASS
  3899 171D 20			        .BYTE   CMD_RENAME          ; 11 RENAME
  3900 171E 2B			        .BYTE   CMD_RMDIR           ; 12 RMDIR
  3901 171F F0			        .BYTE   CMD_SAVE            ; 13 SAVE
  3902 1720 F0			        .BYTE   CMD_SUBMIT          ; 14 SUBMIT
  3903 1721 F0			        .BYTE   CMD_TYPE            ; 15 TYPE
  3904 1722 FD			        .BYTE   CMD_USER            ; 16 USER
  3905 1723 24			        .BYTE   CMD_UNLOCK          ; 17 UNLOCK
  3906 1724 F0			        .BYTE   CMD_AUTORUN         ; 18 AUTORUN
  3907 1725 F0			        .BYTE   CMD_CAR             ; 19 CAR
  3908 1726 F0			        .BYTE   CMD_CLS             ; 20 CLS
  3909 1727 F0			        .BYTE   CMD_COLD            ; 21 COLD
  3910 1728 F0			        .BYTE   CMD_HELP            ; 22 HELP
  3911 1729 F0			        .BYTE   CMD_BASIC           ; 23 BASIC
  3912 172A F0			        .BYTE   CMD_NOSCREEN        ; 24 NOSCREEN
  3913 172B F0			        .BYTE   CMD_PRINT           ; 25 PRINT
  3914 172C F0			        .BYTE   CMD_REENTER         ; 26 REENTER
  3915 172D F0			        .BYTE   CMD_REM             ; 27 REM
  3916 172E F0			        .BYTE   CMD_RUN             ; 28 RUN
  3917 172F F0			        .BYTE   CMD_SCREEN          ; 29 SCREEN
  3918 1730 F0			        .BYTE   CMD_WARM            ; 20 WARM
  3919 1731 F0			        .BYTE   CMD_XEP             ; 31 XEP
  3920 1732 01			        .BYTE   CMD_DRIVE_CHG       ; 32
  3921
  3922 1733			COMMAND:
  3923 1733 4E 43 C4		        .CB     "NCD"               ;  0 NCD
  3924 1736 00			        .BYTE   CMD_IDX.NCD            
  3925
  3926 				;       .CB     "COPY"              ;  1 COPY
  3927 				;       .BYTE   CMD_IDX.COPY           
  3928
  3929 1737 44 49 D2		        .CB     "DIR"               ;  2 DIR
  3930 173A 01			        .BYTE   CMD_IDX.DIR              
  3931
  3932 173B 44 45 CC		        .CB     "DEL"               ;  3 DEL
  3933 173E 02			        .BYTE   CMD_IDX.DEL              
  3934
  3935 173F 4C 4F 41 C4		        .CB     "LOAD"              ;  4 LOAD
  3936 1743 03			        .BYTE   CMD_IDX.LOAD             
  3937
  3938 1744 4C 4F 43 CB		        .CB     "LOCK"              ;  5 LOCK
  3939 1748 04			        .BYTE   CMD_IDX.LOCK             
  3940
  3941 1749 4C 50 D2		        .CB     "LPR"               ;  6 LPR
  3942 174C 05			        .BYTE   CMD_IDX.LPR              
  3943 				                                        
  3944 174D 4D 4B 44 49 D2	        .CB     "MKDIR"             ;  7 MKDIR
  3945 1752 06			        .BYTE   CMD_IDX.MKDIR           
  3946 				                                        
  3947 1753 4E 50 57 C4		        .CB     "NPWD"              ;  8 NPWD
  3948 1757 07			        .BYTE   CMD_IDX.NPWD             
  3949 				                                        
  3950 1758 4E 54 52 41 4E D3	        .CB     "NTRANS"            ;  9 NTRANS
  3951 175E 08			        .BYTE   CMD_IDX.NTRANS            
  3952 				                                        
  3953 175F 50 41 53 D3		        .CB     "PASS"              ; 10 PASS
  3954 1763 09			        .BYTE   CMD_IDX.PASS             
  3955 				                                         
  3956 1764 52 45 4E 41 4D C5	        .CB     "RENAME"            ; 11 RENAME
  3957 176A 0A			        .BYTE   CMD_IDX.RENAME          
  3958 				                                        
  3959 176B 52 4D 44 49 D2	        .CB     "RMDIR"             ; 12 RMDIR
  3960 1770 0B			        .BYTE   CMD_IDX.RMDIR           
  3961 				                                        
  3962 1771 53 41 56 C5		        .CB     "SAVE"              ; 13 SAVE
  3963 1775 0C			        .BYTE   CMD_IDX.SAVE            
  3964 				                                         
  3965 1776 53 55 42 4D 49 D4	        .CB     "SUBMIT"            ; 14 SUBMIT
  3966 177C 0D			        .BYTE   CMD_IDX.SUBMIT             
  3967 				                                        
  3968 177D 54 59 50 C5		        .CB     "TYPE"              ; 15 TYPE
  3969 1781 0E			        .BYTE   CMD_IDX.TYPE                
  3970 				                                          
  3971 1782 55 53 45 D2		        .CB     "USER"              ;  16 USER
  3972 1786 0F			        .BYTE   CMD_IDX.USER              
  3973 				                                        
  3974 1787 55 4E 4C 4F 43 CB	        .CB     "UNLOCK"            ; 17 UNLOCK
  3975 178D 10			        .BYTE   CMD_IDX.UNLOCK            
  3976 				                                        
  3977 178E 41 55 54 4F 52 55 +         .CB     "AUTORUN"           ; 18 AUTORUN
  3978 1795 11			        .BYTE   CMD_IDX.AUTORUN           
  3979 				                                          
  3980 1796 43 41 D2		        .CB     "CAR"               ; 19 CAR
  3981 1799 12			        .BYTE   CMD_IDX.CAR             
  3982 				                                        
  3983 179A 43 4C D3		        .CB     "CLS"               ; 20 CLS
  3984 179D 13			        .BYTE   CMD_IDX.CLS             
  3985 				                                        
  3986 179E 43 4F 4C C4		        .CB     "COLD"              ; 21 COLD
  3987 17A2 14			        .BYTE   CMD_IDX.COLD              
  3988 				                                        
  3989 17A3 48 45 4C D0		        .CB     "HELP"              ; 22 HELP
  3990 17A7 15			        .BYTE   CMD_IDX.HELP               
  3991
  3992 17A8 42 41 53 49 C3	        .CB     "BASIC"             ; 23 NOBASIC
  3993 17AD 16			        .BYTE   CMD_IDX.BASIC           
  3994 				                                        
  3995 17AE 40 4E 4F 53 43 52 +         .CB     "@NOSCREEN"         ; 24 @NOSCREEN
  3996 17B7 17			        .BYTE   CMD_IDX.NOSCREEN       
  3997 				                                      
  3998 17B8 50 52 49 4E D4	        .CB     "PRINT"             ; 25 PRINT
  3999 17BD 18			        .BYTE   CMD_IDX.PRINT           
  4000 				                                        
  4001 17BE 52 45 45 4E 54 45 +         .CB     "REENTER"           ; 26 REENTER
  4002 17C5 19			        .BYTE   CMD_IDX.REENTER         
  4003 				                                        
  4004 17C6 52 45 CD		        .CB     "REM"               ; 27 REM
  4005 17C9 1A			        .BYTE   CMD_IDX.REM             
  4006 				                                        
  4007 17CA 52 55 CE		        .CB     "RUN"               ; 28 RUN
  4008 17CD 1B			        .BYTE   CMD_IDX.RUN             
  4009 				                                        
  4010 17CE 40 53 43 52 45 45 +         .CB     "@SCREEN"           ; 29 @SCREEN
  4011 17D5 1C			        .BYTE   CMD_IDX.SCREEN          
  4012 				                                        
  4013 17D6 57 41 52 CD		        .CB     "WARM"              ; 30 WARM
  4014 17DA 1D			        .BYTE   CMD_IDX.WARM           
  4015 				                                       
  4016 17DB 58 45 D0		        .CB     "XEP"               ; 31 XEP
  4017 17DE 1E			        .BYTE   CMD_IDX.XEP            
  4018 				                                        
  4019 				        ; Drive Change intentionally omitted
  4020
  4021 				; Aliases
  4022 17DF 43 C4		        .CB     "CD"                ; CD = NCD
  4023 17E1 00			        .BYTE   CMD_IDX.NCD           
  4024
  4025 17E2 43 57 C4		        .CB     "CWD"               ; CWD = NCD
  4026 17E5 00			        .BYTE   CMD_IDX.NCD           
  4027
  4028 17E6 45 52 41 53 C5	        .CB     "ERASE"             ; ERASE = DEL
  4029 17EB 02			        .BYTE   CMD_IDX.DEL           
  4030
  4031 17EC 45 52 C1		        .CB     "ERA"               ; ERA = DEL
  4032 17EF 02			        .BYTE   CMD_IDX.DEL           
  4033
  4034 17F0 D8			        .CB     "X"                 ; X = LOAD
  4035 17F1 03			        .BYTE   CMD_IDX.LOAD
  4036
  4037 17F2 50 57 C4		        .CB     "PWD"               ; PWD = NPWD
  4038 17F5 07			        .BYTE   CMD_IDX.NPWD             
  4039
  4040 17F6 52 45 C5		        .CB     "REE"               ; R = REENTER
  4041 17F9 19			        .BYTE   CMD_IDX.REENTER             
  4042
  4043 17FA 52 45 CE		        .CB     "REN"               ; REN = RENAME
  4044 17FD 0A			        .BYTE   CMD_IDX.RENAME
  4045
  4046 17FE 53 4F 55 52 43 C5	        .CB     "SOURCE"            ; SOURCE = SUBMIT
  4047 1804 0D			        .BYTE   CMD_IDX.SUBMIT
  4048
  4049 1805 C0			        .CB     "@"                 ; @ = SUBMIT
  4050 1806 0D			        .BYTE   CMD_IDX.SUBMIT
  4051
  4052 1807 A3			        .CB     "#"                 ; # = REM
  4053 1808 1A			        .BYTE   CMD_IDX.REM
  4054
  4055 1809 A7			        .CB     "'"                 ; ' = REM
  4056 180A 1A			        .BYTE   CMD_IDX.REM
  4057
  4058 				        ; With U1MB, a non-BASIC program might reside
  4059 				        ; in ROM, then BASIC and NOBASIC feel awkward.
  4060 				        ; So, ROMON and ROMOFF. (I know. Inconsistent.)
  4061
  4062 180B 52 4F CD		        .CB     "ROM"               ; ROMON = BASIC
  4063 180E 16			        .BYTE   CMD_IDX.BASIC      
  4064
  4065 = 00DB			COMMAND_SIZE = * - COMMAND - 1
  4066 180F FF			        .BYTE   $FF
  4067
  4068 1810			CMD_TAB_L:
  4069 1810 82			        .BYTE   <(DO_GENERIC-1)     ;  0 NCD
  4070 				;       .BYTE   <(DO_COPY-1)        ;  1 COPY
  4071 1811 F7			        .BYTE   <(DO_DIR-1)         ;  2 DIR
  4072 1812 82			        .BYTE   <(DO_GENERIC-1)     ;  3 DEL
  4073 1813 E1			        .BYTE   <(DO_LOAD-1)        ;  4 LOAD
  4074 1814 82			        .BYTE   <(DO_GENERIC-1)     ;  5 LOCK
  4075 1815 82			        .BYTE   <(DO_LPR-1)         ;  6 LPR
  4076 1816 82			        .BYTE   <(DO_GENERIC-1)     ;  7 MKDIR
  4077 1817 88			        .BYTE   <(DO_NPWD-1)        ;  8 NPWD
  4078 1818 CB			        .BYTE   <(DO_NTRANS-1)      ;  9 NTRANS
  4079 1819 82			        .BYTE   <(DO_GENERIC-1)     ; 10 PASS
  4080 181A 82			        .BYTE   <(DO_GENERIC-1)     ; 11 RENAME
  4081 181B 82			        .BYTE   <(DO_GENERIC-1)     ; 12 RMDIR
  4082 181C 13			        .BYTE   <(DO_SAVE-1)        ; 13 SAVE
  4083 181D 1D			        .BYTE   <(DO_SUBMIT-1)      ; 14 SUBMIT
  4084 181E A2			        .BYTE   <(DO_TYPE-1)        ; 15 TYPE
  4085 181F 82			        .BYTE   <(DO_GENERIC-1)     ; 16 USER
  4086 1820 82			        .BYTE   <(DO_GENERIC-1)     ; 17 UNLOCK
  4087 1821 4E			        .BYTE   <(DO_AUTORUN-1)     ; 18 AUTORUN
  4088 1822 50			        .BYTE   <(DO_CAR-1)         ; 19 CAR
  4089 1823 77			        .BYTE   <(DO_CLS-1)         ; 20 CLS
  4090 1824 80			        .BYTE   <(DO_COLD-1)        ; 21 COLD
  4091 1825 83			        .BYTE   <(DO_HELP-1)        ; 22 HELP
  4092 1826 34			        .BYTE   <(DO_BASIC-1)       ; 23 BASIC
  4093 1827 9C			        .BYTE   <(DO_NOSCREEN-1)    ; 24 NOSCREEN
  4094 1828 A8			        .BYTE   <(DO_PRINT-1)       ; 25 PRINT
  4095 1829 B6			        .BYTE   <(DO_REENTER-1)     ; 26 REENTER
  4096 182A 00			        .BYTE   <(DO_REM-1)         ; 27 REM
  4097 182B 01			        .BYTE   <(DO_RUN-1)         ; 28 RUN
  4098 182C A2			        .BYTE   <(DO_SCREEN-1)      ; 29 SCREEN
  4099 182D 54			        .BYTE   <(DO_WARM-1)        ; 20 WARM
  4100 182E 57			        .BYTE   <(DO_XEP-1)         ; 31 XEP
  4101 182F 3B			        .BYTE   <(DO_DRIVE_CHG-1)   ; 32
  4102
  4103 1830			CMD_TAB_H:
  4104 1830 0D			        .BYTE   >(DO_GENERIC-1)     ;  0 NCD
  4105 				;       .BYTE   >(DO_COPY-1)        ;  1 COPY
  4106 1831 0D			        .BYTE   >(DO_DIR-1)         ;  2 DIR
  4107 1832 0D			        .BYTE   >(DO_GENERIC-1)     ;  3 DEL
  4108 1833 0E			        .BYTE   >(DO_LOAD-1)        ;  4 LOAD
  4109 1834 0D			        .BYTE   >(DO_GENERIC-1)     ;  5 LOCK
  4110 1835 11			        .BYTE   >(DO_LPR-1)         ;  6 LPR
  4111 1836 0D			        .BYTE   >(DO_GENERIC-1)     ;  7 MKDIR
  4112 1837 11			        .BYTE   >(DO_NPWD-1)        ;  8 NPWD
  4113 1838 11			        .BYTE   >(DO_NTRANS-1)      ;  9 NTRANS
  4114 1839 0D			        .BYTE   >(DO_GENERIC-1)     ; 10 PASS
  4115 183A 0D			        .BYTE   >(DO_GENERIC-1)     ; 11 RENAME
  4116 183B 0D			        .BYTE   >(DO_GENERIC-1)     ; 12 RMDIR
  4117 183C 16			        .BYTE   >(DO_SAVE-1)        ; 13 SAVE
  4118 183D 13			        .BYTE   >(DO_SUBMIT-1)      ; 14 SUBMIT
  4119 183E 13			        .BYTE   >(DO_TYPE-1)        ; 15 TYPE
  4120 183F 0D			        .BYTE   >(DO_GENERIC-1)     ; 16 USER
  4121 1840 0D			        .BYTE   >(DO_GENERIC-1)     ; 17 UNLOCK
  4122 1841 12			        .BYTE   >(DO_AUTORUN-1)     ; 18 AUTORUN
  4123 1842 14			        .BYTE   >(DO_CAR-1)         ; 19 CAR
  4124 1843 14			        .BYTE   >(DO_CLS-1)         ; 20 CLS
  4125 1844 14			        .BYTE   >(DO_COLD-1)        ; 21 COLD
  4126 1845 14			        .BYTE   >(DO_HELP-1)        ; 22 HELP
  4127 1846 15			        .BYTE   >(DO_BASIC-1)       ; 23 BASIC
  4128 1847 15			        .BYTE   >(DO_NOSCREEN-1)    ; 24 NOSCREEN
  4129 1848 15			        .BYTE   >(DO_PRINT-1)       ; 25 PRINT
  4130 1849 15			        .BYTE   >(DO_REENTER-1)     ; 26 REENTER
  4131 184A 16			        .BYTE   >(DO_REM-1)         ; 27 REM
  4132 184B 16			        .BYTE   >(DO_RUN-1)         ; 28 RUN
  4133 184C 15			        .BYTE   >(DO_SCREEN-1)      ; 29 SCREEN
  4134 184D 16			        .BYTE   >(DO_WARM-1)        ; 20 WARM
  4135 184E 16			        .BYTE   >(DO_XEP-1)         ; 31 XEP
  4136 184F 0D			        .BYTE   >(DO_DRIVE_CHG-1)   ; 32
  4137
  4138 				        ; DEVHDL TABLE FOR N:
  4139
  4140 1850 BD 07		CIOHND  .WORD   OPEN-1
  4141 1852 0B 08		        .WORD   CLOSE-1
  4142 1854 2C 08		        .WORD   GET-1
  4143 1856 8D 08		        .WORD   PUT-1
  4144 1858 ED 08		        .WORD   STATUS-1
  4145 185A 53 09		        .WORD   SPEC-1
  4146
  4147 				       ; BANNERS
  4148
  4149 185C 23 46 55 4A 49 4E + BREADY  .BYTE   '#FUJINET NOS v0.5.1-alpha',EOL
  4150 1876 23 46 55 4A 49 4E + BERROR  .BYTE   '#FUJINET ERROR',EOL
  4151
  4152 				        ; MESSAGES
  4153
  4154 1885 4E 6E 3F 9B		CDERR   .BYTE   'Nn?',EOL
  4155
  4156 				        ; STRING CONSTANTS
  4157
  4158 1889			MISSING_FILE_STR:
  4159 1889 46 49 4C 45 3F 9B	        .BYTE   'FILE?',EOL
  4160
  4161 				        ; VARIABLES
  4162
  4163 188F 01			DOSDR       .BYTE   $01     ; DOS DRIVE
  4164 1890 01			CMD         .BYTE   $01
  4165 1891 01			CMDPRV      .BYTE   $01
  4166 1892 01			ECHO_FLG    .BYTE   $01     ; Echo batch cmds (1=enabled,0=disabled)
  4167 1893 00			AUTORUN_FLG .BYTE   $00     ; Checked at DOS entry. Runs only on first pass
  4168
  4169 1894 01			TRIP        .BYTE   $01     ; INTR FLAG
  4170 1895 00 00 00 00		RLEN    :MAXDEV .BYTE $00   ; RCV LEN
  4171 1899 00 00 00 00		ROFF    :MAXDEV .BYTE $00   ; RCV OFFSET
  4172 189D 00 00 00 00		TOFF    :MAXDEV .BYTE $00   ; TRX OFFSET
  4173 18A1 01			INQDS       .BYTE   $01     ; DSTATS INQ
  4174
  4175 18A2 00 00 00 00		DVS2    :MAXDEV .BYTE $00   ; DVSTAT+2 SAVE
  4176 18A6 00 00 00 00		DVS3    :MAXDEV .BYTE $00   ; DVSTAT+3 SAVE
  4177
  4178 18AA 00			PRINT_ERR_FLG   .BYTE $00
  4179
  4180 18AB 00			COLOR4_ORIG .BYTE   $00     ; Hold prev border color
  4181
  4182 				       ; BUFFERS (PAGE ALIGNED)
  4183 18AC 00 00 00 00 00 00 +         .ALIGN  $100, $00
  4184 1900			BOOTEND:
  4185
  4186 1900 00 00 00 00 00 00 + RBUF:   :$80 .BYTE $00      ; 128 bytes
  4187 1980 00 00 00 00 00 00 + TBUF:   :$80 .BYTE $00      ; 128 bytes
  4188
  4189 				; Binary loader working variables
  4190 = 1900			BAL     = RBUF
  4191 = 1901			BAH     = RBUF+1    ;
  4192 = 1980			STL     = TBUF      ; Payload Start address
  4193 = 1981			STH     = TBUF+1
  4194 = 1982			ENL     = TBUF+2    ; Payload End address
  4195 = 1983			ENH     = TBUF+3
  4196 = 1984			BLL     = TBUF+4    ; Payload Buffer Length
  4197 = 1985			BLH     = TBUF+5
  4198 = 1986			HEADL   = TBUF+6    ; Bytes read from existing cache
  4199 = 1987			HEADH   = TBUF+7
  4200 = 1988			BODYL   = TBUF+8    ; Total bytes read in contiguous 512-byte blocks
  4201 = 1989			BODYH   = TBUF+9
  4202 = 198A			TAILL   = TBUF+10   ; Bytes read from last cache
  4203 = 198B			TAILH   = TBUF+11
  4204 = 198C			BODYSZL = TBUF+12   ; # Bytes to read at a time in Body
  4205 = 198D			BODYSZH = TBUF+13
  4206 = 198E			STL2    = TBUF+14   ; Payload Start address (working var)
  4207 = 198F			STH2    = TBUF+15
  4208 = 1990			BIN_1ST = TBUF+16   ; Flag for binary loader signature (FF -> 1st pass)
  4209 = 1991			AUTORUN_QUERY_FLG = TBUF+17   ; Flag for printing contents of autorun appkey
  4210
  4211 = 1A00			PGEND   = *
  4212
  4213 				; =================================================================
  4214 				; VTOC and Directory
  4215 				;
  4216
  4217 				; $10 is the added ATR-header
  4218 1A00 00 00 00 00 00 00 + :($B390-*+HDR-$10) DTA $00
  4219 BA80			VTOCSTA:
  4220 BA80 02 BD 02		    DTA $02,$BD,$02
  4221 BA83			VTOCEND:
  4222
  4223 				; Fill the remaining bytes of the VTOC sector
  4224 BA83 00 00 00 00 00 00 +     :($80+VTOCSTA-VTOCEND) DTA $00
  4225
  4226 BB00			DIRSTA:
  4227 BB00 60 C3 02 04 00 30 +     DTA $60,$C3,$02,$04,$00,C"0**********"
  4228 BB10 60 C3 02 04 00 31 +     DTA $60,$C3,$02,$04,$00,C"1 FujiNet  "
  4229 BB20 60 C3 02 04 00 32 +     DTA $60,$C3,$02,$04,$00,C"2 Network  "
  4230 BB30 60 C3 02 04 00 33 +     DTA $60,$C3,$02,$04,$00,C"3   OS     "
  4231 BB40 60 C3 02 04 00 34 +     DTA $60,$C3,$02,$04,$00,C"4          "
  4232 BB50 60 C3 02 04 00 35 +     DTA $60,$C3,$02,$04,$00,C"5 v0.5.1   "
  4233 BB60 60 C3 02 04 00 36 +     DTA $60,$C3,$02,$04,$00,C"6  alpha   "
  4234 BB70 60 C3 02 04 00 37 +     DTA $60,$C3,$02,$04,$00,C"7**********"
  4235 BB80 C0			    DTA $C0
  4236 BB81			DIREND:
  4237
  4238 				; Fill the remaining sectors of the directory
  4239 BB81 00 00 00 00 00 00 +     :($400+DIRSTA-DIREND) DTA $00
  4240
  4241 				; Sectors behind directory
  4242 BF00 00 00 00 00 00 00 +     :($80*352) DTA $00
  4243
  4244 				       END
