mads 2.1.0
Source: nos.s
     1 				        
     2 				        ;; Compile with MADS
     3
     4 				        ;; Authors: Thomas Cherryhomes
     5 				        ;;   <thom.cherryhomes@gmail.com>
     6
     7 				        ;; Michael Sternberg
     8 				        ;;   <mhsternberg@gmail.com>
     9
    10
    11 				        ;; Optimizations being done by djaybee!
    12 				        ;; Thank you so much!
    13
    14
    15 = 000A			DOSVEC  =   $0A         ; DOSVEC
    16 = 000C			DOSINI  =   $0C         ; DOSINI
    17
    18 				        ;; CURRENT IOCB IN ZERO PAGE
    19 = 0020			ZIOCB   =   $20         ; ZP IOCB
    20 = 0020			ZICHID  =   ZIOCB       ; ID
    21 = 0021			ZICDNO  =   ZIOCB+1     ; UNIT #
    22 = 0022			ZICCOM  =   ZIOCB+2     ; COMMAND
    23 = 0023			ZICSTA  =   ZIOCB+3     ; STATUS
    24 = 0024			ZICBAL  =   ZIOCB+4     ; BUF ADR LOW
    25 = 0025			ZICBAH  =   ZIOCB+5     ; BUF ADR HIGH
    26 = 0026			ZICPTL  =   ZIOCB+6     ; PUT ADDR L
    27 = 0027			ZICPTH  =   ZIOCB+7     ; PUT ADDR H
    28 = 0028			ZICBLL  =   ZIOCB+8     ; BUF LEN LOW
    29 = 0029			ZICBLH  =   ZIOCB+9     ; BUF LEN HIGH
    30 = 002A			ZICAX1  =   ZIOCB+10    ; AUX 1
    31 = 002B			ZICAX2  =   ZIOCB+11    ; AUX 2
    32 = 002C			ZICAX3  =   ZIOCB+12    ; AUX 3
    33 = 002D			ZICAX4  =   ZIOCB+13    ; AUX 4
    34 = 002E			ZICAX5  =   ZIOCB+14    ; AUX 5
    35 = 002F			ZICAX6  =   ZIOCB+15    ; AUX 6
    36
    37 = 0052			LMARGN  =   $52         ; Left margin
    38 = 00D4			FR0     =   $D4         ; Floating Point register 0 (used during Hex->ASCII conversion)
    39 = 00F2			CIX     =   $F2         ; Inbuff cursor
    40 = 00F3			INBUFF  =   $F3         ; Ptr to input buffer ($0580)
    41 = 0040			MAX_APPKEY_LEN = $40    ; Used with appkey files
    42
    43 				;---------------------------------------
    44 				; INTERRUPT VECTORS
    45 				; AND OTHER PAGE 2 VARS
    46 				;---------------------------------------
    47
    48 = 0202			VPRCED  =   $0202       ; PROCEED VCTR
    49 = 02C6			COLOR2  =   $02C6       ; MODEF BKG C
    50 = 02E0			RUNAD   =   $02E0       ; RUN ADDRESS
    51 = 02E2			INITAD  =   $02E2       ; INIT ADDRESS
    52 = 02E7			MEMLO   =   $02E7       ; MEM LO
    53 = 02EA			DVSTAT  =   $02EA       ; 4 BYTE STATS
    54
    55 				;---------------------------------------
    56 				; PAGE 3
    57 				; DEVICE CONTROL BLOCK (DCB)
    58 				;---------------------------------------
    59
    60 = 0300			DCB     =   $0300       ; BASE
    61 = 0300			DDEVIC  =   DCB         ; DEVICE #
    62 = 0301			DUNIT   =   DCB+1       ; UNIT #
    63 = 0302			DCOMND  =   DCB+2       ; COMMAND
    64 = 0303			DSTATS  =   DCB+3       ; STATUS/DIR
    65 = 0304			DBUFL   =   DCB+4       ; BUF ADR L
    66 = 0305			DBUFH   =   DCB+5       ; BUF ADR H
    67 = 0306			DTIMLO  =   DCB+6       ; TIMEOUT (S)
    68 = 0307			DRSVD   =   DCB+7       ; NOT USED
    69 = 0308			DBYTL   =   DCB+8       ; BUF LEN L
    70 = 0309			DBYTH   =   DCB+9       ; BUF LEN H
    71 = 030A			DAUXL   =   DCB+10      ; AUX BYTE L
    72 = 030B			DAUXH   =   DCB+11      ; AUX BYTE H
    73
    74 = 031A			HATABS  =   $031A       ; HANDLER TBL
    75
    76 				;---------------------------------------
    77 				; IOCB'S * 8
    78 				;---------------------------------------
    79
    80 = 0340			IOCB    =   $0340       ; IOCB BASE
    81 = 0340			ICHID   =   IOCB        ; ID
    82 = 0341			ICDNO   =   IOCB+1      ; UNIT #
    83 = 0342			ICCOM   =   IOCB+2      ; COMMAND
    84 = 0343			ICSTA   =   IOCB+3      ; STATUS
    85 = 0344			ICBAL   =   IOCB+4      ; BUF ADR LOW
    86 = 0345			ICBAH   =   IOCB+5      ; BUF ADR HIGH
    87 = 0346			ICPTL   =   IOCB+6      ; PUT ADDR L
    88 = 0347			ICPTH   =   IOCB+7      ; PUT ADDR H
    89 = 0348			ICBLL   =   IOCB+8      ; BUF LEN LOW
    90 = 0349			ICBLH   =   IOCB+9      ; BUF LEN HIGH
    91 = 034A			ICAX1   =   IOCB+10     ; AUX 1
    92 = 034B			ICAX2   =   IOCB+11     ; AUX 2
    93 = 034C			ICAX3   =   IOCB+12     ; AUX 3
    94 = 034D			ICAX4   =   IOCB+13     ; AUX 4
    95 = 034E			ICAX5   =   IOCB+14     ; AUX 5
    96 = 034F			ICAX6   =   IOCB+15     ; AUX 6
    97
    98 = 0054			ROWCRS  =   $0054
    99 = 02BB			SCRFLG  =   $02BB       ; Scroll flag
   100 = 02FC			CH      =   $02FC       ; Hardware code for last key pressed
   101 = 02F2			CH1     =   $02F2       ; Prior keyboard character code
   102 = 0582			LNBUF   =   $0582       ; Line Buffer (128 bytes)
   103
   104 				;---------------------------------------
   105 				; HARDWARE REGISTERS
   106 				;---------------------------------------
   107
   108 = D01F			CONSOL  =   $D01F       ; Console switches
   109 = D301			PORTB   =   $D301       ; On XL/XE, used to enable/disable BASIC
   110 = D302			PACTL   =   $D302       ; PIA CTRL A
   111
   112 				;---------------------------------------
   113 				; MATH PACK VECTORS
   114 				;---------------------------------------
   115 = D8E6			FASC    =   $D8E6       ; Floating point to ASCII
   116 = D9AA			IFP     =   $D9AA       ; Integer to floating point
   117
   118 				;---------------------------------------
   119 				; OS ROM VECTORS
   120 				;---------------------------------------
   121
   122 = E456			CIOV    =   $E456       ; CIO ENTRY
   123 = E459			SIOV    =   $E459       ; SIO ENTRY
   124 = E474			WARMSV  =   $E474       ; Warmstart entry point
   125 = E477			COLDSV  =   $E477       ; Coldstart entry point
   126
   127 				;---------------------------------------
   128 				; CONSTANTS
   129 				;---------------------------------------
   130
   131 = 0005			GETREC  =   $05         ; CIO CMD TO GET RECORD
   132 = 0009			PUTREC  =   $09         ; CIO CMD TO PUT RECORD
   133 = 000B			PUTCHR  =   $0B         ; CIO CMD TO PUT CHAR
   134
   135 = 0071			DEVIDN  =   $71         ; SIO DEVID
   136 = 0040			DSREAD  =   $40         ; FUJI->ATARI
   137 = 0080			DSWRIT  =   $80         ; ATARI->FUJI
   138 = 0004			MAXDEV  =   4           ; # OF N: DEVS
   139 = 0088			EOF     =   $88         ; ERROR 136
   140
   141 = 009B			EOL     =   $9B         ; EOL CHAR
   142 = 000D			CR      =   $0D         ; Carrige Return
   143 = 000A			LF      =   $0A         ; Linefeed
   144
   145 = 0003			OPTION  =   $03
   146 = 001C			ESC_KEY =   $1C         ; Hardware code for ESC
   147 = 0021			SPC_KEY =   $21         ; Hardware code for SPACE
   148
   149 = 0004			OINPUT  =   $04         ; CIO/SIO direction
   150 = 0008			OOUTPUT =   $08         ; CIO/SIO direction
   151
   152 				; FujiNet SIO command bytes
   153 = 0001			CMD_DRIVE_CHG       = $01
   154 = 002C			CMD_CD              = $2C
   155 = 00A1			CMD_COPY            = $A1
   156 = 0002			CMD_DIR             = $02
   157 = 0021			CMD_DEL             = $21
   158 = 0028			CMD_LOAD            = $28
   159 = 0023			CMD_LOCK            = $23
   160 = 00FD			CMD_LOGIN           = $FD
   161 = 00F0			CMD_LPR             = $F0
   162 = 002A			CMD_MKDIR           = $2A
   163 = 0030			CMD_NPWD            = $30
   164 = 0054			CMD_NTRANS          = 'T'
   165 = 00FE			CMD_PASSWD          = $FE
   166 = 0020			CMD_RENAME          = $20
   167 = 002B			CMD_RMDIR           = $2B
   168 = 00F0			CMD_SUBMIT          = $F0
   169 = 00F0			CMD_TYPE            = $F0
   170 = 0024			CMD_UNLOCK          = $24
   171 = 00F0			CMD_CAR             = $F0
   172 = 00F0			CMD_CLS             = $F0
   173 = 00F0			CMD_COLD            = $F0
   174 = 00F0			CMD_HELP            = $F0
   175 = 00F0			CMD_NOBASIC         = $F0
   176 = 00F0			CMD_NOSCREEN        = $F0
   177 = 00F0			CMD_PRINT           = $F0
   178 = 00F0			CMD_REENTER         = $F0
   179 = 00F0			CMD_REM             = $F0
   180 = 00F0			CMD_RUN             = $F0
   181 = 00F0			CMD_SCREEN          = $F0
   182 = 00F0			CMD_WARM            = $F0
   183 = 00F0			CMD_XEP             = $F0
   184 = 00F0			CMD_AUTORUN         = $F0
   185
   186 				;;; Macros ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   187
   188 				        .MACRO DCBC
   189 				        .LOCAL
   190 				        LDY     #$0C
   191 				?DCBL   LDA     %%1,Y
   192 				        STA     DCB,Y
   193 				        DEY
   194 				        BPL     ?DCBL
   195 				        .ENDL
   196 				        .ENDM
   197
   198 				; ATR Header
   199 				;        ORG     $0700
   200 					    ORG	    $06f0
   201 				        OPT     h-
   202 06F0 96 02 80 16 80		    DTA	    $96,$02,$80,$16,$80
   203 06F5 00 00 00 00 00 00 + :11     DTA	    $00
   204
   205 				;;; Initialization ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   206
   207 				;        ORG     $0700
   208 				;        OPT     h-
   209
   210 0700 00			HDR:    .BYTE   $00                 ; BLFAG: Boot flag equals zero (unused)
   211 0701 22			        .BYTE   [BOOTEND-HDR]/128   ; BRCNT: Number of consecutive sectors to read
   212 0702 00 07		        .WORD   HDR                 ; BLDADR: Boot sector load address ($700).
   213 0704 C0 E4		        .WORD   $E4C0               ; BIWTARR: Init addr (addr of RTS in ROM)
   214
   215 				;HDR:    .BYTE   $00                 ; BLFAG: Boot flag equals zero (unused)
   216 				;        .BYTE   [PGEND-HDR]/128-2   ; BRCNT: Number of consecutive sectors to read
   217 				;        .WORD   $0700               ; BLDADR: Boot sector load address ($700).
   218 				;        .WORD   $E4C0               ; BIWTARR: Init addr (addr of RTS in ROM)
   219
   220 0706 4C 09 07			    JMP	    START
   221 				;	ORG	*+$64
   222
   223 0709 A5 0C		START:  LDA     DOSINI
   224 070B 8D 27 07		        STA     RESET+1
   225 070E A5 0D		        LDA     DOSINI+1
   226 0710 8D 28 07		        STA     RESET+2
   227
   228 0713 A9 26		        LDA     #<RESET
   229 0715 85 0C		        STA     DOSINI
   230 0717 A9 07		        LDA     #>RESET
   231 0719 85 0D		        STA     DOSINI+1
   232 071B A9 CE		        LDA     #<DOS       ; Point to DOS & CP below
   233 071D 85 0A		        STA     DOSVEC
   234 071F A9 0A		        LDA     #>DOS
   235 0721 85 0B		        STA     DOSVEC+1
   236
   237 0723 4C 39 07		        JMP     ALTMEML     ; Alter MEMLO
   238
   239 0726 20 FF FF		RESET:  JSR     $FFFF       ; Jump to extant DOSINI
   240
   241 0729 A9 4E		        LDA     #'N'
   242 072B 8D 00 18		        STA     RBUF
   243 072E 20 44 07		        JSR     IHTBS       ; Insert into HATABS
   244
   245 0731 A9 44		        LDA     #'D'
   246 0733 8D 00 18		        STA     RBUF
   247 0736 20 44 07		        JSR     IHTBS       ; Clone N: as D: for compatibility
   248
   249 				;---------------------------------------
   250 				;  Alter MEMLO
   251 				;---------------------------------------
   252 0739			ALTMEML:
   253 0739 A9 00		        LDA     #<PGEND
   254 073B 8D E7 02		        STA     MEMLO
   255 073E A9 19		        LDA     #>PGEND
   256 0740 8D E8 02		        STA     MEMLO+1
   257
   258 				        ;; Back to DOS
   259
   260 0743 60			        RTS
   261
   262 				;---------------------------------------
   263 				; Insert entry into HATABS
   264 				;---------------------------------------
   265
   266 0744			IHTBS:
   267 0744 A0 00		        LDY     #$00
   268 0746 B9 1A 03		IH1     LDA     HATABS,Y
   269 0749 F0 0C		        BEQ     HFND
   270 				        ;CMP     #'N'
   271 074B CD 00 18		        CMP     RBUF
   272 074E F0 07		        BEQ     HFND
   273 0750 C8			        INY
   274 0751 C8			        INY
   275 0752 C8			        INY
   276 0753 C0 21		        CPY     #11*3
   277 0755 90 EF		        BCC     IH1
   278
   279 				        ;; Found a slot
   280
   281 0757			HFND:
   282 				        ;LDA     #'N'
   283 				;--
   284 0757 AD 00 18		        LDA     RBUF
   285 075A AA			        TAX
   286 				;--
   287 075B 99 1A 03		        STA     HATABS,Y
   288 075E A9 19		        LDA     #<CIOHND
   289 0760 99 1B 03		        STA     HATABS+1,Y
   290 0763 A9 17		        LDA     #>CIOHND
   291 0765 99 1C 03		        STA     HATABS+2,Y
   292
   293 0768 E0 44		        CPX     #'D'
   294 076A F0 01		        BEQ     HATABS_CONT
   295 076C 60			        RTS
   296
   297 076D			HATABS_CONT:
   298 				        ;; And we're done with HATABS
   299
   300 				        ;; Query FUJINET
   301
   302 076D 20 24 09		        JSR     STPOLL
   303
   304 				        ;; Output Ready/Error
   305
   306 0770			OBANR:
   307 0770 A2 00		        LDX     #$00        ; IOCB #0
   308 0772 A9 09		        LDA     #PUTREC
   309 0774 9D 42 03		        STA     ICCOM,X
   310 0777 A9 28		        LDA     #$28        ; 40 CHARS Max
   311 0779 9D 48 03		        STA     ICBLL,X
   312 077C 8A			        TXA
   313 077D 9D 49 03		        STA     ICBLH,X
   314 0780 AD 03 03		        LDA     DSTATS      ; Check DSTATS
   315 0783 10 06		        BPL     OBRDY       ; < 128 = Ready
   316
   317 				        ;; Status returned error.
   318
   319 0785			OBERR:
   320 0785 A9 3F		        LDA     #<BERROR
   321 0787 A0 17		        LDY     #>BERROR
   322 0789 50 04		        BVC     OBCIO
   323
   324 				        ;; Status returned ready.
   325
   326 078B			OBRDY:
   327 078B A9 25		        LDA     #<BREADY
   328 078D A0 17		        LDY     #>BREADY
   329
   330 078F			OBCIO:
   331 078F 9D 44 03		        STA     ICBAL,X
   332 0792 98			        TYA
   333 0793 9D 45 03		        STA     ICBAH,X
   334
   335 0796 20 56 E4		        JSR     CIOV
   336
   337 				        ;; Vector in proceed interrupt
   338
   339 0799			SPRCED:
   340 0799 A9 5D		        LDA     #<PRCVEC
   341 079B 8D 02 02		        STA     VPRCED
   342 079E A9 0A		        LDA     #>PRCVEC
   343 07A0 8D 03 02		        STA     VPRCED+1
   344
   345 				        ;; And we are done, back to DOS.
   346 07A3 18			        CLC
   347 07A4 60			        RTS
   348
   349 				;;; End Initialization Code ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   350
   351 				; Copy command's template DCB struct to OS's DCB struct (12 bytes)
   352 07A5			DOSIOV:
   353 07A5 8D AE 07		        STA     DODCBL+1
   354 07A8 8C AF 07		        STY     DODCBL+2
   355 07AB A0 0C		        LDY     #$0C
   356 07AD B9 FF FF		DODCBL  LDA     $FFFF,Y
   357 07B0 99 00 03		        STA     DCB,Y
   358 07B3 88			        DEY
   359 07B4 10 F7		        BPL     DODCBL
   360
   361 07B6			SIOVDST:
   362 07B6 20 59 E4		        JSR     SIOV
   363 07B9 AC 03 03		        LDY     DSTATS
   364 07BC 98			        TYA
   365 07BD 60			        RTS
   366
   367
   368 				;---------------------------------------
   369 				; CIO OPEN
   370 				;---------------------------------------
   371
   372 07BE			OPEN:
   373 				        ;; Prepare DCB
   374
   375 07BE 20 59 0A		        JSR     GDIDX       ; Get Device ID in X (0-3)
   376 07C1 A5 21		        LDA     ZICDNO      ; IOCB UNIT # (1-4)
   377 07C3 8D 01 08		        STA     OPNDCB+1    ; Store in DUNIT
   378 07C6 A5 24		        LDA     ZICBAL      ; Get filename buffer
   379 07C8 8D 04 08		        STA     OPNDCB+4    ; stuff in DBUF
   380 07CB A5 25		        LDA     ZICBAH      ; ...
   381 07CD 8D 05 08		        STA     OPNDCB+5    ; ...
   382 07D0 A5 2A		        LDA     ZICAX1      ; Get desired AUX1/AUX2
   383 07D2 8D 0A 08		        STA     OPNDCB+10   ; Save them, and store in DAUX1/DAUX2
   384 07D5 A5 2B		        LDA     ZICAX2      ; ...
   385 07D7 8D 0B 08		        STA     OPNDCB+11   ; ...
   386
   387 				        ;;  Copy DCB template to DCB
   388
   389 07DA A9 00		        LDA     #<OPNDCB
   390 07DC A0 08		        LDY     #>OPNDCB
   391
   392 				        ;;  Send to #FujiNet
   393
   394 07DE 20 A5 07		        JSR     DOSIOV
   395
   396 				        ;; Return DSTATS, unless 144, then get extended error
   397
   398 07E1			OPCERR:
   399 07E1 C0 90		        CPY     #$90        ; ERR 144?
   400 07E3 D0 06		        BNE     OPDONE      ; NOPE. RETURN DSTATS
   401
   402 				        ;; 144 - get extended error
   403
   404 07E5 20 24 09		        JSR     STPOLL      ; POLL FOR STATUS
   405 07E8 AC ED 02		        LDY     DVSTAT+3
   406
   407 				       ; RESET BUFFER LENGTH + OFFSET
   408
   409 07EB			OPDONE:
   410 07EB A9 01		        LDA     #$01
   411 07ED 8D 5D 17		        STA     TRIP
   412 07F0 20 59 0A		        JSR     GDIDX
   413 07F3 A9 00		        LDA     #$00
   414 07F5 9D 5E 17		        STA     RLEN,X
   415 07F8 9D 66 17		        STA     TOFF,X
   416 07FB 9D 62 17		        STA     ROFF,X
   417 07FE 98			        TYA
   418 07FF 60			        RTS                ; AY = ERROR
   419
   420 0800			OPNDCB:
   421 0800 71			        .BYTE   DEVIDN  ; DDEVIC
   422 0801 FF			        .BYTE   $FF     ; DUNIT
   423 0802 4F			        .BYTE   'O'     ; DCOMND
   424 0803 80			        .BYTE   $80     ; DSTATS
   425 0804 FF			        .BYTE   $FF     ; DBUFL
   426 0805 FF			        .BYTE   $FF     ; DBUFH
   427 0806 0F			        .BYTE   $0F     ; DTIMLO
   428 0807 00			        .BYTE   $00     ; DRESVD
   429 0808 00			        .BYTE   $00     ; DBYTL
   430 0809 01			        .BYTE   $01     ; DBYTH
   431 080A FF			        .BYTE   $FF     ; DAUX1
   432 080B FF			        .BYTE   $FF     ; DAUX2
   433
   434 				; End CIO OPEN
   435 				;---------------------------------------
   436
   437 				;---------------------------------------
   438 				; CIO CLOSE 
   439 				;---------------------------------------
   440
   441 080C			CLOSE:
   442 080C 20 50 0A		        JSR     DIPRCD      ; Disable Interrupts
   443 080F 20 59 0A		        JSR     GDIDX
   444 0812 20 AF 08		        JSR     PFLUSH      ; Do a Put Flush if needed.
   445
   446 0815 A5 21		        LDA     ZICDNO      ; IOCB Unit #
   447 0817 8D 22 08		        STA     CLODCB+1    ; to DCB...
   448
   449 081A A9 21		        LDA     #<CLODCB
   450 081C A0 08		        LDY     #>CLODCB
   451
   452 081E 4C A5 07		        JMP     DOSIOV
   453
   454 0821 71			CLODCB .BYTE    DEVIDN      ; DDEVIC
   455 0822 FF			       .BYTE    $FF         ; DUNIT
   456 0823 43			       .BYTE    'C'         ; DCOMND
   457 0824 00			       .BYTE    $00         ; DSTATS
   458 0825 00			       .BYTE    $00         ; DBUFL
   459 0826 00			       .BYTE    $00         ; DBUFH
   460 0827 0F			       .BYTE    $0F         ; DTIMLO
   461 0828 00			       .BYTE    $00         ; DRESVD
   462 0829 00			       .BYTE    $00         ; DBYTL
   463 082A 00			       .BYTE    $00         ; DBYTH
   464 082B 00			       .BYTE    $00         ; DAUX1
   465 082C 00			       .BYTE    $00         ; DAUX2
   466
   467 				; End CIO CLOSE
   468 				;---------------------------------------
   469
   470 				;---------------------------------------
   471 				; CIO GET
   472 				;---------------------------------------
   473
   474 082D 20 59 0A		GET:    JSR     GDIDX       ; IOCB UNIT #-1 into X
   475 0830 BD 5E 17		        LDA     RLEN,X      ; Get # of RX chars waiting
   476 0833 D0 2B		        BNE     GETDISC     ; LEN > 0?
   477
   478 				        ;; If RX buffer is empty, get # of chars waiting...
   479
   480 0835 20 24 09		        JSR     STPOLL      ; Status Poll
   481 0838 20 59 0A		        JSR     GDIDX       ; IOCB UNIT -1 into X (because Poll trashes X)
   482 083B AD EA 02		        LDA     DVSTAT      ; # of bytes waiting (0-127)
   483 083E 9D 5E 17		        STA     RLEN,X      ; Store in RX Len
   484 0841 F0 22		        BEQ     RETEOF
   485
   486 0843 A5 21		GETDO:  LDA     ZICDNO      ; Get IOCB UNIT #
   487 0845 8D 83 08		        STA     GETDCB+1    ; Store into DUNIT
   488 0848 AD EA 02		        LDA     DVSTAT      ; # of bytes waiting
   489 084B 8D 8A 08		        STA     GETDCB+8    ; Store into DBYT...
   490 084E 8D 8C 08		        STA     GETDCB+10   ; and DAUX1...
   491
   492 0851 A9 82		        LDA     #<GETDCB
   493 0853 A0 08		        LDY     #>GETDCB
   494
   495 0855 20 A5 07		        JSR     DOSIOV
   496
   497 				        ;; Clear the Receive buffer offset.
   498
   499 0858 20 59 0A		        JSR     GDIDX       ; IOCB UNIT #-1 into X
   500 085B A9 00		        LDA     #$00
   501 085D 9D 62 17		        STA     ROFF,X
   502
   503 0860			GETDISC:
   504 				        ;LDA     DVSTAT+2    ; Did we disconnect?
   505 0860 AD ED 02		        LDA     DVSTAT+3    ; Did we disconnect?
   506 0863 D0 04		        BNE     GETUPDP     ; nope, update the buffer cursor.
   507
   508 				        ;; We disconnected, emit an EOF.
   509
   510 0865			RETEOF:
   511 0865 A0 88		        LDY     #EOF
   512 0867 98			        TYA
   513 0868 60			        RTS                 ; buh-bye.
   514
   515 0869			GETUPDP:
   516 0869 DE 5E 17		        DEC     RLEN,X      ; Decrement RX length.
   517 086C BC 62 17		        LDY     ROFF,X      ; Get RX offset cursor.
   518
   519 				        ;; Return Next char from appropriate RX buffer.
   520
   521 086F B9 00 18		        LDA     RBUF,Y
   522
   523 				        ;; Increment RX offset
   524
   525 0872 FE 62 17		GX:     INC     ROFF,X      ; Increment RX offset.
   526 0875 A8			        TAY                 ; stuff returned val into Y temporarily.
   527
   528 				        ;; If requested RX buffer is empty, reset TRIP.
   529
   530 0876 BD 5E 17		        LDA     RLEN,X
   531 0879 D0 03		        BNE     GETDONE
   532 087B 8D 5D 17		        STA     TRIP
   533
   534 				        ;; Return byte back to CIO.
   535
   536 087E			GETDONE:
   537 087E 98			        TYA                 ; Move returned val back.
   538 087F A0 01		        LDY     #$01        ; SUCCESS
   539
   540 0881 60			        RTS                 ; DONE...
   541
   542 0882			GETDCB:
   543 0882 71			       .BYTE    DEVIDN      ; DDEVIC
   544 0883 FF			       .BYTE    $FF         ; DUNIT
   545 0884 52			       .BYTE    'R'         ; DCOMND
   546 0885 40			       .BYTE    $40         ; DSTATS
   547 0886 00			       .BYTE    <RBUF       ; DBUFL
   548 0887 18			       .BYTE    >RBUF       ; DBUFH
   549 0888 0F			       .BYTE    $0F         ; DTIMLO
   550 0889 00			       .BYTE    $00         ; DRESVD
   551 088A FF			       .BYTE    $FF         ; DBYTL
   552 088B 00			       .BYTE    $00         ; DBYTH
   553 088C FF			       .BYTE    $FF         ; DAUX1
   554 088D 00			       .BYTE    $00         ; DAUX2
   555
   556 				; End CIO GET
   557 				;---------------------------------------
   558
   559 				;---------------------------------------
   560 				; CIO PUT
   561 				;---------------------------------------
   562
   563 088E			PUT:    ;; Add to TX buffer.
   564
   565 088E 20 59 0A		        JSR     GDIDX
   566 0891 BC 66 17		        LDY     TOFF,X      ; GET TX cursor.
   567 0894 99 80 18		        STA     TBUF,Y      ; TX Buffer
   568
   569 0897 FE 66 17		POFF:   INC     TOFF,X      ; Increment TX cursor
   570 089A A0 01		        LDY     #$01        ; SUCCESSFUL
   571
   572 				        ;; Do a PUT FLUSH if EOL or buffer full.
   573
   574 089C C9 9B		        CMP     #EOL        ; EOL?
   575 089E F0 0B		        BEQ     FLUSH       ; FLUSH BUFFER
   576 08A0 20 59 0A		        JSR     GDIDX       ; GET OFFSET
   577 08A3 BD 66 17		        LDA     TOFF,X
   578 08A6 C9 7F		        CMP     #$7F        ; LEN = $FF?
   579 08A8 F0 01		        BEQ     FLUSH       ; FLUSH BUFFER
   580 08AA 60			        RTS
   581
   582 				       ; FLUSH BUFFER, IF ASKED.
   583
   584 08AB 20 AF 08		FLUSH:  JSR     PFLUSH      ; FLUSH BUFFER
   585 08AE 60			        RTS
   586
   587 08AF			PFLUSH:
   588
   589 				       ; CHECK CONNECTION, AND EOF
   590 				       ; IF DISCONNECTED.
   591
   592 08AF 20 24 09		        JSR     STPOLL      ; GET STATUS
   593 08B2 AD ED 02		        LDA     DVSTAT+3
   594 08B5 F0 AE		        BEQ     RETEOF
   595
   596 08B7 20 59 0A		PF1:    JSR     GDIDX       ; GET DEV X
   597 08BA BD 66 17		        LDA     TOFF,X
   598 08BD D0 03		        BNE     PF2
   599 08BF 4C DF 08		        JMP     PDONE
   600
   601 				       ; FILL OUT DCB FOR PUT FLUSH
   602
   603 08C2 A5 21		PF2:    LDA     ZICDNO
   604 08C4 8D E3 08		        STA     PUTDCB+1
   605
   606 				       ; FINISH DCB AND DO SIOV
   607
   608 08C7 BD 66 17		TBX:    LDA     TOFF,X
   609 08CA 8D EA 08		        STA     PUTDCB+8
   610 08CD 8D EC 08		        STA     PUTDCB+10
   611
   612 08D0 A9 E2		        LDA     #<PUTDCB
   613 08D2 A0 08		        LDY     #>PUTDCB
   614 08D4 20 A5 07		        JSR     DOSIOV
   615
   616 				        ; CLEAR THE OFFSET CURSOR
   617 				        ; AND LENGTH
   618
   619 08D7 20 59 0A		        JSR     GDIDX
   620 08DA A9 00		        LDA     #$00
   621 08DC 9D 66 17		        STA     TOFF,X
   622
   623 08DF A0 01		PDONE:  LDY     #$01
   624 08E1 60			        RTS
   625
   626 08E2 71			PUTDCB .BYTE    DEVIDN      ; DDEVIC
   627 08E3 FF			       .BYTE    $FF         ; DUNIT
   628 08E4 57			       .BYTE    'W'         ; DCOMND
   629 08E5 80			       .BYTE    $80         ; DSTATS
   630 08E6 80			       .BYTE    $80         ; DBUFL
   631 08E7 18			       .BYTE    >TBUF       ; DBUFH
   632 08E8 0F			       .BYTE    $0F         ; DTIMLO
   633 08E9 00			       .BYTE    $00         ; DRESVD
   634 08EA FF			       .BYTE    $FF         ; DBYTL
   635 08EB 00			       .BYTE    $00         ; DBYTH
   636 08EC FF			       .BYTE    $FF         ; DAUX1
   637 08ED 00			       .BYTE    $00         ; DAUX2
   638
   639 				; End CIO PUT
   640 				;---------------------------------------
   641
   642 				;---------------------------------------
   643 				; CIO STATUS 
   644 				;---------------------------------------
   645
   646 08EE 20 47 0A		STATUS: JSR     ENPRCD      ; ENABLE PRCD
   647 08F1 20 59 0A		        JSR     GDIDX       ; GET DEVICE#
   648 08F4 BD 5E 17		        LDA     RLEN,X      ; GET RLEN
   649 08F7 D0 05		        BNE     STSLEN      ; RLEN > 0?
   650 08F9 AD 5D 17		        LDA     TRIP
   651 08FC D0 15		        BNE     STTRI1      ; TRIP = 1?
   652
   653 				        ; NO TRIP, RETURN SAVED LEN
   654
   655 08FE BD 5E 17		STSLEN: LDA     RLEN,X      ; GET RLEN
   656 0901 8D EA 02		        STA     DVSTAT      ; RET IN DVSTAT
   657
   658 				        ; If you don't need to preserve Y then use it instead of A
   659 0904 A9 00		        LDA     #$00
   660 0906 8D EB 02		        STA     DVSTAT+1
   661
   662 				        ; and INY here
   663 0909 A9 01		        LDA     #$01
   664 090B 8D EC 02		        STA     DVSTAT+2
   665 090E 8D ED 02		        STA     DVSTAT+3
   666
   667 0911 D0 0B		        BNE     STDONE
   668
   669 				        ; DO POLL AND UPDATE RCV LEN
   670
   671 0913 20 24 09		STTRI1: JSR     STPOLL      ; POLL FOR ST
   672 0916 9D 5E 17		        STA     RLEN,X
   673
   674 				        ; UPDATE TRIP FLAG
   675
   676 0919 D0 03		STTRIU: BNE     STDONE
   677 091B 8D 5D 17		        STA     TRIP        ; RLEN = 0
   678
   679 				        ; RETURN CONNECTED? FLAG.
   680
   681 091E AD EC 02		STDONE: LDA     DVSTAT+2
   682 0921 A0 01		        LDY     #$01
   683 0923 60			        RTS
   684
   685 				       ; ASK FUJINET FOR STATUS
   686
   687 0924			STPOLL:
   688 0924 A5 21		        LDA     ZICDNO      ; IOCB #
   689 0926 8D 49 09		        STA     STADCB+1
   690
   691 0929 A9 48		        LDA     #<STADCB
   692 092B A0 09		        LDY     #>STADCB
   693
   694 092D 20 A5 07		        JSR     DOSIOV
   695
   696 				        ;; > 127 bytes? make it 127 bytes.
   697
   698 0930 AD EB 02		        LDA     DVSTAT+1
   699 0933 D0 07		        BNE     STADJ
   700 0935 AD EA 02		        LDA     DVSTAT
   701 0938 30 02		        BMI     STADJ
   702 093A 50 08		        BVC     STP2        ; <= 127 bytes...
   703
   704 093C A9 7F		STADJ   LDA     #$7F
   705 093E 8D EA 02		        STA     DVSTAT
   706 				        
   707 0941 8D EB 02		        STA     DVSTAT+1
   708
   709 				       ; A = CONNECTION STATUS
   710
   711 0944 AD EC 02		STP2:   LDA     DVSTAT+2
   712 0947 60			        RTS
   713
   714 0948 71			STADCB: .BYTE   DEVIDN      ; DDEVIC
   715 0949 FF			        .BYTE   $FF         ; DUNIT
   716 094A 53			        .BYTE   'S'         ; DCOMND
   717 094B 40			        .BYTE   $40         ; DSTATS
   718 094C EA			        .BYTE   <DVSTAT     ; DBUFL
   719 094D 02			        .BYTE   >DVSTAT     ; DBUFH
   720 094E 0F			        .BYTE   $0F         ; DTIMLO
   721 094F 00			        .BYTE   $00         ; DRESVD
   722 0950 04			        .BYTE   $04         ; DBYTL
   723 0951 00			        .BYTE   $00         ; DBYTH
   724 0952 00			        .BYTE   $00         ; DAUX1
   725 0953 00			        .BYTE   $00         ; DAUX2
   726
   727 				; End CIO STATUS
   728 				;---------------------------------------
   729
   730 				;---------------------------------------
   731 				; CIO SPECIAL
   732 				;---------------------------------------
   733
   734 0954			SPEC:   ; HANDLE LOCAL COMMANDS.
   735
   736 0954 A5 22		        LDA     ZICCOM
   737 0956 C9 0F		        CMP     #$0F        ; 15 = FLUSH
   738 0958 D0 06		        BNE     S1          ; NO.
   739 095A 20 AF 08		        JSR     PFLUSH      ; DO FLUSH
   740 095D A0 01		        LDY     #$01        ; SUCCESS
   741 095F 60			        RTS
   742
   743 0960 C9 28		S1:     CMP     #40         ; 40 = LOAD AND EXECUTE
   744 0962 F0 03		        BEQ     S2          ; YES.
   745 0964 4C 68 09		        JMP     S3          ; NO. SKIP OVER spec40
   746
   747 0967 60			S2:     RTS
   748 				       ; HANDLE SIO COMMANDS.
   749 				       ; GET DSTATS FOR COMMAND
   750 0968			S3:
   751 0968 A5 21		        LDA     ZICDNO
   752 096A 8D B0 09		        STA     SPEDCB+1
   753 096D A5 22		        LDA     ZICCOM
   754 096F 8D B9 09		        STA     SPEDCB+10
   755
   756 0972 A9 AF		        LDA     #<SPEDCB
   757 0974 A0 09		        LDY     #>SPEDCB
   758 0976 20 A5 07		        JSR     DOSIOV
   759
   760 0979 30 0A		        BMI     :DSERR
   761
   762 				       ; WE GOT A DSTATS INQUIRY
   763 				       ; IF $FF, THE COMMAND IS
   764 				       ; INVALID
   765
   766 097B AD 6A 17		DSOK:   LDA     INQDS
   767 097E C9 FF		        CMP     #$FF        ; INVALID?
   768 0980 D0 04		        BNE     DSGO        ; DO THE CMD
   769 0982 A0 92		        LDY     #$92        ; UNIMP CMD
   770 0984 98			        TYA
   771 0985			DSERR:
   772 0985 60			        RTS
   773
   774 				        ;; Do the special, since we want to pass in all the IOCB
   775 				        ;; Parameters to the DCB, This is being done long-hand.
   776
   777 0986 A5 22		DSGO:   LDA     ZICCOM
   778 0988 48			        PHA
   779 0989 A9 00		        LDA     #$00
   780 098B 48			        PHA
   781 098C AD 6A 17		        LDA     INQDS
   782 098F 48			        PHA
   783 0990 A9 01		        LDA     #$01
   784 0992 48			        PHA
   785 0993 A5 24		        LDA     ZICBAL
   786 0995 48			        PHA
   787 0996 A5 2A		        LDA     ZICAX1
   788 0998 48			        PHA
   789 0999 A5 25		        LDA     ZICBAH
   790 099B 48			        PHA
   791 099C A5 2B		        LDA     ZICAX2
   792 099E 48			        PHA
   793 099F A0 03		        LDY     #$03
   794 09A1			DSGOL:
   795 09A1 68			        PLA
   796 09A2 99 08 03		        STA     DBYTL,Y
   797 09A5 68			        PLA
   798 09A6 99 02 03		        STA     DCOMND,Y
   799 09A9 88			        DEY
   800 09AA 10 F5		        BPL     DSGOL
   801
   802 09AC 4C B6 07		        JMP     SIOVDST
   803
   804 				        ;; Return DSTATS in Y and A
   805
   806 09AF 71			SPEDCB  .BYTE   DEVIDN      ; DDEVIC
   807 09B0 FF			        .BYTE   $FF         ; DUNIT
   808 09B1 FF			        .BYTE   $FF         ; DCOMND ; inq
   809 09B2 40			        .BYTE   $40         ; DSTATS
   810 09B3 6A			        .BYTE   <INQDS      ; DBUFL
   811 09B4 17			        .BYTE   >INQDS      ; DBUFH
   812 09B5 0F			        .BYTE   $0F         ; DTIMLO
   813 09B6 00			        .BYTE   $00         ; DRESVD
   814 09B7 01			        .BYTE   $01         ; DBYTL
   815 09B8 00			        .BYTE   $00         ; DBYTH
   816 09B9 FF			        .BYTE   $FF         ; DAUX1
   817 09BA FF			        .BYTE   $FF         ; DAUX2
   818
   819 				; End CIO SPECIAL
   820 				;---------------------------------------
   821
   822 				;#######################################
   823 				;#                                     #
   824 				;#             CIO Functions           # 
   825 				;#                                     #
   826 				;#######################################
   827
   828
   829 				;---------------------------------------
   830 09BB			CIOCLOSE:
   831 				;---------------------------------------
   832 				    ; X must contain IOCB offset ($10,$20,..)
   833 09BB A9 0C		        LDA     #$0C            ; Close #1 first
   834 09BD 9D 42 03		        STA     ICCOM,X
   835 09C0 4C 56 E4		        JMP     CIOV
   836
   837 				;---------------------------------------
   838 09C3			CIOOPEN:
   839 				;---------------------------------------
   840 				    ; Input: 
   841 				    ; X = IOCB offset ($10,$20,..)
   842 				    ; Y = data direction (4=inp,8=out,12=i/o)
   843 				    ; INBUFF contains ICBAL/H
   844 09C3 A9 03		        LDA     #$03            ; 3 = CIO 'OPEN FILE'
   845 09C5 9D 42 03		        STA     ICCOM,X
   846 09C8 A5 F3		        LDA     INBUFF          ; Pointer to filename
   847 09CA 9D 44 03		        STA     ICBAL,X
   848 09CD A5 F4		        LDA     INBUFF+1        ; Pointer to filename
   849 09CF 9D 45 03		        STA     ICBAH,X
   850 09D2 98			        TYA
   851 09D3 9D 4A 03		        STA     ICAX1,X         ; Data direction
   852 09D6 A9 00		        LDA     #$00
   853 09D8 9D 4B 03		        STA     ICAX2,X         ; Unused
   854 09DB 20 56 E4		        JSR     CIOV            ; Call CIO
   855
   856 09DE			CIOOPEN_DONE:
   857 09DE 60			        RTS
   858
   859 				;---------------------------------------
   860 09DF			CIOSTATUS:
   861 				;---------------------------------------
   862 09DF A9 0D		        LDA     #$0D
   863 09E1 9D 42 03		        STA     ICCOM,X
   864 09E4 20 56 E4		        JSR     CIOV
   865 09E7 10 03		        BPL     CIOSTATUS_DONE
   866 09E9 20 96 0A		        JSR     PRINT_ERROR
   867
   868 09EC			CIOSTATUS_DONE:
   869 09EC 60			        RTS
   870 				        
   871
   872 				;---------------------------------------
   873 09ED			CIOGET:
   874 				;---------------------------------------
   875 				    ; Input: 
   876 				    ; X = IOCB offset ($10,$20,..)
   877 				    ; A = ICBLL
   878 				    ; Y = ICBLH
   879 				    ; INBUFF contains ICBAL/H
   880 09ED 48			        PHA                 ; Stash Buffer length Lo
   881 09EE A9 07		        LDA     #$07        ; GET BYTES command
   882 09F0 9D 42 03		        STA     ICCOM,X
   883 09F3 A5 F3		        LDA     INBUFF      ; Get buffer addr from pointer
   884 09F5 9D 44 03		        STA     ICBAL,X
   885 09F8 A5 F4		        LDA     INBUFF+1
   886 09FA 9D 45 03		        STA     ICBAH,X
   887 09FD 68			        PLA                 ; Retrieve Buffer length Lo
   888 09FE 9D 48 03		        STA     ICBLL,X
   889 0A01 98			        TYA                 ; Get Buffer length Hi
   890 0A02 9D 49 03		        STA     ICBLH,X
   891 0A05 20 56 E4		        JSR     CIOV        ; Bon voyage
   892 0A08 10 00		        BPL     CIOGET_DONE
   893 				;        JMP     PRINT_ERROR
   894
   895 0A0A			CIOGET_DONE:
   896 0A0A 60			        RTS
   897
   898 				;---------------------------------------
   899 0A0B			CIOPUT:
   900 				;---------------------------------------
   901 				    ; Input: 
   902 				    ; X = IOCB offset ($10,$20,..)
   903 				    ; A = ICBLL
   904 				    ; Y = ICBLH
   905 				    ; INBUFF contains ICBAL/H
   906 0A0B 48			        PHA                 ; Stash Buffer length Lo
   907 0A0C A9 0B		        LDA     #$0B        ; PUT BYTES command
   908 0A0E 9D 42 03		        STA     ICCOM,X
   909 0A11 A5 F3		        LDA     INBUFF      ; Get buffer addr from pointer
   910 0A13 9D 44 03		        STA     ICBAL,X
   911 0A16 A5 F4		        LDA     INBUFF+1
   912 0A18 9D 45 03		        STA     ICBAH,X
   913 0A1B 68			        PLA                 ; Retrieve Buffer length Lo
   914 0A1C 9D 48 03		        STA     ICBLL,X
   915 0A1F 98			        TYA                 ; Get Buffer length Hi
   916 0A20 9D 49 03		        STA     ICBLH,X
   917 0A23 20 56 E4		        JSR     CIOV        ; Bon voyage
   918 0A26 10 00		        BPL     CIOPUT_DONE
   919 				;        JMP     PRINT_ERROR
   920
   921 0A28			CIOPUT_DONE:
   922 0A28 60			        RTS
   923
   924 				;---------------------------------------
   925 0A29			CIOGETREC:
   926 				;---------------------------------------
   927 				    ; Input: 
   928 				    ; X = IOCB offset ($10,$20,..)
   929 				    ; A = ICBLL
   930 				    ; Y = ICBLH
   931 				    ; INBUFF contains ICBAL/H
   932 0A29 48			        PHA                 ; Stash Buffer length Lo
   933 0A2A A9 05		        LDA     #$05        ; GET RECORD command
   934 0A2C 9D 42 03		        STA     ICCOM,X
   935 0A2F A5 F3		        LDA     INBUFF      ; Get buffer addr from pointer
   936 0A31 9D 44 03		        STA     ICBAL,X
   937 0A34 A5 F4		        LDA     INBUFF+1
   938 0A36 9D 45 03		        STA     ICBAH,X
   939 0A39 68			        PLA                 ; Retrieve Buffer length Lo
   940 0A3A 9D 48 03		        STA     ICBLL,X
   941 0A3D 98			        TYA                 ; Get Buffer length Hi
   942 0A3E 9D 49 03		        STA     ICBLH,X
   943
   944 0A41 20 56 E4		        JSR     CIOV        ; Bon voyage
   945 0A44 10 00		        BPL     CIOGETREC_DONE
   946 				;        JMP     PRINT_ERROR
   947
   948 0A46			CIOGETREC_DONE:
   949 0A46 60			        RTS
   950
   951 				;#######################################
   952 				;#                                     #
   953 				;#          Utility Functions          #
   954 				;#                                     #
   955 				;#######################################
   956 				        ; ENABLE PROCEED INTERRUPT
   957
   958 0A47 AD 02 D3		ENPRCD: LDA     PACTL
   959 0A4A 09 01		        ORA     #$01        ; ENABLE BIT 0
   960 0A4C 8D 02 D3		        STA     PACTL
   961 0A4F 60			        RTS
   962
   963 				       ; DISABLE PROCEED INTERRUPT
   964
   965 0A50 AD 02 D3		DIPRCD: LDA     PACTL
   966 0A53 29 FE		        AND     #$FE        ; DISABLE BIT0
   967 0A55 8D 02 D3		        STA     PACTL
   968 0A58 60			        RTS
   969
   970 				       ; GET ZIOCB DEVNO - 1 INTO X
   971
   972 0A59 A6 21		GDIDX:  LDX     ZICDNO      ; IOCB UNIT #
   973 0A5B CA			        DEX                 ; - 1
   974 0A5C 60			        RTS
   975
   976 				;---------------------------------------
   977 				; Proceed Vector
   978 				;---------------------------------------
   979
   980 0A5D A9 01		PRCVEC: LDA     #$01
   981 0A5F 8D 5D 17		        STA     TRIP
   982 0A62 68			        PLA
   983 0A63 40			        RTI
   984
   985 				; End Proceed Vector
   986 				;---------------------------------------
   987
   988 				;---------------------------------------
   989 				; Reset LNBUF
   990 				;---------------------------------------
   991 				; Normally this routine is at $DA51
   992 				; But some programs will bank-switch
   993 				; that portion of ROM to RAM
   994 				;---------------------------------------
   995
   996 0A64 A9 05		LDBUFA: LDA     #$05
   997 0A66 85 F4		        STA     INBUFF+1
   998 				;        LDA     #$80
   999 0A68 A9 82		        LDA     #$82
  1000 0A6A 85 F3		        STA     INBUFF
  1001 0A6C 60			        RTS
  1002
  1003 				; End Reset LNBUF
  1004 				;---------------------------------------
  1005
  1006 				;---------------------------------------
  1007 				; Skip spaces
  1008 				;---------------------------------------
  1009 				; Normally this routine is at $DBA1
  1010 				; But some programs will bank-switch
  1011 				; that portion of ROM to RAM
  1012 				;---------------------------------------
  1013
  1014 0A6D A4 F2		SKPSPC: LDY     CIX
  1015 0A6F A9 20		        LDA     #$20
  1016 0A71 D1 F3		@:      CMP     (INBUFF),Y
  1017 0A73 D0 03		        BNE     @+
  1018 0A75 C8			        INY
  1019 0A76 D0 F9		        BNE     @-
  1020 0A78 84 F2		@:      STY     CIX
  1021 0A7A 60			        RTS
  1022
  1023 				; End SKPSPC
  1024 				;---------------------------------------
  1025
  1026 				;---------------------------------------
  1027 				; Print EOL-terminated string
  1028 				; A: String Buffer Lo
  1029 				; Y: String Buffer Hi
  1030 				;---------------------------------------
  1031 0A7B			PRINT_STRING:
  1032
  1033 0A7B A2 00		        LDX     #$00
  1034 				    ;---------------------------------------
  1035 				    ; String Buffer
  1036 				    ;---------------------------------------
  1037 0A7D 9D 44 03		        STA     ICBAL,X
  1038 0A80 98			        TYA
  1039 0A81 9D 45 03		        STA     ICBAH,X
  1040
  1041 				    ;---------------------------------------
  1042 				    ; String Length
  1043 				    ;---------------------------------------
  1044 0A84 A9 80		        LDA     #$80
  1045 0A86 9D 48 03		        STA     ICBLL,X
  1046 0A89 A9 00		        LDA     #$00
  1047 0A8B 9D 49 03		        STA     ICBLH,X
  1048
  1049 				    ;---------------------------------------
  1050 				    ; Call to CIO
  1051 				    ;---------------------------------------
  1052 0A8E A9 09		        LDA     #PUTREC
  1053 0A90 9D 42 03		        STA     ICCOM,X
  1054 0A93 4C 56 E4		        JMP     CIOV
  1055
  1056 				;---------------------------------------
  1057 				; Print integer error number from DOSIOV
  1058 				; Y: Return code from DOSIOV
  1059 				;---------------------------------------
  1060 0A96			PRINT_ERROR:
  1061 0A96 C0 01		        CPY     #$01        ; Exit if success (1)
  1062 0A98 F0 33		        BEQ     PRINT_ERROR_DONE
  1063
  1064 				    ;-----------------------------------
  1065 				    ; If error code = 144, then get
  1066 				    ; extended code from DVSTAT
  1067 				    ;-----------------------------------
  1068 0A9A C0 90		        CPY     #144
  1069 0A9C D0 0A		        BNE     PRINT_ERROR_NEXT
  1070
  1071 0A9E A9 48		        LDA     #<STADCB
  1072 0AA0 A0 09		        LDY     #>STADCB
  1073 0AA2 20 A5 07		        JSR     DOSIOV
  1074 0AA5 AC ED 02		        LDY     DVSTAT+3    ;
  1075
  1076 0AA8			PRINT_ERROR_NEXT:
  1077 				    ;-----------------------------------
  1078 				    ; Convert error code to ASCII
  1079 				    ;-----------------------------------
  1080 0AA8 84 D4		        STY     FR0
  1081 0AAA A9 00		        LDA     #$00
  1082 0AAC 85 D5		        STA     FR0+1
  1083 0AAE 20 AA D9		        JSR     IFP         ; Convert error from int to floating point
  1084 0AB1 20 E6 D8		        JSR     FASC        ; Convert floating point to ASCII
  1085
  1086 				    ;---------------------------------------
  1087 				    ; Find last char in ASCII error (noted by high bit)
  1088 				    ; Unset high bit & append EOL
  1089 				    ;---------------------------------------
  1090 0AB4 A0 FF		        LDY     #$FF        ; Init counter = 0
  1091
  1092 0AB6 C8			@       INY
  1093 0AB7 B1 F3		        LDA     (INBUFF),Y
  1094 0AB9 C9 80		        CMP     #$80
  1095 0ABB 90 F9		        BCC     @-
  1096
  1097 0ABD 29 7F		        AND     #$7F        ; Clear high bit
  1098 0ABF 91 F3		        STA     (INBUFF),Y
  1099 0AC1 C8			        INY
  1100 0AC2 A9 9B		        LDA     #EOL        ; Append EOL
  1101 0AC4 91 F3		        STA     (INBUFF),Y
  1102
  1103 0AC6 A5 F3		        LDA     INBUFF
  1104 0AC8 A4 F4		        LDY     INBUFF+1
  1105 0ACA 4C 7B 0A		        JMP     PRINT_STRING
  1106
  1107 0ACD			PRINT_ERROR_DONE:
  1108 0ACD 60			        RTS
  1109
  1110 				; End Utility Functions
  1111 				;---------------------------------------
  1112
  1113
  1114 				;#######################################
  1115 				;#                                     #
  1116 				;#       COMMAND PROCESSOR (CP)        #
  1117 				;#                                     #
  1118 				;#######################################
  1119
  1120 				;---------------------------------------
  1121 				; DOS Entry point
  1122 				;---------------------------------------
  1123 0ACE			DOS:
  1124 				        ; Bypass Autorun if OPTION switch held
  1125 0ACE AD 1F D0		        LDA     CONSOL
  1126 0AD1 C9 03		        CMP     #OPTION
  1127 0AD3 F0 0D		        BEQ     CPLOOP
  1128 				        ; Autorun injection
  1129 0AD5 A9 10		        LDA     #CMD_IDX.AUTORUN    ; Check for AUTORUN
  1130 0AD7 CD 5C 17		        CMP     AUTORUN_FLG         ; True only on 1st entry
  1131 0ADA F0 06		        BEQ     CPLOOP              ; Skip to Command Processor
  1132 0ADC 8D 5C 17		        STA     AUTORUN_FLG         ; Change flag
  1133 0ADF 20 E1 11		        JSR     SUBMIT_AUTORUN      ; Attempt to execute autorun file
  1134 				       
  1135 0AE2			CPLOOP:
  1136 0AE2 20 E8 0A		        JSR     CP          ; Command Processor
  1137 0AE5 4C E2 0A		        JMP     CPLOOP      ; Keep looping
  1138
  1139
  1140 				;---------------------------------------
  1141 				; Main loop
  1142 				;---------------------------------------
  1143
  1144 0AE8			CP:
  1145 0AE8 A9 FF		        LDA     #$FF        ; Clear command
  1146 0AEA 8D 59 17		        STA     CMD
  1147
  1148 0AED 20 FC 0A		        JSR     SHOWPROMPT
  1149 0AF0 20 21 0B		        JSR     GETCMD
  1150 0AF3			AUTORUN_DO:
  1151 0AF3 20 90 0B		        JSR     PARSECMD
  1152 0AF6 30 03		        BMI     CP_DONE     ; Skip DOCMD if CMD == $FF
  1153 0AF8 20 06 0C		        JSR     DOCMD
  1154 0AFB			CP_DONE:
  1155 0AFB 60			        RTS
  1156
  1157 				;---------------------------------------
  1158 				; Show Command Prompt (Nn:)
  1159 				; Leading EOF requires special CIOV call
  1160 				;---------------------------------------
  1161
  1162 				;---------------------------------------
  1163 0AFC			SHOWPROMPT:
  1164 				;---------------------------------------
  1165
  1166 0AFC AD 58 17		        LDA     DOSDR       ; Get the 1,2,... for N1,N2,...
  1167 0AFF 09 30		        ORA     #'0'        ; Convert, say, 1 to '1'
  1168 0B01 8D E3 15		        STA     PRMPT+2     ; Store in after EOL and N
  1169
  1170 0B04 A2 00		        LDX     #$00
  1171 0B06 A9 0B		        LDA     #PUTCHR
  1172 0B08 9D 42 03		        STA     ICCOM,X
  1173
  1174 0B0B A9 E1		        LDA     #<PRMPT
  1175 0B0D 9D 44 03		        STA     ICBAL,X
  1176 0B10 A9 15		        LDA     #>PRMPT
  1177
  1178 0B12 9D 45 03		        STA     ICBAH,X
  1179 0B15 A9 04		        LDA     #4          ; Prompt length = 4
  1180 0B17 9D 48 03		        STA     ICBLL,X
  1181 0B1A 8A			        TXA                 ; Still zero
  1182 0B1B 9D 49 03		        STA     ICBLH,X
  1183
  1184 0B1E 4C 56 E4		        JMP     CIOV
  1185
  1186 				;---------------------------------------
  1187 0B21			GETCMD:
  1188 				;---------------------------------------
  1189 0B21 A2 00		        LDX     #$00
  1190 0B23 A9 05		        LDA     #GETREC
  1191 0B25 9D 42 03		        STA     ICCOM,X
  1192 0B28 A9 82		        LDA     #<LNBUF
  1193 0B2A 9D 44 03		        STA     ICBAL,X
  1194 0B2D A9 05		        LDA     #>LNBUF
  1195 0B2F 9D 45 03		        STA     ICBAH,X
  1196 0B32 A9 7F		        LDA     #$7F
  1197 0B34 9D 48 03		        STA     ICBLL,X
  1198 0B37 20 56 E4		        JSR     CIOV
  1199
  1200 0B3A			GETCMDTEST:
  1201 0B3A A0 00		        LDY #$00
  1202 0B3C 84 F2		        STY CIX
  1203 0B3E 20 64 0A		        JSR LDBUFA      ; Reset LNBUF to $0580
  1204 0B41 20 6D 0A		        JSR SKPSPC      ; Advance CIX to next space
  1205
  1206 				    ;---------------------------------------
  1207 				    ; CMDSEP is an sequence of bytes contains
  1208 				    ; indexes to chars following spaces
  1209 				    ; Iterate to clear CMDSEP bytes
  1210 				    ;---------------------------------------
  1211 0B44 98			        TYA                 ; A = 0
  1212 0B45 A2 02		        LDX     #$02        ; for X = 2 to 0 step -1
  1213 0B47			GETLOOP:
  1214 0B47 9D 8C 0B		        STA     CMDSEP,X
  1215 0B4A CA			        DEX
  1216 0B4B 10 FA		        BPL     GETLOOP     ; next X
  1217
  1218 				    ; Initial Delimiter to space
  1219 0B4D A9 20		        LDA     #' '
  1220 0B4F 8D 8F 0B		        STA     DELIM
  1221
  1222 				    ;---------------------------------------
  1223 				    ; Loop until EOL is encountered
  1224 				    ;---------------------------------------
  1225 0B52 E8			        INX                 ; Reset X to 0
  1226 0B53			GETCMD_LOOP:
  1227 0B53 B1 F3		        LDA     (INBUFF),Y
  1228 0B55 C9 9B		        CMP     #EOL        ; Found EOL?
  1229 0B57 F0 32		        BEQ     GETCMD_DONE ; yes. skip
  1230 0B59 CD 8F 0B		        CMP     DELIM       ; Found space?
  1231 0B5C F0 03		        BEQ     GETCMD_REPL ; yes. Replace it
  1232 0B5E C8			        INY
  1233 0B5F D0 F2		        BNE     GETCMD_LOOP ; "always" non-zero
  1234
  1235 				    ;---------------------------------------
  1236 				    ; March through the cmd line and note
  1237 				    ; the positions of any args as delimited
  1238 				    ; by spaces or quotes. positions saved
  1239 				    ; in CMDSEP,X
  1240 				    ;---------------------------------------
  1241 0B61			GETCMD_REPL:
  1242 0B61 A9 9B		        LDA     #EOL
  1243 0B63 91 F3		        STA     (INBUFF),Y
  1244 0B65 C8			        INY
  1245 0B66 B1 F3		        LDA     (INBUFF),Y  ; Skip any run of spaces
  1246 0B68 C9 20		        CMP     #' '
  1247 0B6A F0 F5		        BEQ     GETCMD_REPL ; Keep skipping spaces
  1248
  1249 				    ; Here if any run of spaces has ended
  1250 				    ; Are we standing on a double-quote?
  1251 0B6C C9 22		        CMP     #'"'
  1252 0B6E D0 12		        BNE     GETCMD_WR_OFFSET  ; No. Skip ahead
  1253
  1254 				    ; Here if curr char is a double-quote
  1255 0B70 C8			        INY                 ; Advance the command line index
  1256 0B71 A9 22		        LDA     #'"'        ; Is the curr delim a double-quote?
  1257 0B73 CD 8F 0B		        CMP     DELIM       ; If not, change delim to double-quote
  1258 0B76 D0 07		        BNE     GETCMD_DQ_DELIM
  1259
  1260 				    ; Here if curr delim is a double-quote
  1261 				    ; Switch delim to space
  1262 0B78 A9 20		        LDA     #' '
  1263 0B7A 8D 8F 0B		        STA     DELIM
  1264 0B7D D0 03		        BNE     GETCMD_WR_OFFSET
  1265
  1266 				    ; Here if curr delim is space
  1267 				    ; Switch delim to double-quote
  1268 0B7F			GETCMD_DQ_DELIM:
  1269 0B7F 8D 8F 0B		        STA     DELIM
  1270
  1271 				    ; Note the position for the curr command-line arg
  1272 0B82			GETCMD_WR_OFFSET:
  1273 0B82 98			        TYA
  1274 0B83 9D 8C 0B		        STA     CMDSEP,X
  1275 0B86 E8			        INX
  1276 0B87 E0 03		        CPX     #$03
  1277 0B89 90 C8		        BCC     GETCMD_LOOP ; Continue searching
  1278
  1279 0B8B			GETCMD_DONE:
  1280 0B8B 60			        RTS
  1281
  1282 0B8C FF FF FF		CMDSEP: .BYTE $FF,$FF,$FF
  1283 0B8F 20			DELIM:  .BYTE ' '
  1284
  1285 				;---------------------------------------
  1286 0B90			PARSECMD:
  1287 				;---------------------------------------
  1288 0B90 AD 82 05		        LDA     LNBUF
  1289 0B93 C9 9B		        CMP     #EOL        ; Quit immediately if no cmd
  1290 0B95 F0 09		        BEQ     PARSECMD_DONE
  1291
  1292 0B97 20 B5 0B		        JSR     PARSE_INTRINSIC_COMMAND
  1293 0B9A 20 EF 0B		        JSR     PARSE_DRIVE_CHANGE
  1294 0B9D 20 A1 0B		        JSR     PRINT_UNK_CMD
  1295 0BA0			PARSECMD_DONE:
  1296 0BA0 60			        RTS
  1297
  1298 0BA1			PRINT_UNK_CMD:
  1299 0BA1 AD 59 17		        LDA     CMD
  1300 0BA4 C9 FF		        CMP     #$FF
  1301 0BA6 D0 07		        BNE     PRINT_UNK_CMD_DONE
  1302 0BA8 A9 B0		        LDA     #<UNK_CMD_ERR
  1303 0BAA A0 0B		        LDY     #>UNK_CMD_ERR
  1304 0BAC 20 7B 0A		        JSR     PRINT_STRING
  1305 0BAF			PRINT_UNK_CMD_DONE:
  1306 0BAF 60			        RTS
  1307
  1308 0BB0			UNK_CMD_ERR:
  1309 0BB0 43 4D 44 3F 9B	        .BYTE   'CMD?',EOL
  1310
  1311 				;---------------------------------------
  1312 0BB5			PARSE_INTRINSIC_COMMAND:
  1313 				;---------------------------------------
  1314 0BB5 A2 00		        LDX     #$00        ; Initialize X for command code indexing
  1315 0BB7 A0 00		        LDY     #$00
  1316 0BB9 84 F2		        STY     CIX
  1317 0BBB 20 64 0A		        JSR     LDBUFA      ; Set INBUFF to $0580
  1318 0BBE 20 6D 0A		        JSR     SKPSPC      ; Skip whitespace
  1319
  1320 0BC1			PARSE_INTRINSIC_NEXT_CHAR:
  1321 0BC1 B1 F3		        LDA     (INBUFF),Y
  1322 0BC3 29 7F		        AND     #$7F
  1323 0BC5 5D 04 16		        EOR     COMMAND,X   ; X initialized to 0 in caller
  1324 0BC8 C8			        INY
  1325 0BC9 0A			        ASL
  1326 0BCA F0 0B		        BEQ     PARSE_INTRINSIC_CHAR_OK
  1327
  1328 				        ; Skip to next command
  1329
  1330 0BCC			PARSE_INTRINSIC_NEXT_COMMAND:
  1331 0BCC BD 04 16		        LDA     COMMAND,X
  1332 0BCF 0A			        ASL
  1333 0BD0 E8			        INX
  1334 0BD1 90 F9		        BCC     PARSE_INTRINSIC_NEXT_COMMAND
  1335 0BD3 A4 F2		        LDY     CIX
  1336 0BD5 E0 D5		        CPX     #COMMAND_SIZE
  1337
  1338 0BD7			PARSE_INTRINSIC_CHAR_OK:
  1339 0BD7 E8			        INX
  1340 0BD8 90 E7		        BCC     PARSE_INTRINSIC_NEXT_CHAR
  1341 0BDA 84 F2		        STY     CIX
  1342 0BDC B1 F3		        LDA     (INBUFF),Y
  1343 0BDE 30 05		        BMI     PARSE_INTRINSIC_RET
  1344
  1345 0BE0 20 6D 0A		        JSR     SKPSPC
  1346
  1347 0BE3			PARSE_INTRINSIC_RET_ERROR:
  1348 0BE3 A2 D6		        LDX     #COMMAND_SIZE+1
  1349 0BE5			PARSE_INTRINSIC_RET:
  1350 0BE5 BD 04 16		        LDA     COMMAND,X
  1351 0BE8 8D 59 17		        STA     CMD
  1352 0BEB 8D 5A 17		        STA     CMDPRV
  1353 0BEE			PARSE_INTRINSIC_DONE:
  1354 0BEE 60			        RTS
  1355
  1356 				; End of PARSE_INTRINSIC_COMMAND
  1357 				;---------------------------------------
  1358
  1359 				;---------------------------------------
  1360 0BEF			PARSE_DRIVE_CHANGE:
  1361 				;---------------------------------------
  1362 0BEF A2 03		        LDX     #$03        ; Check for EOL in pos 3
  1363 0BF1 BD 82 05		        LDA     LNBUF,X
  1364 0BF4 C9 9B		        CMP     #EOL
  1365 0BF6 D0 0D		        BNE     PARSE_DRIVE_CHANGE_DONE
  1366 0BF8 CA			        DEX                 ; go back one char
  1367 0BF9 BD 82 05		        LDA     LNBUF,X
  1368 0BFC C9 3A		        CMP     #':'        ; Check for colon.
  1369 0BFE D0 05		        BNE     PARSE_DRIVE_CHANGE_DONE
  1370 0C00 A9 1E		        LDA     #CMD_IDX.DRIVE_CHG
  1371 0C02 8D 59 17		        STA     CMD
  1372 0C05			PARSE_DRIVE_CHANGE_DONE:
  1373 0C05 60			        RTS
  1374
  1375 				;---------------------------------------
  1376 0C06			DOCMD:
  1377 				;---------------------------------------
  1378 0C06 AE 59 17		        LDX     CMD
  1379 0C09 30 08		        BMI     DOCMD_DONE      ; Unassigned command = $FF
  1380 0C0B BD FA 16		        LDA     CMD_TAB_H,X     ; Get hi-byte of subroutine's addr
  1381 0C0E 48			        PHA                     ; Push it to the stack
  1382 0C0F BD DB 16		        LDA     CMD_TAB_L,X     ; Get lo-byte of subroutine's addr
  1383 0C12 48			        PHA                     ; Push it to the stack
  1384 0C13			DOCMD_DONE:
  1385 0C13 60			        RTS                     ; Use stack & RTS to jump to subroutine
  1386
  1387 				; End of DOCMD
  1388 				;---------------------------------------
  1389
  1390 				;---------------------------------------
  1391 0C14			DO_DRIVE_CHG:
  1392 				;---------------------------------------
  1393 0C14 AD 82 05		        LDA     LNBUF
  1394 0C17 8D E2 15		        STA     PRMPT+1
  1395 0C1A AD 83 05		        LDA     LNBUF+1
  1396 0C1D C9 31		        CMP     #'1'        ; Skip if '0' or less
  1397 0C1F 90 0A		        BCC     DO_DRIVE_CHG_ERROR
  1398 0C21 C9 39		        CMP     #'9'        ; Skip if '9' or more
  1399 0C23 B0 06		        BCS     DO_DRIVE_CHG_ERROR
  1400 0C25 29 0F		        AND     #$0F        ; Convert, say, to 1-8
  1401 0C27 8D 58 17		        STA     DOSDR
  1402 0C2A 60			        RTS
  1403 0C2B			DO_DRIVE_CHG_ERROR:
  1404 0C2B A9 4E		        LDA     #<CDERR
  1405 0C2D A0 17		        LDY     #>CDERR
  1406 0C2F 4C 7B 0A		        JMP     PRINT_STRING
  1407
  1408 				; End of DOCMD
  1409
  1410 				;---------------------------------------
  1411 				; Returns DOSDR in X
  1412 				; If arg1 contains Nn: then reg X = n
  1413 				; Otherwise X = DOSDR (from curr prompt)
  1414 				;---------------------------------------
  1415 0C32			GET_DOSDR:
  1416 				;---------------------------------------
  1417
  1418 0C32 20 64 0A		        JSR     LDBUFA      ; Reset INBUFF to LNBUF
  1419 0C35 AE 58 17		        LDX     DOSDR       ; Set DUNIT(X) to curr drive
  1420
  1421 				    ;---------------------------------------
  1422 				    ; Consider arg1 = N2:TNFS://localhost/
  1423 				    ; Check arg1 for ":" in 3rd position
  1424 				    ; if found then use char in 2nd position ('2') as DOSDR
  1425 				    ; First, change INBUFF to point to beg. of 1st arg
  1426 				    ;---------------------------------------
  1427 0C38 AD 8C 0B		        LDA     CMDSEP              ; arg offset
  1428 0C3B F0 17		        BEQ     GET_DOSDR_DONE      ; first, if arg1 not pop, leave X as-is & quit
  1429
  1430 0C3D 18			        CLC                         ; Advance pointer to LNBUF
  1431 0C3E 65 F3		        ADC     INBUFF
  1432 0C40 85 F3		        STA     INBUFF
  1433 0C42 90 02		        BCC     GET_DOSDR_NEXT
  1434 0C44 E6 F4		        INC     INBUFF+1
  1435
  1436 0C46			GET_DOSDR_NEXT:
  1437 0C46 A0 02		        LDY     #$02            ; Check for ':' in 3rd pos
  1438 0C48 B1 F3		        LDA     (INBUFF),Y
  1439 0C4A C9 3A		        CMP     #':'
  1440 0C4C D0 06		        BNE     GET_DOSDR_DONE  ; Not found, skip & use default
  1441 0C4E 88			        DEY
  1442 0C4F B1 F3		        LDA     (INBUFF),Y
  1443 0C51 29 0F		        AND     #$0F            ; Convert, say, '2' to 2
  1444 0C53 AA			        TAX                     ; Return DOSDR in X
  1445
  1446 0C54			GET_DOSDR_DONE:
  1447 0C54 60			        RTS
  1448
  1449 				;---------------------------------------
  1450 0C55			DO_GENERIC:
  1451 				;---------------------------------------
  1452
  1453 				    ;---------------------------------------
  1454 				    ; SIO call for NCD,{MK,RM}DIR,DEL,RENAME
  1455 				    ;---------------------------------------
  1456
  1457 				    ;---------------------------------------
  1458 				    ; Get Fujinet SIO command (~ $21 for DEL)
  1459 				    ; X = table index from caller
  1460 				    ;---------------------------------------
  1461 0C55 BD E5 15		        LDA     CMD_DCOMND,X
  1462 0C58 8D B8 0C		        STA     GENDCB+2
  1463
  1464 				    ;---------------------------------------
  1465 				    ; Get DOSDR from either arg1 or curr drive
  1466 				    ;---------------------------------------
  1467 0C5B 20 32 0C		        JSR     GET_DOSDR    ; X will contain int of n in Nn:
  1468 0C5E 8E B7 0C		        STX     GENDCB+1
  1469 0C61 20 8D 15		        JSR     PREPEND_DRIVE
  1470
  1471 				    ;---------------------------------------
  1472 				    ; If this is NCD ensure a '/' char is the last char
  1473 				    ;---------------------------------------
  1474 0C64 AD B8 0C		        LDA     GENDCB+2
  1475 0C67 C9 2C		        CMP     #CMD_CD         ; Is this an NCD command?
  1476 0C69 D0 08		        BNE     DO_GENERIC_NEXT ; No. skip
  1477
  1478 0C6B AD 8C 0B		        LDA     CMDSEP
  1479 0C6E F0 2C		        BEQ     NCD_ERROR
  1480 0C70 20 BA 15		        JSR     APPEND_SLASH    ; Append '/' to path if missing
  1481
  1482 0C73			DO_GENERIC_NEXT:
  1483 				    ;---------------------------------------
  1484 				    ; Populate the DCB
  1485 				    ;---------------------------------------
  1486 0C73 AD 58 17		        LDA     DOSDR
  1487 0C76 8D 49 09		        STA     STADCB+1        ; Yes. Status (not typo)
  1488 				;        STA     GENDCB+1   ; 20221105 - commented-out. checking for bug...
  1489 0C79 A5 F3		        LDA     INBUFF
  1490 0C7B 8D BA 0C		        STA     GENDCB+4
  1491 0C7E A5 F4		        LDA     INBUFF+1
  1492 0C80 8D BB 0C		        STA     GENDCB+5
  1493
  1494 				    ;---------------------------------------
  1495 				    ; Send the command to FujiNet
  1496 				    ;---------------------------------------
  1497 0C83 A9 B6		        LDA     #<GENDCB
  1498 0C85 A0 0C		        LDY     #>GENDCB
  1499 0C87 20 A5 07		        JSR     DOSIOV
  1500 0C8A 20 96 0A		        JSR     PRINT_ERROR
  1501
  1502 0C8D			GEN_UNMOUNT:
  1503 				    ;---------------------------------------
  1504 				    ; if DEL or RENAME, then remount drive
  1505 				    ;---------------------------------------
  1506 0C8D AD 5A 17		        LDA     CMDPRV
  1507 0C90 C9 03		        CMP     #CMD_IDX.DEL
  1508 0C92 F0 04		        BEQ     GEN_REMOUNT
  1509 0C94 C9 0B		        CMP     #CMD_IDX.RENAME
  1510 0C96 D0 03		        BNE     GENDONE
  1511 0C98			GEN_REMOUNT:
  1512 0C98 4C 5A 15		        JMP     REMOUNT_DRIVE
  1513
  1514 0C9B			GENDONE:
  1515 0C9B 60			        RTS
  1516
  1517 				;---------------------------------------
  1518 0C9C			NCD_ERROR:
  1519 				;---------------------------------------
  1520 0C9C A9 B0		        LDA     #<NCD_ERROR_STR
  1521 0C9E A0 0C		        LDY     #>NCD_ERROR_STR
  1522 0CA0 20 7B 0A		        JSR     PRINT_STRING
  1523 0CA3 A0 01		        LDY     #$01        ; Return error
  1524 0CA5 60			        RTS
  1525 				    ;---------------------------------------
  1526 				    ; Close 
  1527 				    ;---------------------------------------
  1528 0CA6 A2 10		        LDX     #$10            ; File #1
  1529 0CA8 A9 0C		        LDA     #$0C            ; Close #1 first
  1530 0CAA 9D 42 03		        STA     ICCOM,X
  1531 0CAD 20 56 E4		        JSR     CIOV
  1532
  1533 0CB0			NCD_ERROR_STR:
  1534 0CB0 50 41 54 48 3F 9B	        .BYTE   'PATH?',EOL
  1535
  1536 				;---------------------------------------
  1537 0CB6			GENDCB:
  1538 0CB6 71			        .BYTE      DEVIDN  ; DDEVIC
  1539 0CB7 FF			        .BYTE      $FF     ; DUNIT
  1540 0CB8 FF			        .BYTE      $FF     ; DCOMND
  1541 0CB9 80			        .BYTE      $80     ; DSTATS
  1542 0CBA FF			        .BYTE      $FF     ; DBUFL
  1543 0CBB FF			        .BYTE      $FF     ; DBUFH
  1544 0CBC 1F			        .BYTE      $1F     ; DTIMLO
  1545 0CBD 00			        .BYTE      $00     ; DRESVD
  1546 0CBE 00			        .BYTE      $00     ; DBYTL
  1547 0CBF 01			        .BYTE      $01     ; DBYTH
  1548 0CC0 00			        .BYTE      $00     ; DAUX1
  1549 0CC1 00			        .BYTE      $00     ; DAUX2
  1550
  1551 				; End of DO_GENERIC
  1552 				;---------------------------------------
  1553
  1554 				;;---------------------------------------
  1555 				;DO_COPY:
  1556 				;;---------------------------------------
  1557 				;
  1558 				;        LDA     #$20
  1559 				;        STA     COLOR2
  1560 				;
  1561 				;        LDA     #<CPYDCB
  1562 				;        LDY     #>CPYDCB
  1563 				;        JSR     DOSIOV
  1564 				;
  1565 				;        LDA     #$20
  1566 				;        STA     COLOR2
  1567 				;
  1568 				;        RTS
  1569 				;
  1570 				;CPYDCB:
  1571 				;        .BYTE      DEVIDN  ; DDEVIC
  1572 				;        .BYTE      $FF     ; DUNIT
  1573 				;        .BYTE      $D8     ; DCOMND
  1574 				;        .BYTE      $80     ; DSTATS
  1575 				;        .BYTE      <COPYSPEC  ; DBUFL
  1576 				;        .BYTE      >COPYSPEC ; DBUFH
  1577 				;        .BYTE      $FE     ; DTIMLO
  1578 				;        .BYTE      $00     ; DRESVD
  1579 				;        .BYTE      $00     ; DBYTL
  1580 				;        .BYTE      $01     ; DBYTH
  1581 				;        .BYTE      3       ; DAUX1
  1582 				;        .BYTE      2       ; DAUX2
  1583 				;
  1584 				;COPYSPEC:
  1585 				;        .BYTE 'iss.po|iss.po',$00
  1586
  1587 				;---------------------------------------
  1588 0CC2			DO_COPY:
  1589 				;---------------------------------------
  1590 0CC2 A9 B0		        LDA     #$B0
  1591 0CC4 8D C6 02		        STA     COLOR2
  1592 0CC7 60			        RTS
  1593
  1594 				;        JSR     COPY_PARSE_FILES    ; locate comma, replace with EOL
  1595 				;        BMI     COPY_DONE
  1596 				;
  1597 				;        LDA     CMDSEP
  1598 				;        STA     CMDSEP+2
  1599 				;
  1600 				;        LDA     CMDSEP+1
  1601 				;        STA     CMDSEP
  1602 				;
  1603 				;        JSR     COPY_OPEN_DEST      ; use CIO to open file 2 for write
  1604 				;        BMI     COPY_DONE
  1605 				;
  1606 				;        LDA     CMDSEP+2
  1607 				;        STA     CMDSEP
  1608 				;        JSR     COPY_OPEN_SRC       ; use CIO to open file 1 for read
  1609 				;        BMI     COPY_DONE
  1610 				;
  1611 				;@:      JSR     COPY_GET_SRC
  1612 				;        JSR     COPY_PUT_DEST
  1613 				;        ;BNE     @-
  1614 				;
  1615 				;COPY_DONE:
  1616 				;    ; Close files
  1617 				;        LDX     #$10
  1618 				;        JSR     CIOCLOSE
  1619 				;        LDX     #$20
  1620 				;        JMP     CIOCLOSE
  1621 				;
  1622 				;;---------------------------------------
  1623 				;COPY_PARSE_FILES:
  1624 				;;---------------------------------------
  1625 				;    ; Find position of comma in line buffer
  1626 				;    ; Return X = position of comma
  1627 				;    ;---------------------------------------
  1628 				;        LDX     CMDSEP
  1629 				;COPY_PARSE_LOOP:
  1630 				;        LDA     LNBUF,X
  1631 				;        CMP     #','
  1632 				;        BEQ     COPY_PARSE_FILES_DONE
  1633 				;        CMP     #EOL
  1634 				;        BEQ     COPY_SHOW_USAGE
  1635 				;        INX
  1636 				;        BNE     COPY_PARSE_LOOP
  1637 				;COPY_PARSE_FILES_DONE:
  1638 				;    ;---------------------------------------
  1639 				;    ; Here if comma found.
  1640 				;    ; Inject EOL where the comma was found
  1641 				;    ;---------------------------------------
  1642 				;        LDA     #EOL
  1643 				;        STA     LNBUF,X
  1644 				;        INX                 ; Advance to start of 2nd arg
  1645 				;        STX     CMDSEP+1    ; Point to 2nd arg now
  1646 				;        RTS
  1647 				;    ;---------------------------------------
  1648 				;    ; Here if no comma found.
  1649 				;    ; Print usage
  1650 				;    ;---------------------------------------
  1651 				;COPY_SHOW_USAGE:
  1652 				;        LDA     #<COPY_SHOW_USAGE_STR
  1653 				;        LDY     #>COPY_SHOW_USAGE_STR
  1654 				;        JSR     PRINT_STRING
  1655 				;        LDY     #$FF
  1656 				;        RTS
  1657 				;
  1658 				;COPY_SHOW_USAGE_STR:
  1659 				;        .BYTE   'COPY SOURCE,DEST',EOL
  1660 				;
  1661 				;; End of COPY_COMMA_POS:
  1662 				;;---------------------------------------
  1663 				;
  1664 				;;---------------------------------------
  1665 				;COPY_OPEN_SRC:
  1666 				;;---------------------------------------
  1667 				;        JSR     GET_DOSDR       ; Get DUNIT
  1668 				;        JSR     PREPEND_DRIVE
  1669 				;
  1670 				;        LDX     #$10            ; File #1
  1671 				;        JSR     CIOCLOSE        ; Assert file #1 is closed
  1672 				;        LDY     #$04            ; Open for input
  1673 				;        JSR     CIOOPEN         ; Open filename @ (INBUFF)
  1674 				;        BPL     COPY_OPEN_SRC_DONE
  1675 				;
  1676 				;        LDA     #<COPY_OPEN_SRC_ERR_STR
  1677 				;        LDY     #>COPY_OPEN_SRC_ERR_STR
  1678 				;        JMP     PRINT_STRING
  1679 				;
  1680 				;COPY_OPEN_SRC_DONE:
  1681 				;        RTS
  1682 				;        
  1683 				;COPY_OPEN_SRC_ERR_STR:
  1684 				;        .BYTE   'UNABLE TO OPEN SOURCE',EOL
  1685 				;
  1686 				;;End of COPY_OPEN_SRC
  1687 				;;---------------------------------------
  1688 				;
  1689 				;;---------------------------------------
  1690 				;COPY_OPEN_DEST:
  1691 				;;---------------------------------------
  1692 				;    ; Advance offset to arg2
  1693 				;        
  1694 				;@:      JSR     GET_DOSDR       ; Get DUNIT
  1695 				;        JSR     PREPEND_DRIVE
  1696 				;
  1697 				;        LDX     #$20            ; Assert file #2 is closed
  1698 				;        JSR     CIOCLOSE
  1699 				;
  1700 				;        LDY     #$08            ; Open for write
  1701 				;        JSR     CIOOPEN
  1702 				;        BPL     COPY_OPEN_DEST_DONE  ; If success, skip ahead
  1703 				;
  1704 				;        LDA     #<COPY_OPEN_DEST_ERR_STR
  1705 				;        LDY     #>COPY_OPEN_DEST_ERR_STR
  1706 				;        JMP     PRINT_STRING
  1707 				;
  1708 				;COPY_OPEN_DEST_DONE:
  1709 				;        RTS
  1710 				;        
  1711 				;COPY_OPEN_DEST_ERR_STR:
  1712 				;        .BYTE   'UNABLE TO OPEN DEST',EOL
  1713 				;
  1714 				;;End of COPY_OPEN_SRC
  1715 				;;---------------------------------------
  1716 				;
  1717 				;;---------------------------------------
  1718 				;COPY_GET_SRC:
  1719 				;;---------------------------------------
  1720 				;        ;LDX     #$10
  1721 				;        ;JSR     CIOSTATUS
  1722 				;
  1723 				;        LDX     #$10
  1724 				;        LDA     #<TBUF
  1725 				;        STA     INBUFF      ; Buffer addr Lo
  1726 				;        LDA     #>TBUF
  1727 				;        STA     INBUFF+1    ; Buffer addr Hi
  1728 				;        LDA     #$80        ; Buffer size Lo
  1729 				;        LDY     #$00        ; Buffer size Hi
  1730 				;        JSR     CIOGET
  1731 				;        BPL     COPY_GET_SRC_DONE
  1732 				;        CPY     #EOF
  1733 				;        BEQ     COPY_GET_SRC_DONE
  1734 				; 
  1735 				;        LDA     #<COPY_GET_SRC_STR
  1736 				;        LDY     #>COPY_GET_SRC_STR
  1737 				;        JMP     PRINT_STRING
  1738 				;
  1739 				;COPY_GET_SRC_DONE:
  1740 				;        RTS
  1741 				;
  1742 				;COPY_GET_SRC_STR:
  1743 				;        .BYTE   'ERROR READING FROM SOURCE',EOL
  1744 				;
  1745 				;;---------------------------------------
  1746 				;COPY_PUT_DEST:
  1747 				;;---------------------------------------
  1748 				;        ;LDX     #$20
  1749 				;        ;JSR     CIOSTATUS
  1750 				;
  1751 				;        LDX     #$20
  1752 				;        LDA     #<TBUF
  1753 				;        STA     INBUFF      ; Buffer addr Lo
  1754 				;        LDA     #>TBUF
  1755 				;        STA     INBUFF+1    ; Buffer addr Hi
  1756 				;        LDA     #$06        ; Buffer size Lo
  1757 				;        LDY     #$00        ; Buffer size Hi
  1758 				;        JSR     CIOPUT
  1759 				;        BPL     COPY_PUT_DEST_DONE
  1760 				;        CPY     #EOF
  1761 				;        BEQ     COPY_PUT_DEST_DONE
  1762 				; 
  1763 				;        LDA     #<COPY_PUT_DEST_STR
  1764 				;        LDY     #>COPY_PUT_DEST_STR
  1765 				;        JMP     PRINT_STRING
  1766 				;
  1767 				;COPY_PUT_DEST_DONE:
  1768 				;        RTS
  1769 				;
  1770 				;COPY_PUT_DEST_STR:
  1771 				;        .BYTE   'ERROR WRITING TO DEST',EOL
  1772 				;
  1773
  1774 				;---------------------------------------
  1775 0CC8			DO_DIR:
  1776 				;---------------------------------------
  1777 0CC8 20 28 0D		        JSR     DIR_INIT    ; set dunits
  1778 0CCB 20 38 0D		        JSR     DIR_OPEN    ; open with dir request
  1779 0CCE C0 01		        CPY     #$01        ; success (1) ?
  1780 0CD0 F0 03		        BEQ     DIR_LOOP    ; if success, jump ahead
  1781 0CD2 4C 96 0A		        JMP     PRINT_ERROR ; exit
  1782
  1783 0CD5			DIR_LOOP:
  1784
  1785 				    ;---------------------------------------
  1786 				    ; Send Status request to SIO
  1787 				    ;---------------------------------------
  1788 0CD5 A9 48		        LDA     #<STADCB
  1789 0CD7 A0 09		        LDY     #>STADCB
  1790 0CD9 20 A5 07		        JSR     DOSIOV
  1791
  1792 				    ;---------------------------------------
  1793 				    ; Status returns DVSTAT
  1794 				    ;---------------------------------------
  1795 0CDC A2 00		        LDX     #$00
  1796 0CDE EC EB 02		        CPX     DVSTAT+1    ; if byte count < 255 (that is, hi=0)
  1797 0CE1 F0 09		        BEQ     DIR_LT_255  ; then skip
  1798
  1799 				    ;---------------------------------------
  1800 				    ; Branch 1: Read 255 bytes (max)
  1801 				    ;---------------------------------------
  1802 0CE3 CA			        DEX                 ; X now 255 (Read FF Bytes)
  1803 0CE4 8E 24 0D		        STX     DIRRDCB+8   ; DBYTL
  1804 0CE7 8E 26 0D		        STX     DIRRDCB+10  ; DAUX1
  1805 0CEA 30 0B		        BMI     DIR_NEXT1   ; "always" true. skip down SIO call
  1806
  1807 				    ;---------------------------------------
  1808 				    ; Branch 2: Read < 255 bytes
  1809 				    ;---------------------------------------
  1810 0CEC			DIR_LT_255:
  1811 0CEC AD EA 02		        LDA     DVSTAT      ; Get count of bytes remaining
  1812 0CEF F0 6C		        BEQ     DIR_ERROR   ; If here then DVSTAT = $0000 (error)
  1813 0CF1 8D 24 0D		        STA     DIRRDCB+8   ; DBYTL
  1814 0CF4 8D 26 0D		        STA     DIRRDCB+10  ; DAUX1
  1815
  1816 				    ;-------------------------
  1817 				    ; Send Read request to SIO
  1818 				    ;-------------------------
  1819 0CF7			DIR_NEXT1:
  1820 0CF7 A9 1C		        LDA     #<DIRRDCB
  1821 0CF9 A0 0D		        LDY     #>DIRRDCB
  1822 0CFB 20 A5 07		        JSR     DOSIOV      ; Fetch directory listing
  1823 0CFE 20 8D 0D		        JSR     DIR_PRINT   ; xfer payload to screen
  1824
  1825 				    ;---------------------------------------
  1826 				    ; Pause output if SPACE key code found
  1827 				    ;---------------------------------------
  1828 0D01			DIR_WAIT:
  1829 0D01 AD FC 02		        LDA     CH
  1830 0D04 C9 21		        CMP     #SPC_KEY
  1831 0D06 F0 F9		        BEQ     DIR_WAIT
  1832
  1833 				    ;---------------------------------------
  1834 				    ; Exit loop if ESC key code found
  1835 				    ;---------------------------------------
  1836 0D08 AD FC 02		        LDA     CH
  1837 0D0B C9 1C		        CMP     #ESC_KEY    ; hardware code for ESC key
  1838 0D0D F0 05		        BEQ     DIR_NEXT
  1839
  1840 				    ;---------------------------------------
  1841 				    ; Loop if more data to read
  1842 				    ;---------------------------------------
  1843 0D0F AD EB 02		        LDA     DVSTAT+1    ; Was there more to read (that is, was hi>0)?
  1844 0D12 D0 C1		        BNE     DIR_LOOP    ; If yes, then do it again
  1845
  1846 0D14			DIR_NEXT:
  1847 0D14 A9 FF		        LDA     #$FF        ; Clear key
  1848 0D16 8D FC 02		        STA     CH
  1849 0D19 4C AB 0D		        JMP     DIR_CLOSE
  1850
  1851 0D1C			DIRRDCB:
  1852 0D1C 71			        .BYTE   DEVIDN      ; DDEVIC
  1853 0D1D FF			        .BYTE   $FF         ; DUNIT
  1854 0D1E 52			        .BYTE   'R'         ; DCOMND
  1855 0D1F 40			        .BYTE   $40         ; DSTATS
  1856 0D20 00			        .BYTE   <RBUF       ; DBUFL
  1857 0D21 18			        .BYTE   >RBUF       ; DBUFH
  1858 0D22 1F			        .BYTE   $1F         ; DTIMLO
  1859 0D23 00			        .BYTE   $00         ; DRESVD
  1860 0D24 00			        .BYTE   $00         ; DBYTL
  1861 0D25 00			        .BYTE   $00         ; DBYTH
  1862 0D26 00			        .BYTE   $00         ; DAUX1
  1863 0D27 00			        .BYTE   $00         ; DAUX2
  1864
  1865 				;---------------------------------------
  1866 				; Set DUNITs in all DCBs used by DIR
  1867 				;---------------------------------------
  1868 0D28			DIR_INIT:
  1869 				;---------------------------------------
  1870 0D28 20 32 0C		        JSR     GET_DOSDR   ; On return, X <- n in Nn:
  1871 0D2B 8E 82 0D		        STX     DIRODCB+1   ; DUNIT for Open
  1872 0D2E 8E 49 09		        STX     STADCB+1    ; DUNIT for Status
  1873 0D31 8E 1D 0D		        STX     DIRRDCB+1   ; DUNIT for Read
  1874 0D34 8E 22 08		        STX     CLODCB+1    ; DUNIT for Close
  1875 0D37 60			        RTS
  1876
  1877 				;---------------------------------------
  1878 0D38			DIR_OPEN:
  1879 				;---------------------------------------
  1880 0D38 20 8D 15		        JSR     PREPEND_DRIVE
  1881
  1882 				    ;-----------------------------------
  1883 				    ; Default to arg1
  1884 				    ;-----------------------------------
  1885 0D3B A6 F3		        LDX     INBUFF
  1886 0D3D A4 F4		        LDY     INBUFF+1
  1887
  1888 				    ;-----------------------------------
  1889 				    ; But use Nn:*.* if no arg1
  1890 				    ;-----------------------------------
  1891 0D3F AD 8C 0B		        LDA     CMDSEP          ; 0 means no arg1
  1892 0D42 D0 0C		        BNE     DIR_OPEN_NEXT   ; If arg1 present then skip
  1893
  1894 				    ;-----------------------------------
  1895 				    ; Here if no arg1
  1896 				    ;-----------------------------------
  1897 0D44 A2 7A		        LDX     #<DIR_OPEN_STR
  1898 0D46 A0 0D		        LDY     #>DIR_OPEN_STR
  1899
  1900 0D48 AD 58 17		        LDA     DOSDR
  1901 0D4B 09 30		        ORA     #'0'            ; Convert, say, 1 to '1'
  1902 0D4D 8D 7B 0D		        STA     DIR_OPEN_STR+1  ; Inject DOSDR into string
  1903
  1904 0D50			DIR_OPEN_NEXT:
  1905 0D50 8E 85 0D		        STX     DIRODCB+4       ; DBUFL
  1906 0D53 8C 86 0D		        STY     DIRODCB+5       ; DBUFH
  1907
  1908 0D56 A9 81		        LDA     #<DIRODCB
  1909 0D58 A0 0D		        LDY     #>DIRODCB
  1910 0D5A 4C A5 07		        JMP     DOSIOV
  1911
  1912 				;---------------------------------------
  1913 0D5D			DIR_ERROR:
  1914 				;---------------------------------------
  1915 0D5D A9 67		        LDA     #<DIR_ERROR_STR
  1916 0D5F A0 0D		        LDY     #>DIR_ERROR_STR
  1917 0D61 20 7B 0A		        JSR     PRINT_STRING
  1918 0D64 A0 01		        LDY     #$01            ; Return error
  1919 0D66 60			        RTS
  1920
  1921 0D67			DIR_ERROR_STR:
  1922 0D67 55 4E 41 42 4C 45 +         .BYTE   'UNABLE TO READ DIR',EOL
  1923
  1924 0D7A			DIR_OPEN_STR:
  1925 0D7A 4E 20 3A 2A 2E 2A +         .BYTE   'N :*.*',EOL
  1926
  1927 0D81			DIRODCB:
  1928 0D81 71			        .BYTE   DEVIDN          ; DDEVIC
  1929 0D82 FF			        .BYTE   $FF             ; DUNIT
  1930 0D83 4F			        .BYTE   'O'             ; DCOMND
  1931 0D84 80			        .BYTE   $80             ; DSTATS
  1932 0D85 FF			        .BYTE   $FF             ; DBUFL
  1933 0D86 FF			        .BYTE   $FF             ; DBUFH
  1934 0D87 1F			        .BYTE   $1F             ; DTIMLO
  1935 0D88 00			        .BYTE   $00             ; DRESVD
  1936 0D89 00			        .BYTE   $00             ; DBYTL
  1937 0D8A 01			        .BYTE   $01             ; DBYTH
  1938 0D8B 06			        .BYTE   $06             ; DAUX1
  1939 0D8C 80			        .BYTE   $80             ; DAUX2 (Long Dir)
  1940
  1941 				; End of DIR_OPEN
  1942 				;---------------------------------------
  1943
  1944 				;---------------------------------------
  1945 0D8D			DIR_PRINT:
  1946 				;---------------------------------------
  1947 				        ; Print results using CIO
  1948 0D8D A2 00		        LDX     #$00
  1949 0D8F A9 0B		        LDA     #PUTCHR
  1950 0D91 9D 42 03		        STA     ICCOM,X
  1951
  1952 				        ; Fill out buffer loc
  1953 0D94 A9 00		        LDA     #<RBUF
  1954 0D96 9D 44 03		        STA     ICBAL,X
  1955 0D99 A9 18		        LDA     #>RBUF
  1956 0D9B 9D 45 03		        STA     ICBAH,X
  1957
  1958 				        ; Fill out size loc
  1959 0D9E AD 24 0D		        LDA     DIRRDCB+8
  1960 0DA1 9D 48 03		        STA     ICBLL,X
  1961 0DA4 8A			        TXA
  1962 0DA5 9D 49 03		        STA     ICBLH,X
  1963 0DA8 4C 56 E4		        JMP     CIOV
  1964
  1965 				;---------------------------------------
  1966 0DAB			DIR_CLOSE:
  1967 				;---------------------------------------
  1968 				        ; Close
  1969 0DAB A9 21		        LDA     #<CLODCB
  1970 0DAD A0 08		        LDY     #>CLODCB
  1971 0DAF 4C A5 07		        JMP     DOSIOV
  1972
  1973 				;---------------------------------------
  1974 0DB2			DO_LOAD:
  1975 				;---------------------------------------
  1976 				    ; Binary Loader based on work by Richard J. Kalagher 07-AUG-1983
  1977
  1978 				    ; Open file
  1979 0DB2 AD 8C 0B		        LDA     CMDSEP          ; Quit if no arg1
  1980 0DB5 D0 03		        BNE     LOAD_NEXT1
  1981 0DB7 4C 4E 10		        JMP     LOAD_ERROR
  1982
  1983 0DBA			LOAD_NEXT1:
  1984 				    ; Point INBUFF to start of filename
  1985 0DBA 18			        CLC
  1986 0DBB 65 F3		        ADC     INBUFF          ; [A] contains offset to arg1
  1987 0DBD 85 F3		        STA     INBUFF
  1988 0DBF 90 02		        BCC     LOAD_NEXT2
  1989 0DC1 E6 F4		        INC     INBUFF+1
  1990
  1991 0DC3			LOAD_NEXT2:
  1992 0DC3 A9 91		        LDA     #$91          ; Feable attempt to point cmd line
  1993 0DC5 85 0A		        STA     DOSVEC          ; to DOSVEC for use by other 
  1994 0DC7 A9 05		        LDA     #$05            ; cmd line executables
  1995 0DC9 85 0B		        STA     DOSVEC+1
  1996
  1997 0DCB 20 5E 0E		        JSR     LOAD_NTRANS     ; Disable any EOL transation
  1998 0DCE 20 1A 0E		        JSR     LOAD_SETUP      ; Set up run and init to RTS
  1999 0DD1 A9 04		        LDA     #OINPUT         ; A arg needed in LOAD_OPEN
  2000 0DD3 20 30 0E		        JSR     LOAD_OPEN       ; Open the file
  2001 0DD6 C0 01		        CPY     #$01            ; Quit if unable to open
  2002 0DD8 D0 3F		        BNE     R
  2003
  2004 0DDA A9 FF		        LDA     #$FF
  2005 0DDC 8D 90 18		        STA     BIN_1ST
  2006 0DDF 20 6C 0E		        JSR     LOAD_READ2
  2007 0DE2 20 8D 0E		        JSR     LOAD_CHKFF
  2008 0DE5 C0 01		        CPY     #$01
  2009 0DE7 D0 30		        BNE     R
  2010
  2011 0DE9 EE 90 18		        INC     BIN_1ST
  2012 				    ; Process each payload
  2013 0DEC 20 6C 0E		GETFIL: JSR     LOAD_READ2      ; Get two bytes (binary header)
  2014 0DEF 30 28		        BMI     R               ; Exit if EOF hit
  2015 0DF1 20 25 0E		        JSR     LOAD_INIT       ; Set init default
  2016 0DF4 A2 01		        LDX     #$01
  2017 0DF6 20 8D 0E		        JSR     LOAD_CHKFF      ; Check if header (and start addr, too)
  2018 0DF9 20 C4 0E		        JSR     LOAD_STRAD      ; Put start address in
  2019 0DFC 20 6C 0E		        JSR     LOAD_READ2      ; Get to more butes (end addr)
  2020 0DFF 20 D1 0E		        JSR     LOAD_ENDAD      ; Put end address in
  2021 0E02 20 EA 0E		        JSR     LOAD_BUFLEN     ; Calculate buffer length
  2022 0E05 20 0F 0F		        JSR     LOAD_GETDAT     ; Get the data record
  2023 0E08 10 03		        BPL     @+              ; Was EOF detected?
  2024 0E0A 20 16 0E		        JSR     JSTART          ; Yes. Go to RUNAD
  2025 0E0D 20 13 0E		@:      JSR     JINIT           ; Attempt initialization
  2026 0E10 4C EC 0D		        JMP     GETFIL          ; Process next payload
  2027
  2028 0E13 6C E2 02		JINIT:  JMP     (INITAD)        ; Will either RTS or perform INIT
  2029 0E16 6C E0 02		JSTART: JMP     (RUNAD)         ; Godspeed.
  2030 0E19 60			R:      RTS                     ; Stunt-double for (INITAD),(RUNAD)
  2031
  2032 				;---------------------------------------
  2033 0E1A			LOAD_SETUP:
  2034 				;---------------------------------------
  2035 0E1A A9 19		        LDA     #<R
  2036 0E1C 8D E0 02		        STA     RUNAD
  2037 0E1F A9 0E		        LDA     #>R
  2038 0E21 8D E1 02		        STA     RUNAD+1
  2039 0E24 60			        RTS
  2040
  2041 				;---------------------------------------
  2042 0E25			LOAD_INIT:
  2043 				;---------------------------------------
  2044 0E25 A9 19		        LDA     #<R
  2045 0E27 8D E2 02		        STA     INITAD
  2046 0E2A A9 0E		        LDA     #>R
  2047 0E2C 8D E3 02		        STA     INITAD+1
  2048 0E2F 60			        RTS
  2049
  2050 				;---------------------------------------
  2051 0E30			LOAD_OPEN:
  2052 				;---------------------------------------
  2053 0E30 48			        PHA                     ; A = data direction (4=in, 8=out)
  2054 0E31 20 32 0C		        JSR     GET_DOSDR       ; Get DUNIT
  2055 0E34 8E 01 08		        STX     OPNDCB+1        ; Set DUNIT
  2056 0E37 8E 83 08		        STX     GETDCB+1        ; Set DUNIT FOR READ
  2057 0E3A 20 8D 15		        JSR     PREPEND_DRIVE
  2058
  2059 0E3D A5 F3		        LDA     INBUFF          ; Register location of filename
  2060 0E3F 8D 04 08		        STA     OPNDCB+4
  2061 0E42 A5 F4		        LDA     INBUFF+1
  2062 0E44 8D 05 08		        STA     OPNDCB+5
  2063
  2064 0E47 68			        PLA                     ; A = data direction (4=in, 8=out)
  2065 0E48 8D 0A 08		        STA     OPNDCB+10
  2066 0E4B A9 00		        LDA     #$00            ; AUX2: No translation
  2067 0E4D 8D 0B 08		        STA     OPNDCB+11
  2068
  2069 0E50 A9 00		        LDA     #<OPNDCB
  2070 0E52 A0 08		        LDY     #>OPNDCB
  2071
  2072 0E54 20 A5 07		        JSR     DOSIOV
  2073 0E57 48			        PHA
  2074 0E58 20 96 0A		        JSR     PRINT_ERROR
  2075 0E5B 68			        PLA
  2076 0E5C A8			        TAY
  2077
  2078 0E5D 60			        RTS
  2079
  2080 				;---------------------------------------
  2081 0E5E			LOAD_NTRANS:
  2082 				;---------------------------------------
  2083 				    ; Disable any EOL transation otherwise
  2084 				    ; binary data will be corrupted during load
  2085 				    ;---------------------------------------
  2086 0E5E 20 32 0C		        JSR     GET_DOSDR       ; Get DUNIT
  2087 0E61 8E 4D 11		        STX     NTRDCB+1        ; Set DUNIT
  2088 0E64 A9 00		        LDA     #$00
  2089 0E66 8D 57 11		        STA     NTRDCB+11       ; Translation mode (0 = NONE)
  2090 0E69 4C 19 11		        JMP     NTRANS_CALL     ; Reuse code in DO_NTRANS
  2091
  2092 				;---------------------------------------
  2093 0E6C			LOAD_READ2:
  2094 				;---------------------------------------
  2095 				    ; Load 2 bytes into Buffer (BAL/H).
  2096 				    ;---------------------------------------
  2097 				    ; This is accomplished by abusing the LOAD_GETDAT
  2098 				    ; routine by stuffing the buffer addr (BAL/H)
  2099 				    ; into the payload Start/End addrs. We're doing
  2100 				    ; this in case a payload  header straddles a
  2101 				    ; cache boundary. LOAD_GETDAT has the logic for
  2102 				    ; dealing with that.
  2103 				    ;---------------------------------------
  2104 0E6C A9 00		        LDA     #<BAL
  2105 0E6E 8D 80 18		        STA     STL             ; Payload start address
  2106 0E71 A9 18		        LDA     #>BAL
  2107 0E73 8D 81 18		        STA     STH
  2108
  2109 0E76 A9 01		        LDA     #<BAH
  2110 0E78 8D 82 18		        STA     ENL             ; Payload end address
  2111 0E7B A9 18		        LDA     #>BAH
  2112 0E7D 8D 83 18		        STA     ENH
  2113
  2114 0E80 A2 02		        LDX     #$02
  2115 0E82 8E 84 18		        STX     BLL             ; Payload size (2)
  2116 0E85 A9 00		        LDA     #$00
  2117 0E87 8D 85 18		        STA     BLH
  2118
  2119 0E8A 4C 0F 0F		        JMP     LOAD_GETDAT     ; Read 2 bytes
  2120
  2121 				;---------------------------------------
  2122 0E8D			LOAD_CHKFF:
  2123 				;---------------------------------------
  2124 				    ; On 1st pass, check for binary signature (FF FF)
  2125 				    ; On 2..n passes, Skip FF FF (if found) 
  2126 				    ; and read next 2 bytes
  2127 				    ;---------------------------------------
  2128 				        
  2129 0E8D A9 FF		        LDA     #$FF
  2130 0E8F CD 00 18		        CMP     BAL         ; Is 1st byte FF?
  2131 0E92 D0 0D		        BNE     NOTFF       ; If no, skip down.
  2132 0E94 CD 01 18		        CMP     BAH         ; Is 2nd byte FF?
  2133 0E97 D0 08		        BNE     NOTFF       ; If no, skip down.
  2134
  2135 				    ;---------------------------------------
  2136 				    ; Here if FF FF tags found. 
  2137 				    ; On 1st pass, we're done.
  2138 				    ; On 2..n passes, read next 2 bytes and leave.
  2139 				    ;---------------------------------------
  2140 0E99 CD 90 18		        CMP     BIN_1ST     ; Is this 1st pass?
  2141 0E9C F0 13		        BEQ     NOTFF_DONE  ; If yes, then we're done here.
  2142 0E9E 4C 6C 0E		        JMP     LOAD_READ2  ; 
  2143
  2144 				    ;---------------------------------------
  2145 				    ; Here if FF FF tags NOT found. 
  2146 				    ; On 1st pass, print error.
  2147 				    ; On 2..n passes, the 2 bytes = payload start addr.
  2148 				    ;---------------------------------------
  2149 0EA1 A0 01		NOTFF:  LDY     #$01        ; Preload success return code
  2150 0EA3 CD 90 18		        CMP     BIN_1ST     ; A still has FF. BIN_1ST = FF on first pass
  2151 0EA6 D0 09		        BNE     NOTFF_DONE  ; Not 1st pass, exit with success.
  2152
  2153 0EA8			NOTFF_ERR:
  2154 0EA8 A9 B2		        LDA     #<LOAD_ERROR_STR2
  2155 0EAA A0 0E		        LDY     #>LOAD_ERROR_STR2
  2156 0EAC 20 7B 0A		        JSR     PRINT_STRING
  2157
  2158 0EAF A0 FF		        LDY     #$FF        ; Return failure
  2159 0EB1			NOTFF_DONE:
  2160 0EB1 60			        RTS
  2161
  2162 0EB2			LOAD_ERROR_STR2:
  2163 0EB2 4E 4F 54 20 41 20 +         .BYTE   'NOT A BINARY FILE',EOL
  2164
  2165 				;---------------------------------------
  2166 0EC4			LOAD_STRAD:
  2167 				;---------------------------------------
  2168 				    ; Save payload start address into STL2/STLH2.
  2169 				    ; Otherwise it will get clobbered
  2170 				    ; when reading payload end address.
  2171 0EC4 AD 00 18		        LDA     RBUF
  2172 0EC7 8D 8E 18		        STA     STL2
  2173 0ECA AD 01 18		        LDA     RBUF+1
  2174 0ECD 8D 8F 18		        STA     STH2
  2175 0ED0 60			        RTS
  2176
  2177 				;---------------------------------------
  2178 0ED1			LOAD_ENDAD:
  2179 				;---------------------------------------
  2180 				    ; Save payload end address
  2181 0ED1 AD 8E 18		        LDA     STL2
  2182 0ED4 8D 80 18		        STA     STL
  2183 0ED7 AD 8F 18		        LDA     STH2
  2184 0EDA 8D 81 18		        STA     STH
  2185 				    
  2186 0EDD AD 00 18		        LDA     RBUF
  2187 0EE0 8D 82 18		        STA     ENL
  2188 0EE3 AD 01 18		        LDA     RBUF+1
  2189 0EE6 8D 83 18		        STA     ENH
  2190 0EE9 60			        RTS
  2191
  2192 				;---------------------------------------
  2193 0EEA			LOAD_BUFLEN:
  2194 				;---------------------------------------
  2195 				    ; Calculate buffer length (end-start+1)
  2196
  2197 				    ; Calc buffer size Lo
  2198 0EEA AD 82 18		        LDA     ENL
  2199 0EED 38			        SEC
  2200 0EEE ED 80 18		        SBC     STL
  2201 0EF1 8D 84 18		        STA     BLL     ; Buffer Length Lo
  2202
  2203 				    ; Calc buffer size Hi
  2204 0EF4 AD 83 18		        LDA     ENH     ; Calc buffer size Hi
  2205 0EF7 ED 81 18		        SBC     STH
  2206 0EFA 8D 85 18		        STA     BLH     ; Buffer Length Hi
  2207
  2208 				    ; Add 1
  2209 0EFD 18			        CLC
  2210 0EFE AD 84 18		        LDA     BLL
  2211 0F01 69 01		        ADC     #$01
  2212 0F03 8D 84 18		        STA     BLL
  2213
  2214 0F06 AD 85 18		        LDA     BLH
  2215 0F09 69 00		        ADC     #$00    ; Take care of any carry
  2216 0F0B 8D 85 18		        STA     BLH
  2217
  2218 0F0E 60			        RTS
  2219
  2220 				;---------------------------------------
  2221 0F0F			LOAD_GETDAT:
  2222 				;---------------------------------------
  2223 				    ; Definitions:
  2224 				    ; HEAD = requested bytes that will be found in current cache (< 512 bytes)
  2225 				    ; BODY = contiguous 512 byte sections. BODY = n * 512 bytes)
  2226 				    ; TAIL = any bytes remaining after BODY (< 512 bytes)
  2227
  2228 0F0F 20 32 0C		        JSR     GET_DOSDR
  2229 0F12 8E 36 10		        STX     BINDCB+1
  2230
  2231 0F15 20 11 10		        JSR     GETDAT_CHECK_EOF    ; Check EOF before proceeding
  2232 0F18 10 01		        BPL     GETDAT_NEXT1        ; If true, then EOF found. Exit
  2233 0F1A 60			        RTS
  2234
  2235 				    ; Check if bytes requested BL < DVSTAT (bytes waiting in cache)
  2236 0F1B			GETDAT_NEXT1:
  2237 0F1B AD EA 02		        LDA     DVSTAT
  2238 0F1E CD 84 18		        CMP     BLL
  2239 0F21 AD EB 02		        LDA     DVSTAT+1
  2240 0F24 ED 85 18		        SBC     BLH
  2241 0F27 B0 4C		        BCS     GETDAT_OPT2     ; BL <= BW (bytes waiting)
  2242
  2243 0F29			GETDAT_OPT1:
  2244 				    ;--------------------------------
  2245 				    ; Here if bytes requested > bytes 
  2246 				    ; remaining in cache
  2247 				    ;------------------------P--------
  2248
  2249 				    ;-------------------------------
  2250 				    ; Head = BW (bytes waiting)
  2251 				    ;-------------------------------
  2252 0F29 AD EA 02		        LDA     DVSTAT
  2253 0F2C 8D 86 18		        STA     HEADL
  2254 0F2F AD EB 02		        LDA     DVSTAT+1
  2255 0F32 8D 87 18		        STA     HEADH
  2256
  2257 				    ;-------------------------------
  2258 				    ; Tail = (BL - HEAD) mod 512
  2259 				    ;-------------------------------
  2260 0F35 38			        SEC
  2261 0F36 AD 84 18		        LDA     BLL
  2262 0F39 ED 86 18		        SBC     HEADL
  2263 0F3C 29 FF		        AND     #$FF
  2264 0F3E 8D 8A 18		        STA     TAILL
  2265 0F41 AD 85 18		        LDA     BLH
  2266 0F44 ED 87 18		        SBC     HEADH
  2267 0F47 29 01		        AND     #$01
  2268 0F49 8D 8B 18		        STA     TAILH
  2269
  2270 				    ;-----------------------------------
  2271 				    ; Body = BL - HEAD - TAIL
  2272 				    ;-----------------------------------
  2273 				        ; 1. Body = BL - HEAD
  2274 				        ;-------------------------------
  2275 0F4C 38			        SEC
  2276 0F4D AD 84 18		        LDA     BLL
  2277 0F50 ED 86 18		        SBC     HEADL
  2278 0F53 8D 88 18		        STA     BODYL
  2279 0F56 AD 85 18		        LDA     BLH
  2280 0F59 ED 87 18		        SBC     HEADH
  2281 0F5C 8D 89 18		        STA     BODYH
  2282
  2283 				        ;-------------------------------
  2284 				        ; 2. Body = Body - HEAD
  2285 				        ;-------------------------------
  2286 0F5F 38			        SEC
  2287 0F60 AD 88 18		        LDA     BODYL
  2288 0F63 ED 8A 18		        SBC     TAILL
  2289 0F66 8D 88 18		        STA     BODYL
  2290 0F69 AD 89 18		        LDA     BODYH
  2291 0F6C ED 8B 18		        SBC     TAILH
  2292 0F6F 8D 89 18		        STA     BODYH
  2293
  2294 0F72 4C 8F 0F		        JMP     GETDAT_READ
  2295
  2296 0F75			GETDAT_OPT2:
  2297 				    ;--------------------------------
  2298 				    ; Here if bytes requested <= bytes 
  2299 				    ; remaining in cache
  2300 				    ;--------------------------------
  2301 				    ; Head = BL, TAIL = BODY = 0
  2302 				    ;--------------------------------
  2303 0F75 AD 84 18		        LDA     BLL
  2304 0F78 8D 86 18		        STA     HEADL
  2305 0F7B AD 85 18		        LDA     BLH
  2306 0F7E 8D 87 18		        STA     HEADH
  2307 0F81 A9 00		        LDA     #$00
  2308 0F83 8D 8A 18		        STA     TAILL
  2309 0F86 8D 8B 18		        STA     TAILH
  2310 0F89 8D 88 18		        STA     BODYL
  2311 0F8C 8D 89 18		        STA     BODYH
  2312
  2313 				;---------------------------------------
  2314 0F8F			GETDAT_READ:
  2315 				;---------------------------------------
  2316 				    ;---------------------------------------
  2317 				    ; Read HEAD bytes
  2318 				    ;---------------------------------------
  2319 0F8F AD 86 18		        LDA     HEADL
  2320 0F92 8D 84 18		        STA     BLL
  2321 0F95 AD 87 18		        LDA     HEADH
  2322 0F98 8D 85 18		        STA     BLH
  2323 0F9B 20 CC 0F		        JSR     GETDAT_DOSIOV
  2324 0F9E 10 01		        BPL     GETDAT_BODY ; Skip ahead if no problems
  2325 0FA0 60			        RTS                 ; Bail if error
  2326
  2327 				    ;---------------------------------------
  2328 				    ; Read BODY bytes
  2329 				    ;---------------------------------------
  2330 0FA1			GETDAT_BODY:
  2331 0FA1 AE 89 18		        LDX     BODYH
  2332 0FA4			GETDAT_BODY_LOOP:
  2333 0FA4 F0 1A		        BEQ     GETDAT_TAIL ; Skip if less than a page to read
  2334
  2335 0FA6 A9 00		        LDA     #$00
  2336 0FA8 8D 84 18		        STA     BLL         ; Buffer length
  2337 0FAB A9 02		        LDA     #$02        ; 512 bytes at a time
  2338 0FAD 8D 85 18		        STA     BLH
  2339
  2340 0FB0 8A			        TXA                 ; Stash our loop index (X)
  2341 0FB1 48			        PHA                 ; onto the stack
  2342 0FB2 20 CC 0F		        JSR     GETDAT_DOSIOV   
  2343 0FB5 10 03		        BPL     @+          ; Skip ahead if no problems
  2344 0FB7 68			        PLA                 ; Here if problem. Clean up stack
  2345 0FB8 98			        TYA                 ; Reset N status flag before returning
  2346 0FB9 60			        RTS                 ; Bail if error
  2347
  2348 0FBA 68			@:      PLA                 ; Retrieve our loop index
  2349 0FBB AA			        TAX                 ; and xfer it back into X
  2350 0FBC CA			        DEX                 ; -2 (we pull 0200 bytes at a time)
  2351 0FBD CA			        DEX                 ; 
  2352 0FBE D0 E4		        BNE     GETDAT_BODY_LOOP
  2353
  2354 0FC0			GETDAT_TAIL:
  2355 				    ;---------------------------------------
  2356 				    ; Read TAIL bytes
  2357 				    ;---------------------------------------
  2358 0FC0 AD 8A 18		        LDA     TAILL
  2359 0FC3 8D 84 18		        STA     BLL
  2360 0FC6 AD 8B 18		        LDA     TAILH
  2361 0FC9 8D 85 18		        STA     BLH
  2362
  2363 				;---------------------------------------
  2364 0FCC			GETDAT_DOSIOV:
  2365 				;---------------------------------------
  2366 				    ; Bail if BL = 0
  2367 0FCC AD 84 18		        LDA     BLL
  2368 0FCF D0 05		        BNE     @+
  2369 0FD1 AD 85 18		        LDA     BLH
  2370 0FD4 F0 5C		        BEQ     CHECK_EOF_DONE
  2371
  2372 0FD6			@:
  2373 				    ; SIO READ
  2374 0FD6 AD 80 18		        LDA     STL
  2375 0FD9 8D 39 10		        STA     BINDCB+4    ; Start Address Lo
  2376 0FDC AD 81 18		        LDA     STH
  2377 0FDF 8D 3A 10		        STA     BINDCB+5    ; Start Address Hi
  2378 0FE2 AD 84 18		        LDA     BLL
  2379 0FE5 8D 3D 10		        STA     BINDCB+8    ; Buffer Size Lo
  2380 0FE8 8D 3F 10		        STA     BINDCB+10
  2381 0FEB AD 85 18		        LDA     BLH
  2382 0FEE 8D 3E 10		        STA     BINDCB+9    ; Buffer Size Hi
  2383 0FF1 8D 40 10		        STA     BINDCB+11
  2384
  2385 				    ;---------------------------------------
  2386 				    ; Send Read request to SIO
  2387 				    ;---------------------------------------
  2388 0FF4 A9 35		        LDA     #<BINDCB
  2389 0FF6 A0 10		        LDY     #>BINDCB
  2390 0FF8 20 A5 07		        JSR     DOSIOV
  2391 0FFB 20 96 0A		        JSR     PRINT_ERROR
  2392
  2393 				    ;---------------------------------------
  2394 				    ; Advance start address by buffer length
  2395 				    ;---------------------------------------
  2396 0FFE 18			        CLC
  2397 0FFF AD 80 18		        LDA     STL
  2398 1002 6D 84 18		        ADC     BLL
  2399 1005 8D 80 18		        STA     STL
  2400
  2401 1008 AD 81 18		        LDA     STH
  2402 100B 6D 85 18		        ADC     BLH
  2403 100E 8D 81 18		        STA     STH
  2404
  2405 1011			GETDAT_CHECK_EOF:
  2406 				    ; Get status (updates DVSTAT, DSTATS)
  2407 1011 AD 36 10		        LDA     BINDCB+1
  2408 1014 8D 49 09		        STA     STADCB+1
  2409 1017 A9 48		        LDA     #<STADCB
  2410 1019 A0 09		        LDY     #>STADCB
  2411 101B 20 A5 07		        JSR     DOSIOV
  2412
  2413 				    ; Return -1 if DVSTAT == $0000 and DVSTAT+3 == EOF
  2414 101E AD EA 02		        LDA     DVSTAT
  2415 1021 D0 0F		        BNE     CHECK_EOF_DONE
  2416
  2417 1023 AD EB 02		        LDA     DVSTAT+1
  2418 1026 D0 0A		        BNE     CHECK_EOF_DONE
  2419
  2420 1028 A9 88		        LDA     #EOF
  2421 102A CD ED 02		        CMP     DVSTAT+3        ; Is it EOF
  2422 102D D0 03		        BNE     CHECK_EOF_DONE  ; No? Go to success
  2423 102F A0 FF		        LDY     #$FF            ; Yes? Return -1
  2424 1031 60			        RTS
  2425
  2426 1032			CHECK_EOF_DONE:
  2427 1032 A0 01		        LDY     #$01            ; Return success
  2428 1034 60			        RTS
  2429
  2430 1035			BINDCB:
  2431 1035 71			       .BYTE    DEVIDN      ; DDEVIC
  2432 1036 FF			       .BYTE    $FF         ; DUNIT
  2433 1037 52			       .BYTE    'R'         ; DCOMND
  2434 1038 40			       .BYTE    $40         ; DSTATS
  2435 1039 FF			       .BYTE    $FF         ; DBUFL
  2436 103A FF			       .BYTE    $FF         ; DBUFH
  2437 103B 0F			       .BYTE    $0F         ; DTIMLO
  2438 103C 00			       .BYTE    $00         ; DRESVD
  2439 103D FF			       .BYTE    $FF         ; DBYTL
  2440 103E FF			       .BYTE    $FF         ; DBYTH
  2441 103F FF			       .BYTE    $FF         ; DAUX1
  2442 1040 FF			       .BYTE    $FF         ; DAUX2
  2443
  2444
  2445 				;---------------------------------------
  2446 1041			LOAD_CLOSE:
  2447 				;---------------------------------------
  2448 1041 AD 36 10		        LDA     BINDCB+1
  2449 1044 8D 22 08		        STA     CLODCB+1
  2450 1047 A9 21		        LDA     #<CLODCB
  2451 1049 A0 08		        LDY     #>CLODCB
  2452 104B 4C A5 07		        JMP     DOSIOV
  2453
  2454 				;---------------------------------------
  2455 104E			LOAD_ERROR:
  2456 				;---------------------------------------
  2457 104E A9 52		        LDA     #<MISSING_FILE_STR
  2458 1050 A0 17		        LDY     #>MISSING_FILE_STR
  2459 1052 4C 7B 0A		        JMP     PRINT_STRING
  2460
  2461 				;---------------------------------------
  2462 1055			DO_LOCK:
  2463 				;---------------------------------------
  2464 1055 A9 60		        LDA     #$60
  2465 1057 8D C6 02		        STA     COLOR2
  2466 105A 60			        RTS
  2467
  2468 				;---------------------------------------
  2469 105B			DO_LOGIN:
  2470 				;---------------------------------------
  2471 105B A9 A0		        LDA     #$A0
  2472 105D 8D C6 02		        STA     COLOR2
  2473 1060 60			        RTS
  2474
  2475 1061			LOGIN_ERROR:
  2476 1061 A9 68		        LDA     #<LOGIN_ERROR_STR
  2477 1063 A0 10		        LDY     #>LOGIN_ERROR_STR
  2478 1065 4C 7B 0A		        JMP     PRINT_STRING
  2479
  2480 1068			LOGIN_ERROR_STR:
  2481 1068 4C 4F 47 49 4E 20 +         .BYTE   'LOGIN [N[n]:] <USERNAME> <PASSWORD>',EOL
  2482
  2483 				;---------------------------------------
  2484 108C			DO_LPR:
  2485 				;---------------------------------------
  2486 108C A9 B0		        LDA     #$B0
  2487 108E 8D C6 02		        STA     COLOR2
  2488 1091 60			        RTS
  2489
  2490 				;---------------------------------------
  2491 1092			DO_NPWD:
  2492 				;---------------------------------------
  2493 1092 A9 9B		        LDA     #EOL        ; Truncate buffer
  2494 1094 8D 00 18		        STA     RBUF
  2495
  2496 1097 20 32 0C		        JSR     GET_DOSDR   ; X will contain n in Nn:
  2497 109A 8E CA 10		        STX     PWDDCB+1
  2498
  2499 109D A9 C9		        LDA     #<PWDDCB
  2500 109F A0 10		        LDY     #>PWDDCB
  2501 10A1 20 A5 07		        JSR     DOSIOV
  2502 10A4 20 96 0A		        JSR     PRINT_ERROR
  2503
  2504 				    ;---------------------------------------
  2505 				    ; If we entered DO_NPWD from REMOUNT_DRIVE
  2506 				    ; then scipt printing output
  2507 				    ;---------------------------------------
  2508 10A7 AD 5A 17		        LDA     CMDPRV
  2509 10AA C9 03		        CMP     #CMD_IDX.DEL
  2510 10AC F0 1A		        BEQ     NPWD_DONE
  2511 10AE C9 0B		        CMP     #CMD_IDX.RENAME
  2512 10B0 F0 16		        BEQ     NPWD_DONE
  2513
  2514 10B2			NPWD_LOOP:
  2515 10B2 A9 00		        LDA     #<RBUF
  2516 10B4 A0 18		        LDY     #>RBUF
  2517 10B6 20 7B 0A		        JSR     PRINT_STRING
  2518
  2519 10B9 A9 48		        LDA     #<STADCB
  2520 10BB A0 09		        LDY     #>STADCB
  2521 10BD 20 A5 07		        JSR     DOSIOV
  2522 10C0 20 96 0A		        JSR     PRINT_ERROR
  2523
  2524 				    ;---------------------------------------
  2525 				    ; Loop if more data to read
  2526 				    ;---------------------------------------
  2527 10C3 AD EB 02		        LDA     DVSTAT+1    ; Was there more to read (that is, was hi>0)?
  2528 10C6 D0 EA		        BNE     NPWD_LOOP   ; If yes, then do it again
  2529
  2530 10C8			NPWD_DONE:
  2531 10C8 60			        RTS
  2532
  2533 10C9			PWDDCB:
  2534 10C9 71			        .BYTE   DEVIDN      ; DDEVIC
  2535 10CA FF			        .BYTE   $FF         ; DUNIT
  2536 10CB 30			        .BYTE   $30         ; DCOMND
  2537 10CC 40			        .BYTE   $40         ; DSTATS
  2538 10CD 00			        .BYTE   <RBUF       ; DBUFL
  2539 10CE 18			        .BYTE   >RBUF       ; DBUFH
  2540 10CF 1F			        .BYTE   $1F         ; DTIMLO
  2541 10D0 00			        .BYTE   $00         ; DRESVD
  2542 10D1 00			        .BYTE   $00         ; DBYTL
  2543 10D2 01			        .BYTE   $01         ; DBYTH
  2544 10D3 00			        .BYTE   $00         ; DAUX1
  2545 10D4 00			        .BYTE   $00         ; DAUX2
  2546
  2547 				; End of DO_NPWD
  2548 				;---------------------------------------
  2549
  2550 				;---------------------------------------
  2551 10D5			DO_NTRANS:
  2552 				;---------------------------------------
  2553 10D5 AE 8C 0B		        LDX     CMDSEP          ; Check if there's any args
  2554 10D8 F0 49		        BEQ     NTRANS_ERROR    ; No. Show usage and quit
  2555
  2556 10DA AD 58 17		        LDA     DOSDR           ; Go with current drive for now
  2557 10DD 8D 4D 11		        STA     NTRDCB+1        ; it'll be overwritten later if req'd
  2558
  2559 				    ;---------------------------------------
  2560 				    ; Check for argc = 2
  2561 				    ;---------------------------------------
  2562 10E0 AC 8C 0B		        LDY     CMDSEP          ; Stash offset to arg1 in Y
  2563 10E3 AE 8D 0B		        LDX     CMDSEP+1        ; Is there an arg2?
  2564 10E6 F0 21		        BEQ     PARSE_MODE      ; No. parse arg1 as mode (0-3)
  2565
  2566 				    ;---------------------------------------
  2567 				    ; Here if argc = 2 (arg1 = Nn: arg2 = mode)
  2568 				    ;---------------------------------------
  2569 10E8 AE 8C 0B		        LDX     CMDSEP          ; Get offset to arg1 (Nn:)
  2570 10EB BD 82 05		        LDA     LNBUF,X         ; Is arg1's (N[n]:) 1st char = 'N'?
  2571 10EE C9 4E		        CMP     #'N'            ;
  2572 10F0 D0 31		        BNE     NTRANS_ERROR    ; No? Then quit
  2573 10F2 BD 83 05		        LDA     LNBUF+1,X
  2574 10F5 C9 3A		        CMP     #':'            ; Is arg1's (N[n]:) 2nd char = ':'?
  2575 10F7 F0 10		        BEQ     PARSE_MODE      ; Yes, stick with default drive
  2576
  2577 				    ;---------------------------------------
  2578 				    ; Parse drive number
  2579 				    ;---------------------------------------
  2580 10F9 C9 31		        CMP     #'1'            ; Quit if n in Nn not 1..4
  2581 10FB 90 26		        BCC     NTRANS_ERROR    ; Quit if < '1'
  2582 10FD C9 39		        CMP     #'9'
  2583 10FF B0 22		        BCS     NTRANS_ERROR    ; Quit if >= '9'
  2584 1101 49 30		        EOR     #%00110000
  2585 1103 8D 4D 11		        STA     NTRDCB+1
  2586 1106 AC 8D 0B		        LDY     CMDSEP+1
  2587
  2588 				    ;---------------------------------------
  2589 				    ; Confirm valid parameter
  2590 				    ;---------------------------------------
  2591 1109			PARSE_MODE:
  2592 1109 B9 82 05		        LDA     LNBUF,Y         ; Quit if mode not 0..3
  2593 110C C9 30		        CMP     #'0'
  2594 110E 90 13		        BCC     NTRANS_ERROR
  2595 1110 C9 34		        CMP     #'4'
  2596 1112 B0 0F		        BCS     NTRANS_ERROR
  2597 1114 49 30		        EOR     #%00110000      ; Here if valid parameter
  2598 1116 8D 57 11		        STA     NTRDCB+11       ; Assign parameter to DCB
  2599
  2600 				    ;---------------------------------------
  2601 				    ; Call SIO
  2602 				    ;---------------------------------------
  2603 1119			NTRANS_CALL:
  2604 1119 A9 4C		        LDA     #<NTRDCB
  2605 111B A0 11		        LDY     #>NTRDCB
  2606 111D 20 A5 07		        JSR     DOSIOV
  2607 1120 4C 96 0A		        JMP     PRINT_ERROR
  2608
  2609 1123			NTRANS_ERROR:
  2610 1123 A9 2A		        LDA     #<NTRANS_ERROR_STR
  2611 1125 A0 11		        LDY     #>NTRANS_ERROR_STR
  2612 1127 4C 7B 0A		        JMP     PRINT_STRING
  2613
  2614 112A			NTRANS_ERROR_STR:
  2615 112A 4D 4F 44 45 3F 20 +         .BYTE   'MODE? 0=NONE, 1=CR, 2=LF, 3=CR/LF',EOL
  2616
  2617 114C			NTRDCB:
  2618 114C 71			        .BYTE   DEVIDN  ; DDEVIC
  2619 114D FF			        .BYTE   $FF     ; DUNIT
  2620 114E 54			        .BYTE   'T'     ; DCOMND
  2621 114F 00			        .BYTE   $00     ; DSTATS
  2622 1150 00			        .BYTE   $00     ; DBUFL
  2623 1151 00			        .BYTE   $00     ; DBUFH
  2624 1152 1F			        .BYTE   $1F     ; DTIMLO
  2625 1153 00			        .BYTE   $00     ; DRESVD
  2626 1154 00			        .BYTE   $00     ; DBYTL
  2627 1155 00			        .BYTE   $00     ; DBYTH
  2628 1156 00			        .BYTE   $00     ; DAUX1
  2629 1157 00			        .BYTE   $00     ; DAUX2
  2630
  2631 				; End of DO_NTRANS
  2632 				;---------------------------------------
  2633
  2634 				;---------------------------------------
  2635 1158			DO_AUTORUN:
  2636 				;---------------------------------------
  2637 				    ; Change URL stored in AUTORUN app key
  2638 				    ;-----------------------------------
  2639 1158 AD 8C 0B		        LDA     CMDSEP          ; Check if there's any arg
  2640 115B D0 07		        BNE     AUTORUN_NEXT1   ; If arg found, skip ahead
  2641
  2642 				    ; Here if no command line arg found
  2643 				    ; Print error message and exit
  2644 115D A9 A5		        LDA     #<AUTORUN_ERROR_STR
  2645 115F A0 11		        LDY     #>AUTORUN_ERROR_STR
  2646 1161 4C 7B 0A		        JMP     PRINT_STRING
  2647
  2648 1164			AUTORUN_NEXT1:
  2649 				    ; Point to start of arg on command line
  2650 1164 18			        CLC
  2651 1165 65 F3		        ADC     INBUFF          ; INBUFF += CMDSEP
  2652 1167 85 F3		        STA     INBUFF
  2653 1169 8D D9 11		        STA     APPKEYWRITEDCB+4
  2654
  2655 				    ; If "AUTORUN ?" Then abuse AUTORUN_SUBMIT to print appkey
  2656 116C A0 00		        LDY     #$00
  2657 116E A9 3F		        LDA     #'?'
  2658 1170 8D 91 18		        STA     AUTORUN_QUERY_FLG
  2659 1173 D1 F3		        CMP     (INBUFF),Y
  2660 1175 F0 6A		        BEQ     SUBMIT_AUTORUN
  2661
  2662 				    ; Open app key
  2663 1177 A9 01		        LDA     #$01            ; Open for write (1)
  2664 1179 8D 91 18		        STA     AUTORUN_QUERY_FLG
  2665 117C 8D AF 11		        STA     AUTORUN_APPKEY+4
  2666 117F A9 BD		        LDA     #<APPKEYOPENDCB
  2667 1181 A0 11		        LDY     #>APPKEYOPENDCB
  2668 1183 20 A5 07		        JSR     DOSIOV
  2669
  2670 				    ; Find length of URL (arg1)
  2671 1186 A0 FF		        LDY     #$FF            ; Init strlen
  2672 1188			AUTORUN_LOOP1
  2673 1188 C8			        INY                     ; Incr strlen
  2674 1189 B1 F3		        LDA     (INBUFF),Y
  2675 118B C9 9B		        CMP     #EOL            ; At end of string?
  2676 118D D0 F9		        BNE     AUTORUN_LOOP1   ; No. Keep counting
  2677
  2678 118F A9 0A		        LDA     #LF             ; Convert EOL to LF
  2679 1191 91 F3		        STA     (INBUFF),Y
  2680 1193 C8			        INY                     ; One more for strlen
  2681
  2682 1194			AUTORUN_NEXT2: 
  2683 				    ; Write app key
  2684 1194 8C DF 11		        STY     APPKEYWRITEDCB+10   ; Y = strlen
  2685 1197 A9 D5		        LDA     #<APPKEYWRITEDCB
  2686 1199 A0 11		        LDY     #>APPKEYWRITEDCB
  2687 119B 20 A5 07		        JSR     DOSIOV
  2688
  2689 				    ; Close app key
  2690 119E A9 B1		        LDA     #<APPKEYCLOSEDCB
  2691 11A0 A0 11		        LDY     #>APPKEYCLOSEDCB
  2692 11A2 4C A5 07		        JMP     DOSIOV
  2693
  2694 11A5			AUTORUN_ERROR_STR:
  2695 11A5 50 41 54 48 3F 9B	        .BYTE   'PATH?',EOL
  2696
  2697 11AB			AUTORUN_APPKEY:
  2698 11AB 79 DB		        .WORD   $DB79           ; creator ID
  2699 11AD 00			        .BYTE   $00             ; app ID
  2700 11AE 00			        .BYTE   $00             ; key ID
  2701 11AF 00			        .BYTE   $00             ; read or write mode
  2702 11B0 00			        .BYTE   $00             ; unused
  2703
  2704 11B1			APPKEYCLOSEDCB:
  2705 11B1 70			        .BYTE   $70             ; DDEVIC
  2706 11B2 01			        .BYTE   $01             ; DUNIT
  2707 11B3 DB			        .BYTE   $DB             ; DCOMND
  2708 11B4 00			        .BYTE   $00             ; DSTATS
  2709 11B5 00			        .BYTE   $00             ; DBUFL
  2710 11B6 00			        .BYTE   $00             ; DBUFH
  2711 11B7 0F			        .BYTE   $0F             ; DTIMLO
  2712 11B8 00			        .BYTE   $00             ; DRESVD
  2713 11B9 00			        .BYTE   $00             ; DBYTL
  2714 11BA 00			        .BYTE   $00             ; DBYTH
  2715 11BB 00			        .BYTE   $00             ; DAUX1
  2716 11BC 00			        .BYTE   $00             ; DAUX2
  2717
  2718 11BD			APPKEYOPENDCB:
  2719 11BD 70			        .BYTE   $70             ; DDEVIC
  2720 11BE 01			        .BYTE   $01             ; DUNIT
  2721 11BF DC			        .BYTE   $DC             ; DCOMND
  2722 11C0 80			        .BYTE   $80             ; DSTATS
  2723 11C1 AB			        .BYTE   <AUTORUN_APPKEY ; DBUFL
  2724 11C2 11			        .BYTE   >AUTORUN_APPKEY ; DBUFH
  2725 11C3 0F			        .BYTE   $0F             ; DTIMLO
  2726 11C4 00			        .BYTE   $00             ; DRESVD
  2727 11C5 06			        .BYTE   $06             ; DBYTL
  2728 11C6 00			        .BYTE   $00             ; DBYTH
  2729 11C7 00			        .BYTE   $00             ; DAUX1
  2730 11C8 00			        .BYTE   $00             ; DAUX2
  2731
  2732 11C9			APPKEYREADDCB:
  2733 11C9 70			        .BYTE   $70             ; DDEVIC
  2734 11CA 01			        .BYTE   $01             ; DUNIT
  2735 11CB DD			        .BYTE   $DD             ; DCOMND
  2736 11CC 40			        .BYTE   $40             ; DSTATS
  2737 11CD 82			        .BYTE   <LNBUF          ; DBUFL
  2738 11CE 05			        .BYTE   >LNBUF          ; DBUFH
  2739 11CF 01			        .BYTE   $01             ; DTIMLO - minimize timeout
  2740 11D0 00			        .BYTE   $00             ; DRESVD
  2741 11D1 40			        .BYTE   MAX_APPKEY_LEN  ; DBYTL
  2742 11D2 00			        .BYTE   $00             ; DBYTH
  2743 11D3 00			        .BYTE   $00             ; DAUX1
  2744 11D4 00			        .BYTE   $00             ; DAUX2
  2745
  2746 11D5			APPKEYWRITEDCB:
  2747 11D5 70			        .BYTE   $70             ; DDEVIC
  2748 11D6 01			        .BYTE   $01             ; DUNIT
  2749 11D7 DE			        .BYTE   $DE             ; DCOMND
  2750 11D8 80			        .BYTE   $80             ; DSTATS
  2751 11D9 FF			        .BYTE   $FF             ; DBUFL
  2752 11DA 05			        .BYTE   $05             ; DBUFH (expect page 5)
  2753 11DB 0F			        .BYTE   $0F             ; DTIMLO
  2754 11DC 00			        .BYTE   $00             ; DRESVD
  2755 11DD 40			        .BYTE   MAX_APPKEY_LEN  ; DBYTL
  2756 11DE 00			        .BYTE   $00             ; DBYTH
  2757 11DF FF			        .BYTE   $FF             ; DAUX1 (# actual bytes)
  2758 11E0 00			        .BYTE   $00             ; DAUX2
  2759
  2760 				;---------------------------------------
  2761 11E1			SUBMIT_AUTORUN:
  2762 				;---------------------------------------
  2763 				    ; At initial DOS boot, read URL for 
  2764 				    ; app key file from SD card's
  2765 				    ; FujiNet folder.
  2766 				    ;
  2767 				    ; filename: db790000.key
  2768 				    ; contents: url to a batch file
  2769 				    ;---------------------------------------
  2770 11E1 20 64 0A		        JSR     LDBUFA
  2771
  2772 				    ; Open app key
  2773 11E4 A9 00		        LDA     #$00            ; Open for read
  2774 11E6 8D AF 11		        STA     AUTORUN_APPKEY+4
  2775 11E9 A9 BD		        LDA     #<APPKEYOPENDCB
  2776 11EB A0 11		        LDY     #>APPKEYOPENDCB
  2777 11ED 20 A5 07		        JSR     DOSIOV
  2778
  2779 11F0 C0 01		        CPY     #$01            ; Was open successful?
  2780 11F2 F0 01		        BEQ     AUTOSUB_NEXT    ; Yes. Continue.
  2781 11F4 60			        RTS                     ; No. Exit
  2782
  2783 11F5			AUTOSUB_NEXT:
  2784 				    ; Read app key
  2785 11F5 A9 C9		        LDA     #<APPKEYREADDCB
  2786 11F7 A0 11		        LDY     #>APPKEYREADDCB
  2787 11F9 20 A5 07		        JSR     DOSIOV
  2788
  2789 				    ; Close app key
  2790 11FC A9 B1		        LDA     #<APPKEYCLOSEDCB
  2791 11FE A0 11		        LDY     #>APPKEYCLOSEDCB
  2792 1200 20 A5 07		        JSR     DOSIOV
  2793
  2794 				    ; Does the returned URL contain something?
  2795 1203 AE 82 05		        LDX     LNBUF           ; X contains strlen of AUTORUN path
  2796 1206 D0 01		        BNE     AUTORUN_CALL_SUBMIT
  2797
  2798
  2799 1208			AUTOSUB_DONE:
  2800 1208 60			        RTS
  2801
  2802 1209			AUTORUN_CALL_SUBMIT:
  2803 				    ; Replace end-of-line in buffer with null terminator
  2804 1209 CA			        DEX                     ; Move index back 1 position
  2805 120A A9 00		        LDA     #$00            ;
  2806 120C 9D 84 05		        STA     LNBUF+2,X       ; Write null-terminator 
  2807 120F A9 02		        LDA     #$02            ; Change arg1 location...
  2808 1211 8D 8C 0B		        STA     CMDSEP          ;  to point to filename
  2809
  2810 				    ;---------------------------------------
  2811 				    ; If here because of "AUTORUN ?", then
  2812 				    ; print contents of appkey file. But first
  2813 				    ; we have to terminate appkey string with EOL
  2814 				    ;---------------------------------------
  2815 1214 AD 91 18		        LDA     AUTORUN_QUERY_FLG
  2816 1217 C9 3F		        CMP     #'?'
  2817 1219 D0 18		        BNE     SUBMIT_NEXT1
  2818
  2819 121B A9 9B		        LDA     #EOL            ; Inject EOL to terminate string
  2820 121D 9D 84 05		        STA     LNBUF+2,X
  2821 1220 A9 84		        LDA     #<(LNBUF+2)
  2822 1222 A0 05		        LDY     #>(LNBUF+2)
  2823 1224 4C 7B 0A		        JMP     PRINT_STRING    ; Print AUTORUN path and sneak out
  2824
  2825 				;---------------------------------------
  2826 1227			DO_SUBMIT:
  2827 				;---------------------------------------
  2828 1227 AD 8C 0B		        LDA     CMDSEP
  2829 122A D0 07		        BNE     SUBMIT_NEXT1
  2830
  2831 				    ; Filename required
  2832 122C A9 52		        LDA     #<MISSING_FILE_STR
  2833 122E A0 17		        LDY     #>MISSING_FILE_STR
  2834 1230 4C 7B 0A		        JMP     PRINT_STRING
  2835
  2836 1233			SUBMIT_NEXT1:
  2837
  2838 				    ; Default to NOSCREEN
  2839 1233 A9 00		        LDA     #$00
  2840 1235 8D 5B 17		        STA     ECHO_FLG
  2841
  2842 				    ; Prep file path
  2843 1238 20 32 0C		        JSR     GET_DOSDR       ; Get DUNIT
  2844 123B 20 8D 15		        JSR     PREPEND_DRIVE
  2845
  2846 				    ; Assert FILE #1 is closed
  2847 123E A2 10		        LDX     #$10
  2848 1240 20 BB 09		        JSR     CIOCLOSE
  2849 				        
  2850 				    ; OPEN #1, 4, 0, file path
  2851 1243 A2 10		        LDX     #$10            ; File #1
  2852 1245 A0 04		        LDY     #$04            ; Open for input
  2853 1247 20 C3 09		        JSR     CIOOPEN         ; Open filename @ (INBUFF)
  2854 124A 10 03		        BPL     SUBMIT_NEXT2
  2855 124C 4C 96 0A		        JMP     PRINT_ERROR
  2856
  2857 				    ; Read batch file character by character
  2858 				    ; This allows it be end-of-line agnostic
  2859 				    ; Branch forward when an end-of-line is interpretted.
  2860
  2861 124F			SUBMIT_NEXT2:
  2862 124F 20 64 0A		        JSR     LDBUFA      ; Reset INBUFF to $0580
  2863 1252 C6 F3		        DEC     INBUFF      ; Init 1 byte before buffer
  2864 1254 A9 FF		        LDA     #$FF        ; Clear command
  2865 1256 8D 59 17		        STA     CMD
  2866
  2867 1259			SUBMIT_GETCH:
  2868 1259 E6 F3		        INC     INBUFF          ; Advance pointer
  2869 125B D0 02		        BNE     SUBMIT_NEXT3
  2870 125D E6 F4		        INC     INBUFF+1
  2871
  2872 125F			SUBMIT_NEXT3:
  2873 125F A2 10		        LDX     #$10            ; OPEN #1
  2874 1261 A9 01		        LDA     #$01            ; Get 1 byte
  2875 1263 A0 00		        LDY     #$00            ; ditto
  2876
  2877 1265 20 ED 09		        JSR     CIOGET          ; Get byte from file
  2878 1268 A0 00		        LDY     #$00            ;
  2879 126A B1 F3		        LDA     (INBUFF),Y      ; byte will be here
  2880 				        
  2881 126C C9 0D		        CMP     #CR             ; Just skip if Windows CR
  2882 126E F0 E9		        BEQ     SUBMIT_GETCH
  2883
  2884 1270 C9 0A		        CMP     #LF             ; Convert LF to EOL
  2885 1272 D0 04		        BNE     SUBMIT_EOL
  2886 1274 A9 9B		        LDA     #EOL
  2887 1276 91 F3		        STA     (INBUFF),Y
  2888
  2889 1278			SUBMIT_EOL:
  2890 1278 C9 9B		        CMP     #EOL            ; At end of command line?
  2891 127A D0 DD		        BNE     SUBMIT_GETCH    ; No. Get next byte.
  2892
  2893 				    ; Here if we've reached the end of a command line.
  2894 				    ; At end of file?
  2895 127C A2 10		        LDX     #$10            ; Channel #1
  2896 127E BD 43 03		        LDA     ICSTA,X         ; Inspect return code
  2897 1281 C9 88		        CMP     #EOF
  2898 1283 F0 22		        BEQ     SUBMIT_DONE     ; No error, try parsing cmd
  2899
  2900 1285 AD 5B 17		        LDA     ECHO_FLG        ; Skip echo if SCREEN is disabled
  2901 1288 F0 11		        BEQ     SUBMIT_NEXT4
  2902 128A AD 82 05		        LDA     LNBUF
  2903 128D C9 40		        CMP     #'@'            ; Skip lines beginning with @
  2904 128F F0 0A		        BEQ     SUBMIT_NEXT4
  2905
  2906 				    ; Echo commands
  2907 1291 20 64 0A		        JSR     LDBUFA
  2908 1294 A5 F3		        LDA     INBUFF
  2909 1296 A4 F4		        LDY     INBUFF+1
  2910 1298 20 7B 0A		        JSR     PRINT_STRING
  2911
  2912 129B			SUBMIT_NEXT4:
  2913 129B 20 3A 0B		        JSR     GETCMDTEST
  2914 129E 20 90 0B		        JSR     PARSECMD
  2915 12A1 20 06 0C		        JSR     DOCMD
  2916 12A4 38			        SEC
  2917 12A5 B0 A8		        BCS     SUBMIT_NEXT2
  2918
  2919 12A7			SUBMIT_DONE
  2920 12A7 A2 10		        LDX     #$10
  2921 12A9 4C BB 09		        JMP     CIOCLOSE
  2922
  2923 				; End of DO_SUBMIT
  2924 				;---------------------------------------
  2925
  2926 				;---------------------------------------
  2927 12AC			DO_TYPE:
  2928 				;---------------------------------------
  2929 12AC AD 8C 0B		        LDA     CMDSEP
  2930 12AF D0 07		        BNE     TYPE_SKIP
  2931
  2932 12B1			TYPE_USAGE:
  2933 12B1 A9 52		        LDA     #<MISSING_FILE_STR
  2934 12B3 A0 17		        LDY     #>MISSING_FILE_STR
  2935 12B5 4C 7B 0A		        JMP     PRINT_STRING
  2936
  2937 12B8			TYPE_SKIP:
  2938 12B8 20 32 0C		        JSR     GET_DOSDR       ; Get DUNIT
  2939 12BB 20 8D 15		        JSR     PREPEND_DRIVE
  2940
  2941 				    ; Assert input file closed
  2942 12BE A2 10		        LDX     #$10            ; File #1
  2943 12C0 20 BB 09		        JSR     CIOCLOSE        ; Assert file #1 is closed
  2944
  2945 				    ; Open input file
  2946 12C3 A2 10		        LDX     #$10            ; File #1
  2947 12C5 A0 04		        LDY     #$04            ; Open for input
  2948 12C7 20 C3 09		        JSR     CIOOPEN         ; Open filename @ (INBUFF)
  2949 12CA 10 08		        BPL     TYPE_NEXT
  2950
  2951 				    ; If open failed, Print error
  2952 12CC A2 10		        LDX     #$10            ; File #1
  2953 12CE BC 43 03		        LDY     ICSTA,X
  2954 12D1 4C 96 0A		        JMP     PRINT_ERROR
  2955
  2956 12D4			TYPE_NEXT:
  2957
  2958 				    ; Initialize pagination
  2959 12D4 20 79 13		        JSR     DO_CLS
  2960 12D7 A9 15		        LDA     #21
  2961 12D9 8D BB 02		        STA     SCRFLG
  2962
  2963 12DC			TYPE_LOOP:
  2964 				    ; Bail if ESC key is pressed
  2965 12DC AD FC 02		        LDA     CH
  2966 12DF C9 1C		        CMP     #ESC_KEY
  2967 12E1 F0 49		        BEQ     TYPE_DONE
  2968
  2969 				    ; Check if page is full
  2970 12E3 AD BB 02		        LDA     SCRFLG
  2971 12E6 C9 16		        CMP     #22             ; if SCRFLG < 21
  2972 12E8 90 14		        BCC     TYPE_READ       ; then skip to read
  2973
  2974 				    ; Here if page is full
  2975 				    ; Wait for keypress
  2976 12EA A9 FF		        LDA     #$FF            ; Clear keypress
  2977 12EC 8D FC 02		        STA     CH
  2978
  2979 12EF			TYPE_WAIT:
  2980 12EF AE FC 02		        LDX     CH              ; Will be $FF if no keypress
  2981 12F2 E8			        INX                     ; $FF --> $00
  2982 12F3 F0 FA		        BEQ     TYPE_WAIT       ; Keep waiting if $00
  2983
  2984 12F5 E0 1C		        CPX     #ESC_KEY        ; Leave if ESC key pressed
  2985 12F7 F0 33		        BEQ     TYPE_DONE
  2986
  2987 				    ; Reset pagination
  2988 12F9 A9 00		        LDA     #$00
  2989 12FB 8D BB 02		        STA     SCRFLG
  2990
  2991 12FE			TYPE_READ:
  2992 				    ; Read from file
  2993 12FE A2 10		        LDX     #$10
  2994 1300 A9 01		        LDA     #$01
  2995 1302 A0 00		        LDY     #$00
  2996 1304 20 ED 09		        JSR     CIOGET
  2997
  2998 				    ; Quit if EOF
  2999 1307 A2 10		        LDX     #$10
  3000 1309 BD 43 03		        LDA     ICSTA,X
  3001 130C C9 88		        CMP     #EOF
  3002 130E F0 1C		        BEQ     TYPE_DONE
  3003
  3004 				    ; Convert CRLF or LF --> EOL
  3005 1310 A0 00		        LDY     #$00
  3006 1312 B1 F3		        LDA     (INBUFF),Y
  3007 1314 C9 0D		        CMP     #CR     ; Skip CR
  3008 1316 F0 11		        BEQ     TYPE_NEXT3
  3009 1318 C9 0A		        CMP     #LF     ; Convert LF --> EOL
  3010 131A D0 04		        BNE     TYPE_NEXT2
  3011 131C A9 9B		        LDA     #EOL
  3012 131E 91 F3		        STA     (INBUFF),Y
  3013
  3014 1320			TYPE_NEXT2:
  3015 				    ; Write to screen
  3016 1320 A2 00		        LDX     #$00
  3017 1322 A9 01		        LDA     #$01
  3018 1324 A0 00		        LDY     #$00
  3019 1326 20 0B 0A		        JSR     CIOPUT
  3020
  3021 1329			TYPE_NEXT3:
  3022 				    ; Do next
  3023 1329 4C DC 12		        JMP     TYPE_LOOP
  3024 				        
  3025 132C			TYPE_DONE:
  3026 132C A9 FF		        LDA     #$FF
  3027 132E 8D FC 02		        STA     CH
  3028 1331 A2 10		        LDX     #$10            ; Close File #1
  3029 1333 4C BB 09		        JMP     CIOCLOSE        ; 
  3030
  3031 1336			TYPE_OPEN_ERR_STR:
  3032 1336 55 4E 41 42 4C 45 +         .BYTE   'UNABLE TO OPEN FILE',EOL
  3033
  3034 				;---------------------------------------
  3035 134A			DO_UNLOCK:
  3036 				;---------------------------------------
  3037 134A A9 90		        LDA     #$90
  3038 134C 8D C6 02		        STA     COLOR2
  3039 134F 60			        RTS
  3040
  3041 				;---------------------------------------
  3042 1350			DO_CAR:
  3043 				;---------------------------------------
  3044
  3045 				    ;---------------------------------------
  3046 				    ; Is cart address space RAM or ROM?
  3047 				    ;---------------------------------------
  3048 1350 AD 00 A0		        LDA     $A000
  3049 1353 EE 00 A0		        INC     $A000
  3050 1356 CD 00 A0		        CMP     $A000
  3051 1359 F0 0A		        BEQ     DO_CAR_NEXT
  3052
  3053 				    ;---------------------------------------
  3054 				    ; RAM found
  3055 				    ;---------------------------------------
  3056 135B 8D 00 A0		        STA     $A000
  3057 135E A9 6C		        LDA     #<DO_CAR_ERR
  3058 1360 A0 13		        LDY     #>DO_CAR_ERR
  3059 1362 4C 7B 0A		        JMP     PRINT_STRING
  3060
  3061 1365			DO_CAR_NEXT:
  3062 1365 A9 FF		        LDA     #$FF
  3063 1367 85 08		        STA     $08         ; Warmstart
  3064 1369 6C FA BF		        JMP     ($BFFA)
  3065
  3066 136C			DO_CAR_ERR:
  3067 136C 4E 4F 20 43 41 52 +         .BYTE   'NO CARTRIDGE',EOL
  3068
  3069 				;---------------------------------------
  3070 1379			DO_CLS:
  3071 				;---------------------------------------
  3072 1379 A9 80		        LDA     #<CLS_STR
  3073 137B A0 13		        LDY     #>CLS_STR
  3074 137D 4C 7B 0A		        JMP     PRINT_STRING
  3075
  3076 1380			CLS_STR:
  3077 1380 7D 9B		        .BYTE   125,EOL
  3078
  3079 				;---------------------------------------
  3080 1382			DO_COLD:
  3081 				;---------------------------------------
  3082 1382 4C 77 E4		        JMP     COLDSV
  3083
  3084 				;---------------------------------------
  3085 1385			DO_HELP:
  3086 				;---------------------------------------
  3087 				    ; Append either "HELP" or arg1 to URL
  3088 1385 A2 00		        LDX     #$00        ; index to start of article buf
  3089 1387 AC 8C 0B		        LDY     CMDSEP      ; index to cmd line arg
  3090 				        
  3091 138A			HELP_LOOP1:
  3092 138A B1 F3		        LDA     (INBUFF),Y
  3093 138C C9 9B		        CMP     #EOL
  3094 138E F0 11		        BEQ     HELP_NEXT1  ; Exit loop at end of arg
  3095 1390 E0 16		        CPX     #22
  3096 1392 10 2B		        BPL     HELP_DONE   ; Exit if arg is too long
  3097 1394 9D 1B 14		        STA     HELP_ARTICLE,X
  3098 1397 E8			        INX
  3099 1398 C8			        INY
  3100 1399 D0 EF		        BNE     HELP_LOOP1  ; Always true
  3101
  3102 				    ; Append .DOC extension to article name
  3103 139B			HELP_EXT:
  3104 139B 2E 44 4F 43 9B 00	        .BYTE   '.DOC',EOL,$00
  3105
  3106 13A1			HELP_NEXT1:
  3107 13A1 A0 00		        LDY     #$00
  3108
  3109 13A3			HELP_LOOP2:
  3110 13A3 B9 9B 13		        LDA     HELP_EXT,Y
  3111 13A6 9D 1B 14		        STA     HELP_ARTICLE,X  ; Store null term too
  3112 13A9 F0 04		        BEQ     HELP_NEXT2      ; Skip ahead if terminator
  3113 13AB E8			        INX
  3114 13AC C8			        INY
  3115 13AD D0 F4		        BNE     HELP_LOOP2  ; Always true
  3116
  3117 13AF			HELP_NEXT2:
  3118 				    ; Copy URL to LNBUF
  3119 13AF A2 00		        LDX     #$00    ; Index to start of HELP_URL
  3120 13B1 A0 05		        LDY     #$05    ; Index to start at arg1 for "TYPE "
  3121 				    
  3122 13B3			HELP_LOOP3:
  3123 13B3 BD C7 13		        LDA     HELP_URL,X  ; Get source byte
  3124 13B6 99 82 05		        STA     LNBUF,Y     ; Write to target location
  3125 13B9 F0 04		        BEQ     HELP_DONE   ; Exit loop on null terminator
  3126 13BB E8			        INX                 ; Advance indices
  3127 13BC C8			        INY
  3128 13BD D0 F4		        BNE     HELP_LOOP3  ; Always true
  3129 				        
  3130 13BF			HELP_DONE:        
  3131 13BF A9 05		        LDA     #$05        ; Trick TYPE to look for URL in arg1
  3132 13C1 8D 8C 0B		        STA     CMDSEP
  3133 13C4 4C AC 12		        JMP     DO_TYPE
  3134
  3135 13C7			HELP_URL:
  3136 13C7 4E 38 3A 48 54 54 +         .BYTE   'N8:HTTPS://raw.githubusercontent.com/michaelsternberg/fujinet-nhandler/nos/nos/HELP/'
  3137
  3138 141B			HELP_ARTICLE:
  3139 141B 00 00 00 00 00 00 +     :24 .BYTE   $00
  3140
  3141 				;---------------------------------------
  3142 1433			DO_NOBASIC:
  3143 				;---------------------------------------
  3144 				    ; Quit if 400/800
  3145 1433 AD F7 FF		        LDA     $FFF7
  3146 1436 C9 FF		        CMP     #$FF        ; ????
  3147 1438 F0 21		        BEQ     NOBASIC_ERROR
  3148 143A C9 DD		        CMP     #$DD        ; OSA NTSC
  3149 143C F0 1D		        BEQ     NOBASIC_ERROR
  3150 143E C9 F3		        CMP     #$F3        ; OSB NTSC
  3151 1440 F0 19		        BEQ     NOBASIC_ERROR
  3152 1442 C9 D6		        CMP     #$D6        ; OSA PAL
  3153 1444 F0 15		        BEQ     NOBASIC_ERROR
  3154 1446 C9 22		        CMP     #$22        ; OSB PAL
  3155 1448 F0 11		        BEQ     NOBASIC_ERROR
  3156 144A C9 0A		        CMP     #$0A        ; OSA 1200XL
  3157 144C F0 0D		        BEQ     NOBASIC_ERROR
  3158 144E C9 0B		        CMP     #$0B        ; OSB 1200XL
  3159 1450 F0 09		        BEQ     NOBASIC_ERROR
  3160 				        
  3161 				    ; Disable BASIC
  3162 1452 AD 01 D3		        LDA     PORTB
  3163 1455 09 02		        ORA     #%00000010  ; if Bit 1 = 1 then BASIC is disabled
  3164 1457 8D 01 D3		        STA     PORTB
  3165 145A 60			        RTS
  3166
  3167 				;---------------------------------------
  3168 145B			NOBASIC_ERROR:
  3169 				;---------------------------------------
  3170 145B A9 62		        LDA     #<NOBASIC_ERROR_STR
  3171 145D A0 14		        LDY     #>NOBASIC_ERROR_STR
  3172 145F 4C 7B 0A		        JMP     PRINT_STRING
  3173
  3174 1462			NOBASIC_ERROR_STR:
  3175 1462 4E 4F 20 42 55 49 +         .BYTE   'NO BUILT-IN BASIC',EOL
  3176
  3177 				;---------------------------------------
  3178 1474			DO_NOSCREEN:
  3179 				;---------------------------------------
  3180 1474 A9 00		        LDA     #$00
  3181 1476 8D 5B 17		        STA     ECHO_FLG    ; Disable echo in batch processing
  3182 1479 60			        RTS
  3183
  3184 				;---------------------------------------
  3185 147A			DO_SCREEN:
  3186 				;---------------------------------------
  3187 147A A9 01		        LDA     #$01
  3188 147C 8D 5B 17		        STA     ECHO_FLG    ; Enable echo in batch processing
  3189 147F 60			        RTS
  3190
  3191 				;---------------------------------------
  3192 1480			DO_PRINT:
  3193 				;---------------------------------------
  3194 1480 AD 8C 0B		        LDA     CMDSEP
  3195 1483 F0 08		        BEQ     PRINT_DONE
  3196
  3197 1485 18			        CLC
  3198 1486 65 F3		        ADC     INBUFF
  3199 1488 A4 F4		        LDY     INBUFF+1
  3200 148A 4C 7B 0A		        JMP     PRINT_STRING
  3201
  3202 148D			PRINT_DONE:
  3203 148D 60			        RTS
  3204
  3205 				;---------------------------------------
  3206 148E			DO_REENTER:
  3207 				;---------------------------------------
  3208 				    ; Jump to the address stored in RUNAD or INITAD
  3209 				    ; Do the one that isn't pointing to R (RUNAD first)
  3210
  3211 				    ; Skip it all if both contain $0000
  3212 148E AD E2 02		        LDA     INITAD
  3213 1491 D0 16		        BNE     DO_REENTER_CONT
  3214 1493 AD E3 02		        LDA     INITAD+1
  3215 1496 D0 11		        BNE     DO_REENTER_CONT
  3216 1498 AD E0 02		        LDA     RUNAD
  3217 149B D0 0C		        BNE     DO_REENTER_CONT
  3218 149D AD E1 02		        LDA     RUNAD+1
  3219 14A0 D0 07		        BNE     DO_REENTER_CONT
  3220
  3221 14A2 A9 BD		        LDA     #<DO_REENTER_ERR
  3222 14A4 A0 14		        LDY     #>DO_REENTER_ERR
  3223 14A6 4C 7B 0A		        JMP     PRINT_STRING
  3224
  3225 14A9			DO_REENTER_CONT:
  3226 14A9 AD E0 02		        LDA     RUNAD
  3227 14AC C9 0E		        CMP     #>R
  3228 14AE D0 07		        BNE     DO_REENTER_RUNAD
  3229 14B0 AD E1 02		        LDA     RUNAD+1
  3230 14B3 C9 0E		        CMP     #>R
  3231 14B5 F0 03		        BEQ     DO_REENTER_INITAD
  3232
  3233 14B7			DO_REENTER_RUNAD:
  3234 14B7 6C E0 02		        JMP     (RUNAD)     ; Godspeed
  3235
  3236 14BA			DO_REENTER_INITAD:
  3237 14BA 6C E2 02		        JMP     (INITAD)    ; Godspeed
  3238
  3239 14BD			DO_REENTER_ERR:
  3240 14BD 4E 4F 20 41 44 44 +         .BYTE   'NO ADDR IN INITAD OR RUNAD',EOL
  3241
  3242 				;---------------------------------------
  3243 14D8			DO_REM:
  3244 				;---------------------------------------
  3245 14D8 60			        RTS
  3246
  3247 				;---------------------------------------
  3248 14D9			DO_RUN:
  3249 				;---------------------------------------
  3250 14D9 AD 8C 0B		        LDA     CMDSEP      ; Get position for address arg
  3251 14DC A8			        TAY                 ; Offset to arg used later
  3252 14DD 18			        CLC
  3253 14DE 69 04		        ADC     #$04
  3254 14E0 8D 00 18		        STA     RBUF
  3255
  3256 				    ;---------------------------------------
  3257 				    ; ASCII hex char to integer conversion
  3258 				    ; algorithm borrowed from Apple II Monitor
  3259 				    ;---------------------------------------
  3260 14E3 A9 00		        LDA     #$00
  3261 14E5 85 F3		        STA     INBUFF      ; L
  3262 14E7 85 F4		        STA     INBUFF+1    ; H
  3263 14E9			NEXTHEX:
  3264 14E9 B9 82 05		        LDA     LNBUF,Y     ; Get character for hex test.
  3265 14EC 49 30		        EOR     #%00110000  ; Maps digits to $0-$9
  3266 14EE C9 0A		        CMP     #$0A        ; Digit?
  3267 14F0 90 06		        BCC     DIG         ; Yes.
  3268 14F2 69 88		        ADC     #$88        ; Map letter "A"-"F" to $FA-FF.
  3269 14F4 C9 FA		        CMP     #$FA        ; Hex letter?
  3270 14F6 90 17		        BCC     NOTHEX      ; No, character not hex.
  3271
  3272 14F8 0A			DIG:    ASL
  3273 14F9 0A			        ASL
  3274 14FA 0A			        ASL
  3275 14FB 0A			        ASL
  3276 14FC A2 04		        LDX     #$04        ; Shift count.
  3277
  3278 14FE			HEXSHIFT:
  3279 14FE 0A			        ASL
  3280 14FF 26 F3		        ROL     INBUFF      ; Rotate into LSD.
  3281 1501 26 F4		        ROL     INBUFF+1    ; Rotate into MSD's.
  3282 1503 CA			        DEX                 ; Done 4 shifts?
  3283 1504 D0 F8		        BNE     HEXSHIFT    ; No, loop.
  3284 1506 C8			        INY                 ; Advance text index
  3285 1507 CC 00 18		        CPY     RBUF        ; Processed 4 characters?
  3286 150A D0 DD		        BNE     NEXTHEX     ; No, get next character.
  3287
  3288 150C 6C F3 00		        JMP     (INBUFF)    ; Goto requested address. Godspeed.
  3289
  3290 150F			NOTHEX:
  3291 150F A9 16		        LDA     #<RUN_ERROR_STR
  3292 1511 A0 15		        LDY     #>RUN_ERROR_STR
  3293 1513 4C 7B 0A		        JMP     PRINT_STRING
  3294
  3295 1516			RUN_ERROR_STR:
  3296 1516 41 44 44 52 3F 20 +         .BYTE   'ADDR? 0000..FFFF',EOL
  3297
  3298 				;---------------------------------------
  3299 1527			DO_WARM:
  3300 				;---------------------------------------
  3301 1527 4C 74 E4		        JMP     WARMSV
  3302
  3303 				;---------------------------------------
  3304 152A			DO_XEP:
  3305 				;---------------------------------------
  3306 152A A0 19		        LDY     #$19        ; CMD = $19 (enter 40 col)
  3307 152C AE 8C 0B		        LDX     CMDSEP
  3308 152F BD 82 05		        LDA     LNBUF,X
  3309 1532 C9 34		        CMP     #'4'
  3310 1534 F0 01		        BEQ     @+
  3311 1536 88			        DEY                 ; CMD = $18 (enter 80 col)
  3312 1537			@:      
  3313 1537 A2 00		        LDX     #$00
  3314 1539 98			        TYA
  3315 153A 9D 42 03		        STA     ICCOM,X
  3316 153D A9 57		        LDA     #<EDEV
  3317 153F 9D 44 03		        STA     ICBAL,X
  3318 1542 A9 15		        LDA     #>EDEV
  3319 1544 9D 45 03		        STA     ICBAH,X
  3320 1547 A9 2C		        LDA     #$2C
  3321 1549 9D 4A 03		        STA     ICAX1,X
  3322 154C A9 00		        LDA     #$00
  3323 154E 9D 4B 03		        STA     ICAX2,X
  3324 1551 20 56 E4		        JSR     CIOV
  3325 1554 4C 79 13		        JMP     DO_CLS
  3326
  3327 1557 25 1A 9B		EDEV:   .BYTE   "E:",EOL
  3328 				        
  3329 				;---------------------------------------
  3330 155A			REMOUNT_DRIVE:
  3331 				;---------------------------------------
  3332
  3333 				    ;---------------------------------------
  3334 				    ; Workaround for timeout issue regarding idempotent commands that
  3335 				    ; unmount the server.  So far, these are DEL and RENAME. This
  3336 				    ; routine, remounts the TNFS URL by calling NPWD and attempts
  3337 				    ; a MKDIR on the returned mount point. Hopefully this is an
  3338 				    ; non-consequential operation since the directory already exists.
  3339 				    ;---------------------------------------
  3340
  3341 155A 20 92 10		        JSR     DO_NPWD         ; Curr dir for drive now in RBUF
  3342
  3343 155D AD 00 18		        LDA     RBUF            ; Quit if not TNFS. Only TNFS is affected.
  3344 1560 C9 54		        CMP     #'T'            ; TODO More letters needed if...
  3345 1562 D0 28		        BNE     REMOUNT_DONE    ; ...another Txxx protocol exists
  3346
  3347 1564 A9 4E		        LDA     #'N'
  3348 1566 8D 00 18		        STA     RBUF+0
  3349 1569 AD 58 17		        LDA     DOSDR           ; Get drive number
  3350 156C 09 30		        ORA     #'0'            ; Convert, say, 1 to '1'
  3351 156E 8D 01 18		        STA     RBUF+1
  3352 1571 A9 3A		        LDA     #':'
  3353 1573 8D 02 18		        STA     RBUF+2
  3354
  3355 1576 A9 2A		        LDA     #CMD_MKDIR
  3356 1578 8D B8 0C		        STA     GENDCB+2
  3357 157B A9 00		        LDA     #<RBUF          ; TODO Is this needed
  3358 157D 8D BA 0C		        STA     GENDCB+4        ; TODO or is it hardcoded in DO_GENERIC?
  3359 1580 A9 18		        LDA     #>RBUF
  3360 1582 8D BB 0C		        STA     GENDCB+5
  3361
  3362 1585 A9 B6		        LDA     #<GENDCB
  3363 1587 A0 0C		        LDY     #>GENDCB
  3364 1589 4C A5 07		        JMP     DOSIOV
  3365
  3366 158C			REMOUNT_DONE:
  3367 158C 60			        RTS
  3368
  3369 				;---------------------------------------
  3370 158D			PREPEND_DRIVE:
  3371 				;---------------------------------------
  3372 				        ; Inject "Nn:" in front of a plain filename
  3373 				        ; before passing it to the FujiNet
  3374 158D A0 00		        LDY     #$00
  3375 158F A9 4E		        LDA     #'N'
  3376 1591 D1 F3		        CMP     (INBUFF),Y  ; Does arg1 already begin with N?
  3377
  3378 1593 A0 02		        LDY     #$02
  3379 1595 A9 3A		        LDA     #':'
  3380 1597 D1 F3		        CMP     (INBUFF),Y
  3381 1599 F0 1C		        BEQ     PREPEND_DRIVE_DONE
  3382 159B 88			        DEY
  3383 159C D1 F3		        CMP     (INBUFF),Y
  3384 159E F0 17		        BEQ     PREPEND_DRIVE_DONE
  3385
  3386 				        ; Move input buffer pointer back 3 bytes
  3387 15A0 38			        SEC
  3388 15A1 A5 F3		        LDA     INBUFF
  3389 15A3 E9 03		        SBC     #$03
  3390 15A5 85 F3		        STA     INBUFF
  3391 15A7 A5 F4		        LDA     INBUFF+1
  3392 15A9 E9 00		        SBC     #$00
  3393 15AB 85 F4		        STA     INBUFF+1
  3394
  3395 				        ; Inject PRMPT to front of arg1
  3396 15AD A0 03		        LDY     #$03
  3397 15AF			PREPEND_DRIVE_LOOP:
  3398 15AF B9 E1 15		        LDA     PRMPT,Y
  3399 15B2 88			        DEY
  3400 15B3 91 F3		        STA     (INBUFF),Y
  3401 15B5 D0 F8		        BNE     PREPEND_DRIVE_LOOP
  3402
  3403 15B7			PREPEND_DRIVE_DONE:
  3404 15B7 A0 01		        LDY     #$01
  3405 15B9 60			        RTS             ; Y = $00 here
  3406
  3407 				;---------------------------------------
  3408 15BA			APPEND_SLASH:
  3409 				;---------------------------------------
  3410 				    ;---------------------------------------
  3411 				    ; Skip if relative path (..)
  3412 				    ;---------------------------------------
  3413 15BA A0 00		        LDY     #$00
  3414 15BC A9 2E		        LDA     #'.'
  3415 15BE D1 F3		        CMP     (INBUFF),Y
  3416 15C0 F0 1E		        BEQ     APPEND_SLASH_DONE
  3417
  3418 15C2 A0 FF		        LDY     #$FF        ; Iterate thru arg2 until EOF
  3419 15C4			APPEND_SLASH_LOOP:
  3420 15C4 C8			        INY                 ; Zero on 1st pass
  3421 15C5 B1 F3		        LDA     (INBUFF),Y
  3422 15C7 C9 9B		        CMP     #EOL
  3423 15C9 D0 F9		        BNE     APPEND_SLASH_LOOP
  3424
  3425 15CB 88			        DEY                 ; Move pointer back one character
  3426 15CC B1 F3		        LDA     (INBUFF),Y
  3427 15CE C9 2F		        CMP     #'/'        ; If already slash then skip rest
  3428 15D0 F0 0E		        BEQ     APPEND_SLASH_DONE
  3429 15D2 C9 3A		        CMP     #':'        ; If a drive, skip
  3430 15D4 F0 0A		        BEQ     APPEND_SLASH_DONE
  3431
  3432 15D6 C8			        INY                 ; Else inject '/' + EOL
  3433 15D7 A9 2F		        LDA     #'/'
  3434 15D9 91 F3		        STA     (INBUFF),Y
  3435 15DB C8			        INY
  3436 15DC A9 9B		        LDA     #EOL
  3437 15DE 91 F3		        STA     (INBUFF),Y
  3438
  3439 15E0			APPEND_SLASH_DONE:
  3440 15E0 60			        RTS
  3441
  3442 15E1			PRMPT:
  3443 15E1 9B 4E 20 3A		        .BYTE   EOL,'N :'
  3444
  3445 				;;; End CP ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  3446 				;;; Variables
  3447
  3448 15E5			        .ENUM   CMD_IDX
  3449 				        ;---------------
  3450 = 0000			                NCD                 ;  0
  3451 = 0001			                COPY                ;  1
  3452 = 0002			                DIR                 ;  2
  3453 = 0003			                DEL                 ;  3
  3454 = 0004			                LOAD                ;  4
  3455 = 0005			                LOCK                ;  5
  3456 = 0006			                LOGIN               ;  6
  3457 = 0007			                LPR                 ;  7
  3458 = 0008			                MKDIR               ;  8
  3459 = 0009			                NPWD                ;  9
  3460 = 000A			                NTRANS              ; 10
  3461 = 000B			                RENAME              ; 11
  3462 = 000C			                RMDIR               ; 12
  3463 = 000D			                SUBMIT              ; 13
  3464 = 000E			                TYPE                ; 14
  3465 = 000F			                UNLOCK              ; 15
  3466 = 0010			                AUTORUN             ; 16
  3467 = 0011			                CAR                 ; 17
  3468 = 0012			                CLS                 ; 18
  3469 = 0013			                COLD                ; 19
  3470 = 0014			                HELP                ; 20
  3471 = 0015			                NOBASIC             ; 21
  3472 = 0016			                NOSCREEN            ; 22
  3473 = 0017			                PRINT               ; 23
  3474 = 0018			                REENTER             ; 24
  3475 = 0019			                REM                 ; 25
  3476 = 001A			                RUN                 ; 26
  3477 = 001B			                SCREEN              ; 27
  3478 = 001C			                WARM                ; 28
  3479 = 001D			                XEP                 ; 29
  3480 = 001E			                DRIVE_CHG           ; 30
  3481 				        .ENDE
  3482
  3483 15E5			CMD_DCOMND:
  3484 15E5 2C			        .BYTE   CMD_CD              ;  0 NCD
  3485 15E6 A1			        .BYTE   CMD_COPY            ;  1 COPY
  3486 15E7 02			        .BYTE   CMD_DIR             ;  2 DIR
  3487 15E8 21			        .BYTE   CMD_DEL             ;  3 DEL
  3488 15E9 28			        .BYTE   CMD_LOAD            ;  4 LOAD
  3489 15EA 23			        .BYTE   CMD_LOCK            ;  5 LOCK
  3490 15EB FD			        .BYTE   CMD_LOGIN           ;  6 LOGIN
  3491 15EC F0			        .BYTE   CMD_LPR             ;  7 LPR
  3492 15ED 2A			        .BYTE   CMD_MKDIR           ;  8 MKDIR
  3493 15EE 30			        .BYTE   CMD_NPWD            ;  9 NPWD
  3494 15EF 54			        .BYTE   CMD_NTRANS          ; 10 NTRANS
  3495 15F0 20			        .BYTE   CMD_RENAME          ; 11 RENAME
  3496 15F1 2B			        .BYTE   CMD_RMDIR           ; 12 RMDIR
  3497 15F2 F0			        .BYTE   CMD_SUBMIT          ; 13 SUBMIT
  3498 15F3 F0			        .BYTE   CMD_TYPE            ; 14 TYPE
  3499 15F4 24			        .BYTE   CMD_UNLOCK          ; 15 UNLOCK
  3500 15F5 F0			        .BYTE   CMD_AUTORUN         ; 16 AUTORUN
  3501 15F6 F0			        .BYTE   CMD_CAR             ; 17 CAR
  3502 15F7 F0			        .BYTE   CMD_CLS             ; 18 CLS
  3503 15F8 F0			        .BYTE   CMD_COLD            ; 19 COLD
  3504 15F9 F0			        .BYTE   CMD_HELP            ; 20 HELP
  3505 15FA F0			        .BYTE   CMD_NOBASIC         ; 21 NOBASIC
  3506 15FB F0			        .BYTE   CMD_NOSCREEN        ; 22 NOSCREEN
  3507 15FC F0			        .BYTE   CMD_PRINT           ; 23 PRINT
  3508 15FD F0			        .BYTE   CMD_REENTER         ; 24 REENTER
  3509 15FE F0			        .BYTE   CMD_REM             ; 25 REM
  3510 15FF F0			        .BYTE   CMD_RUN             ; 26 RUN
  3511 1600 F0			        .BYTE   CMD_SCREEN          ; 27 SCREEN
  3512 1601 F0			        .BYTE   CMD_WARM            ; 28 WARM
  3513 1602 F0			        .BYTE   CMD_XEP             ; 29 XEP
  3514 1603 01			        .BYTE   CMD_DRIVE_CHG       ; 30
  3515
  3516 1604			COMMAND:
  3517 1604 4E 43 C4		        .CB     "NCD"               ;  0 NCD
  3518 1607 00			        .BYTE   CMD_IDX.NCD            
  3519
  3520 1608 43 4F 50 D9		        .CB     "COPY"              ;  1 COPY
  3521 160C 01			        .BYTE   CMD_IDX.COPY           
  3522
  3523 160D 44 49 D2		        .CB     "DIR"               ;  2 DIR
  3524 1610 02			        .BYTE   CMD_IDX.DIR              
  3525
  3526 1611 44 45 CC		        .CB     "DEL"               ;  3 DEL
  3527 1614 03			        .BYTE   CMD_IDX.DEL              
  3528
  3529 1615 4C 4F 41 C4		        .CB     "LOAD"              ;  4 LOAD
  3530 1619 04			        .BYTE   CMD_IDX.LOAD             
  3531
  3532 161A 4C 4F 43 CB		        .CB     "LOCK"              ;  5 LOCK
  3533 161E 05			        .BYTE   CMD_IDX.LOCK             
  3534
  3535 161F 4C 4F 47 49 CE	        .CB     "LOGIN"             ;  6 LOGIN
  3536 1624 06			        .BYTE   CMD_IDX.LOGIN              
  3537 				                                        
  3538 1625 4C 50 D2		        .CB     "LPR"               ;  7 LPR
  3539 1628 07			        .BYTE   CMD_IDX.LPR                
  3540 				                                          
  3541 1629 4D 4B 44 49 D2	        .CB     "MKDIR"             ;  8 MKDIR
  3542 162E 08			        .BYTE   CMD_IDX.MKDIR           
  3543 				                                        
  3544 162F 4E 50 57 C4		        .CB     "NPWD"              ;  9 NPWD
  3545 1633 09			        .BYTE   CMD_IDX.NPWD             
  3546 				                                        
  3547 1634 4E 54 52 41 4E D3	        .CB     "NTRANS"            ; 10 NTRANS
  3548 163A 0A			        .BYTE   CMD_IDX.NTRANS            
  3549 				                                        
  3550 163B 52 45 4E 41 4D C5	        .CB     "RENAME"            ; 11 RENAME
  3551 1641 0B			        .BYTE   CMD_IDX.RENAME          
  3552 				                                        
  3553 1642 52 4D 44 49 D2	        .CB     "RMDIR"             ; 12 RMDIR
  3554 1647 0C			        .BYTE   CMD_IDX.RMDIR           
  3555 				                                        
  3556 1648 53 55 42 4D 49 D4	        .CB     "SUBMIT"            ; 13 SUBMIT
  3557 164E 0D			        .BYTE   CMD_IDX.SUBMIT             
  3558 				                                        
  3559 164F 54 59 50 C5		        .CB     "TYPE"              ; 14 SUBMIT
  3560 1653 0E			        .BYTE   CMD_IDX.TYPE              
  3561 				                                        
  3562 1654 55 4E 4C 4F 43 CB	        .CB     "UNLOCK"            ; 15 UNLOCK
  3563 165A 0F			        .BYTE   CMD_IDX.UNLOCK            
  3564 				                                        
  3565 165B 41 55 54 4F 52 55 +         .CB     "AUTORUN"           ; 16 AUTORUN
  3566 1662 10			        .BYTE   CMD_IDX.AUTORUN           
  3567 				                                          
  3568 1663 43 41 D2		        .CB     "CAR"               ; 17 CAR
  3569 1666 11			        .BYTE   CMD_IDX.CAR             
  3570 				                                        
  3571 1667 43 4C D3		        .CB     "CLS"               ; 18 CLS
  3572 166A 12			        .BYTE   CMD_IDX.CLS             
  3573 				                                       
  3574 166B 43 4F 4C C4		        .CB     "COLD"              ; 19 COLD
  3575 166F 13			        .BYTE   CMD_IDX.COLD              
  3576 				                                        
  3577 1670 48 45 4C D0		        .CB     "HELP"              ; 20 HELP
  3578 1674 14			        .BYTE   CMD_IDX.HELP               
  3579 				                                        
  3580 1675 4E 4F 42 41 53 49 +         .CB     "NOBASIC"           ; 21 NOBASIC
  3581 167C 15			        .BYTE   CMD_IDX.NOBASIC           
  3582 				                                          
  3583 167D 40 4E 4F 53 43 52 +         .CB     "@NOSCREEN"         ; 22 @NOSCREEN
  3584 1686 16			        .BYTE   CMD_IDX.NOSCREEN         
  3585 				                                        
  3586 1687 50 52 49 4E D4	        .CB     "PRINT"             ; 23 PRINT
  3587 168C 17			        .BYTE   CMD_IDX.PRINT           
  3588 				                                        
  3589 168D 52 45 45 4E 54 45 +         .CB     "REENTER"           ; 24 REENTER
  3590 1694 18			        .BYTE   CMD_IDX.REENTER         
  3591 				                                        
  3592 1695 52 45 CD		        .CB     "REM"               ; 25 REM
  3593 1698 19			        .BYTE   CMD_IDX.REM             
  3594 				                                        
  3595 1699 52 55 CE		        .CB     "RUN"               ; 26 RUN
  3596 169C 1A			        .BYTE   CMD_IDX.RUN             
  3597 				                                        
  3598 169D 40 53 43 52 45 45 +         .CB     "@SCREEN"           ; 27 @SCREEN
  3599 16A4 1B			        .BYTE   CMD_IDX.SCREEN        
  3600 				                                      
  3601 16A5 57 41 52 CD		        .CB     "WARM"              ; 28 WARM
  3602 16A9 1C			        .BYTE   CMD_IDX.WARM          
  3603 				                                      
  3604 16AA 58 45 D0		        .CB     "XEP"               ; 29 XEP
  3605 16AD 1D			        .BYTE   CMD_IDX.XEP            
  3606 				                                        
  3607 				; Aliases
  3608 16AE 43 C4		        .CB     "CD"                ; CD = NCD
  3609 16B0 00			        .BYTE   CMD_IDX.NCD           
  3610
  3611 16B1 43 57 C4		        .CB     "CWD"               ; CWD = NCD
  3612 16B4 00			        .BYTE   CMD_IDX.NCD           
  3613
  3614 16B5 45 52 41 53 C5	        .CB     "ERASE"             ; ERASE = DEL
  3615 16BA 03			        .BYTE   CMD_IDX.DEL           
  3616
  3617 16BB 45 52 C1		        .CB     "ERA"               ; ERA = DEL
  3618 16BE 03			        .BYTE   CMD_IDX.DEL           
  3619
  3620 16BF D8			        .CB     "X"                 ; X = LOAD
  3621 16C0 04			        .BYTE   CMD_IDX.LOAD
  3622
  3623 16C1 50 57 C4		        .CB     "PWD"               ; PWD = NPWD
  3624 16C4 09			        .BYTE   CMD_IDX.NPWD             
  3625
  3626 16C5 52 45 C5		        .CB     "REE"               ; R = REENTER
  3627 16C8 18			        .BYTE   CMD_IDX.REENTER             
  3628
  3629 16C9 52 45 CE		        .CB     "REN"               ; REN = RENAME
  3630 16CC 0B			        .BYTE   CMD_IDX.RENAME
  3631
  3632 16CD 53 4F 55 52 43 C5	        .CB     "SOURCE"            ; SOURCE = SUBMIT
  3633 16D3 0D			        .BYTE   CMD_IDX.SUBMIT
  3634
  3635 16D4 C0			        .CB     "@"                 ; @ = SUBMIT
  3636 16D5 0D			        .BYTE   CMD_IDX.SUBMIT
  3637
  3638 16D6 A3			        .CB     "#"                 ; # = REM
  3639 16D7 19			        .BYTE   CMD_IDX.REM
  3640
  3641 16D8 A7			        .CB     "'"                 ; ' = REM
  3642 16D9 19			        .BYTE   CMD_IDX.REM
  3643
  3644 				        ; Drive Change intentionally omitted
  3645
  3646 = 00D5			COMMAND_SIZE = * - COMMAND - 1
  3647 16DA FF			        .BYTE   $FF
  3648
  3649 16DB			CMD_TAB_L:
  3650 16DB 54			        .BYTE   <(DO_GENERIC-1)     ;  0 NCD
  3651 16DC C1			        .BYTE   <(DO_COPY-1)        ;  1 COPY
  3652 16DD C7			        .BYTE   <(DO_DIR-1)         ;  2 DIR
  3653 16DE 54			        .BYTE   <(DO_GENERIC-1)     ;  3 DEL
  3654 16DF B1			        .BYTE   <(DO_LOAD-1)        ;  4 LOAD
  3655 16E0 54			        .BYTE   <(DO_LOCK-1)        ;  5 LOCK
  3656 16E1 5A			        .BYTE   <(DO_LOGIN-1)       ;  6 LOGIN
  3657 16E2 8B			        .BYTE   <(DO_LPR-1)         ;  7 LPR
  3658 16E3 54			        .BYTE   <(DO_GENERIC-1)     ;  8 MKDIR
  3659 16E4 91			        .BYTE   <(DO_NPWD-1)        ;  9 NPWD
  3660 16E5 D4			        .BYTE   <(DO_NTRANS-1)      ; 10 NTRANS
  3661 16E6 54			        .BYTE   <(DO_GENERIC-1)     ; 11 RENAME
  3662 16E7 54			        .BYTE   <(DO_GENERIC-1)     ; 12 RMDIR
  3663 16E8 26			        .BYTE   <(DO_SUBMIT-1)      ; 13 SUBMIT
  3664 16E9 AB			        .BYTE   <(DO_TYPE-1)        ; 14 TYPE
  3665 16EA 49			        .BYTE   <(DO_UNLOCK-1)      ; 15 UNLOCK
  3666 16EB 57			        .BYTE   <(DO_AUTORUN-1)     ; 16 AUTORUN
  3667 16EC 4F			        .BYTE   <(DO_CAR-1)         ; 17 CAR
  3668 16ED 78			        .BYTE   <(DO_CLS-1)         ; 18 CLS
  3669 16EE 81			        .BYTE   <(DO_COLD-1)        ; 19 COLD
  3670 16EF 84			        .BYTE   <(DO_HELP-1)        ; 20 HELP
  3671 16F0 32			        .BYTE   <(DO_NOBASIC-1)     ; 21 NOBASIC
  3672 16F1 73			        .BYTE   <(DO_NOSCREEN-1)    ; 22 NOSCREEN
  3673 16F2 7F			        .BYTE   <(DO_PRINT-1)       ; 23 PRINT
  3674 16F3 8D			        .BYTE   <(DO_REENTER-1)     ; 24 REENTER
  3675 16F4 D7			        .BYTE   <(DO_REM-1)         ; 25 REM
  3676 16F5 D8			        .BYTE   <(DO_RUN-1)         ; 26 RUN
  3677 16F6 79			        .BYTE   <(DO_SCREEN-1)      ; 27 SCREEN
  3678 16F7 26			        .BYTE   <(DO_WARM-1)        ; 28 WARM
  3679 16F8 29			        .BYTE   <(DO_XEP-1)         ; 29 XEP
  3680 16F9 13			        .BYTE   <(DO_DRIVE_CHG-1)   ; 30
  3681
  3682 16FA			CMD_TAB_H:
  3683 16FA 0C			        .BYTE   >(DO_GENERIC-1)     ;  0 NCD
  3684 16FB 0C			        .BYTE   >(DO_COPY-1)        ;  1 COPY
  3685 16FC 0C			        .BYTE   >(DO_DIR-1)         ;  2 DIR
  3686 16FD 0C			        .BYTE   >(DO_GENERIC-1)     ;  3 DEL
  3687 16FE 0D			        .BYTE   >(DO_LOAD-1)        ;  4 LOAD
  3688 16FF 10			        .BYTE   >(DO_LOCK-1)        ;  5 LOCK
  3689 1700 10			        .BYTE   >(DO_LOGIN-1)       ;  6 LOGIN
  3690 1701 10			        .BYTE   >(DO_LPR-1)         ;  7 LPR
  3691 1702 0C			        .BYTE   >(DO_GENERIC-1)     ;  8 MKDIR
  3692 1703 10			        .BYTE   >(DO_NPWD-1)        ;  9 NPWD
  3693 1704 10			        .BYTE   >(DO_NTRANS-1)      ; 10 NTRANS
  3694 1705 0C			        .BYTE   >(DO_GENERIC-1)     ; 11 RENAME
  3695 1706 0C			        .BYTE   >(DO_GENERIC-1)     ; 12 RMDIR
  3696 1707 12			        .BYTE   >(DO_SUBMIT-1)      ; 13 SUBMIT
  3697 1708 12			        .BYTE   >(DO_TYPE-1)        ; 14 TYPE
  3698 1709 13			        .BYTE   >(DO_UNLOCK-1)      ; 15 UNLOCK
  3699 170A 11			        .BYTE   >(DO_AUTORUN-1)     ; 16 AUTORUN
  3700 170B 13			        .BYTE   >(DO_CAR-1)         ; 17 CAR
  3701 170C 13			        .BYTE   >(DO_CLS-1)         ; 18 CLS
  3702 170D 13			        .BYTE   >(DO_COLD-1)        ; 19 COLD
  3703 170E 13			        .BYTE   >(DO_HELP-1)        ; 20 HELP
  3704 170F 14			        .BYTE   >(DO_NOBASIC-1)     ; 21 NOBASIC
  3705 1710 14			        .BYTE   >(DO_NOSCREEN-1)    ; 22 NOSCREEN
  3706 1711 14			        .BYTE   >(DO_PRINT-1)       ; 23 PRINT
  3707 1712 14			        .BYTE   >(DO_REENTER-1)     ; 24 REENTER
  3708 1713 14			        .BYTE   >(DO_REM-1)         ; 25 REM
  3709 1714 14			        .BYTE   >(DO_RUN-1)         ; 26 RUN
  3710 1715 14			        .BYTE   >(DO_SCREEN-1)      ; 27 SCREEN
  3711 1716 15			        .BYTE   >(DO_WARM-1)        ; 28 WARM
  3712 1717 15			        .BYTE   >(DO_XEP-1)         ; 29 XEP
  3713 1718 0C			        .BYTE   >(DO_DRIVE_CHG-1)   ; 30
  3714
  3715 				        ; DEVHDL TABLE FOR N:
  3716
  3717 1719 BD 07		CIOHND  .WORD   OPEN-1
  3718 171B 0B 08		        .WORD   CLOSE-1
  3719 171D 2C 08		        .WORD   GET-1
  3720 171F 8D 08		        .WORD   PUT-1
  3721 1721 ED 08		        .WORD   STATUS-1
  3722 1723 53 09		        .WORD   SPEC-1
  3723
  3724 				       ; BANNERS
  3725
  3726 1725 23 46 55 4A 49 4E + BREADY  .BYTE   '#FUJINET NOS v0.4.2-alpha',EOL
  3727 173F 23 46 55 4A 49 4E + BERROR  .BYTE   '#FUJINET ERROR',EOL
  3728
  3729 				        ; MESSAGES
  3730
  3731 174E 4E 23 3F 9B		CDERR   .BYTE   'N#?',EOL
  3732
  3733 				        ; STRING CONSTANTS
  3734
  3735 1752			MISSING_FILE_STR:
  3736 1752 46 49 4C 45 3F 9B	        .BYTE   'FILE?',EOL
  3737
  3738 				        ; VARIABLES
  3739
  3740 1758 01			DOSDR       .BYTE   $01     ; DOS DRIVE
  3741 1759 01			CMD         .BYTE   $01
  3742 175A 01			CMDPRV      .BYTE   $01
  3743 175B 01			ECHO_FLG    .BYTE   $01     ; Echo batch cmds (1=enabled,0=disabled)
  3744 175C 00			AUTORUN_FLG .BYTE   $00     ; Checked at DOS entry. Runs only on first pass
  3745
  3746 175D 01			TRIP    .BYTE   $01         ; INTR FLAG
  3747 175E 00 00 00 00		RLEN    :MAXDEV .BYTE $00   ; RCV LEN
  3748 1762 00 00 00 00		ROFF    :MAXDEV .BYTE $00   ; RCV OFFSET
  3749 1766 00 00 00 00		TOFF    :MAXDEV .BYTE $00   ; TRX OFFSET
  3750 176A 01			INQDS   .BYTE   $01         ; DSTATS INQ
  3751
  3752 176B 00 00 00 00		DVS2    :MAXDEV .BYTE $00   ; DVSTAT+2 SAVE
  3753 176F 00 00 00 00		DVS3    :MAXDEV .BYTE $00   ; DVSTAT+3 SAVE
  3754
  3755 				       ; BUFFERS (PAGE ALIGNED)
  3756 1773 00 00 00 00 00 00 +         .ALIGN  $100, $00
  3757 1800			BOOTEND:
  3758
  3759 1800 00 00 00 00 00 00 + RBUF:   :$80 .BYTE $00      ; 128 bytes
  3760 1880 00 00 00 00 00 00 + TBUF:   :$80 .BYTE $00      ; 128 bytes
  3761
  3762 				; Binary loader working variables
  3763 = 1800			BAL     = RBUF
  3764 = 1801			BAH     = RBUF+1    ;
  3765 = 1880			STL     = TBUF      ; Payload Start address
  3766 = 1881			STH     = TBUF+1
  3767 = 1882			ENL     = TBUF+2    ; Payload End address
  3768 = 1883			ENH     = TBUF+3
  3769 = 1884			BLL     = TBUF+4    ; Payload Buffer Length
  3770 = 1885			BLH     = TBUF+5
  3771 = 1886			HEADL   = TBUF+6    ; Bytes read from existing cache
  3772 = 1887			HEADH   = TBUF+7
  3773 = 1888			BODYL   = TBUF+8    ; Total bytes read in contiguous 512-byte blocks
  3774 = 1889			BODYH   = TBUF+9
  3775 = 188A			TAILL   = TBUF+10   ; Bytes read from last cache
  3776 = 188B			TAILH   = TBUF+11
  3777 = 188C			BODYSZL = TBUF+12   ; # Bytes to read at a time in Body
  3778 = 188D			BODYSZH = TBUF+13
  3779 = 188E			STL2    = TBUF+14   ; Payload Start address (working var)
  3780 = 188F			STH2    = TBUF+15
  3781 = 1890			BIN_1ST = TBUF+16   ; Flag for binary loader signature (FF -> 1st pass)
  3782 = 1891			AUTORUN_QUERY_FLG = TBUF+17   ; Flag for printing contents of autorun appkey
  3783
  3784 = 1900			PGEND   = *
  3785
  3786 				; =================================================================
  3787 				; VTOC and Directory
  3788 				;
  3789
  3790 				; $10 is the added ATR-header
  3791 1900 00 00 00 00 00 00 + :($B390-*+HDR-$10) DTA $00
  3792 BA80			VTOCSTA:
  3793 BA80 02 BD 02		    DTA $02,$BD,$02
  3794 BA83			VTOCEND:
  3795
  3796 				; Fill the remaining bytes of the VTOC sector
  3797 BA83 00 00 00 00 00 00 +     :($80+VTOCSTA-VTOCEND) DTA $00
  3798
  3799 BB00			DIRSTA:
  3800 BB00 60 C3 02 04 00 30 +     DTA $60,$C3,$02,$04,$00,C"0**********"
  3801 BB10 60 C3 02 04 00 31 +     DTA $60,$C3,$02,$04,$00,C"1 FujiNet  "
  3802 BB20 60 C3 02 04 00 32 +     DTA $60,$C3,$02,$04,$00,C"2 Network  "
  3803 BB30 60 C3 02 04 00 33 +     DTA $60,$C3,$02,$04,$00,C"3   OS     "
  3804 BB40 60 C3 02 04 00 34 +     DTA $60,$C3,$02,$04,$00,C"4          "
  3805 BB50 60 C3 02 04 00 35 +     DTA $60,$C3,$02,$04,$00,C"5 v0.4.2   "
  3806 BB60 60 C3 02 04 00 36 +     DTA $60,$C3,$02,$04,$00,C"6  alpha   "
  3807 BB70 60 C3 02 04 00 37 +     DTA $60,$C3,$02,$04,$00,C"7**********"
  3808 BB80 C0			    DTA $C0
  3809 BB81			DIREND:
  3810
  3811 				; Fill the remaining sectors of the directory
  3812 BB81 00 00 00 00 00 00 +     :($400+DIRSTA-DIREND) DTA $00
  3813
  3814 				; Sectors behind directory
  3815 BF00 00 00 00 00 00 00 +     :($80*352) DTA $00
  3816
  3817 				       END
