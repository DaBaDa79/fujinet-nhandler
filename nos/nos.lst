mads 2.1.0
Source: nos.s
     1 				        ;; nos FujiNet Operating System
     2 				        ;; Compile with MADS
     3
     4 				        ;; Authors: Thomas Cherryhomes
     5 				        ;;   <thom.cherryhomes@gmail.com>
     6
     7 				        ;; Michael Sternberg
     8 				        ;;   <mhsternberg@gmail.com>
     9
    10
    11 				        ;; Optimizations being done by djaybee!
    12 				        ;; Thank you so much!
    13
    14
    15 = 000A			DOSVEC  =   $0A         ; DOSVEC
    16 = 000C			DOSINI  =   $0C         ; DOSINI
    17
    18 				        ;; CURRENT IOCB IN ZERO PAGE
    19 = 0020			ZIOCB   =   $20         ; ZP IOCB
    20 = 0020			ZICHID  =   ZIOCB       ; ID
    21 = 0021			ZICDNO  =   ZIOCB+1     ; UNIT #
    22 = 0022			ZICCOM  =   ZIOCB+2     ; COMMAND
    23 = 0023			ZICSTA  =   ZIOCB+3     ; STATUS
    24 = 0024			ZICBAL  =   ZIOCB+4     ; BUF ADR LOW
    25 = 0025			ZICBAH  =   ZIOCB+5     ; BUF ADR HIGH
    26 = 0026			ZICPTL  =   ZIOCB+6     ; PUT ADDR L
    27 = 0027			ZICPTH  =   ZIOCB+7     ; PUT ADDR H
    28 = 0028			ZICBLL  =   ZIOCB+8     ; BUF LEN LOW
    29 = 0029			ZICBLH  =   ZIOCB+9     ; BUF LEN HIGH
    30 = 002A			ZICAX1  =   ZIOCB+10    ; AUX 1
    31 = 002B			ZICAX2  =   ZIOCB+11    ; AUX 2
    32 = 002C			ZICAX3  =   ZIOCB+12    ; AUX 3
    33 = 002D			ZICAX4  =   ZIOCB+13    ; AUX 4
    34 = 002E			ZICAX5  =   ZIOCB+14    ; AUX 5
    35 = 002F			ZICAX6  =   ZIOCB+15    ; AUX 6
    36
    37 = 0052			LMARGN  =   $52         ; Left margin
    38 = 00D4			FR0     =   $D4         ; Floating Point register 0 (used during Hex->ASCII conversion)
    39 = 00F2			CIX     =   $F2         ; Inbuff cursor
    40 = 00F3			INBUFF  =   $F3         ; Ptr to input buffer ($0580)
    41 = 0040			MAX_APPKEY_LEN = $40    ; Used with appkey files
    42
    43 				;---------------------------------------
    44 				; INTERRUPT VECTORS
    45 				; AND OTHER PAGE 2 VARS
    46 				;---------------------------------------
    47
    48 = 0202			VPRCED  =   $0202       ; PROCEED VCTR
    49 = 02C6			COLOR2  =   $02C6       ; MODEF BKG C
    50 = 02E0			RUNAD   =   $02E0       ; RUN ADDRESS
    51 = 02E2			INITAD  =   $02E2       ; INIT ADDRESS
    52 = 02E7			MEMLO   =   $02E7       ; MEM LO
    53 = 02EA			DVSTAT  =   $02EA       ; 4 BYTE STATS
    54
    55 				;---------------------------------------
    56 				; PAGE 3
    57 				; DEVICE CONTROL BLOCK (DCB)
    58 				;---------------------------------------
    59
    60 = 0300			DCB     =   $0300       ; BASE
    61 = 0300			DDEVIC  =   DCB         ; DEVICE #
    62 = 0301			DUNIT   =   DCB+1       ; UNIT #
    63 = 0302			DCOMND  =   DCB+2       ; COMMAND
    64 = 0303			DSTATS  =   DCB+3       ; STATUS/DIR
    65 = 0304			DBUFL   =   DCB+4       ; BUF ADR L
    66 = 0305			DBUFH   =   DCB+5       ; BUF ADR H
    67 = 0306			DTIMLO  =   DCB+6       ; TIMEOUT (S)
    68 = 0307			DRSVD   =   DCB+7       ; NOT USED
    69 = 0308			DBYTL   =   DCB+8       ; BUF LEN L
    70 = 0309			DBYTH   =   DCB+9       ; BUF LEN H
    71 = 030A			DAUXL   =   DCB+10      ; AUX BYTE L
    72 = 030B			DAUXH   =   DCB+11      ; AUX BYTE H
    73
    74 = 031A			HATABS  =   $031A       ; HANDLER TBL
    75
    76 				;---------------------------------------
    77 				; IOCB'S * 8
    78 				;---------------------------------------
    79
    80 = 0340			IOCB    =   $0340       ; IOCB BASE
    81 = 0340			ICHID   =   IOCB        ; ID
    82 = 0341			ICDNO   =   IOCB+1      ; UNIT #
    83 = 0342			ICCOM   =   IOCB+2      ; COMMAND
    84 = 0343			ICSTA   =   IOCB+3      ; STATUS
    85 = 0344			ICBAL   =   IOCB+4      ; BUF ADR LOW
    86 = 0345			ICBAH   =   IOCB+5      ; BUF ADR HIGH
    87 = 0346			ICPTL   =   IOCB+6      ; PUT ADDR L
    88 = 0347			ICPTH   =   IOCB+7      ; PUT ADDR H
    89 = 0348			ICBLL   =   IOCB+8      ; BUF LEN LOW
    90 = 0349			ICBLH   =   IOCB+9      ; BUF LEN HIGH
    91 = 034A			ICAX1   =   IOCB+10     ; AUX 1
    92 = 034B			ICAX2   =   IOCB+11     ; AUX 2
    93 = 034C			ICAX3   =   IOCB+12     ; AUX 3
    94 = 034D			ICAX4   =   IOCB+13     ; AUX 4
    95 = 034E			ICAX5   =   IOCB+14     ; AUX 5
    96 = 034F			ICAX6   =   IOCB+15     ; AUX 6
    97
    98 = 0054			ROWCRS  =   $0054
    99 = 02BB			SCRFLG  =   $02BB       ; Scroll flag
   100 = 02FC			CH      =   $02FC       ; Hardware code for last key pressed
   101 = 02F2			CH1     =   $02F2       ; Prior keyboard character code
   102 = 0582			LNBUF   =   $0582       ; Line Buffer (128 bytes)
   103
   104 				;---------------------------------------
   105 				; HARDWARE REGISTERS
   106 				;---------------------------------------
   107
   108 = D301			PORTB   =   $D301       ; On XL/XE, used to enable/disable BASIC
   109 = D302			PACTL   =   $D302       ; PIA CTRL A
   110
   111 				;---------------------------------------
   112 				; MATH PACK VECTORS
   113 				;---------------------------------------
   114 = D8E6			FASC    =   $D8E6       ; Floating point to ASCII
   115 = D9AA			IFP     =   $D9AA       ; Integer to floating point
   116
   117 				;---------------------------------------
   118 				; OS ROM VECTORS
   119 				;---------------------------------------
   120
   121 = E456			CIOV    =   $E456       ; CIO ENTRY
   122 = E459			SIOV    =   $E459       ; SIO ENTRY
   123 = E474			WARMSV  =   $E474       ; Warmstart entry point
   124 = E477			COLDSV  =   $E477       ; Coldstart entry point
   125
   126 				;---------------------------------------
   127 				; CONSTANTS
   128 				;---------------------------------------
   129
   130 = 0005			GETREC  =   $05         ; CIO CMD TO GET RECORD
   131 = 0009			PUTREC  =   $09         ; CIO CMD TO PUT RECORD
   132 = 000B			PUTCHR  =   $0B         ; CIO CMD TO PUT CHAR
   133
   134 = 0071			DEVIDN  =   $71         ; SIO DEVID
   135 = 0040			DSREAD  =   $40         ; FUJI->ATARI
   136 = 0080			DSWRIT  =   $80         ; ATARI->FUJI
   137 = 0004			MAXDEV  =   4           ; # OF N: DEVS
   138 = 0088			EOF     =   $88         ; ERROR 136
   139
   140 = 009B			EOL     =   $9B         ; EOL CHAR
   141 = 000D			CR      =   $0D         ; Carrige Return
   142 = 000A			LF      =   $0A         ; Linefeed
   143
   144 = 001C			ESC_KEY =   $1C         ; Hardware code for ESC
   145 = 0021			SPC_KEY =   $21         ; Hardware code for SPACE
   146
   147 = 0004			OINPUT  =   $04         ; CIO/SIO direction
   148 = 0008			OOUTPUT =   $08         ; CIO/SIO direction
   149
   150 				; FujiNet SIO command bytes
   151 = 0001			CMD_DRIVE_CHG       = $01
   152 = 002C			CMD_CD              = $2C
   153 = 00A1			CMD_COPY            = $A1
   154 = 0002			CMD_DIR             = $02
   155 = 0021			CMD_DEL             = $21
   156 = 0028			CMD_LOAD            = $28
   157 = 0023			CMD_LOCK            = $23
   158 = 00FD			CMD_LOGIN           = $FD
   159 = 002A			CMD_MKDIR           = $2A
   160 = 0030			CMD_NPWD            = $30
   161 = 0054			CMD_NTRANS          = 'T'
   162 = 00FE			CMD_PASSWD          = $FE
   163 = 0020			CMD_RENAME          = $20
   164 = 002B			CMD_RMDIR           = $2B
   165 = 00F0			CMD_SUBMIT          = $F0
   166 = 00F0			CMD_TYPE            = $F0
   167 = 0024			CMD_UNLOCK          = $24
   168 = 00F0			CMD_CAR             = $F0
   169 = 00F0			CMD_CLS             = $F0
   170 = 00F0			CMD_COLD            = $F0
   171 = 00F0			CMD_HELP            = $F0
   172 = 00F0			CMD_NOBASIC         = $F0
   173 = 00F0			CMD_NOSCREEN        = $F0
   174 = 00F0			CMD_PRINT           = $F0
   175 = 00F0			CMD_REENTER         = $F0
   176 = 00F0			CMD_REM             = $F0
   177 = 00F0			CMD_RUN             = $F0
   178 = 00F0			CMD_SCREEN          = $F0
   179 = 00F0			CMD_WARM            = $F0
   180 = 00F0			CMD_XEP             = $F0
   181 = 00F0			CMD_AUTORUN         = $F0
   182
   183 				;;; Macros ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   184
   185 				        .MACRO DCBC
   186 				        .LOCAL
   187 				        LDY     #$0C
   188 				?DCBL   LDA     %%1,Y
   189 				        STA     DCB,Y
   190 				        DEY
   191 				        BPL     ?DCBL
   192 				        .ENDL
   193 				        .ENDM
   194
   195 				; ATR Header
   196 				;        ORG     $0700
   197 					    ORG	    $06f0
   198 				        OPT     h-
   199 06F0 96 02 80 16 80		    DTA	    $96,$02,$80,$16,$80
   200 06F5 00 00 00 00 00 00 + :11     DTA	    $00
   201
   202 				;;; Initialization ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   203
   204 				;        ORG     $0700
   205 				;        OPT     h-
   206
   207 0700 00			HDR:    .BYTE   $00                 ; BLFAG: Boot flag equals zero (unused)
   208 0701 22			        .BYTE   [BOOTEND-HDR]/128   ; BRCNT: Number of consecutive sectors to read
   209 0702 00 07		        .WORD   HDR                 ; BLDADR: Boot sector load address ($700).
   210 0704 C0 E4		        .WORD   $E4C0               ; BIWTARR: Init addr (addr of RTS in ROM)
   211
   212 				;HDR:    .BYTE   $00                 ; BLFAG: Boot flag equals zero (unused)
   213 				;        .BYTE   [PGEND-HDR]/128-2   ; BRCNT: Number of consecutive sectors to read
   214 				;        .WORD   $0700               ; BLDADR: Boot sector load address ($700).
   215 				;        .WORD   $E4C0               ; BIWTARR: Init addr (addr of RTS in ROM)
   216
   217 0706 4C 09 07			JMP	START
   218 				;	ORG	*+$64
   219
   220 0709 A5 0C		START:  LDA     DOSINI
   221 070B 8D 27 07		        STA     RESET+1
   222 070E A5 0D		        LDA     DOSINI+1
   223 0710 8D 28 07		        STA     RESET+2
   224
   225 0713 A9 26		        LDA     #<RESET
   226 0715 85 0C		        STA     DOSINI
   227 0717 A9 07		        LDA     #>RESET
   228 0719 85 0D		        STA     DOSINI+1
   229 071B A9 CE		        LDA     #<DOS       ; Point to DOS & CP below
   230 071D 85 0A		        STA     DOSVEC
   231 071F A9 0A		        LDA     #>DOS
   232 0721 85 0B		        STA     DOSVEC+1
   233
   234 0723 4C 39 07		        JMP     ALTMEML     ; Alter MEMLO
   235
   236 0726 20 FF FF		RESET:  JSR     $FFFF       ; Jump to extant DOSINI
   237
   238 0729 A9 4E		        LDA     #'N'
   239 072B 8D 00 18		        STA     RBUF
   240 072E 20 44 07		        JSR     IHTBS       ; Insert into HATABS
   241
   242 0731 A9 44		        LDA     #'D'
   243 0733 8D 00 18		        STA     RBUF
   244 0736 20 44 07		        JSR     IHTBS       ; Clone N: as D: for compatibility
   245
   246 				;---------------------------------------
   247 				;  Alter MEMLO
   248 				;---------------------------------------
   249 0739			ALTMEML:
   250 0739 A9 00		        LDA     #<PGEND
   251 073B 8D E7 02		        STA     MEMLO
   252 073E A9 19		        LDA     #>PGEND
   253 0740 8D E8 02		        STA     MEMLO+1
   254
   255 				        ;; Back to DOS
   256
   257 0743 60			        RTS
   258
   259 				;---------------------------------------
   260 				; Insert entry into HATABS
   261 				;---------------------------------------
   262
   263 0744			IHTBS:
   264 0744 A0 00		        LDY     #$00
   265 0746 B9 1A 03		IH1     LDA     HATABS,Y
   266 0749 F0 0C		        BEQ     HFND
   267 				        ;CMP     #'N'
   268 074B CD 00 18		        CMP     RBUF
   269 074E F0 07		        BEQ     HFND
   270 0750 C8			        INY
   271 0751 C8			        INY
   272 0752 C8			        INY
   273 0753 C0 21		        CPY     #11*3
   274 0755 90 EF		        BCC     IH1
   275
   276 				        ;; Found a slot
   277
   278 0757			HFND:
   279 				        ;LDA     #'N'
   280 				;--
   281 0757 AD 00 18		        LDA     RBUF
   282 075A AA			        TAX
   283 				;--
   284 075B 99 1A 03		        STA     HATABS,Y
   285 075E A9 A7		        LDA     #<CIOHND
   286 0760 99 1B 03		        STA     HATABS+1,Y
   287 0763 A9 16		        LDA     #>CIOHND
   288 0765 99 1C 03		        STA     HATABS+2,Y
   289
   290 0768 E0 44		        CPX     #'D'
   291 076A F0 01		        BEQ     HATABS_CONT
   292 076C 60			        RTS
   293
   294 076D			HATABS_CONT:
   295 				        ;; And we're done with HATABS
   296
   297 				        ;; Query FUJINET
   298
   299 076D 20 24 09		        JSR     STPOLL
   300
   301 				        ;; Output Ready/Error
   302
   303 0770			OBANR:
   304 0770 A2 00		        LDX     #$00        ; IOCB #0
   305 0772 A9 09		        LDA     #PUTREC
   306 0774 9D 42 03		        STA     ICCOM,X
   307 0777 A9 28		        LDA     #$28        ; 40 CHARS Max
   308 0779 9D 48 03		        STA     ICBLL,X
   309 077C 8A			        TXA
   310 077D 9D 49 03		        STA     ICBLH,X
   311 0780 AD 03 03		        LDA     DSTATS      ; Check DSTATS
   312 0783 10 06		        BPL     OBRDY       ; < 128 = Ready
   313
   314 				        ;; Status returned error.
   315
   316 0785			OBERR:
   317 0785 A9 CD		        LDA     #<BERROR
   318 0787 A0 16		        LDY     #>BERROR
   319 0789 50 04		        BVC     OBCIO
   320
   321 				        ;; Status returned ready.
   322
   323 078B			OBRDY:
   324 078B A9 B3		        LDA     #<BREADY
   325 078D A0 16		        LDY     #>BREADY
   326
   327 078F			OBCIO:
   328 078F 9D 44 03		        STA     ICBAL,X
   329 0792 98			        TYA
   330 0793 9D 45 03		        STA     ICBAH,X
   331
   332 0796 20 56 E4		        JSR     CIOV
   333
   334 				        ;; Vector in proceed interrupt
   335
   336 0799			SPRCED:
   337 0799 A9 5D		        LDA     #<PRCVEC
   338 079B 8D 02 02		        STA     VPRCED
   339 079E A9 0A		        LDA     #>PRCVEC
   340 07A0 8D 03 02		        STA     VPRCED+1
   341
   342 				        ;; And we are done, back to DOS.
   343 07A3 18			        CLC
   344 07A4 60			        RTS
   345
   346 				;;; End Initialization Code ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   347
   348 				; Copy command's template DCB struct to OS's DCB struct (12 bytes)
   349 07A5			DOSIOV:
   350 07A5 8D AE 07		        STA     DODCBL+1
   351 07A8 8C AF 07		        STY     DODCBL+2
   352 07AB A0 0C		        LDY     #$0C
   353 07AD B9 FF FF		DODCBL  LDA     $FFFF,Y
   354 07B0 99 00 03		        STA     DCB,Y
   355 07B3 88			        DEY
   356 07B4 10 F7		        BPL     DODCBL
   357
   358 07B6			SIOVDST:
   359 07B6 20 59 E4		        JSR     SIOV
   360 07B9 AC 03 03		        LDY     DSTATS
   361 07BC 98			        TYA
   362 07BD 60			        RTS
   363
   364
   365 				;---------------------------------------
   366 				; CIO OPEN
   367 				;---------------------------------------
   368
   369 07BE			OPEN:
   370 				        ;; Prepare DCB
   371
   372 07BE 20 59 0A		        JSR     GDIDX       ; Get Device ID in X (0-3)
   373 07C1 A5 21		        LDA     ZICDNO      ; IOCB UNIT # (1-4)
   374 07C3 8D 01 08		        STA     OPNDCB+1    ; Store in DUNIT
   375 07C6 A5 24		        LDA     ZICBAL      ; Get filename buffer
   376 07C8 8D 04 08		        STA     OPNDCB+4    ; stuff in DBUF
   377 07CB A5 25		        LDA     ZICBAH      ; ...
   378 07CD 8D 05 08		        STA     OPNDCB+5    ; ...
   379 07D0 A5 2A		        LDA     ZICAX1      ; Get desired AUX1/AUX2
   380 07D2 8D 0A 08		        STA     OPNDCB+10   ; Save them, and store in DAUX1/DAUX2
   381 07D5 A5 2B		        LDA     ZICAX2      ; ...
   382 07D7 8D 0B 08		        STA     OPNDCB+11   ; ...
   383
   384 				        ;;  Copy DCB template to DCB
   385
   386 07DA A9 00		        LDA     #<OPNDCB
   387 07DC A0 08		        LDY     #>OPNDCB
   388
   389 				        ;;  Send to #FujiNet
   390
   391 07DE 20 A5 07		        JSR     DOSIOV
   392
   393 				        ;; Return DSTATS, unless 144, then get extended error
   394
   395 07E1			OPCERR:
   396 07E1 C0 90		        CPY     #$90        ; ERR 144?
   397 07E3 D0 06		        BNE     OPDONE      ; NOPE. RETURN DSTATS
   398
   399 				        ;; 144 - get extended error
   400
   401 07E5 20 24 09		        JSR     STPOLL      ; POLL FOR STATUS
   402 07E8 AC ED 02		        LDY     DVSTAT+3
   403
   404 				       ; RESET BUFFER LENGTH + OFFSET
   405
   406 07EB			OPDONE:
   407 07EB A9 01		        LDA     #$01
   408 07ED 8D EB 16		        STA     TRIP
   409 07F0 20 59 0A		        JSR     GDIDX
   410 07F3 A9 00		        LDA     #$00
   411 07F5 9D EC 16		        STA     RLEN,X
   412 07F8 9D F4 16		        STA     TOFF,X
   413 07FB 9D F0 16		        STA     ROFF,X
   414 07FE 98			        TYA
   415 07FF 60			        RTS                ; AY = ERROR
   416
   417 0800			OPNDCB:
   418 0800 71			        .BYTE   DEVIDN  ; DDEVIC
   419 0801 FF			        .BYTE   $FF     ; DUNIT
   420 0802 4F			        .BYTE   'O'     ; DCOMND
   421 0803 80			        .BYTE   $80     ; DSTATS
   422 0804 FF			        .BYTE   $FF     ; DBUFL
   423 0805 FF			        .BYTE   $FF     ; DBUFH
   424 0806 0F			        .BYTE   $0F     ; DTIMLO
   425 0807 00			        .BYTE   $00     ; DRESVD
   426 0808 00			        .BYTE   $00     ; DBYTL
   427 0809 01			        .BYTE   $01     ; DBYTH
   428 080A FF			        .BYTE   $FF     ; DAUX1
   429 080B FF			        .BYTE   $FF     ; DAUX2
   430
   431 				; End CIO OPEN
   432 				;---------------------------------------
   433
   434 				;---------------------------------------
   435 				; CIO CLOSE 
   436 				;---------------------------------------
   437
   438 080C			CLOSE:
   439 080C 20 50 0A		        JSR     DIPRCD      ; Disable Interrupts
   440 080F 20 59 0A		        JSR     GDIDX
   441 0812 20 AF 08		        JSR     PFLUSH      ; Do a Put Flush if needed.
   442
   443 0815 A5 21		        LDA     ZICDNO      ; IOCB Unit #
   444 0817 8D 22 08		        STA     CLODCB+1    ; to DCB...
   445
   446 081A A9 21		        LDA     #<CLODCB
   447 081C A0 08		        LDY     #>CLODCB
   448
   449 081E 4C A5 07		        JMP     DOSIOV
   450
   451 0821 71			CLODCB .BYTE    DEVIDN      ; DDEVIC
   452 0822 FF			       .BYTE    $FF         ; DUNIT
   453 0823 43			       .BYTE    'C'         ; DCOMND
   454 0824 00			       .BYTE    $00         ; DSTATS
   455 0825 00			       .BYTE    $00         ; DBUFL
   456 0826 00			       .BYTE    $00         ; DBUFH
   457 0827 0F			       .BYTE    $0F         ; DTIMLO
   458 0828 00			       .BYTE    $00         ; DRESVD
   459 0829 00			       .BYTE    $00         ; DBYTL
   460 082A 00			       .BYTE    $00         ; DBYTH
   461 082B 00			       .BYTE    $00         ; DAUX1
   462 082C 00			       .BYTE    $00         ; DAUX2
   463
   464 				; End CIO CLOSE
   465 				;---------------------------------------
   466
   467 				;---------------------------------------
   468 				; CIO GET
   469 				;---------------------------------------
   470
   471 082D 20 59 0A		GET:    JSR     GDIDX       ; IOCB UNIT #-1 into X
   472 0830 BD EC 16		        LDA     RLEN,X      ; Get # of RX chars waiting
   473 0833 D0 2B		        BNE     GETDISC     ; LEN > 0?
   474
   475 				        ;; If RX buffer is empty, get # of chars waiting...
   476
   477 0835 20 24 09		        JSR     STPOLL      ; Status Poll
   478 0838 20 59 0A		        JSR     GDIDX       ; IOCB UNIT -1 into X (because Poll trashes X)
   479 083B AD EA 02		        LDA     DVSTAT      ; # of bytes waiting (0-127)
   480 083E 9D EC 16		        STA     RLEN,X      ; Store in RX Len
   481 0841 F0 22		        BEQ     RETEOF
   482
   483 0843 A5 21		GETDO:  LDA     ZICDNO      ; Get IOCB UNIT #
   484 0845 8D 83 08		        STA     GETDCB+1    ; Store into DUNIT
   485 0848 AD EA 02		        LDA     DVSTAT      ; # of bytes waiting
   486 084B 8D 8A 08		        STA     GETDCB+8    ; Store into DBYT...
   487 084E 8D 8C 08		        STA     GETDCB+10   ; and DAUX1...
   488
   489 0851 A9 82		        LDA     #<GETDCB
   490 0853 A0 08		        LDY     #>GETDCB
   491
   492 0855 20 A5 07		        JSR     DOSIOV
   493
   494 				        ;; Clear the Receive buffer offset.
   495
   496 0858 20 59 0A		        JSR     GDIDX       ; IOCB UNIT #-1 into X
   497 085B A9 00		        LDA     #$00
   498 085D 9D F0 16		        STA     ROFF,X
   499
   500 0860			GETDISC:
   501 				        ;LDA     DVSTAT+2    ; Did we disconnect?
   502 0860 AD ED 02		        LDA     DVSTAT+3    ; Did we disconnect?
   503 0863 D0 04		        BNE     GETUPDP     ; nope, update the buffer cursor.
   504
   505 				        ;; We disconnected, emit an EOF.
   506
   507 0865			RETEOF:
   508 0865 A0 88		        LDY     #EOF
   509 0867 98			        TYA
   510 0868 60			        RTS                 ; buh-bye.
   511
   512 0869			GETUPDP:
   513 0869 DE EC 16		        DEC     RLEN,X      ; Decrement RX length.
   514 086C BC F0 16		        LDY     ROFF,X      ; Get RX offset cursor.
   515
   516 				        ;; Return Next char from appropriate RX buffer.
   517
   518 086F B9 00 18		        LDA     RBUF,Y
   519
   520 				        ;; Increment RX offset
   521
   522 0872 FE F0 16		GX:     INC     ROFF,X      ; Increment RX offset.
   523 0875 A8			        TAY                 ; stuff returned val into Y temporarily.
   524
   525 				        ;; If requested RX buffer is empty, reset TRIP.
   526
   527 0876 BD EC 16		        LDA     RLEN,X
   528 0879 D0 03		        BNE     GETDONE
   529 087B 8D EB 16		        STA     TRIP
   530
   531 				        ;; Return byte back to CIO.
   532
   533 087E			GETDONE:
   534 087E 98			        TYA                 ; Move returned val back.
   535 087F A0 01		        LDY     #$01        ; SUCCESS
   536
   537 0881 60			        RTS                 ; DONE...
   538
   539 0882			GETDCB:
   540 0882 71			       .BYTE    DEVIDN      ; DDEVIC
   541 0883 FF			       .BYTE    $FF         ; DUNIT
   542 0884 52			       .BYTE    'R'         ; DCOMND
   543 0885 40			       .BYTE    $40         ; DSTATS
   544 0886 00			       .BYTE    <RBUF       ; DBUFL
   545 0887 18			       .BYTE    >RBUF       ; DBUFH
   546 0888 0F			       .BYTE    $0F         ; DTIMLO
   547 0889 00			       .BYTE    $00         ; DRESVD
   548 088A FF			       .BYTE    $FF         ; DBYTL
   549 088B 00			       .BYTE    $00         ; DBYTH
   550 088C FF			       .BYTE    $FF         ; DAUX1
   551 088D 00			       .BYTE    $00         ; DAUX2
   552
   553 				; End CIO GET
   554 				;---------------------------------------
   555
   556 				;---------------------------------------
   557 				; CIO PUT
   558 				;---------------------------------------
   559
   560 088E			PUT:    ;; Add to TX buffer.
   561
   562 088E 20 59 0A		        JSR     GDIDX
   563 0891 BC F4 16		        LDY     TOFF,X      ; GET TX cursor.
   564 0894 99 80 18		        STA     TBUF,Y      ; TX Buffer
   565
   566 0897 FE F4 16		POFF:   INC     TOFF,X      ; Increment TX cursor
   567 089A A0 01		        LDY     #$01        ; SUCCESSFUL
   568
   569 				        ;; Do a PUT FLUSH if EOL or buffer full.
   570
   571 089C C9 9B		        CMP     #EOL        ; EOL?
   572 089E F0 0B		        BEQ     FLUSH       ; FLUSH BUFFER
   573 08A0 20 59 0A		        JSR     GDIDX       ; GET OFFSET
   574 08A3 BD F4 16		        LDA     TOFF,X
   575 08A6 C9 7F		        CMP     #$7F        ; LEN = $FF?
   576 08A8 F0 01		        BEQ     FLUSH       ; FLUSH BUFFER
   577 08AA 60			        RTS
   578
   579 				       ; FLUSH BUFFER, IF ASKED.
   580
   581 08AB 20 AF 08		FLUSH:  JSR     PFLUSH      ; FLUSH BUFFER
   582 08AE 60			        RTS
   583
   584 08AF			PFLUSH:
   585
   586 				       ; CHECK CONNECTION, AND EOF
   587 				       ; IF DISCONNECTED.
   588
   589 08AF 20 24 09		        JSR     STPOLL      ; GET STATUS
   590 08B2 AD ED 02		        LDA     DVSTAT+3
   591 08B5 F0 AE		        BEQ     RETEOF
   592
   593 08B7 20 59 0A		PF1:    JSR     GDIDX       ; GET DEV X
   594 08BA BD F4 16		        LDA     TOFF,X
   595 08BD D0 03		        BNE     PF2
   596 08BF 4C DF 08		        JMP     PDONE
   597
   598 				       ; FILL OUT DCB FOR PUT FLUSH
   599
   600 08C2 A5 21		PF2:    LDA     ZICDNO
   601 08C4 8D E3 08		        STA     PUTDCB+1
   602
   603 				       ; FINISH DCB AND DO SIOV
   604
   605 08C7 BD F4 16		TBX:    LDA     TOFF,X
   606 08CA 8D EA 08		        STA     PUTDCB+8
   607 08CD 8D EC 08		        STA     PUTDCB+10
   608
   609 08D0 A9 E2		        LDA     #<PUTDCB
   610 08D2 A0 08		        LDY     #>PUTDCB
   611 08D4 20 A5 07		        JSR     DOSIOV
   612
   613 				        ; CLEAR THE OFFSET CURSOR
   614 				        ; AND LENGTH
   615
   616 08D7 20 59 0A		        JSR     GDIDX
   617 08DA A9 00		        LDA     #$00
   618 08DC 9D F4 16		        STA     TOFF,X
   619
   620 08DF A0 01		PDONE:  LDY     #$01
   621 08E1 60			        RTS
   622
   623 08E2 71			PUTDCB .BYTE    DEVIDN      ; DDEVIC
   624 08E3 FF			       .BYTE    $FF         ; DUNIT
   625 08E4 57			       .BYTE    'W'         ; DCOMND
   626 08E5 80			       .BYTE    $80         ; DSTATS
   627 08E6 80			       .BYTE    $80         ; DBUFL
   628 08E7 18			       .BYTE    >TBUF       ; DBUFH
   629 08E8 0F			       .BYTE    $0F         ; DTIMLO
   630 08E9 00			       .BYTE    $00         ; DRESVD
   631 08EA FF			       .BYTE    $FF         ; DBYTL
   632 08EB 00			       .BYTE    $00         ; DBYTH
   633 08EC FF			       .BYTE    $FF         ; DAUX1
   634 08ED 00			       .BYTE    $00         ; DAUX2
   635
   636 				; End CIO PUT
   637 				;---------------------------------------
   638
   639 				;---------------------------------------
   640 				; CIO STATUS 
   641 				;---------------------------------------
   642
   643 08EE 20 47 0A		STATUS: JSR     ENPRCD      ; ENABLE PRCD
   644 08F1 20 59 0A		        JSR     GDIDX       ; GET DEVICE#
   645 08F4 BD EC 16		        LDA     RLEN,X      ; GET RLEN
   646 08F7 D0 05		        BNE     STSLEN      ; RLEN > 0?
   647 08F9 AD EB 16		        LDA     TRIP
   648 08FC D0 15		        BNE     STTRI1      ; TRIP = 1?
   649
   650 				        ; NO TRIP, RETURN SAVED LEN
   651
   652 08FE BD EC 16		STSLEN: LDA     RLEN,X      ; GET RLEN
   653 0901 8D EA 02		        STA     DVSTAT      ; RET IN DVSTAT
   654
   655 				        ; If you don't need to preserve Y then use it instead of A
   656 0904 A9 00		        LDA     #$00
   657 0906 8D EB 02		        STA     DVSTAT+1
   658
   659 				        ; and INY here
   660 0909 A9 01		        LDA     #$01
   661 090B 8D EC 02		        STA     DVSTAT+2
   662 090E 8D ED 02		        STA     DVSTAT+3
   663
   664 0911 D0 0B		        BNE     STDONE
   665
   666 				        ; DO POLL AND UPDATE RCV LEN
   667
   668 0913 20 24 09		STTRI1: JSR     STPOLL      ; POLL FOR ST
   669 0916 9D EC 16		        STA     RLEN,X
   670
   671 				        ; UPDATE TRIP FLAG
   672
   673 0919 D0 03		STTRIU: BNE     STDONE
   674 091B 8D EB 16		        STA     TRIP        ; RLEN = 0
   675
   676 				        ; RETURN CONNECTED? FLAG.
   677
   678 091E AD EC 02		STDONE: LDA     DVSTAT+2
   679 0921 A0 01		        LDY     #$01
   680 0923 60			        RTS
   681
   682 				       ; ASK FUJINET FOR STATUS
   683
   684 0924			STPOLL:
   685 0924 A5 21		        LDA     ZICDNO      ; IOCB #
   686 0926 8D 49 09		        STA     STADCB+1
   687
   688 0929 A9 48		        LDA     #<STADCB
   689 092B A0 09		        LDY     #>STADCB
   690
   691 092D 20 A5 07		        JSR     DOSIOV
   692
   693 				        ;; > 127 bytes? make it 127 bytes.
   694
   695 0930 AD EB 02		        LDA     DVSTAT+1
   696 0933 D0 07		        BNE     STADJ
   697 0935 AD EA 02		        LDA     DVSTAT
   698 0938 30 02		        BMI     STADJ
   699 093A 50 08		        BVC     STP2        ; <= 127 bytes...
   700
   701 093C A9 7F		STADJ   LDA     #$7F
   702 093E 8D EA 02		        STA     DVSTAT
   703 				        
   704 0941 8D EB 02		        STA     DVSTAT+1
   705
   706 				       ; A = CONNECTION STATUS
   707
   708 0944 AD EC 02		STP2:   LDA     DVSTAT+2
   709 0947 60			        RTS
   710
   711 0948 71			STADCB: .BYTE   DEVIDN      ; DDEVIC
   712 0949 FF			        .BYTE   $FF         ; DUNIT
   713 094A 53			        .BYTE   'S'         ; DCOMND
   714 094B 40			        .BYTE   $40         ; DSTATS
   715 094C EA			        .BYTE   <DVSTAT     ; DBUFL
   716 094D 02			        .BYTE   >DVSTAT     ; DBUFH
   717 094E 0F			        .BYTE   $0F         ; DTIMLO
   718 094F 00			        .BYTE   $00         ; DRESVD
   719 0950 04			        .BYTE   $04         ; DBYTL
   720 0951 00			        .BYTE   $00         ; DBYTH
   721 0952 00			        .BYTE   $00         ; DAUX1
   722 0953 00			        .BYTE   $00         ; DAUX2
   723
   724 				; End CIO STATUS
   725 				;---------------------------------------
   726
   727 				;---------------------------------------
   728 				; CIO SPECIAL
   729 				;---------------------------------------
   730
   731 0954			SPEC:   ; HANDLE LOCAL COMMANDS.
   732
   733 0954 A5 22		        LDA     ZICCOM
   734 0956 C9 0F		        CMP     #$0F        ; 15 = FLUSH
   735 0958 D0 06		        BNE     S1          ; NO.
   736 095A 20 AF 08		        JSR     PFLUSH      ; DO FLUSH
   737 095D A0 01		        LDY     #$01        ; SUCCESS
   738 095F 60			        RTS
   739
   740 0960 C9 28		S1:     CMP     #40         ; 40 = LOAD AND EXECUTE
   741 0962 F0 03		        BEQ     S2          ; YES.
   742 0964 4C 68 09		        JMP     S3          ; NO. SKIP OVER spec40
   743
   744 0967 60			S2:     RTS
   745 				       ; HANDLE SIO COMMANDS.
   746 				       ; GET DSTATS FOR COMMAND
   747 0968			S3:
   748 0968 A5 21		        LDA     ZICDNO
   749 096A 8D B0 09		        STA     SPEDCB+1
   750 096D A5 22		        LDA     ZICCOM
   751 096F 8D B9 09		        STA     SPEDCB+10
   752
   753 0972 A9 AF		        LDA     #<SPEDCB
   754 0974 A0 09		        LDY     #>SPEDCB
   755 0976 20 A5 07		        JSR     DOSIOV
   756
   757 0979 30 0A		        BMI     :DSERR
   758
   759 				       ; WE GOT A DSTATS INQUIRY
   760 				       ; IF $FF, THE COMMAND IS
   761 				       ; INVALID
   762
   763 097B AD F8 16		DSOK:   LDA     INQDS
   764 097E C9 FF		        CMP     #$FF        ; INVALID?
   765 0980 D0 04		        BNE     DSGO        ; DO THE CMD
   766 0982 A0 92		        LDY     #$92        ; UNIMP CMD
   767 0984 98			        TYA
   768 0985			DSERR:
   769 0985 60			        RTS
   770
   771 				        ;; Do the special, since we want to pass in all the IOCB
   772 				        ;; Parameters to the DCB, This is being done long-hand.
   773
   774 0986 A5 22		DSGO:   LDA     ZICCOM
   775 0988 48			        PHA
   776 0989 A9 00		        LDA     #$00
   777 098B 48			        PHA
   778 098C AD F8 16		        LDA     INQDS
   779 098F 48			        PHA
   780 0990 A9 01		        LDA     #$01
   781 0992 48			        PHA
   782 0993 A5 24		        LDA     ZICBAL
   783 0995 48			        PHA
   784 0996 A5 2A		        LDA     ZICAX1
   785 0998 48			        PHA
   786 0999 A5 25		        LDA     ZICBAH
   787 099B 48			        PHA
   788 099C A5 2B		        LDA     ZICAX2
   789 099E 48			        PHA
   790 099F A0 03		        LDY     #$03
   791 09A1			DSGOL:
   792 09A1 68			        PLA
   793 09A2 99 08 03		        STA     DBYTL,Y
   794 09A5 68			        PLA
   795 09A6 99 02 03		        STA     DCOMND,Y
   796 09A9 88			        DEY
   797 09AA 10 F5		        BPL     DSGOL
   798
   799 09AC 4C B6 07		        JMP     SIOVDST
   800
   801 				        ;; Return DSTATS in Y and A
   802
   803 09AF 71			SPEDCB  .BYTE   DEVIDN      ; DDEVIC
   804 09B0 FF			        .BYTE   $FF         ; DUNIT
   805 09B1 FF			        .BYTE   $FF         ; DCOMND ; inq
   806 09B2 40			        .BYTE   $40         ; DSTATS
   807 09B3 F8			        .BYTE   <INQDS      ; DBUFL
   808 09B4 16			        .BYTE   >INQDS      ; DBUFH
   809 09B5 0F			        .BYTE   $0F         ; DTIMLO
   810 09B6 00			        .BYTE   $00         ; DRESVD
   811 09B7 01			        .BYTE   $01         ; DBYTL
   812 09B8 00			        .BYTE   $00         ; DBYTH
   813 09B9 FF			        .BYTE   $FF         ; DAUX1
   814 09BA FF			        .BYTE   $FF         ; DAUX2
   815
   816 				; End CIO SPECIAL
   817 				;---------------------------------------
   818
   819 				;#######################################
   820 				;#                                     #
   821 				;#             CIO Functions           # 
   822 				;#                                     #
   823 				;#######################################
   824
   825
   826 				;---------------------------------------
   827 09BB			CIOCLOSE:
   828 				;---------------------------------------
   829 				    ; X must contain IOCB offset ($10,$20,..)
   830 09BB A9 0C		        LDA     #$0C            ; Close #1 first
   831 09BD 9D 42 03		        STA     ICCOM,X
   832 09C0 4C 56 E4		        JMP     CIOV
   833
   834 				;---------------------------------------
   835 09C3			CIOOPEN:
   836 				;---------------------------------------
   837 				    ; Input: 
   838 				    ; X = IOCB offset ($10,$20,..)
   839 				    ; Y = data direction (4=inp,8=out,12=i/o)
   840 				    ; INBUFF contains ICBAL/H
   841 09C3 A9 03		        LDA     #$03            ; 3 = CIO 'OPEN FILE'
   842 09C5 9D 42 03		        STA     ICCOM,X
   843 09C8 A5 F3		        LDA     INBUFF          ; Pointer to filename
   844 09CA 9D 44 03		        STA     ICBAL,X
   845 09CD A5 F4		        LDA     INBUFF+1        ; Pointer to filename
   846 09CF 9D 45 03		        STA     ICBAH,X
   847 09D2 98			        TYA
   848 09D3 9D 4A 03		        STA     ICAX1,X         ; Data direction
   849 09D6 A9 00		        LDA     #$00
   850 09D8 9D 4B 03		        STA     ICAX2,X         ; Unused
   851 09DB 20 56 E4		        JSR     CIOV            ; Call CIO
   852
   853 09DE			CIOOPEN_DONE:
   854 09DE 60			        RTS
   855
   856 				;---------------------------------------
   857 09DF			CIOSTATUS:
   858 				;---------------------------------------
   859 09DF A9 0D		        LDA     #$0D
   860 09E1 9D 42 03		        STA     ICCOM,X
   861 09E4 20 56 E4		        JSR     CIOV
   862 09E7 10 03		        BPL     CIOSTATUS_DONE
   863 09E9 20 96 0A		        JSR     PRINT_ERROR
   864
   865 09EC			CIOSTATUS_DONE:
   866 09EC 60			        RTS
   867 				        
   868
   869 				;---------------------------------------
   870 09ED			CIOGET:
   871 				;---------------------------------------
   872 				    ; Input: 
   873 				    ; X = IOCB offset ($10,$20,..)
   874 				    ; A = ICBLL
   875 				    ; Y = ICBLH
   876 				    ; INBUFF contains ICBAL/H
   877 09ED 48			        PHA                 ; Stash Buffer length Lo
   878 09EE A9 07		        LDA     #$07        ; GET BYTES command
   879 09F0 9D 42 03		        STA     ICCOM,X
   880 09F3 A5 F3		        LDA     INBUFF      ; Get buffer addr from pointer
   881 09F5 9D 44 03		        STA     ICBAL,X
   882 09F8 A5 F4		        LDA     INBUFF+1
   883 09FA 9D 45 03		        STA     ICBAH,X
   884 09FD 68			        PLA                 ; Retrieve Buffer length Lo
   885 09FE 9D 48 03		        STA     ICBLL,X
   886 0A01 98			        TYA                 ; Get Buffer length Hi
   887 0A02 9D 49 03		        STA     ICBLH,X
   888 0A05 20 56 E4		        JSR     CIOV        ; Bon voyage
   889 0A08 10 00		        BPL     CIOGET_DONE
   890 				;        JMP     PRINT_ERROR
   891
   892 0A0A			CIOGET_DONE:
   893 0A0A 60			        RTS
   894
   895 				;---------------------------------------
   896 0A0B			CIOPUT:
   897 				;---------------------------------------
   898 				    ; Input: 
   899 				    ; X = IOCB offset ($10,$20,..)
   900 				    ; A = ICBLL
   901 				    ; Y = ICBLH
   902 				    ; INBUFF contains ICBAL/H
   903 0A0B 48			        PHA                 ; Stash Buffer length Lo
   904 0A0C A9 0B		        LDA     #$0B        ; PUT BYTES command
   905 0A0E 9D 42 03		        STA     ICCOM,X
   906 0A11 A5 F3		        LDA     INBUFF      ; Get buffer addr from pointer
   907 0A13 9D 44 03		        STA     ICBAL,X
   908 0A16 A5 F4		        LDA     INBUFF+1
   909 0A18 9D 45 03		        STA     ICBAH,X
   910 0A1B 68			        PLA                 ; Retrieve Buffer length Lo
   911 0A1C 9D 48 03		        STA     ICBLL,X
   912 0A1F 98			        TYA                 ; Get Buffer length Hi
   913 0A20 9D 49 03		        STA     ICBLH,X
   914 0A23 20 56 E4		        JSR     CIOV        ; Bon voyage
   915 0A26 10 00		        BPL     CIOPUT_DONE
   916 				;        JMP     PRINT_ERROR
   917
   918 0A28			CIOPUT_DONE:
   919 0A28 60			        RTS
   920
   921 				;---------------------------------------
   922 0A29			CIOGETREC:
   923 				;---------------------------------------
   924 				    ; Input: 
   925 				    ; X = IOCB offset ($10,$20,..)
   926 				    ; A = ICBLL
   927 				    ; Y = ICBLH
   928 				    ; INBUFF contains ICBAL/H
   929 0A29 48			        PHA                 ; Stash Buffer length Lo
   930 0A2A A9 05		        LDA     #$05        ; GET RECORD command
   931 0A2C 9D 42 03		        STA     ICCOM,X
   932 0A2F A5 F3		        LDA     INBUFF      ; Get buffer addr from pointer
   933 0A31 9D 44 03		        STA     ICBAL,X
   934 0A34 A5 F4		        LDA     INBUFF+1
   935 0A36 9D 45 03		        STA     ICBAH,X
   936 0A39 68			        PLA                 ; Retrieve Buffer length Lo
   937 0A3A 9D 48 03		        STA     ICBLL,X
   938 0A3D 98			        TYA                 ; Get Buffer length Hi
   939 0A3E 9D 49 03		        STA     ICBLH,X
   940
   941 0A41 20 56 E4		        JSR     CIOV        ; Bon voyage
   942 0A44 10 00		        BPL     CIOGETREC_DONE
   943 				;        JMP     PRINT_ERROR
   944
   945 0A46			CIOGETREC_DONE:
   946 0A46 60			        RTS
   947
   948 				;#######################################
   949 				;#                                     #
   950 				;#          Utility Functions          #
   951 				;#                                     #
   952 				;#######################################
   953 				        ; ENABLE PROCEED INTERRUPT
   954
   955 0A47 AD 02 D3		ENPRCD: LDA     PACTL
   956 0A4A 09 01		        ORA     #$01        ; ENABLE BIT 0
   957 0A4C 8D 02 D3		        STA     PACTL
   958 0A4F 60			        RTS
   959
   960 				       ; DISABLE PROCEED INTERRUPT
   961
   962 0A50 AD 02 D3		DIPRCD: LDA     PACTL
   963 0A53 29 FE		        AND     #$FE        ; DISABLE BIT0
   964 0A55 8D 02 D3		        STA     PACTL
   965 0A58 60			        RTS
   966
   967 				       ; GET ZIOCB DEVNO - 1 INTO X
   968
   969 0A59 A6 21		GDIDX:  LDX     ZICDNO      ; IOCB UNIT #
   970 0A5B CA			        DEX                 ; - 1
   971 0A5C 60			        RTS
   972
   973 				;---------------------------------------
   974 				; Proceed Vector
   975 				;---------------------------------------
   976
   977 0A5D A9 01		PRCVEC: LDA     #$01
   978 0A5F 8D EB 16		        STA     TRIP
   979 0A62 68			        PLA
   980 0A63 40			        RTI
   981
   982 				; End Proceed Vector
   983 				;---------------------------------------
   984
   985 				;---------------------------------------
   986 				; Reset LNBUF
   987 				;---------------------------------------
   988 				; Normally this routine is at $DA51
   989 				; But some programs will bank-switch
   990 				; that portion of ROM to RAM
   991 				;---------------------------------------
   992
   993 0A64 A9 05		LDBUFA: LDA     #$05
   994 0A66 85 F4		        STA     INBUFF+1
   995 				;        LDA     #$80
   996 0A68 A9 82		        LDA     #$82
   997 0A6A 85 F3		        STA     INBUFF
   998 0A6C 60			        RTS
   999
  1000 				; End Reset LNBUF
  1001 				;---------------------------------------
  1002
  1003 				;---------------------------------------
  1004 				; Skip spaces
  1005 				;---------------------------------------
  1006 				; Normally this routine is at $DBA1
  1007 				; But some programs will bank-switch
  1008 				; that portion of ROM to RAM
  1009 				;---------------------------------------
  1010
  1011 0A6D A4 F2		SKPSPC: LDY     CIX
  1012 0A6F A9 20		        LDA     #$20
  1013 0A71 D1 F3		@:      CMP     (INBUFF),Y
  1014 0A73 D0 03		        BNE     @+
  1015 0A75 C8			        INY
  1016 0A76 D0 F9		        BNE     @-
  1017 0A78 84 F2		@:      STY     CIX
  1018 0A7A 60			        RTS
  1019
  1020 				; End SKPSPC
  1021 				;---------------------------------------
  1022
  1023 				;---------------------------------------
  1024 				; Print EOL-terminated string
  1025 				; A: String Buffer Lo
  1026 				; Y: String Buffer Hi
  1027 				;---------------------------------------
  1028 0A7B			PRINT_STRING:
  1029
  1030 0A7B A2 00		        LDX     #$00
  1031 				    ;---------------------------------------
  1032 				    ; String Buffer
  1033 				    ;---------------------------------------
  1034 0A7D 9D 44 03		        STA     ICBAL,X
  1035 0A80 98			        TYA
  1036 0A81 9D 45 03		        STA     ICBAH,X
  1037
  1038 				    ;---------------------------------------
  1039 				    ; String Length
  1040 				    ;---------------------------------------
  1041 0A84 A9 80		        LDA     #$80
  1042 0A86 9D 48 03		        STA     ICBLL,X
  1043 0A89 A9 00		        LDA     #$00
  1044 0A8B 9D 49 03		        STA     ICBLH,X
  1045
  1046 				    ;---------------------------------------
  1047 				    ; Call to CIO
  1048 				    ;---------------------------------------
  1049 0A8E A9 09		        LDA     #PUTREC
  1050 0A90 9D 42 03		        STA     ICCOM,X
  1051 0A93 4C 56 E4		        JMP     CIOV
  1052
  1053 				;---------------------------------------
  1054 				; Print integer error number from DOSIOV
  1055 				; Y: Return code from DOSIOV
  1056 				;---------------------------------------
  1057 0A96			PRINT_ERROR:
  1058 0A96 C0 01		        CPY     #$01        ; Exit if success (1)
  1059 0A98 F0 33		        BEQ     PRINT_ERROR_DONE
  1060
  1061 				    ;-----------------------------------
  1062 				    ; If error code = 144, then get
  1063 				    ; extended code from DVSTAT
  1064 				    ;-----------------------------------
  1065 0A9A C0 90		        CPY     #144
  1066 0A9C D0 0A		        BNE     PRINT_ERROR_NEXT
  1067
  1068 0A9E A9 48		        LDA     #<STADCB
  1069 0AA0 A0 09		        LDY     #>STADCB
  1070 0AA2 20 A5 07		        JSR     DOSIOV
  1071 0AA5 AC ED 02		        LDY     DVSTAT+3    ;
  1072
  1073 0AA8			PRINT_ERROR_NEXT:
  1074 				    ;-----------------------------------
  1075 				    ; Convert error code to ASCII
  1076 				    ;-----------------------------------
  1077 0AA8 84 D4		        STY     FR0
  1078 0AAA A9 00		        LDA     #$00
  1079 0AAC 85 D5		        STA     FR0+1
  1080 0AAE 20 AA D9		        JSR     IFP         ; Convert error from int to floating point
  1081 0AB1 20 E6 D8		        JSR     FASC        ; Convert floating point to ASCII
  1082
  1083 				    ;---------------------------------------
  1084 				    ; Find last char in ASCII error (noted by high bit)
  1085 				    ; Unset high bit & append EOL
  1086 				    ;---------------------------------------
  1087 0AB4 A0 FF		        LDY     #$FF        ; Init counter = 0
  1088
  1089 0AB6 C8			@       INY
  1090 0AB7 B1 F3		        LDA     (INBUFF),Y
  1091 0AB9 C9 80		        CMP     #$80
  1092 0ABB 90 F9		        BCC     @-
  1093
  1094 0ABD 29 7F		        AND     #$7F        ; Clear high bit
  1095 0ABF 91 F3		        STA     (INBUFF),Y
  1096 0AC1 C8			        INY
  1097 0AC2 A9 9B		        LDA     #EOL        ; Append EOL
  1098 0AC4 91 F3		        STA     (INBUFF),Y
  1099
  1100 0AC6 A5 F3		        LDA     INBUFF
  1101 0AC8 A4 F4		        LDY     INBUFF+1
  1102 0ACA 4C 7B 0A		        JMP     PRINT_STRING
  1103
  1104 0ACD			PRINT_ERROR_DONE:
  1105 0ACD 60			        RTS
  1106
  1107 				; End Utility Functions
  1108 				;---------------------------------------
  1109
  1110
  1111 				;#######################################
  1112 				;#                                     #
  1113 				;#       COMMAND PROCESSOR (CP)        #
  1114 				;#                                     #
  1115 				;#######################################
  1116
  1117 				;---------------------------------------
  1118 				; DOS Entry point
  1119 				;---------------------------------------
  1120 0ACE			DOS:
  1121 				        ; Autorun injection
  1122 0ACE A9 0F		        LDA     #CMD_IDX.AUTORUN    ; Check for AUTORUN
  1123 0AD0 CD EA 16		        CMP     AUTORUN_FLG         ; True only on 1st entry
  1124 0AD3 F0 06		        BEQ     CPLOOP              ; Skip to Command Processor
  1125 0AD5 8D EA 16		        STA     AUTORUN_FLG         ; Change flag
  1126 0AD8 20 87 11		        JSR     SUBMIT_AUTORUN      ; Attempt to execute autorun file
  1127 				       
  1128 0ADB			CPLOOP:
  1129 0ADB 20 E1 0A		        JSR     CP          ; Command Processor
  1130 0ADE 4C DB 0A		        JMP     CPLOOP      ; Keep looping
  1131
  1132
  1133 				;---------------------------------------
  1134 				; Main loop
  1135 				;---------------------------------------
  1136
  1137 0AE1			CP:
  1138 0AE1 A9 FF		        LDA     #$FF        ; Clear command
  1139 0AE3 8D E7 16		        STA     CMD
  1140
  1141 0AE6 20 F5 0A		        JSR     SHOWPROMPT
  1142 0AE9 20 1A 0B		        JSR     GETCMD
  1143 0AEC			AUTORUN_DO:
  1144 0AEC 20 89 0B		        JSR     PARSECMD
  1145 0AEF 30 03		        BMI     CP_DONE     ; Skip DOCMD if CMD == $FF
  1146 0AF1 20 FF 0B		        JSR     DOCMD
  1147 0AF4			CP_DONE:
  1148 0AF4 60			        RTS
  1149
  1150 				;---------------------------------------
  1151 				; Show Command Prompt (Nn:)
  1152 				; Leading EOF requires special CIOV call
  1153 				;---------------------------------------
  1154
  1155 				;---------------------------------------
  1156 0AF5			SHOWPROMPT:
  1157 				;---------------------------------------
  1158
  1159 0AF5 AD E6 16		        LDA     DOSDR       ; Get the 1,2,... for N1,N2,...
  1160 0AF8 09 30		        ORA     #'0'        ; Convert, say, 1 to '1'
  1161 0AFA 8D 78 15		        STA     PRMPT+2     ; Store in after EOL and N
  1162
  1163 0AFD A2 00		        LDX     #$00
  1164 0AFF A9 0B		        LDA     #PUTCHR
  1165 0B01 9D 42 03		        STA     ICCOM,X
  1166
  1167 0B04 A9 76		        LDA     #<PRMPT
  1168 0B06 9D 44 03		        STA     ICBAL,X
  1169 0B09 A9 15		        LDA     #>PRMPT
  1170
  1171 0B0B 9D 45 03		        STA     ICBAH,X
  1172 0B0E A9 04		        LDA     #4          ; Prompt length = 4
  1173 0B10 9D 48 03		        STA     ICBLL,X
  1174 0B13 8A			        TXA                 ; Still zero
  1175 0B14 9D 49 03		        STA     ICBLH,X
  1176
  1177 0B17 4C 56 E4		        JMP     CIOV
  1178
  1179 				;---------------------------------------
  1180 0B1A			GETCMD:
  1181 				;---------------------------------------
  1182 0B1A A2 00		        LDX     #$00
  1183 0B1C A9 05		        LDA     #GETREC
  1184 0B1E 9D 42 03		        STA     ICCOM,X
  1185 0B21 A9 82		        LDA     #<LNBUF
  1186 0B23 9D 44 03		        STA     ICBAL,X
  1187 0B26 A9 05		        LDA     #>LNBUF
  1188 0B28 9D 45 03		        STA     ICBAH,X
  1189 0B2B A9 7F		        LDA     #$7F
  1190 0B2D 9D 48 03		        STA     ICBLL,X
  1191 0B30 20 56 E4		        JSR     CIOV
  1192
  1193 0B33			GETCMDTEST:
  1194 0B33 A0 00		        LDY #$00
  1195 0B35 84 F2		        STY CIX
  1196 0B37 20 64 0A		        JSR LDBUFA      ; Reset LNBUF to $0580
  1197 0B3A 20 6D 0A		        JSR SKPSPC      ; Advance CIX to next space
  1198
  1199 				    ;---------------------------------------
  1200 				    ; CMDSEP is an sequence of bytes contains
  1201 				    ; indexes to chars following spaces
  1202 				    ; Iterate to clear CMDSEP bytes
  1203 				    ;---------------------------------------
  1204 0B3D 98			        TYA                 ; A = 0
  1205 0B3E A2 02		        LDX     #$02        ; for X = 2 to 0 step -1
  1206 0B40			GETLOOP:
  1207 0B40 9D 85 0B		        STA     CMDSEP,X
  1208 0B43 CA			        DEX
  1209 0B44 10 FA		        BPL     GETLOOP     ; next X
  1210
  1211 				    ; Initial Delimiter to space
  1212 0B46 A9 20		        LDA     #' '
  1213 0B48 8D 88 0B		        STA     DELIM
  1214
  1215 				    ;---------------------------------------
  1216 				    ; Loop until EOL is encountered
  1217 				    ;---------------------------------------
  1218 0B4B E8			        INX                 ; Reset X to 0
  1219 0B4C			GETCMD_LOOP:
  1220 0B4C B1 F3		        LDA     (INBUFF),Y
  1221 0B4E C9 9B		        CMP     #EOL        ; Found EOL?
  1222 0B50 F0 32		        BEQ     GETCMD_DONE ; yes. skip
  1223 0B52 CD 88 0B		        CMP     DELIM       ; Found space?
  1224 0B55 F0 03		        BEQ     GETCMD_REPL ; yes. Replace it
  1225 0B57 C8			        INY
  1226 0B58 D0 F2		        BNE     GETCMD_LOOP ; "always" non-zero
  1227
  1228 				    ;---------------------------------------
  1229 				    ; March through the cmd line and note
  1230 				    ; the positions of any args as delimited
  1231 				    ; by spaces or quotes. positions saved
  1232 				    ; in CMDSEP,X
  1233 				    ;---------------------------------------
  1234 0B5A			GETCMD_REPL:
  1235 0B5A A9 9B		        LDA     #EOL
  1236 0B5C 91 F3		        STA     (INBUFF),Y
  1237 0B5E C8			        INY
  1238 0B5F B1 F3		        LDA     (INBUFF),Y  ; Skip any run of spaces
  1239 0B61 C9 20		        CMP     #' '
  1240 0B63 F0 F5		        BEQ     GETCMD_REPL ; Keep skipping spaces
  1241
  1242 				    ; Here if any run of spaces has ended
  1243 				    ; Are we standing on a double-quote?
  1244 0B65 C9 22		        CMP     #'"'
  1245 0B67 D0 12		        BNE     GETCMD_WR_OFFSET  ; No. Skip ahead
  1246
  1247 				    ; Here if curr char is a double-quote
  1248 0B69 C8			        INY                 ; Advance the command line index
  1249 0B6A A9 22		        LDA     #'"'        ; Is the curr delim a double-quote?
  1250 0B6C CD 88 0B		        CMP     DELIM       ; If not, change delim to double-quote
  1251 0B6F D0 07		        BNE     GETCMD_DQ_DELIM
  1252
  1253 				    ; Here if curr delim is a double-quote
  1254 				    ; Switch delim to space
  1255 0B71 A9 20		        LDA     #' '
  1256 0B73 8D 88 0B		        STA     DELIM
  1257 0B76 D0 03		        BNE     GETCMD_WR_OFFSET
  1258
  1259 				    ; Here if curr delim is space
  1260 				    ; Switch delim to double-quote
  1261 0B78			GETCMD_DQ_DELIM:
  1262 0B78 8D 88 0B		        STA     DELIM
  1263
  1264 				    ; Note the position for the curr command-line arg
  1265 0B7B			GETCMD_WR_OFFSET:
  1266 0B7B 98			        TYA
  1267 0B7C 9D 85 0B		        STA     CMDSEP,X
  1268 0B7F E8			        INX
  1269 0B80 E0 03		        CPX     #$03
  1270 0B82 90 C8		        BCC     GETCMD_LOOP ; Continue searching
  1271
  1272 0B84			GETCMD_DONE:
  1273 0B84 60			        RTS
  1274
  1275 0B85 FF FF FF		CMDSEP: .BYTE $FF,$FF,$FF
  1276 0B88 20			DELIM:  .BYTE ' '
  1277
  1278 				;---------------------------------------
  1279 0B89			PARSECMD:
  1280 				;---------------------------------------
  1281 0B89 AD 82 05		        LDA     LNBUF
  1282 0B8C C9 9B		        CMP     #EOL        ; Quit immediately if no cmd
  1283 0B8E F0 09		        BEQ     PARSECMD_DONE
  1284
  1285 0B90 20 AE 0B		        JSR     PARSE_INTRINSIC_COMMAND
  1286 0B93 20 E8 0B		        JSR     PARSE_DRIVE_CHANGE
  1287 0B96 20 9A 0B		        JSR     PRINT_UNK_CMD
  1288 0B99			PARSECMD_DONE:
  1289 0B99 60			        RTS
  1290
  1291 0B9A			PRINT_UNK_CMD:
  1292 0B9A AD E7 16		        LDA     CMD
  1293 0B9D C9 FF		        CMP     #$FF
  1294 0B9F D0 07		        BNE     PRINT_UNK_CMD_DONE
  1295 0BA1 A9 A9		        LDA     #<UNK_CMD_ERR
  1296 0BA3 A0 0B		        LDY     #>UNK_CMD_ERR
  1297 0BA5 20 7B 0A		        JSR     PRINT_STRING
  1298 0BA8			PRINT_UNK_CMD_DONE:
  1299 0BA8 60			        RTS
  1300
  1301 0BA9			UNK_CMD_ERR:
  1302 0BA9 43 4D 44 3F 9B	        .BYTE   'CMD?',EOL
  1303
  1304 				;---------------------------------------
  1305 0BAE			PARSE_INTRINSIC_COMMAND:
  1306 				;---------------------------------------
  1307 0BAE A2 00		        LDX     #$00        ; Initialize X for command code indexing
  1308 0BB0 A0 00		        LDY     #$00
  1309 0BB2 84 F2		        STY     CIX
  1310 0BB4 20 64 0A		        JSR     LDBUFA      ; Set INBUFF to $0580
  1311 0BB7 20 6D 0A		        JSR     SKPSPC      ; Skip whitespace
  1312
  1313 0BBA			PARSE_INTRINSIC_NEXT_CHAR:
  1314 0BBA B1 F3		        LDA     (INBUFF),Y
  1315 0BBC 29 7F		        AND     #$7F
  1316 0BBE 5D 98 15		        EOR     COMMAND,X   ; X initialized to 0 in caller
  1317 0BC1 C8			        INY
  1318 0BC2 0A			        ASL
  1319 0BC3 F0 0B		        BEQ     PARSE_INTRINSIC_CHAR_OK
  1320
  1321 				        ; Skip to next command
  1322
  1323 0BC5			PARSE_INTRINSIC_NEXT_COMMAND:
  1324 0BC5 BD 98 15		        LDA     COMMAND,X
  1325 0BC8 0A			        ASL
  1326 0BC9 E8			        INX
  1327 0BCA 90 F9		        BCC     PARSE_INTRINSIC_NEXT_COMMAND
  1328 0BCC A4 F2		        LDY     CIX
  1329 0BCE E0 D1		        CPX     #COMMAND_SIZE
  1330
  1331 0BD0			PARSE_INTRINSIC_CHAR_OK:
  1332 0BD0 E8			        INX
  1333 0BD1 90 E7		        BCC     PARSE_INTRINSIC_NEXT_CHAR
  1334 0BD3 84 F2		        STY     CIX
  1335 0BD5 B1 F3		        LDA     (INBUFF),Y
  1336 0BD7 30 05		        BMI     PARSE_INTRINSIC_RET
  1337
  1338 0BD9 20 6D 0A		        JSR     SKPSPC
  1339
  1340 0BDC			PARSE_INTRINSIC_RET_ERROR:
  1341 0BDC A2 D2		        LDX     #COMMAND_SIZE+1
  1342 0BDE			PARSE_INTRINSIC_RET:
  1343 0BDE BD 98 15		        LDA     COMMAND,X
  1344 0BE1 8D E7 16		        STA     CMD
  1345 0BE4 8D E8 16		        STA     CMDPRV
  1346 0BE7			PARSE_INTRINSIC_DONE:
  1347 0BE7 60			        RTS
  1348
  1349 				; End of PARSE_INTRINSIC_COMMAND
  1350 				;---------------------------------------
  1351
  1352 				;---------------------------------------
  1353 0BE8			PARSE_DRIVE_CHANGE:
  1354 				;---------------------------------------
  1355 0BE8 A2 03		        LDX     #$03        ; Check for EOL in pos 3
  1356 0BEA BD 82 05		        LDA     LNBUF,X
  1357 0BED C9 9B		        CMP     #EOL
  1358 0BEF D0 0D		        BNE     PARSE_DRIVE_CHANGE_DONE
  1359 0BF1 CA			        DEX                 ; go back one char
  1360 0BF2 BD 82 05		        LDA     LNBUF,X
  1361 0BF5 C9 3A		        CMP     #':'        ; Check for colon.
  1362 0BF7 D0 05		        BNE     PARSE_DRIVE_CHANGE_DONE
  1363 0BF9 A9 1D		        LDA     #CMD_IDX.DRIVE_CHG
  1364 0BFB 8D E7 16		        STA     CMD
  1365 0BFE			PARSE_DRIVE_CHANGE_DONE:
  1366 0BFE 60			        RTS
  1367
  1368 				;---------------------------------------
  1369 0BFF			DOCMD:
  1370 				;---------------------------------------
  1371 0BFF AE E7 16		        LDX     CMD
  1372 0C02 30 08		        BMI     DOCMD_DONE      ; Unassigned command = $FF
  1373 0C04 BD 89 16		        LDA     CMD_TAB_H,X     ; Get hi-byte of subroutine's addr
  1374 0C07 48			        PHA                     ; Push it to the stack
  1375 0C08 BD 6B 16		        LDA     CMD_TAB_L,X     ; Get lo-byte of subroutine's addr
  1376 0C0B 48			        PHA                     ; Push it to the stack
  1377 0C0C			DOCMD_DONE:
  1378 0C0C 60			        RTS                     ; Use stack & RTS to jump to subroutine
  1379
  1380 				; End of DOCMD
  1381 				;---------------------------------------
  1382
  1383 				;---------------------------------------
  1384 0C0D			DO_DRIVE_CHG:
  1385 				;---------------------------------------
  1386 0C0D AD 82 05		        LDA     LNBUF
  1387 0C10 8D 77 15		        STA     PRMPT+1
  1388 0C13 AD 83 05		        LDA     LNBUF+1
  1389 0C16 C9 31		        CMP     #'1'        ; Skip if '0' or less
  1390 0C18 90 0A		        BCC     DO_DRIVE_CHG_ERROR
  1391 0C1A C9 39		        CMP     #'9'        ; Skip if '9' or more
  1392 0C1C B0 06		        BCS     DO_DRIVE_CHG_ERROR
  1393 0C1E 29 0F		        AND     #$0F        ; Convert, say, to 1-8
  1394 0C20 8D E6 16		        STA     DOSDR
  1395 0C23 60			        RTS
  1396 0C24			DO_DRIVE_CHG_ERROR:
  1397 0C24 A9 DC		        LDA     #<CDERR
  1398 0C26 A0 16		        LDY     #>CDERR
  1399 0C28 4C 7B 0A		        JMP     PRINT_STRING
  1400
  1401 				; End of DOCMD
  1402
  1403 				;---------------------------------------
  1404 				; Returns DOSDR in X
  1405 				; If arg1 contains Nn: then reg X = n
  1406 				; Otherwise X = DOSDR (from curr prompt)
  1407 				;---------------------------------------
  1408 0C2B			GET_DOSDR:
  1409 				;---------------------------------------
  1410
  1411 0C2B 20 64 0A		        JSR     LDBUFA      ; Reset INBUFF to LNBUF
  1412 0C2E AE E6 16		        LDX     DOSDR       ; Set DUNIT(X) to curr drive
  1413
  1414 				    ;---------------------------------------
  1415 				    ; Consider arg1 = N2:TNFS://localhost/
  1416 				    ; Check arg1 for ":" in 3rd position
  1417 				    ; if found then use char in 2nd position ('2') as DOSDR
  1418 				    ; First, change INBUFF to point to beg. of 1st arg
  1419 				    ;---------------------------------------
  1420 0C31 AD 85 0B		        LDA     CMDSEP              ; arg offset
  1421 0C34 F0 17		        BEQ     GET_DOSDR_DONE      ; first, if arg1 not pop, leave X as-is & quit
  1422
  1423 0C36 18			        CLC                         ; Advance pointer to LNBUF
  1424 0C37 65 F3		        ADC     INBUFF
  1425 0C39 85 F3		        STA     INBUFF
  1426 0C3B 90 02		        BCC     GET_DOSDR_NEXT
  1427 0C3D E6 F4		        INC     INBUFF+1
  1428
  1429 0C3F			GET_DOSDR_NEXT:
  1430 0C3F A0 02		        LDY     #$02            ; Check for ':' in 3rd pos
  1431 0C41 B1 F3		        LDA     (INBUFF),Y
  1432 0C43 C9 3A		        CMP     #':'
  1433 0C45 D0 06		        BNE     GET_DOSDR_DONE  ; Not found, skip & use default
  1434 0C47 88			        DEY
  1435 0C48 B1 F3		        LDA     (INBUFF),Y
  1436 0C4A 29 0F		        AND     #$0F            ; Convert, say, '2' to 2
  1437 0C4C AA			        TAX                     ; Return DOSDR in X
  1438
  1439 0C4D			GET_DOSDR_DONE:
  1440 0C4D 60			        RTS
  1441
  1442 				;---------------------------------------
  1443 0C4E			DO_GENERIC:
  1444 				;---------------------------------------
  1445
  1446 				    ;---------------------------------------
  1447 				    ; SIO call for NCD,{MK,RM}DIR,DEL,RENAME
  1448 				    ;---------------------------------------
  1449
  1450 				    ;---------------------------------------
  1451 				    ; Get Fujinet SIO command (~ $21 for DEL)
  1452 				    ; X = table index from caller
  1453 				    ;---------------------------------------
  1454 0C4E BD 7A 15		        LDA     CMD_DCOMND,X
  1455 0C51 8D B1 0C		        STA     GENDCB+2
  1456
  1457 				    ;---------------------------------------
  1458 				    ; Get DOSDR from either arg1 or curr drive
  1459 				    ;---------------------------------------
  1460 0C54 20 2B 0C		        JSR     GET_DOSDR    ; X will contain int of n in Nn:
  1461 0C57 8E B0 0C		        STX     GENDCB+1
  1462 0C5A 20 22 15		        JSR     PREPEND_DRIVE
  1463
  1464 				    ;---------------------------------------
  1465 				    ; If this is NCD ensure a '/' char is the last char
  1466 				    ;---------------------------------------
  1467 0C5D AD B1 0C		        LDA     GENDCB+2
  1468 0C60 C9 2C		        CMP     #CMD_CD         ; Is this an NCD command?
  1469 0C62 D0 08		        BNE     DO_GENERIC_NEXT ; No. skip
  1470
  1471 0C64 AD 85 0B		        LDA     CMDSEP
  1472 0C67 F0 2C		        BEQ     NCD_ERROR
  1473 0C69 20 4F 15		        JSR     APPEND_SLASH    ; Append '/' to path if missing
  1474
  1475 0C6C			DO_GENERIC_NEXT:
  1476 				    ;---------------------------------------
  1477 				    ; Populate the DCB
  1478 				    ;---------------------------------------
  1479 0C6C AD E6 16		        LDA     DOSDR
  1480 0C6F 8D 49 09		        STA     STADCB+1        ; Yes. Status (not typo)
  1481 				;        STA     GENDCB+1   ; 20221105 - commented-out. checking for bug...
  1482 0C72 A5 F3		        LDA     INBUFF
  1483 0C74 8D B3 0C		        STA     GENDCB+4
  1484 0C77 A5 F4		        LDA     INBUFF+1
  1485 0C79 8D B4 0C		        STA     GENDCB+5
  1486
  1487 				    ;---------------------------------------
  1488 				    ; Send the command to FujiNet
  1489 				    ;---------------------------------------
  1490 0C7C A9 AF		        LDA     #<GENDCB
  1491 0C7E A0 0C		        LDY     #>GENDCB
  1492 0C80 20 A5 07		        JSR     DOSIOV
  1493 0C83 20 96 0A		        JSR     PRINT_ERROR
  1494
  1495 0C86			GEN_UNMOUNT:
  1496 				    ;---------------------------------------
  1497 				    ; if DEL or RENAME, then remount drive
  1498 				    ;---------------------------------------
  1499 0C86 AD E8 16		        LDA     CMDPRV
  1500 0C89 C9 03		        CMP     #CMD_IDX.DEL
  1501 0C8B F0 04		        BEQ     GEN_REMOUNT
  1502 0C8D C9 0A		        CMP     #CMD_IDX.RENAME
  1503 0C8F D0 03		        BNE     GENDONE
  1504 0C91			GEN_REMOUNT:
  1505 0C91 4C EF 14		        JMP     REMOUNT_DRIVE
  1506
  1507 0C94			GENDONE:
  1508 0C94 60			        RTS
  1509
  1510 				;---------------------------------------
  1511 0C95			NCD_ERROR:
  1512 				;---------------------------------------
  1513 0C95 A9 A9		        LDA     #<NCD_ERROR_STR
  1514 0C97 A0 0C		        LDY     #>NCD_ERROR_STR
  1515 0C99 20 7B 0A		        JSR     PRINT_STRING
  1516 0C9C A0 01		        LDY     #$01        ; Return error
  1517 0C9E 60			        RTS
  1518 				    ;---------------------------------------
  1519 				    ; Close 
  1520 				    ;---------------------------------------
  1521 0C9F A2 10		        LDX     #$10            ; File #1
  1522 0CA1 A9 0C		        LDA     #$0C            ; Close #1 first
  1523 0CA3 9D 42 03		        STA     ICCOM,X
  1524 0CA6 20 56 E4		        JSR     CIOV
  1525
  1526 0CA9			NCD_ERROR_STR:
  1527 0CA9 50 41 54 48 3F 9B	        .BYTE   'PATH?',EOL
  1528
  1529 				;---------------------------------------
  1530 0CAF			GENDCB:
  1531 0CAF 71			        .BYTE      DEVIDN  ; DDEVIC
  1532 0CB0 FF			        .BYTE      $FF     ; DUNIT
  1533 0CB1 FF			        .BYTE      $FF     ; DCOMND
  1534 0CB2 80			        .BYTE      $80     ; DSTATS
  1535 0CB3 FF			        .BYTE      $FF     ; DBUFL
  1536 0CB4 FF			        .BYTE      $FF     ; DBUFH
  1537 0CB5 1F			        .BYTE      $1F     ; DTIMLO
  1538 0CB6 00			        .BYTE      $00     ; DRESVD
  1539 0CB7 00			        .BYTE      $00     ; DBYTL
  1540 0CB8 01			        .BYTE      $01     ; DBYTH
  1541 0CB9 00			        .BYTE      $00     ; DAUX1
  1542 0CBA 00			        .BYTE      $00     ; DAUX2
  1543
  1544 				; End of DO_GENERIC
  1545 				;---------------------------------------
  1546
  1547 				;;---------------------------------------
  1548 				;DO_COPY:
  1549 				;;---------------------------------------
  1550 				;
  1551 				;        LDA     #$20
  1552 				;        STA     COLOR2
  1553 				;
  1554 				;        LDA     #<CPYDCB
  1555 				;        LDY     #>CPYDCB
  1556 				;        JSR     DOSIOV
  1557 				;
  1558 				;        LDA     #$20
  1559 				;        STA     COLOR2
  1560 				;
  1561 				;        RTS
  1562 				;
  1563 				;CPYDCB:
  1564 				;        .BYTE      DEVIDN  ; DDEVIC
  1565 				;        .BYTE      $FF     ; DUNIT
  1566 				;        .BYTE      $D8     ; DCOMND
  1567 				;        .BYTE      $80     ; DSTATS
  1568 				;        .BYTE      <COPYSPEC  ; DBUFL
  1569 				;        .BYTE      >COPYSPEC ; DBUFH
  1570 				;        .BYTE      $FE     ; DTIMLO
  1571 				;        .BYTE      $00     ; DRESVD
  1572 				;        .BYTE      $00     ; DBYTL
  1573 				;        .BYTE      $01     ; DBYTH
  1574 				;        .BYTE      3       ; DAUX1
  1575 				;        .BYTE      2       ; DAUX2
  1576 				;
  1577 				;COPYSPEC:
  1578 				;        .BYTE 'iss.po|iss.po',$00
  1579
  1580 				;---------------------------------------
  1581 0CBB			DO_COPY:
  1582 				;---------------------------------------
  1583 0CBB A9 B0		        LDA     #$B0
  1584 0CBD 8D C6 02		        STA     COLOR2
  1585 0CC0 60			        RTS
  1586
  1587 				;        JSR     COPY_PARSE_FILES    ; locate comma, replace with EOL
  1588 				;        BMI     COPY_DONE
  1589 				;
  1590 				;        LDA     CMDSEP
  1591 				;        STA     CMDSEP+2
  1592 				;
  1593 				;        LDA     CMDSEP+1
  1594 				;        STA     CMDSEP
  1595 				;
  1596 				;        JSR     COPY_OPEN_DEST      ; use CIO to open file 2 for write
  1597 				;        BMI     COPY_DONE
  1598 				;
  1599 				;        LDA     CMDSEP+2
  1600 				;        STA     CMDSEP
  1601 				;        JSR     COPY_OPEN_SRC       ; use CIO to open file 1 for read
  1602 				;        BMI     COPY_DONE
  1603 				;
  1604 				;@:      JSR     COPY_GET_SRC
  1605 				;        JSR     COPY_PUT_DEST
  1606 				;        ;BNE     @-
  1607 				;
  1608 				;COPY_DONE:
  1609 				;    ; Close files
  1610 				;        LDX     #$10
  1611 				;        JSR     CIOCLOSE
  1612 				;        LDX     #$20
  1613 				;        JMP     CIOCLOSE
  1614 				;
  1615 				;;---------------------------------------
  1616 				;COPY_PARSE_FILES:
  1617 				;;---------------------------------------
  1618 				;    ; Find position of comma in line buffer
  1619 				;    ; Return X = position of comma
  1620 				;    ;---------------------------------------
  1621 				;        LDX     CMDSEP
  1622 				;COPY_PARSE_LOOP:
  1623 				;        LDA     LNBUF,X
  1624 				;        CMP     #','
  1625 				;        BEQ     COPY_PARSE_FILES_DONE
  1626 				;        CMP     #EOL
  1627 				;        BEQ     COPY_SHOW_USAGE
  1628 				;        INX
  1629 				;        BNE     COPY_PARSE_LOOP
  1630 				;COPY_PARSE_FILES_DONE:
  1631 				;    ;---------------------------------------
  1632 				;    ; Here if comma found.
  1633 				;    ; Inject EOL where the comma was found
  1634 				;    ;---------------------------------------
  1635 				;        LDA     #EOL
  1636 				;        STA     LNBUF,X
  1637 				;        INX                 ; Advance to start of 2nd arg
  1638 				;        STX     CMDSEP+1    ; Point to 2nd arg now
  1639 				;        RTS
  1640 				;    ;---------------------------------------
  1641 				;    ; Here if no comma found.
  1642 				;    ; Print usage
  1643 				;    ;---------------------------------------
  1644 				;COPY_SHOW_USAGE:
  1645 				;        LDA     #<COPY_SHOW_USAGE_STR
  1646 				;        LDY     #>COPY_SHOW_USAGE_STR
  1647 				;        JSR     PRINT_STRING
  1648 				;        LDY     #$FF
  1649 				;        RTS
  1650 				;
  1651 				;COPY_SHOW_USAGE_STR:
  1652 				;        .BYTE   'COPY SOURCE,DEST',EOL
  1653 				;
  1654 				;; End of COPY_COMMA_POS:
  1655 				;;---------------------------------------
  1656 				;
  1657 				;;---------------------------------------
  1658 				;COPY_OPEN_SRC:
  1659 				;;---------------------------------------
  1660 				;        JSR     GET_DOSDR       ; Get DUNIT
  1661 				;        JSR     PREPEND_DRIVE
  1662 				;
  1663 				;        LDX     #$10            ; File #1
  1664 				;        JSR     CIOCLOSE        ; Assert file #1 is closed
  1665 				;        LDY     #$04            ; Open for input
  1666 				;        JSR     CIOOPEN         ; Open filename @ (INBUFF)
  1667 				;        BPL     COPY_OPEN_SRC_DONE
  1668 				;
  1669 				;        LDA     #<COPY_OPEN_SRC_ERR_STR
  1670 				;        LDY     #>COPY_OPEN_SRC_ERR_STR
  1671 				;        JMP     PRINT_STRING
  1672 				;
  1673 				;COPY_OPEN_SRC_DONE:
  1674 				;        RTS
  1675 				;        
  1676 				;COPY_OPEN_SRC_ERR_STR:
  1677 				;        .BYTE   'UNABLE TO OPEN SOURCE',EOL
  1678 				;
  1679 				;;End of COPY_OPEN_SRC
  1680 				;;---------------------------------------
  1681 				;
  1682 				;;---------------------------------------
  1683 				;COPY_OPEN_DEST:
  1684 				;;---------------------------------------
  1685 				;    ; Advance offset to arg2
  1686 				;        
  1687 				;@:      JSR     GET_DOSDR       ; Get DUNIT
  1688 				;        JSR     PREPEND_DRIVE
  1689 				;
  1690 				;        LDX     #$20            ; Assert file #2 is closed
  1691 				;        JSR     CIOCLOSE
  1692 				;
  1693 				;        LDY     #$08            ; Open for write
  1694 				;        JSR     CIOOPEN
  1695 				;        BPL     COPY_OPEN_DEST_DONE  ; If success, skip ahead
  1696 				;
  1697 				;        LDA     #<COPY_OPEN_DEST_ERR_STR
  1698 				;        LDY     #>COPY_OPEN_DEST_ERR_STR
  1699 				;        JMP     PRINT_STRING
  1700 				;
  1701 				;COPY_OPEN_DEST_DONE:
  1702 				;        RTS
  1703 				;        
  1704 				;COPY_OPEN_DEST_ERR_STR:
  1705 				;        .BYTE   'UNABLE TO OPEN DEST',EOL
  1706 				;
  1707 				;;End of COPY_OPEN_SRC
  1708 				;;---------------------------------------
  1709 				;
  1710 				;;---------------------------------------
  1711 				;COPY_GET_SRC:
  1712 				;;---------------------------------------
  1713 				;        ;LDX     #$10
  1714 				;        ;JSR     CIOSTATUS
  1715 				;
  1716 				;        LDX     #$10
  1717 				;        LDA     #<TBUF
  1718 				;        STA     INBUFF      ; Buffer addr Lo
  1719 				;        LDA     #>TBUF
  1720 				;        STA     INBUFF+1    ; Buffer addr Hi
  1721 				;        LDA     #$80        ; Buffer size Lo
  1722 				;        LDY     #$00        ; Buffer size Hi
  1723 				;        JSR     CIOGET
  1724 				;        BPL     COPY_GET_SRC_DONE
  1725 				;        CPY     #EOF
  1726 				;        BEQ     COPY_GET_SRC_DONE
  1727 				; 
  1728 				;        LDA     #<COPY_GET_SRC_STR
  1729 				;        LDY     #>COPY_GET_SRC_STR
  1730 				;        JMP     PRINT_STRING
  1731 				;
  1732 				;COPY_GET_SRC_DONE:
  1733 				;        RTS
  1734 				;
  1735 				;COPY_GET_SRC_STR:
  1736 				;        .BYTE   'ERROR READING FROM SOURCE',EOL
  1737 				;
  1738 				;;---------------------------------------
  1739 				;COPY_PUT_DEST:
  1740 				;;---------------------------------------
  1741 				;        ;LDX     #$20
  1742 				;        ;JSR     CIOSTATUS
  1743 				;
  1744 				;        LDX     #$20
  1745 				;        LDA     #<TBUF
  1746 				;        STA     INBUFF      ; Buffer addr Lo
  1747 				;        LDA     #>TBUF
  1748 				;        STA     INBUFF+1    ; Buffer addr Hi
  1749 				;        LDA     #$06        ; Buffer size Lo
  1750 				;        LDY     #$00        ; Buffer size Hi
  1751 				;        JSR     CIOPUT
  1752 				;        BPL     COPY_PUT_DEST_DONE
  1753 				;        CPY     #EOF
  1754 				;        BEQ     COPY_PUT_DEST_DONE
  1755 				; 
  1756 				;        LDA     #<COPY_PUT_DEST_STR
  1757 				;        LDY     #>COPY_PUT_DEST_STR
  1758 				;        JMP     PRINT_STRING
  1759 				;
  1760 				;COPY_PUT_DEST_DONE:
  1761 				;        RTS
  1762 				;
  1763 				;COPY_PUT_DEST_STR:
  1764 				;        .BYTE   'ERROR WRITING TO DEST',EOL
  1765 				;
  1766
  1767 				;---------------------------------------
  1768 0CC1			DO_DIR:
  1769 				;---------------------------------------
  1770 0CC1 20 21 0D		        JSR     DIR_INIT    ; set dunits
  1771 0CC4 20 31 0D		        JSR     DIR_OPEN    ; open with dir request
  1772 0CC7 C0 01		        CPY     #$01        ; success (1) ?
  1773 0CC9 F0 03		        BEQ     DIR_LOOP    ; if success, jump ahead
  1774 0CCB 4C 96 0A		        JMP     PRINT_ERROR ; exit
  1775
  1776 0CCE			DIR_LOOP:
  1777
  1778 				    ;---------------------------------------
  1779 				    ; Send Status request to SIO
  1780 				    ;---------------------------------------
  1781 0CCE A9 48		        LDA     #<STADCB
  1782 0CD0 A0 09		        LDY     #>STADCB
  1783 0CD2 20 A5 07		        JSR     DOSIOV
  1784
  1785 				    ;---------------------------------------
  1786 				    ; Status returns DVSTAT
  1787 				    ;---------------------------------------
  1788 0CD5 A2 00		        LDX     #$00
  1789 0CD7 EC EB 02		        CPX     DVSTAT+1    ; if byte count < 255 (that is, hi=0)
  1790 0CDA F0 09		        BEQ     DIR_LT_255  ; then skip
  1791
  1792 				    ;---------------------------------------
  1793 				    ; Branch 1: Read 255 bytes (max)
  1794 				    ;---------------------------------------
  1795 0CDC CA			        DEX                 ; X now 255 (Read FF Bytes)
  1796 0CDD 8E 1D 0D		        STX     DIRRDCB+8   ; DBYTL
  1797 0CE0 8E 1F 0D		        STX     DIRRDCB+10  ; DAUX1
  1798 0CE3 30 0B		        BMI     DIR_NEXT1   ; "always" true. skip down SIO call
  1799
  1800 				    ;---------------------------------------
  1801 				    ; Branch 2: Read < 255 bytes
  1802 				    ;---------------------------------------
  1803 0CE5			DIR_LT_255:
  1804 0CE5 AD EA 02		        LDA     DVSTAT      ; Get count of bytes remaining
  1805 0CE8 F0 6C		        BEQ     DIR_ERROR   ; If here then DVSTAT = $0000 (error)
  1806 0CEA 8D 1D 0D		        STA     DIRRDCB+8   ; DBYTL
  1807 0CED 8D 1F 0D		        STA     DIRRDCB+10  ; DAUX1
  1808
  1809 				    ;-------------------------
  1810 				    ; Send Read request to SIO
  1811 				    ;-------------------------
  1812 0CF0			DIR_NEXT1:
  1813 0CF0 A9 15		        LDA     #<DIRRDCB
  1814 0CF2 A0 0D		        LDY     #>DIRRDCB
  1815 0CF4 20 A5 07		        JSR     DOSIOV      ; Fetch directory listing
  1816 0CF7 20 86 0D		        JSR     DIR_PRINT   ; xfer payload to screen
  1817
  1818 				    ;---------------------------------------
  1819 				    ; Pause output if SPACE key code found
  1820 				    ;---------------------------------------
  1821 0CFA			DIR_WAIT:
  1822 0CFA AD FC 02		        LDA     CH
  1823 0CFD C9 21		        CMP     #SPC_KEY
  1824 0CFF F0 F9		        BEQ     DIR_WAIT
  1825
  1826 				    ;---------------------------------------
  1827 				    ; Exit loop if ESC key code found
  1828 				    ;---------------------------------------
  1829 0D01 AD FC 02		        LDA     CH
  1830 0D04 C9 1C		        CMP     #ESC_KEY    ; hardware code for ESC key
  1831 0D06 F0 05		        BEQ     DIR_NEXT
  1832
  1833 				    ;---------------------------------------
  1834 				    ; Loop if more data to read
  1835 				    ;---------------------------------------
  1836 0D08 AD EB 02		        LDA     DVSTAT+1    ; Was there more to read (that is, was hi>0)?
  1837 0D0B D0 C1		        BNE     DIR_LOOP    ; If yes, then do it again
  1838
  1839 0D0D			DIR_NEXT:
  1840 0D0D A9 FF		        LDA     #$FF        ; Clear key
  1841 0D0F 8D FC 02		        STA     CH
  1842 0D12 4C A4 0D		        JMP     DIR_CLOSE
  1843
  1844 0D15			DIRRDCB:
  1845 0D15 71			        .BYTE   DEVIDN      ; DDEVIC
  1846 0D16 FF			        .BYTE   $FF         ; DUNIT
  1847 0D17 52			        .BYTE   'R'         ; DCOMND
  1848 0D18 40			        .BYTE   $40         ; DSTATS
  1849 0D19 00			        .BYTE   <RBUF       ; DBUFL
  1850 0D1A 18			        .BYTE   >RBUF       ; DBUFH
  1851 0D1B 1F			        .BYTE   $1F         ; DTIMLO
  1852 0D1C 00			        .BYTE   $00         ; DRESVD
  1853 0D1D 00			        .BYTE   $00         ; DBYTL
  1854 0D1E 00			        .BYTE   $00         ; DBYTH
  1855 0D1F 00			        .BYTE   $00         ; DAUX1
  1856 0D20 00			        .BYTE   $00         ; DAUX2
  1857
  1858 				;---------------------------------------
  1859 				; Set DUNITs in all DCBs used by DIR
  1860 				;---------------------------------------
  1861 0D21			DIR_INIT:
  1862 				;---------------------------------------
  1863 0D21 20 2B 0C		        JSR     GET_DOSDR   ; On return, X <- n in Nn:
  1864 0D24 8E 7B 0D		        STX     DIRODCB+1   ; DUNIT for Open
  1865 0D27 8E 49 09		        STX     STADCB+1    ; DUNIT for Status
  1866 0D2A 8E 16 0D		        STX     DIRRDCB+1   ; DUNIT for Read
  1867 0D2D 8E 22 08		        STX     CLODCB+1    ; DUNIT for Close
  1868 0D30 60			        RTS
  1869
  1870 				;---------------------------------------
  1871 0D31			DIR_OPEN:
  1872 				;---------------------------------------
  1873 0D31 20 22 15		        JSR     PREPEND_DRIVE
  1874
  1875 				    ;-----------------------------------
  1876 				    ; Default to arg1
  1877 				    ;-----------------------------------
  1878 0D34 A6 F3		        LDX     INBUFF
  1879 0D36 A4 F4		        LDY     INBUFF+1
  1880
  1881 				    ;-----------------------------------
  1882 				    ; But use Nn:*.* if no arg1
  1883 				    ;-----------------------------------
  1884 0D38 AD 85 0B		        LDA     CMDSEP          ; 0 means no arg1
  1885 0D3B D0 0C		        BNE     DIR_OPEN_NEXT   ; If arg1 present then skip
  1886
  1887 				    ;-----------------------------------
  1888 				    ; Here if no arg1
  1889 				    ;-----------------------------------
  1890 0D3D A2 73		        LDX     #<DIR_OPEN_STR
  1891 0D3F A0 0D		        LDY     #>DIR_OPEN_STR
  1892
  1893 0D41 AD E6 16		        LDA     DOSDR
  1894 0D44 09 30		        ORA     #'0'            ; Convert, say, 1 to '1'
  1895 0D46 8D 74 0D		        STA     DIR_OPEN_STR+1  ; Inject DOSDR into string
  1896
  1897 0D49			DIR_OPEN_NEXT:
  1898 0D49 8E 7E 0D		        STX     DIRODCB+4       ; DBUFL
  1899 0D4C 8C 7F 0D		        STY     DIRODCB+5       ; DBUFH
  1900
  1901 0D4F A9 7A		        LDA     #<DIRODCB
  1902 0D51 A0 0D		        LDY     #>DIRODCB
  1903 0D53 4C A5 07		        JMP     DOSIOV
  1904
  1905 				;---------------------------------------
  1906 0D56			DIR_ERROR:
  1907 				;---------------------------------------
  1908 0D56 A9 60		        LDA     #<DIR_ERROR_STR
  1909 0D58 A0 0D		        LDY     #>DIR_ERROR_STR
  1910 0D5A 20 7B 0A		        JSR     PRINT_STRING
  1911 0D5D A0 01		        LDY     #$01            ; Return error
  1912 0D5F 60			        RTS
  1913
  1914 0D60			DIR_ERROR_STR:
  1915 0D60 55 4E 41 42 4C 45 +         .BYTE   'UNABLE TO READ DIR',EOL
  1916
  1917 0D73			DIR_OPEN_STR:
  1918 0D73 4E 20 3A 2A 2E 2A +         .BYTE   'N :*.*',EOL
  1919
  1920 0D7A			DIRODCB:
  1921 0D7A 71			        .BYTE   DEVIDN          ; DDEVIC
  1922 0D7B FF			        .BYTE   $FF             ; DUNIT
  1923 0D7C 4F			        .BYTE   'O'             ; DCOMND
  1924 0D7D 80			        .BYTE   $80             ; DSTATS
  1925 0D7E FF			        .BYTE   $FF             ; DBUFL
  1926 0D7F FF			        .BYTE   $FF             ; DBUFH
  1927 0D80 1F			        .BYTE   $1F             ; DTIMLO
  1928 0D81 00			        .BYTE   $00             ; DRESVD
  1929 0D82 00			        .BYTE   $00             ; DBYTL
  1930 0D83 01			        .BYTE   $01             ; DBYTH
  1931 0D84 06			        .BYTE   $06             ; DAUX1
  1932 0D85 80			        .BYTE   $80             ; DAUX2 (Long Dir)
  1933
  1934 				; End of DIR_OPEN
  1935 				;---------------------------------------
  1936
  1937 				;---------------------------------------
  1938 0D86			DIR_PRINT:
  1939 				;---------------------------------------
  1940 				        ; Print results using CIO
  1941 0D86 A2 00		        LDX     #$00
  1942 0D88 A9 0B		        LDA     #PUTCHR
  1943 0D8A 9D 42 03		        STA     ICCOM,X
  1944
  1945 				        ; Fill out buffer loc
  1946 0D8D A9 00		        LDA     #<RBUF
  1947 0D8F 9D 44 03		        STA     ICBAL,X
  1948 0D92 A9 18		        LDA     #>RBUF
  1949 0D94 9D 45 03		        STA     ICBAH,X
  1950
  1951 				        ; Fill out size loc
  1952 0D97 AD 1D 0D		        LDA     DIRRDCB+8
  1953 0D9A 9D 48 03		        STA     ICBLL,X
  1954 0D9D 8A			        TXA
  1955 0D9E 9D 49 03		        STA     ICBLH,X
  1956 0DA1 4C 56 E4		        JMP     CIOV
  1957
  1958 				;---------------------------------------
  1959 0DA4			DIR_CLOSE:
  1960 				;---------------------------------------
  1961 				        ; Close
  1962 0DA4 A9 21		        LDA     #<CLODCB
  1963 0DA6 A0 08		        LDY     #>CLODCB
  1964 0DA8 4C A5 07		        JMP     DOSIOV
  1965
  1966 				;---------------------------------------
  1967 0DAB			DO_LOAD:
  1968 				;---------------------------------------
  1969 				    ; Binary Loader based on work by Richard J. Kalagher 07-AUG-1983
  1970
  1971 				    ; Open file
  1972 0DAB AD 85 0B		        LDA     CMDSEP          ; Quit if no arg1
  1973 0DAE D0 03		        BNE     LOAD_NEXT1
  1974 0DB0 4C 08 10		        JMP     LOAD_ERROR
  1975
  1976 0DB3			LOAD_NEXT1:
  1977 				    ; Point INBUFF to start of filename
  1978 0DB3 18			        CLC
  1979 0DB4 65 F3		        ADC     INBUFF          ; [A] contains offset to arg1
  1980 0DB6 85 F3		        STA     INBUFF
  1981 0DB8 90 02		        BCC     LOAD_NEXT2
  1982 0DBA E6 F4		        INC     INBUFF+1
  1983
  1984 0DBC			LOAD_NEXT2:
  1985 0DBC 20 3B 0E		        JSR     LOAD_NTRANS     ; Disable any EOL transation
  1986 0DBF 20 F7 0D		        JSR     LOAD_SETUP      ; Set up run and init to RTS
  1987 0DC2 A9 04		        LDA     #OINPUT         ; A arg needed in LOAD_OPEN
  1988 0DC4 20 0D 0E		        JSR     LOAD_OPEN       ; Open the file
  1989 0DC7 C0 01		        CPY     #$01            ; Quit if unable to open
  1990 0DC9 D0 2B		        BNE     R
  1991
  1992 				    ; Process each payload
  1993 0DCB 20 49 0E		GETFIL: JSR     LOAD_READ2      ; Get two bytes (binary header)
  1994 0DCE 30 26		        BMI     R               ; Exit if EOF hit
  1995 0DD0 20 02 0E		        JSR     LOAD_INIT       ; Set init default
  1996 0DD3 20 63 0E		        JSR     LOAD_CHKFF      ; Check if header (and start addr, too)
  1997 0DD6 20 86 0E		        JSR     LOAD_STRAD      ; Put start address in
  1998 0DD9 20 49 0E		        JSR     LOAD_READ2      ; Get to more butes (end addr)
  1999 0DDC 20 93 0E		        JSR     LOAD_ENDAD      ; Put end address in
  2000 0DDF 20 A0 0E		        JSR     LOAD_BUFLEN     ; Calculate buffer length
  2001 0DE2 20 C5 0E		        JSR     LOAD_GETDAT     ; Get the data record
  2002 0DE5 10 03		        BPL     @+              ; Was EOF detected?
  2003 0DE7 20 F3 0D		        JSR     JSTART          ; Yes. Go to RUNAD
  2004 0DEA 20 F0 0D		@:      JSR     JINIT           ; Attempt initialization
  2005 0DED 4C CB 0D		        JMP     GETFIL          ; Process next payload
  2006
  2007 0DF0 6C E2 02		JINIT:  JMP     (INITAD)        ; Will either RTS or perform INIT
  2008 0DF3 6C E0 02		JSTART: JMP     (RUNAD)         ; Godspeed.
  2009 0DF6 60			R:      RTS                     ; Stunt-double for (INITAD),(RUNAD)
  2010
  2011 				;---------------------------------------
  2012 0DF7			LOAD_SETUP:
  2013 				;---------------------------------------
  2014 0DF7 A9 F6		        LDA     #<R
  2015 0DF9 8D E0 02		        STA     RUNAD
  2016 0DFC A9 0D		        LDA     #>R
  2017 0DFE 8D E1 02		        STA     RUNAD+1
  2018 0E01 60			        RTS
  2019
  2020 				;---------------------------------------
  2021 0E02			LOAD_INIT:
  2022 				;---------------------------------------
  2023 0E02 A9 F6		        LDA     #<R
  2024 0E04 8D E2 02		        STA     INITAD
  2025 0E07 A9 0D		        LDA     #>R
  2026 0E09 8D E3 02		        STA     INITAD+1
  2027 0E0C 60			        RTS
  2028
  2029 				;---------------------------------------
  2030 0E0D			LOAD_OPEN:
  2031 				;---------------------------------------
  2032 0E0D 48			        PHA                     ; A = data direction (4=in, 8=out)
  2033 0E0E 20 2B 0C		        JSR     GET_DOSDR       ; Get DUNIT
  2034 0E11 8E 01 08		        STX     OPNDCB+1        ; Set DUNIT
  2035 0E14 8E 83 08		        STX     GETDCB+1        ; Set DUNIT FOR READ
  2036 0E17 20 22 15		        JSR     PREPEND_DRIVE
  2037
  2038 0E1A A5 F3		        LDA     INBUFF          ; Register location of filename
  2039 0E1C 8D 04 08		        STA     OPNDCB+4
  2040 0E1F A5 F4		        LDA     INBUFF+1
  2041 0E21 8D 05 08		        STA     OPNDCB+5
  2042
  2043 0E24 68			        PLA                     ; A = data direction (4=in, 8=out)
  2044 0E25 8D 0A 08		        STA     OPNDCB+10
  2045 0E28 A9 00		        LDA     #$00            ; AUX2: No translation
  2046 0E2A 8D 0B 08		        STA     OPNDCB+11
  2047
  2048 0E2D A9 00		        LDA     #<OPNDCB
  2049 0E2F A0 08		        LDY     #>OPNDCB
  2050
  2051 0E31 20 A5 07		        JSR     DOSIOV
  2052 0E34 48			        PHA
  2053 0E35 20 96 0A		        JSR     PRINT_ERROR
  2054 0E38 68			        PLA
  2055 0E39 A8			        TAY
  2056
  2057 0E3A 60			        RTS
  2058
  2059 				;---------------------------------------
  2060 0E3B			LOAD_NTRANS:
  2061 				;---------------------------------------
  2062 				    ; Disable any EOL transation otherwise
  2063 				    ; binary data will be corrupted during load
  2064 				    ;---------------------------------------
  2065 0E3B 20 2B 0C		        JSR     GET_DOSDR       ; Get DUNIT
  2066 0E3E 8E 01 11		        STX     NTRDCB+1        ; Set DUNIT
  2067 0E41 A9 00		        LDA     #$00
  2068 0E43 8D 0B 11		        STA     NTRDCB+11       ; Translation mode (0 = NONE)
  2069 0E46 4C CD 10		        JMP     NTRANS_CALL     ; Reuse code in DO_NTRANS
  2070
  2071 				;---------------------------------------
  2072 0E49			LOAD_READ2:
  2073 				;---------------------------------------
  2074
  2075 0E49 A9 02		        LDA     #$02
  2076 0E4B 8D 8A 08		        STA     GETDCB+8        ; DBYTL
  2077 0E4E 8D 8C 08		        STA     GETDCB+10       ; DAUX1
  2078
  2079 0E51 A9 00		        LDA     #$00
  2080 0E53 8D 8B 08		        STA     GETDCB+9        ; DBYTH
  2081 0E56 8D 8D 08		        STA     GETDCB+11       ; DAUX2
  2082
  2083 0E59 A9 82		        LDA     #<GETDCB
  2084 0E5B A0 08		        LDY     #>GETDCB
  2085 0E5D 20 A5 07		        JSR     DOSIOV
  2086
  2087 				    ; Return -1 if EOF is found
  2088 0E60 4C CB 0F		        JMP     GETDAT_CHECK_EOF
  2089
  2090 				;---------------------------------------
  2091 0E63			LOAD_CHKFF:
  2092 				;---------------------------------------
  2093 				    ; Check for binary file signature ($FF $FF)
  2094 0E63 AE 00 18		        LDX     BAL
  2095 0E66 E8			        INX
  2096 0E67 F0 01		        BEQ     TEST2
  2097 0E69 60			        RTS
  2098 0E6A AE 01 18		TEST2:  LDX     BAH
  2099 0E6D E8			        INX
  2100 0E6E F0 01		        BEQ     ITSFF
  2101 0E70 60			        RTS
  2102 0E71 4C 49 0E		ITSFF:  JMP     LOAD_READ2  ; Get start address and return
  2103
  2104 				;        LDA     #<LOAD_ERROR_STR2
  2105 				;        LDY     #>LOAD_ERROR_STR2
  2106 				;        JMP     PRINT_STRING
  2107
  2108 0E74			LOAD_ERROR_STR2:
  2109 0E74 4E 4F 54 20 41 20 +         .BYTE   'NOT A BINARY FILE',EOL
  2110
  2111 				;---------------------------------------
  2112 0E86			LOAD_STRAD:
  2113 				;---------------------------------------
  2114 				    ; Save payload start address
  2115 0E86 AD 00 18		        LDA     RBUF
  2116 0E89 8D 80 18		        STA     STL
  2117 0E8C AD 01 18		        LDA     RBUF+1
  2118 0E8F 8D 81 18		        STA     STH
  2119 0E92 60			        RTS
  2120
  2121 				;---------------------------------------
  2122 0E93			LOAD_ENDAD:
  2123 				;---------------------------------------
  2124 				    ; Save payload end address
  2125 0E93 AD 00 18		        LDA     RBUF
  2126 0E96 8D 82 18		        STA     ENL
  2127 0E99 AD 01 18		        LDA     RBUF+1
  2128 0E9C 8D 83 18		        STA     ENH
  2129 0E9F 60			        RTS
  2130
  2131 				;---------------------------------------
  2132 0EA0			LOAD_BUFLEN:
  2133 				;---------------------------------------
  2134 				    ; Calculate buffer length (end-start+1)
  2135
  2136 				    ; Calc buffer size Lo
  2137 0EA0 AD 82 18		        LDA     ENL
  2138 0EA3 38			        SEC
  2139 0EA4 ED 80 18		        SBC     STL
  2140 0EA7 8D 84 18		        STA     BLL     ; Buffer Length Lo
  2141
  2142 				    ; Calc buffer size Hi
  2143 0EAA AD 83 18		        LDA     ENH     ; Calc buffer size Hi
  2144 0EAD ED 81 18		        SBC     STH
  2145 0EB0 8D 85 18		        STA     BLH     ; Buffer Length Hi
  2146
  2147 				    ; Add 1
  2148 0EB3 18			        CLC
  2149 0EB4 AD 84 18		        LDA     BLL
  2150 0EB7 69 01		        ADC     #$01
  2151 0EB9 8D 84 18		        STA     BLL
  2152
  2153 0EBC AD 85 18		        LDA     BLH
  2154 0EBF 69 00		        ADC     #$00    ; Take care of any carry
  2155 0EC1 8D 85 18		        STA     BLH
  2156
  2157 0EC4 60			        RTS
  2158
  2159 				;---------------------------------------
  2160 0EC5			LOAD_GETDAT:
  2161 				;---------------------------------------
  2162 				    ; Definitions:
  2163 				    ; HEAD = requested bytes that will be found in current cache (< 512 bytes)
  2164 				    ; BODY = contiguous 512 byte sections. BODY = n * 512 bytes)
  2165 				    ; TAIL = any bytes remaining after BODY (< 512 bytes)
  2166
  2167 0EC5 20 2B 0C		        JSR     GET_DOSDR
  2168 0EC8 8E F0 0F		        STX     BINDCB+1
  2169
  2170 				    ; Get current status
  2171 0ECB 8E 49 09		        STX     STADCB+1
  2172 0ECE A9 48		        LDA     #<STADCB
  2173 0ED0 A0 09		        LDY     #>STADCB
  2174 0ED2 20 A5 07		        JSR     DOSIOV
  2175
  2176 				    ; Check if bytes requested BL < DVSTAT (bytes waiting in cache)
  2177 0ED5 AD EA 02		        LDA     DVSTAT
  2178 0ED8 CD 84 18		        CMP     BLL
  2179 0EDB AD EB 02		        LDA     DVSTAT+1
  2180 0EDE ED 85 18		        SBC     BLH
  2181 0EE1 B0 4C		        BCS     GETDAT_OPT2     ; BL <= BW (bytes waiting)
  2182
  2183 0EE3			GETDAT_OPT1:
  2184 				    ;--------------------------------
  2185 				    ; Here if bytes requested > bytes 
  2186 				    ; remaining in cache
  2187 				    ;--------------------------------
  2188
  2189 				    ;-------------------------------
  2190 				    ; Head = BW (bytes waiting)
  2191 				    ;-------------------------------
  2192 0EE3 AD EA 02		        LDA     DVSTAT
  2193 0EE6 8D 86 18		        STA     HEADL
  2194 0EE9 AD EB 02		        LDA     DVSTAT+1
  2195 0EEC 8D 87 18		        STA     HEADH
  2196
  2197 				    ;-------------------------------
  2198 				    ; Tail = (BL - HEAD) mod 512
  2199 				    ;-------------------------------
  2200 0EEF 38			        SEC
  2201 0EF0 AD 84 18		        LDA     BLL
  2202 0EF3 ED 86 18		        SBC     HEADL
  2203 0EF6 29 FF		        AND     #$FF
  2204 0EF8 8D 8A 18		        STA     TAILL
  2205 0EFB AD 85 18		        LDA     BLH
  2206 0EFE ED 87 18		        SBC     HEADH
  2207 0F01 29 01		        AND     #$01
  2208 0F03 8D 8B 18		        STA     TAILH
  2209
  2210 				    ;-----------------------------------
  2211 				    ; Body = BL - HEAD - TAIL
  2212 				    ;-----------------------------------
  2213 				        ; 1. Body = BL - HEAD
  2214 				        ;-------------------------------
  2215 0F06 38			        SEC
  2216 0F07 AD 84 18		        LDA     BLL
  2217 0F0A ED 86 18		        SBC     HEADL
  2218 0F0D 8D 88 18		        STA     BODYL
  2219 0F10 AD 85 18		        LDA     BLH
  2220 0F13 ED 87 18		        SBC     HEADH
  2221 0F16 8D 89 18		        STA     BODYH
  2222
  2223 				        ;-------------------------------
  2224 				        ; 2. Body = Body - HEAD
  2225 				        ;-------------------------------
  2226 0F19 38			        SEC
  2227 0F1A AD 88 18		        LDA     BODYL
  2228 0F1D ED 8A 18		        SBC     TAILL
  2229 0F20 8D 88 18		        STA     BODYL
  2230 0F23 AD 89 18		        LDA     BODYH
  2231 0F26 ED 8B 18		        SBC     TAILH
  2232 0F29 8D 89 18		        STA     BODYH
  2233
  2234 0F2C 4C 49 0F		        JMP     GETDAT_READ
  2235
  2236 0F2F			GETDAT_OPT2:
  2237 				    ;--------------------------------
  2238 				    ; Here if bytes requested <= bytes 
  2239 				    ; remaining in cache
  2240 				    ;--------------------------------
  2241 				    ; Head = BL, TAIL = BODY = 0
  2242 				    ;--------------------------------
  2243 0F2F AD 84 18		        LDA     BLL
  2244 0F32 8D 86 18		        STA     HEADL
  2245 0F35 AD 85 18		        LDA     BLH
  2246 0F38 8D 87 18		        STA     HEADH
  2247 0F3B A9 00		        LDA     #$00
  2248 0F3D 8D 8A 18		        STA     TAILL
  2249 0F40 8D 8B 18		        STA     TAILH
  2250 0F43 8D 88 18		        STA     BODYL
  2251 0F46 8D 89 18		        STA     BODYH
  2252
  2253 				;---------------------------------------
  2254 0F49			GETDAT_READ:
  2255 				;---------------------------------------
  2256 				    ;---------------------------------------
  2257 				    ; Read HEAD bytes
  2258 				    ;---------------------------------------
  2259 0F49 AD 86 18		        LDA     HEADL
  2260 0F4C 8D 84 18		        STA     BLL
  2261 0F4F AD 87 18		        LDA     HEADH
  2262 0F52 8D 85 18		        STA     BLH
  2263 0F55 20 86 0F		        JSR     GETDAT_DOSIOV
  2264 0F58 10 01		        BPL     GETDAT_BODY ; Skip ahead if no problems
  2265 0F5A 60			        RTS                 ; Bail if error
  2266
  2267 				    ;---------------------------------------
  2268 				    ; Read BODY bytes
  2269 				    ;---------------------------------------
  2270 0F5B			GETDAT_BODY:
  2271 0F5B AE 89 18		        LDX     BODYH
  2272 0F5E			GETDAT_BODY_LOOP:
  2273 0F5E F0 1A		        BEQ     GETDAT_TAIL ; Skip if less than a page to read
  2274
  2275 0F60 A9 00		        LDA     #$00
  2276 0F62 8D 84 18		        STA     BLL         ; Buffer length
  2277 0F65 A9 02		        LDA     #$02        ; 512 bytes at a time
  2278 0F67 8D 85 18		        STA     BLH
  2279
  2280 0F6A 8A			        TXA                 ; Stash our loop index (X)
  2281 0F6B 48			        PHA                 ; onto the stack
  2282 0F6C 20 86 0F		        JSR     GETDAT_DOSIOV   
  2283 0F6F 10 03		        BPL     @+          ; Skip ahead if no problems
  2284 0F71 68			        PLA                 ; Here if problem. Clean up stack
  2285 0F72 98			        TYA                 ; Reset N status flag before returning
  2286 0F73 60			        RTS                 ; Bail if error
  2287
  2288 0F74 68			@:      PLA                 ; Retrieve our loop index
  2289 0F75 AA			        TAX                 ; and xfer it back into X
  2290 0F76 CA			        DEX                 ; -2 (we pull 0200 bytes at a time)
  2291 0F77 CA			        DEX                 ; 
  2292 0F78 D0 E4		        BNE     GETDAT_BODY_LOOP
  2293
  2294 0F7A			GETDAT_TAIL:
  2295 				    ;---------------------------------------
  2296 				    ; Read TAIL bytes
  2297 				    ;---------------------------------------
  2298 0F7A AD 8A 18		        LDA     TAILL
  2299 0F7D 8D 84 18		        STA     BLL
  2300 0F80 AD 8B 18		        LDA     TAILH
  2301 0F83 8D 85 18		        STA     BLH
  2302
  2303 				;---------------------------------------
  2304 0F86			GETDAT_DOSIOV:
  2305 				;---------------------------------------
  2306 				    ; Bail if BL = 0
  2307 0F86 AD 84 18		        LDA     BLL
  2308 0F89 D0 05		        BNE     @+
  2309 0F8B AD 85 18		        LDA     BLH
  2310 0F8E F0 5C		        BEQ     CHECK_EOF_DONE
  2311
  2312 0F90			@:
  2313 				    ; SIO READ
  2314 0F90 AD 80 18		        LDA     STL
  2315 0F93 8D F3 0F		        STA     BINDCB+4    ; Start Address Lo
  2316 0F96 AD 81 18		        LDA     STH
  2317 0F99 8D F4 0F		        STA     BINDCB+5    ; Start Address Hi
  2318 0F9C AD 84 18		        LDA     BLL
  2319 0F9F 8D F7 0F		        STA     BINDCB+8    ; Buffer Size Lo
  2320 0FA2 8D F9 0F		        STA     BINDCB+10
  2321 0FA5 AD 85 18		        LDA     BLH
  2322 0FA8 8D F8 0F		        STA     BINDCB+9    ; Buffer Size Hi
  2323 0FAB 8D FA 0F		        STA     BINDCB+11
  2324
  2325 				    ;---------------------------------------
  2326 				    ; Send Read request to SIO
  2327 				    ;---------------------------------------
  2328 0FAE A9 EF		        LDA     #<BINDCB
  2329 0FB0 A0 0F		        LDY     #>BINDCB
  2330 0FB2 20 A5 07		        JSR     DOSIOV
  2331 0FB5 20 96 0A		        JSR     PRINT_ERROR
  2332
  2333 0FB8 18			        CLC
  2334 0FB9 AD 80 18		        LDA     STL
  2335 0FBC 6D 84 18		        ADC     BLL
  2336 0FBF 8D 80 18		        STA     STL
  2337
  2338 0FC2 AD 81 18		        LDA     STH
  2339 0FC5 6D 85 18		        ADC     BLH
  2340 0FC8 8D 81 18		        STA     STH
  2341
  2342 0FCB			GETDAT_CHECK_EOF:
  2343 				    ; Get status (updates DVSTAT, DSTATS)
  2344 0FCB AD 83 08		        LDA     GETDCB+1
  2345 0FCE 8D 49 09		        STA     STADCB+1
  2346 0FD1 A9 48		        LDA     #<STADCB
  2347 0FD3 A0 09		        LDY     #>STADCB
  2348 0FD5 20 A5 07		        JSR     DOSIOV
  2349
  2350 				    ; Return -1 if DVSTAT == $0000 and DVSTAT+3 == EOF
  2351 0FD8 AD EA 02		        LDA     DVSTAT
  2352 0FDB D0 0F		        BNE     CHECK_EOF_DONE
  2353
  2354 0FDD AD EB 02		        LDA     DVSTAT+1
  2355 0FE0 D0 0A		        BNE     CHECK_EOF_DONE
  2356
  2357 0FE2 A9 88		        LDA     #EOF
  2358 0FE4 CD ED 02		        CMP     DVSTAT+3        ; Is it EOF
  2359 0FE7 D0 03		        BNE     CHECK_EOF_DONE  ; No? Go to success
  2360 0FE9 A0 FF		        LDY     #$FF            ; Yes? Return -1
  2361 0FEB 60			        RTS
  2362
  2363 0FEC			CHECK_EOF_DONE:
  2364 0FEC A0 01		        LDY     #$01            ; Return success
  2365 0FEE 60			        RTS
  2366
  2367 0FEF			BINDCB:
  2368 0FEF 71			       .BYTE    DEVIDN      ; DDEVIC
  2369 0FF0 FF			       .BYTE    $FF         ; DUNIT
  2370 0FF1 52			       .BYTE    'R'         ; DCOMND
  2371 0FF2 40			       .BYTE    $40         ; DSTATS
  2372 0FF3 FF			       .BYTE    $FF         ; DBUFL
  2373 0FF4 FF			       .BYTE    $FF         ; DBUFH
  2374 0FF5 0F			       .BYTE    $0F         ; DTIMLO
  2375 0FF6 00			       .BYTE    $00         ; DRESVD
  2376 0FF7 FF			       .BYTE    $FF         ; DBYTL
  2377 0FF8 FF			       .BYTE    $FF         ; DBYTH
  2378 0FF9 FF			       .BYTE    $FF         ; DAUX1
  2379 0FFA FF			       .BYTE    $FF         ; DAUX2
  2380
  2381
  2382 				;---------------------------------------
  2383 0FFB			LOAD_CLOSE:
  2384 				;---------------------------------------
  2385 0FFB AD F0 0F		        LDA     BINDCB+1
  2386 0FFE 8D 22 08		        STA     CLODCB+1
  2387 1001 A9 21		        LDA     #<CLODCB
  2388 1003 A0 08		        LDY     #>CLODCB
  2389 1005 4C A5 07		        JMP     DOSIOV
  2390
  2391 				;---------------------------------------
  2392 1008			LOAD_ERROR:
  2393 				;---------------------------------------
  2394 1008 A9 E0		        LDA     #<MISSING_FILE_STR
  2395 100A A0 16		        LDY     #>MISSING_FILE_STR
  2396 100C 4C 7B 0A		        JMP     PRINT_STRING
  2397
  2398 				;---------------------------------------
  2399 100F			DO_LOCK:
  2400 				;---------------------------------------
  2401 100F A9 60		        LDA     #$60
  2402 1011 8D C6 02		        STA     COLOR2
  2403 1014 60			        RTS
  2404
  2405 				;---------------------------------------
  2406 1015			DO_LOGIN:
  2407 				;---------------------------------------
  2408 1015 A9 A0		        LDA     #$A0
  2409 1017 8D C6 02		        STA     COLOR2
  2410 101A 60			        RTS
  2411
  2412 101B			LOGIN_ERROR:
  2413 101B A9 22		        LDA     #<LOGIN_ERROR_STR
  2414 101D A0 10		        LDY     #>LOGIN_ERROR_STR
  2415 101F 4C 7B 0A		        JMP     PRINT_STRING
  2416
  2417 1022			LOGIN_ERROR_STR:
  2418 1022 4C 4F 47 49 4E 20 +         .BYTE   'LOGIN [N[n]:] <USERNAME> <PASSWORD>',EOL
  2419
  2420 				;---------------------------------------
  2421 1046			DO_NPWD:
  2422 				;---------------------------------------
  2423 1046 A9 9B		        LDA     #EOL        ; Truncate buffer
  2424 1048 8D 00 18		        STA     RBUF
  2425
  2426 104B 20 2B 0C		        JSR     GET_DOSDR   ; X will contain n in Nn:
  2427 104E 8E 7E 10		        STX     PWDDCB+1
  2428
  2429 1051 A9 7D		        LDA     #<PWDDCB
  2430 1053 A0 10		        LDY     #>PWDDCB
  2431 1055 20 A5 07		        JSR     DOSIOV
  2432 1058 20 96 0A		        JSR     PRINT_ERROR
  2433
  2434 				    ;---------------------------------------
  2435 				    ; If we entered DO_NPWD from REMOUNT_DRIVE
  2436 				    ; then scipt printing output
  2437 				    ;---------------------------------------
  2438 105B AD E8 16		        LDA     CMDPRV
  2439 105E C9 03		        CMP     #CMD_IDX.DEL
  2440 1060 F0 1A		        BEQ     NPWD_DONE
  2441 1062 C9 0A		        CMP     #CMD_IDX.RENAME
  2442 1064 F0 16		        BEQ     NPWD_DONE
  2443
  2444 1066			NPWD_LOOP:
  2445 1066 A9 00		        LDA     #<RBUF
  2446 1068 A0 18		        LDY     #>RBUF
  2447 106A 20 7B 0A		        JSR     PRINT_STRING
  2448
  2449 106D A9 48		        LDA     #<STADCB
  2450 106F A0 09		        LDY     #>STADCB
  2451 1071 20 A5 07		        JSR     DOSIOV
  2452 1074 20 96 0A		        JSR     PRINT_ERROR
  2453
  2454 				    ;---------------------------------------
  2455 				    ; Loop if more data to read
  2456 				    ;---------------------------------------
  2457 1077 AD EB 02		        LDA     DVSTAT+1    ; Was there more to read (that is, was hi>0)?
  2458 107A D0 EA		        BNE     NPWD_LOOP   ; If yes, then do it again
  2459
  2460 107C			NPWD_DONE:
  2461 107C 60			        RTS
  2462
  2463 107D			PWDDCB:
  2464 107D 71			        .BYTE      DEVIDN  ; DDEVIC
  2465 107E FF			        .BYTE      $FF     ; DUNIT
  2466 107F 30			        .BYTE      $30     ; DCOMND
  2467 1080 40			        .BYTE      $40     ; DSTATS
  2468 1081 00			        .BYTE      <RBUF   ; DBUFL
  2469 1082 18			        .BYTE      >RBUF   ; DBUFH
  2470 1083 1F			        .BYTE      $1F     ; DTIMLO
  2471 1084 00			        .BYTE      $00     ; DRESVD
  2472 1085 00			        .BYTE      $00     ; DBYTL
  2473 1086 01			        .BYTE      $01     ; DBYTH
  2474 1087 00			        .BYTE      $00     ; DAUX1
  2475 1088 00			        .BYTE      $00     ; DAUX2
  2476
  2477 				; End of DO_NPWD
  2478 				;---------------------------------------
  2479
  2480 				;---------------------------------------
  2481 1089			DO_NTRANS:
  2482 				;---------------------------------------
  2483 1089 AE 85 0B		        LDX     CMDSEP          ; Check if there's any args
  2484 108C F0 49		        BEQ     NTRANS_ERROR    ; No. Show usage and quit
  2485
  2486 108E AD E6 16		        LDA     DOSDR           ; Go with current drive for now
  2487 1091 8D 01 11		        STA     NTRDCB+1        ; it'll be overwritten later if req'd
  2488
  2489 				    ;---------------------------------------
  2490 				    ; Check for argc = 2
  2491 				    ;---------------------------------------
  2492 1094 AC 85 0B		        LDY     CMDSEP          ; Stash offset to arg1 in Y
  2493 1097 AE 86 0B		        LDX     CMDSEP+1        ; Is there an arg2?
  2494 109A F0 21		        BEQ     PARSE_MODE      ; No. parse arg1 as mode (0-3)
  2495
  2496 				    ;---------------------------------------
  2497 				    ; Here if argc = 2 (arg1 = Nn: arg2 = mode)
  2498 				    ;---------------------------------------
  2499 109C AE 85 0B		        LDX     CMDSEP          ; Get offset to arg1 (Nn:)
  2500 109F BD 82 05		        LDA     LNBUF,X         ; Is arg1's (N[n]:) 1st char = 'N'?
  2501 10A2 C9 4E		        CMP     #'N'            ;
  2502 10A4 D0 31		        BNE     NTRANS_ERROR    ; No? Then quit
  2503 10A6 BD 83 05		        LDA     LNBUF+1,X
  2504 10A9 C9 3A		        CMP     #':'            ; Is arg1's (N[n]:) 2nd char = ':'?
  2505 10AB F0 10		        BEQ     PARSE_MODE      ; Yes, stick with default drive
  2506
  2507 				    ;---------------------------------------
  2508 				    ; Parse drive number
  2509 				    ;---------------------------------------
  2510 10AD C9 31		        CMP     #'1'            ; Quit if n in Nn not 1..4
  2511 10AF 90 26		        BCC     NTRANS_ERROR    ; Quit if < '1'
  2512 10B1 C9 39		        CMP     #'9'
  2513 10B3 B0 22		        BCS     NTRANS_ERROR    ; Quit if >= '9'
  2514 10B5 49 30		        EOR     #%00110000
  2515 10B7 8D 01 11		        STA     NTRDCB+1
  2516 10BA AC 86 0B		        LDY     CMDSEP+1
  2517
  2518 				    ;---------------------------------------
  2519 				    ; Confirm valid parameter
  2520 				    ;---------------------------------------
  2521 10BD			PARSE_MODE:
  2522 10BD B9 82 05		        LDA     LNBUF,Y         ; Quit if mode not 0..3
  2523 10C0 C9 30		        CMP     #'0'
  2524 10C2 90 13		        BCC     NTRANS_ERROR
  2525 10C4 C9 34		        CMP     #'4'
  2526 10C6 B0 0F		        BCS     NTRANS_ERROR
  2527 10C8 49 30		        EOR     #%00110000      ; Here if valid parameter
  2528 10CA 8D 0B 11		        STA     NTRDCB+11       ; Assign parameter to DCB
  2529
  2530 				    ;---------------------------------------
  2531 				    ; Call SIO
  2532 				    ;---------------------------------------
  2533 10CD			NTRANS_CALL:
  2534 10CD A9 00		        LDA     #<NTRDCB
  2535 10CF A0 11		        LDY     #>NTRDCB
  2536 10D1 20 A5 07		        JSR     DOSIOV
  2537 10D4 4C 96 0A		        JMP     PRINT_ERROR
  2538
  2539 10D7			NTRANS_ERROR:
  2540 10D7 A9 DE		        LDA     #<NTRANS_ERROR_STR
  2541 10D9 A0 10		        LDY     #>NTRANS_ERROR_STR
  2542 10DB 4C 7B 0A		        JMP     PRINT_STRING
  2543
  2544 10DE			NTRANS_ERROR_STR:
  2545 10DE 4D 4F 44 45 3F 20 +         .BYTE   'MODE? 0=NONE, 1=CR, 2=LF, 3=CR/LF',EOL
  2546
  2547 1100			NTRDCB:
  2548 1100 71			        .BYTE   DEVIDN  ; DDEVIC
  2549 1101 FF			        .BYTE   $FF     ; DUNIT
  2550 1102 54			        .BYTE   'T'     ; DCOMND
  2551 1103 00			        .BYTE   $00     ; DSTATS
  2552 1104 00			        .BYTE   $00     ; DBUFL
  2553 1105 00			        .BYTE   $00     ; DBUFH
  2554 1106 1F			        .BYTE   $1F     ; DTIMLO
  2555 1107 00			        .BYTE   $00     ; DRESVD
  2556 1108 00			        .BYTE   $00     ; DBYTL
  2557 1109 00			        .BYTE   $00     ; DBYTH
  2558 110A 00			        .BYTE   $00     ; DAUX1
  2559 110B 00			        .BYTE   $00     ; DAUX2
  2560
  2561 				; End of DO_NTRANS
  2562 				;---------------------------------------
  2563
  2564 				;---------------------------------------
  2565 110C			DO_AUTORUN:
  2566 				;---------------------------------------
  2567 				    ; Change URL stored in AUTORUN app key
  2568 				    ;-----------------------------------
  2569 110C AD 85 0B		        LDA     CMDSEP          ; Check if there's any arg
  2570 110F D0 07		        BNE     AUTORUN_NEXT1   ; If arg found, skip ahead
  2571
  2572 				    ; Here if no command line arg found
  2573 				    ; Print error message and exit
  2574 1111 A9 4B		        LDA     #<AUTORUN_ERROR_STR
  2575 1113 A0 11		        LDY     #>AUTORUN_ERROR_STR
  2576 1115 4C 7B 0A		        JMP     PRINT_STRING
  2577
  2578 1118			AUTORUN_NEXT1:
  2579 				    ; Point to start of arg on command line
  2580 1118 18			        CLC
  2581 1119 65 F3		        ADC     INBUFF          ; INBUFF += CMDSEP
  2582 111B 85 F3		        STA     INBUFF
  2583 111D 8D 7F 11		        STA     APPKEYWRITEDCB+4
  2584
  2585 				    ; Open app key
  2586 1120 A9 01		        LDA     #$01            ; Open for write (1)
  2587 1122 8D 55 11		        STA     AUTORUN_APPKEY+4
  2588 1125 A9 63		        LDA     #<APPKEYOPENDCB
  2589 1127 A0 11		        LDY     #>APPKEYOPENDCB
  2590 1129 20 A5 07		        JSR     DOSIOV
  2591
  2592 				    ; Find length of URL (arg1)
  2593 112C A0 FF		        LDY     #$FF            ; Init strlen
  2594 112E			AUTORUN_LOOP1
  2595 112E C8			        INY                     ; Incr strlen
  2596 112F B1 F3		        LDA     (INBUFF),Y
  2597 1131 C9 9B		        CMP     #EOL            ; At end of string?
  2598 1133 D0 F9		        BNE     AUTORUN_LOOP1   ; No. Keep counting
  2599
  2600 1135 A9 0A		        LDA     #LF             ; Convert EOL to LF
  2601 1137 91 F3		        STA     (INBUFF),Y
  2602 1139 C8			        INY                     ; One more for strlen
  2603
  2604 113A			AUTORUN_NEXT2: 
  2605 				    ; Write app key
  2606 113A 8C 85 11		        STY     APPKEYWRITEDCB+10   ; Y = strlen
  2607 113D A9 7B		        LDA     #<APPKEYWRITEDCB
  2608 113F A0 11		        LDY     #>APPKEYWRITEDCB
  2609 1141 20 A5 07		        JSR     DOSIOV
  2610
  2611 				    ; Close app key
  2612 1144 A9 57		        LDA     #<APPKEYCLOSEDCB
  2613 1146 A0 11		        LDY     #>APPKEYCLOSEDCB
  2614 1148 4C A5 07		        JMP     DOSIOV
  2615
  2616 114B			AUTORUN_ERROR_STR:
  2617 114B 50 41 54 48 3F 9B	        .BYTE   'PATH?',EOL
  2618
  2619 1151			AUTORUN_APPKEY:
  2620 1151 79 DB		        .WORD   $DB79           ; creator ID
  2621 1153 00			        .BYTE   $00             ; app ID
  2622 1154 00			        .BYTE   $00             ; key ID
  2623 1155 00			        .BYTE   $00             ; read or write mode
  2624 1156 00			        .BYTE   $00             ; unused
  2625
  2626 1157			APPKEYCLOSEDCB:
  2627 1157 70			        .BYTE   $70             ; DDEVIC
  2628 1158 01			        .BYTE   $01             ; DUNIT
  2629 1159 DB			        .BYTE   $DB             ; DCOMND
  2630 115A 00			        .BYTE   $00             ; DSTATS
  2631 115B 00			        .BYTE   $00             ; DBUFL
  2632 115C 00			        .BYTE   $00             ; DBUFH
  2633 115D 0F			        .BYTE   $0F             ; DTIMLO
  2634 115E 00			        .BYTE   $00             ; DRESVD
  2635 115F 00			        .BYTE   $00             ; DBYTL
  2636 1160 00			        .BYTE   $00             ; DBYTH
  2637 1161 00			        .BYTE   $00             ; DAUX1
  2638 1162 00			        .BYTE   $00             ; DAUX2
  2639
  2640 1163			APPKEYOPENDCB:
  2641 1163 70			        .BYTE   $70             ; DDEVIC
  2642 1164 01			        .BYTE   $01             ; DUNIT
  2643 1165 DC			        .BYTE   $DC             ; DCOMND
  2644 1166 80			        .BYTE   $80             ; DSTATS
  2645 1167 51			        .BYTE   <AUTORUN_APPKEY ; DBUFL
  2646 1168 11			        .BYTE   >AUTORUN_APPKEY ; DBUFH
  2647 1169 0F			        .BYTE   $0F             ; DTIMLO
  2648 116A 00			        .BYTE   $00             ; DRESVD
  2649 116B 06			        .BYTE   $06             ; DBYTL
  2650 116C 00			        .BYTE   $00             ; DBYTH
  2651 116D 00			        .BYTE   $00             ; DAUX1
  2652 116E 00			        .BYTE   $00             ; DAUX2
  2653
  2654 116F			APPKEYREADDCB:
  2655 116F 70			        .BYTE   $70             ; DDEVIC
  2656 1170 01			        .BYTE   $01             ; DUNIT
  2657 1171 DD			        .BYTE   $DD             ; DCOMND
  2658 1172 40			        .BYTE   $40             ; DSTATS
  2659 1173 82			        .BYTE   <LNBUF          ; DBUFL
  2660 1174 05			        .BYTE   >LNBUF          ; DBUFH
  2661 1175 01			        .BYTE   $01             ; DTIMLO - minimize timeout
  2662 1176 00			        .BYTE   $00             ; DRESVD
  2663 1177 40			        .BYTE   MAX_APPKEY_LEN  ; DBYTL
  2664 1178 00			        .BYTE   $00             ; DBYTH
  2665 1179 00			        .BYTE   $00             ; DAUX1
  2666 117A 00			        .BYTE   $00             ; DAUX2
  2667
  2668 117B			APPKEYWRITEDCB:
  2669 117B 70			        .BYTE   $70             ; DDEVIC
  2670 117C 01			        .BYTE   $01             ; DUNIT
  2671 117D DE			        .BYTE   $DE             ; DCOMND
  2672 117E 80			        .BYTE   $80             ; DSTATS
  2673 117F FF			        .BYTE   $FF             ; DBUFL
  2674 1180 05			        .BYTE   $05             ; DBUFH (expect page 5)
  2675 1181 0F			        .BYTE   $0F             ; DTIMLO
  2676 1182 00			        .BYTE   $00             ; DRESVD
  2677 1183 40			        .BYTE   MAX_APPKEY_LEN  ; DBYTL
  2678 1184 00			        .BYTE   $00             ; DBYTH
  2679 1185 FF			        .BYTE   $FF             ; DAUX1 (# actual bytes)
  2680 1186 00			        .BYTE   $00             ; DAUX2
  2681
  2682 				;---------------------------------------
  2683 1187			SUBMIT_AUTORUN:
  2684 				;---------------------------------------
  2685 				    ; At initial DOS boot, read URL for 
  2686 				    ; app key file from SD card's
  2687 				    ; FujiNet folder.
  2688 				    ;
  2689 				    ; filename: db790000.key
  2690 				    ; contents: url to a batch file
  2691 				    ;---------------------------------------
  2692 1187 20 64 0A		        JSR     LDBUFA
  2693
  2694 				    ; Open app key
  2695 118A A9 00		        LDA     #$00            ; Open for read
  2696 118C 8D 55 11		        STA     AUTORUN_APPKEY+4
  2697 118F A9 63		        LDA     #<APPKEYOPENDCB
  2698 1191 A0 11		        LDY     #>APPKEYOPENDCB
  2699 1193 20 A5 07		        JSR     DOSIOV
  2700
  2701 1196 C0 01		        CPY     #$01            ; Was open successful?
  2702 1198 F0 01		        BEQ     AUTOSUB_NEXT    ; Yes. Continue.
  2703 119A 60			        RTS                     ; No. Exit
  2704
  2705 119B			AUTOSUB_NEXT:
  2706 				    ; Read app key
  2707 119B A9 6F		        LDA     #<APPKEYREADDCB
  2708 119D A0 11		        LDY     #>APPKEYREADDCB
  2709 119F 20 A5 07		        JSR     DOSIOV
  2710
  2711 				    ; Close app key
  2712 11A2 A9 57		        LDA     #<APPKEYCLOSEDCB
  2713 11A4 A0 11		        LDY     #>APPKEYCLOSEDCB
  2714 11A6 20 A5 07		        JSR     DOSIOV
  2715
  2716 				    ; Does the returned URL contain something?
  2717 11A9 AE 82 05		        LDX     LNBUF
  2718 11AC D0 01		        BNE     AUTORUN_CALL_SUBMIT
  2719 11AE 60			        RTS
  2720
  2721 11AF			AUTORUN_CALL_SUBMIT:
  2722 				    ; Replace end-of-line in buffer with null terminator
  2723 11AF CA			        DEX                     ; Move index back 1 position
  2724 11B0 A9 00		        LDA     #$00            ;
  2725 11B2 9D 84 05		        STA     LNBUF+2,X       ; Write null-terminator 
  2726 11B5 A9 02		        LDA     #$02            ; Change arg1 location...
  2727 11B7 8D 85 0B		        STA     CMDSEP          ;  to point to filename
  2728 11BA D0 0C		        BNE     SUBMIT_NEXT1    ; Fall through
  2729
  2730 				;---------------------------------------
  2731 11BC			DO_SUBMIT:
  2732 				;---------------------------------------
  2733 11BC AD 85 0B		        LDA     CMDSEP
  2734 11BF D0 07		        BNE     SUBMIT_NEXT1
  2735
  2736 				    ; Filename required
  2737 11C1 A9 E0		        LDA     #<MISSING_FILE_STR
  2738 11C3 A0 16		        LDY     #>MISSING_FILE_STR
  2739 11C5 4C 7B 0A		        JMP     PRINT_STRING
  2740
  2741 11C8			SUBMIT_NEXT1:
  2742
  2743 				    ; Default to NOSCREEN
  2744 11C8 A9 00		        LDA     #$00
  2745 11CA 8D E9 16		        STA     ECHO_FLG
  2746
  2747 				    ; Prep file path
  2748 11CD 20 2B 0C		        JSR     GET_DOSDR       ; Get DUNIT
  2749 11D0 20 22 15		        JSR     PREPEND_DRIVE
  2750
  2751 				    ; Assert FILE #1 is closed
  2752 11D3 A2 10		        LDX     #$10
  2753 11D5 20 BB 09		        JSR     CIOCLOSE
  2754 				        
  2755 				    ; OPEN #1, 4, 0, file path
  2756 11D8 A2 10		        LDX     #$10            ; File #1
  2757 11DA A0 04		        LDY     #$04            ; Open for input
  2758 11DC 20 C3 09		        JSR     CIOOPEN         ; Open filename @ (INBUFF)
  2759 11DF 10 03		        BPL     SUBMIT_NEXT2
  2760 11E1 4C 96 0A		        JMP     PRINT_ERROR
  2761
  2762 				    ; Read batch file character by character
  2763 				    ; This allows it be end-of-line agnostic
  2764 				    ; Branch forward when an end-of-line is interpretted.
  2765
  2766 11E4			SUBMIT_NEXT2:
  2767 11E4 20 64 0A		        JSR     LDBUFA      ; Reset INBUFF to $0580
  2768 11E7 C6 F3		        DEC     INBUFF      ; Init 1 byte before buffer
  2769 11E9 A9 FF		        LDA     #$FF        ; Clear command
  2770 11EB 8D E7 16		        STA     CMD
  2771
  2772 11EE			SUBMIT_GETCH:
  2773 11EE E6 F3		        INC     INBUFF          ; Advance pointer
  2774 11F0 D0 02		        BNE     SUBMIT_NEXT3
  2775 11F2 E6 F4		        INC     INBUFF+1
  2776
  2777 11F4			SUBMIT_NEXT3:
  2778 11F4 A2 10		        LDX     #$10            ; OPEN #1
  2779 11F6 A9 01		        LDA     #$01            ; Get 1 byte
  2780 11F8 A0 00		        LDY     #$00            ; ditto
  2781
  2782 11FA 20 ED 09		        JSR     CIOGET          ; Get byte from file
  2783 11FD A0 00		        LDY     #$00            ;
  2784 11FF B1 F3		        LDA     (INBUFF),Y      ; byte will be here
  2785 				        
  2786 1201 C9 0D		        CMP     #CR             ; Just skip if Windows CR
  2787 1203 F0 E9		        BEQ     SUBMIT_GETCH
  2788
  2789 1205 C9 0A		        CMP     #LF             ; Convert LF to EOL
  2790 1207 D0 04		        BNE     SUBMIT_EOL
  2791 1209 A9 9B		        LDA     #EOL
  2792 120B 91 F3		        STA     (INBUFF),Y
  2793
  2794 120D			SUBMIT_EOL:
  2795 120D C9 9B		        CMP     #EOL            ; At end of command line?
  2796 120F D0 DD		        BNE     SUBMIT_GETCH    ; No. Get next byte.
  2797
  2798 				    ; Here if we've reached the end of a command line.
  2799 				    ; At end of file?
  2800 1211 A2 10		        LDX     #$10            ; Channel #1
  2801 1213 BD 43 03		        LDA     ICSTA,X         ; Inspect return code
  2802 1216 C9 88		        CMP     #EOF
  2803 1218 F0 22		        BEQ     SUBMIT_DONE     ; No error, try parsing cmd
  2804
  2805 121A AD E9 16		        LDA     ECHO_FLG        ; Skip echo if SCREEN is disabled
  2806 121D F0 11		        BEQ     SUBMIT_NEXT4
  2807 121F AD 82 05		        LDA     LNBUF
  2808 1222 C9 40		        CMP     #'@'            ; Skip lines beginning with @
  2809 1224 F0 0A		        BEQ     SUBMIT_NEXT4
  2810
  2811 				    ; Echo commands
  2812 1226 20 64 0A		        JSR     LDBUFA
  2813 1229 A5 F3		        LDA     INBUFF
  2814 122B A4 F4		        LDY     INBUFF+1
  2815 122D 20 7B 0A		        JSR     PRINT_STRING
  2816
  2817 1230			SUBMIT_NEXT4:
  2818 1230 20 33 0B		        JSR     GETCMDTEST
  2819 1233 20 89 0B		        JSR     PARSECMD
  2820 1236 20 FF 0B		        JSR     DOCMD
  2821 1239 38			        SEC
  2822 123A B0 A8		        BCS     SUBMIT_NEXT2
  2823
  2824 123C			SUBMIT_DONE
  2825 123C A2 10		        LDX     #$10
  2826 123E 4C BB 09		        JMP     CIOCLOSE
  2827
  2828 				; End of DO_SUBMIT
  2829 				;---------------------------------------
  2830
  2831 				;---------------------------------------
  2832 1241			DO_TYPE:
  2833 				;---------------------------------------
  2834 1241 AD 85 0B		        LDA     CMDSEP
  2835 1244 D0 07		        BNE     TYPE_SKIP
  2836
  2837 1246			TYPE_USAGE:
  2838 1246 A9 E0		        LDA     #<MISSING_FILE_STR
  2839 1248 A0 16		        LDY     #>MISSING_FILE_STR
  2840 124A 4C 7B 0A		        JMP     PRINT_STRING
  2841
  2842 124D			TYPE_SKIP:
  2843 124D 20 2B 0C		        JSR     GET_DOSDR       ; Get DUNIT
  2844 1250 20 22 15		        JSR     PREPEND_DRIVE
  2845
  2846 				    ; Assert input file closed
  2847 1253 A2 10		        LDX     #$10            ; File #1
  2848 1255 20 BB 09		        JSR     CIOCLOSE        ; Assert file #1 is closed
  2849
  2850 				    ; Open input file
  2851 1258 A2 10		        LDX     #$10            ; File #1
  2852 125A A0 04		        LDY     #$04            ; Open for input
  2853 125C 20 C3 09		        JSR     CIOOPEN         ; Open filename @ (INBUFF)
  2854 125F 10 08		        BPL     TYPE_NEXT
  2855
  2856 				    ; If open failed, Print error
  2857 1261 A2 10		        LDX     #$10            ; File #1
  2858 1263 BC 43 03		        LDY     ICSTA,X
  2859 1266 4C 96 0A		        JMP     PRINT_ERROR
  2860
  2861 1269			TYPE_NEXT:
  2862
  2863 				    ; Initialize pagination
  2864 1269 20 0E 13		        JSR     DO_CLS
  2865 126C A9 15		        LDA     #21
  2866 126E 8D BB 02		        STA     SCRFLG
  2867
  2868 1271			TYPE_LOOP:
  2869 				    ; Bail if ESC key is pressed
  2870 1271 AD FC 02		        LDA     CH
  2871 1274 C9 1C		        CMP     #ESC_KEY
  2872 1276 F0 49		        BEQ     TYPE_DONE
  2873
  2874 				    ; Check if page is full
  2875 1278 AD BB 02		        LDA     SCRFLG
  2876 127B C9 16		        CMP     #22         ; if SCRFLG < 21
  2877 127D 90 14		        BCC     TYPE_READ   ; then skip to read
  2878
  2879 				    ; Here if page is full
  2880 				    ; Wait for keypress
  2881 127F A9 FF		        LDA     #$FF    ; Clear keypress
  2882 1281 8D FC 02		        STA     CH
  2883
  2884 1284			TYPE_WAIT:
  2885 1284 AE FC 02		        LDX     CH
  2886 1287 E8			        INX
  2887 1288 F0 FA		        BEQ     TYPE_WAIT
  2888
  2889 128A E0 1C		        CPX     #ESC_KEY
  2890 128C F0 33		        BEQ     TYPE_DONE
  2891
  2892 				    ; Reset pagination
  2893 128E A9 00		        LDA     #$00
  2894 1290 8D BB 02		        STA     SCRFLG
  2895
  2896 1293			TYPE_READ:
  2897 				    ; Read from file
  2898 1293 A2 10		        LDX     #$10
  2899 1295 A9 01		        LDA     #$01
  2900 1297 A0 00		        LDY     #$00
  2901 1299 20 ED 09		        JSR     CIOGET
  2902
  2903 				    ; Quit if EOF
  2904 129C A2 10		        LDX     #$10
  2905 129E BD 43 03		        LDA     ICSTA,X
  2906 12A1 C9 88		        CMP     #EOF
  2907 12A3 F0 1C		        BEQ     TYPE_DONE
  2908
  2909 				    ; Convert CRLF or LF --> EOL
  2910 12A5 A0 00		        LDY     #$00
  2911 12A7 B1 F3		        LDA     (INBUFF),Y
  2912 12A9 C9 0D		        CMP     #CR     ; Skip CR
  2913 12AB F0 11		        BEQ     TYPE_NEXT3
  2914 12AD C9 0A		        CMP     #LF     ; Convert LF --> EOL
  2915 12AF D0 04		        BNE     TYPE_NEXT2
  2916 12B1 A9 9B		        LDA     #EOL
  2917 12B3 91 F3		        STA     (INBUFF),Y
  2918
  2919 12B5			TYPE_NEXT2:
  2920 				    ; Write to screen
  2921 12B5 A2 00		        LDX     #$00
  2922 12B7 A9 01		        LDA     #$01
  2923 12B9 A0 00		        LDY     #$00
  2924 12BB 20 0B 0A		        JSR     CIOPUT
  2925
  2926 12BE			TYPE_NEXT3:
  2927 				    ; Do next
  2928 12BE 4C 71 12		        JMP     TYPE_LOOP
  2929 				        
  2930 12C1			TYPE_DONE:
  2931 12C1 A9 FF		        LDA     #$FF
  2932 12C3 8D FC 02		        STA     CH
  2933 12C6 A2 10		        LDX     #$10            ; Close File #1
  2934 12C8 4C BB 09		        JMP     CIOCLOSE        ; 
  2935
  2936 12CB			TYPE_OPEN_ERR_STR:
  2937 12CB 55 4E 41 42 4C 45 +         .BYTE   'UNABLE TO OPEN FILE',EOL
  2938
  2939 				;---------------------------------------
  2940 12DF			DO_UNLOCK:
  2941 				;---------------------------------------
  2942 12DF A9 90		        LDA     #$90
  2943 12E1 8D C6 02		        STA     COLOR2
  2944 12E4 60			        RTS
  2945
  2946 				;---------------------------------------
  2947 12E5			DO_CAR:
  2948 				;---------------------------------------
  2949
  2950 				    ;---------------------------------------
  2951 				    ; Is cart address space RAM or ROM?
  2952 				    ;---------------------------------------
  2953 12E5 AD 00 A0		        LDA     $A000
  2954 12E8 EE 00 A0		        INC     $A000
  2955 12EB CD 00 A0		        CMP     $A000
  2956 12EE F0 0A		        BEQ     DO_CAR_NEXT
  2957
  2958 				    ;---------------------------------------
  2959 				    ; RAM found
  2960 				    ;---------------------------------------
  2961 12F0 8D 00 A0		        STA     $A000
  2962 12F3 A9 01		        LDA     #<DO_CAR_ERR
  2963 12F5 A0 13		        LDY     #>DO_CAR_ERR
  2964 12F7 4C 7B 0A		        JMP     PRINT_STRING
  2965
  2966 12FA			DO_CAR_NEXT:
  2967 12FA A9 FF		        LDA     #$FF
  2968 12FC 85 08		        STA     $08         ; Warmstart
  2969 12FE 6C FA BF		        JMP     ($BFFA)
  2970
  2971 1301			DO_CAR_ERR:
  2972 1301 4E 4F 20 43 41 52 +         .BYTE   'NO CARTRIDGE',EOL
  2973
  2974 				;---------------------------------------
  2975 130E			DO_CLS:
  2976 				;---------------------------------------
  2977 130E A9 15		        LDA     #<CLS_STR
  2978 1310 A0 13		        LDY     #>CLS_STR
  2979 1312 4C 7B 0A		        JMP     PRINT_STRING
  2980
  2981 1315			CLS_STR:
  2982 1315 7D 9B		        .BYTE   125,EOL
  2983
  2984 				;---------------------------------------
  2985 1317			DO_COLD:
  2986 				;---------------------------------------
  2987 1317 4C 77 E4		        JMP     COLDSV
  2988
  2989 				;---------------------------------------
  2990 131A			DO_HELP:
  2991 				;---------------------------------------
  2992 				    ; Append either "HELP" or arg1 to URL
  2993 131A A2 00		        LDX     #$00        ; index to start of article buf
  2994 131C AC 85 0B		        LDY     CMDSEP      ; index to cmd line arg
  2995 				        
  2996 131F			HELP_LOOP1:
  2997 131F B1 F3		        LDA     (INBUFF),Y
  2998 1321 C9 9B		        CMP     #EOL
  2999 1323 F0 11		        BEQ     HELP_NEXT1  ; Exit loop at end of arg
  3000 1325 E0 16		        CPX     #22
  3001 1327 10 2B		        BPL     HELP_DONE   ; Exit if arg is too long
  3002 1329 9D B0 13		        STA     HELP_ARTICLE,X
  3003 132C E8			        INX
  3004 132D C8			        INY
  3005 132E D0 EF		        BNE     HELP_LOOP1  ; Always true
  3006
  3007 				    ; Append .DOC extension to article name
  3008 1330			HELP_EXT:
  3009 1330 2E 44 4F 43 9B 00	        .BYTE   '.DOC',EOL,$00
  3010
  3011 1336			HELP_NEXT1:
  3012 1336 A0 00		        LDY     #$00
  3013
  3014 1338			HELP_LOOP2:
  3015 1338 B9 30 13		        LDA     HELP_EXT,Y
  3016 133B 9D B0 13		        STA     HELP_ARTICLE,X  ; Store null term too
  3017 133E F0 04		        BEQ     HELP_NEXT2      ; Skip ahead if terminator
  3018 1340 E8			        INX
  3019 1341 C8			        INY
  3020 1342 D0 F4		        BNE     HELP_LOOP2  ; Always true
  3021
  3022 1344			HELP_NEXT2:
  3023 				    ; Copy URL to LNBUF
  3024 1344 A2 00		        LDX     #$00    ; Index to start of HELP_URL
  3025 1346 A0 05		        LDY     #$05    ; Index to start at arg1 for "TYPE "
  3026 				    
  3027 1348			HELP_LOOP3:
  3028 1348 BD 5C 13		        LDA     HELP_URL,X  ; Get source byte
  3029 134B 99 82 05		        STA     LNBUF,Y     ; Write to target location
  3030 134E F0 04		        BEQ     HELP_DONE   ; Exit loop on null terminator
  3031 1350 E8			        INX                 ; Advance indices
  3032 1351 C8			        INY
  3033 1352 D0 F4		        BNE     HELP_LOOP3  ; Always true
  3034 				        
  3035 1354			HELP_DONE:        
  3036 1354 A9 05		        LDA     #$05        ; Trick TYPE to look for URL in arg1
  3037 1356 8D 85 0B		        STA     CMDSEP
  3038 1359 4C 41 12		        JMP     DO_TYPE
  3039
  3040 135C			HELP_URL:
  3041 135C 4E 38 3A 48 54 54 +         .BYTE   'N8:HTTPS://raw.githubusercontent.com/michaelsternberg/fujinet-nhandler/nos/nos/HELP/'
  3042
  3043 13B0			HELP_ARTICLE:
  3044 13B0 00 00 00 00 00 00 +     :24 .BYTE   $00
  3045
  3046 				;---------------------------------------
  3047 13C8			DO_NOBASIC:
  3048 				;---------------------------------------
  3049 				    ; Quit if 400/800
  3050 13C8 AD F7 FF		        LDA     $FFF7
  3051 13CB C9 FF		        CMP     #$FF        ; ????
  3052 13CD F0 21		        BEQ     NOBASIC_ERROR
  3053 13CF C9 DD		        CMP     #$DD        ; OSA NTSC
  3054 13D1 F0 1D		        BEQ     NOBASIC_ERROR
  3055 13D3 C9 F3		        CMP     #$F3        ; OSB NTSC
  3056 13D5 F0 19		        BEQ     NOBASIC_ERROR
  3057 13D7 C9 D6		        CMP     #$D6        ; OSA PAL
  3058 13D9 F0 15		        BEQ     NOBASIC_ERROR
  3059 13DB C9 22		        CMP     #$22        ; OSB PAL
  3060 13DD F0 11		        BEQ     NOBASIC_ERROR
  3061 13DF C9 0A		        CMP     #$0A        ; OSA 1200XL
  3062 13E1 F0 0D		        BEQ     NOBASIC_ERROR
  3063 13E3 C9 0B		        CMP     #$0B        ; OSB 1200XL
  3064 13E5 F0 09		        BEQ     NOBASIC_ERROR
  3065 				        
  3066 				    ; Disable BASIC
  3067 13E7 AD 01 D3		        LDA     PORTB
  3068 13EA 09 02		        ORA     #%00000010  ; if Bit 1 = 1 then BASIC is disabled
  3069 13EC 8D 01 D3		        STA     PORTB
  3070 13EF 60			        RTS
  3071
  3072 				;---------------------------------------
  3073 13F0			NOBASIC_ERROR:
  3074 				;---------------------------------------
  3075 13F0 A9 F7		        LDA     #<NOBASIC_ERROR_STR
  3076 13F2 A0 13		        LDY     #>NOBASIC_ERROR_STR
  3077 13F4 4C 7B 0A		        JMP     PRINT_STRING
  3078
  3079 13F7			NOBASIC_ERROR_STR:
  3080 13F7 4E 4F 20 42 55 49 +         .BYTE   'NO BUILT-IN BASIC',EOL
  3081
  3082 				;---------------------------------------
  3083 1409			DO_NOSCREEN:
  3084 				;---------------------------------------
  3085 1409 A9 00		        LDA     #$00
  3086 140B 8D E9 16		        STA     ECHO_FLG    ; Disable echo in batch processing
  3087 140E 60			        RTS
  3088
  3089 				;---------------------------------------
  3090 140F			DO_SCREEN:
  3091 				;---------------------------------------
  3092 140F A9 01		        LDA     #$01
  3093 1411 8D E9 16		        STA     ECHO_FLG    ; Enable echo in batch processing
  3094 1414 60			        RTS
  3095
  3096 				;---------------------------------------
  3097 1415			DO_PRINT:
  3098 				;---------------------------------------
  3099 1415 AD 85 0B		        LDA     CMDSEP
  3100 1418 F0 08		        BEQ     PRINT_DONE
  3101
  3102 141A 18			        CLC
  3103 141B 65 F3		        ADC     INBUFF
  3104 141D A4 F4		        LDY     INBUFF+1
  3105 141F 4C 7B 0A		        JMP     PRINT_STRING
  3106
  3107 1422			PRINT_DONE:
  3108 1422 60			        RTS
  3109
  3110 				;---------------------------------------
  3111 1423			DO_REENTER:
  3112 				;---------------------------------------
  3113 				    ; Jump to the address stored in RUNAD or INITAD
  3114 				    ; Do the one that isn't pointing to R (RUNAD first)
  3115
  3116 				    ; Skip it all if both contain $0000
  3117 1423 AD E2 02		        LDA     INITAD
  3118 1426 D0 16		        BNE     DO_REENTER_CONT
  3119 1428 AD E3 02		        LDA     INITAD+1
  3120 142B D0 11		        BNE     DO_REENTER_CONT
  3121 142D AD E0 02		        LDA     RUNAD
  3122 1430 D0 0C		        BNE     DO_REENTER_CONT
  3123 1432 AD E1 02		        LDA     RUNAD+1
  3124 1435 D0 07		        BNE     DO_REENTER_CONT
  3125
  3126 1437 A9 52		        LDA     #<DO_REENTER_ERR
  3127 1439 A0 14		        LDY     #>DO_REENTER_ERR
  3128 143B 4C 7B 0A		        JMP     PRINT_STRING
  3129
  3130 143E			DO_REENTER_CONT:
  3131 143E AD E0 02		        LDA     RUNAD
  3132 1441 C9 0D		        CMP     #>R
  3133 1443 D0 07		        BNE     DO_REENTER_RUNAD
  3134 1445 AD E1 02		        LDA     RUNAD+1
  3135 1448 C9 0D		        CMP     #>R
  3136 144A F0 03		        BEQ     DO_REENTER_INITAD
  3137
  3138 144C			DO_REENTER_RUNAD:
  3139 144C 6C E0 02		        JMP     (RUNAD)     ; Godspeed
  3140
  3141 144F			DO_REENTER_INITAD:
  3142 144F 6C E2 02		        JMP     (INITAD)    ; Godspeed
  3143
  3144 1452			DO_REENTER_ERR:
  3145 1452 4E 4F 20 41 44 44 +         .BYTE   'NO ADDR IN INITAD OR RUNAD',EOL
  3146
  3147 				;---------------------------------------
  3148 146D			DO_REM:
  3149 				;---------------------------------------
  3150 146D 60			        RTS
  3151
  3152 				;---------------------------------------
  3153 146E			DO_RUN:
  3154 				;---------------------------------------
  3155 146E AD 85 0B		        LDA     CMDSEP      ; Get position for address arg
  3156 1471 A8			        TAY                 ; Offset to arg used later
  3157 1472 18			        CLC
  3158 1473 69 04		        ADC     #$04
  3159 1475 8D 00 18		        STA     RBUF
  3160
  3161 				    ;---------------------------------------
  3162 				    ; ASCII hex char to integer conversion
  3163 				    ; algorithm borrowed from Apple II Monitor
  3164 				    ;---------------------------------------
  3165 1478 A9 00		        LDA     #$00
  3166 147A 85 F3		        STA     INBUFF      ; L
  3167 147C 85 F4		        STA     INBUFF+1    ; H
  3168 147E			NEXTHEX:
  3169 147E B9 82 05		        LDA     LNBUF,Y     ; Get character for hex test.
  3170 1481 49 30		        EOR     #%00110000  ; Maps digits to $0-$9
  3171 1483 C9 0A		        CMP     #$0A        ; Digit?
  3172 1485 90 06		        BCC     DIG         ; Yes.
  3173 1487 69 88		        ADC     #$88        ; Map letter "A"-"F" to $FA-FF.
  3174 1489 C9 FA		        CMP     #$FA        ; Hex letter?
  3175 148B 90 17		        BCC     NOTHEX      ; No, character not hex.
  3176
  3177 148D 0A			DIG:    ASL
  3178 148E 0A			        ASL
  3179 148F 0A			        ASL
  3180 1490 0A			        ASL
  3181 1491 A2 04		        LDX     #$04        ; Shift count.
  3182
  3183 1493			HEXSHIFT:
  3184 1493 0A			        ASL
  3185 1494 26 F3		        ROL     INBUFF      ; Rotate into LSD.
  3186 1496 26 F4		        ROL     INBUFF+1    ; Rotate into MSD's.
  3187 1498 CA			        DEX                 ; Done 4 shifts?
  3188 1499 D0 F8		        BNE     HEXSHIFT    ; No, loop.
  3189 149B C8			        INY                 ; Advance text index
  3190 149C CC 00 18		        CPY     RBUF        ; Processed 4 characters?
  3191 149F D0 DD		        BNE     NEXTHEX     ; No, get next character.
  3192
  3193 14A1 6C F3 00		        JMP     (INBUFF)    ; Goto requested address. Godspeed.
  3194
  3195 14A4			NOTHEX:
  3196 14A4 A9 AB		        LDA     #<RUN_ERROR_STR
  3197 14A6 A0 14		        LDY     #>RUN_ERROR_STR
  3198 14A8 4C 7B 0A		        JMP     PRINT_STRING
  3199
  3200 14AB			RUN_ERROR_STR:
  3201 14AB 41 44 44 52 3F 20 +         .BYTE   'ADDR? 0000..FFFF',EOL
  3202
  3203 				;---------------------------------------
  3204 14BC			DO_WARM:
  3205 				;---------------------------------------
  3206 14BC 4C 74 E4		        JMP     WARMSV
  3207
  3208 				;---------------------------------------
  3209 14BF			DO_XEP:
  3210 				;---------------------------------------
  3211 14BF A0 19		        LDY     #$19        ; CMD = $19 (enter 40 col)
  3212 14C1 AE 85 0B		        LDX     CMDSEP
  3213 14C4 BD 82 05		        LDA     LNBUF,X
  3214 14C7 C9 34		        CMP     #'4'
  3215 14C9 F0 01		        BEQ     @+
  3216 14CB 88			        DEY                 ; CMD = $18 (enter 80 col)
  3217 14CC			@:      
  3218 14CC A2 00		        LDX     #$00
  3219 14CE 98			        TYA
  3220 14CF 9D 42 03		        STA     ICCOM,X
  3221 14D2 A9 EC		        LDA     #<EDEV
  3222 14D4 9D 44 03		        STA     ICBAL,X
  3223 14D7 A9 14		        LDA     #>EDEV
  3224 14D9 9D 45 03		        STA     ICBAH,X
  3225 14DC A9 2C		        LDA     #$2C
  3226 14DE 9D 4A 03		        STA     ICAX1,X
  3227 14E1 A9 00		        LDA     #$00
  3228 14E3 9D 4B 03		        STA     ICAX2,X
  3229 14E6 20 56 E4		        JSR     CIOV
  3230 14E9 4C 0E 13		        JMP     DO_CLS
  3231
  3232 14EC 25 1A 9B		EDEV:   .BYTE   "E:",EOL
  3233 				        
  3234 				;---------------------------------------
  3235 14EF			REMOUNT_DRIVE:
  3236 				;---------------------------------------
  3237
  3238 				    ;---------------------------------------
  3239 				    ; Workaround for timeout issue regarding idempotent commands that
  3240 				    ; unmount the server.  So far, these are DEL and RENAME. This
  3241 				    ; routine, remounts the TNFS URL by calling NPWD and attempts
  3242 				    ; a MKDIR on the returned mount point. Hopefully this is an
  3243 				    ; non-consequential operation since the directory already exists.
  3244 				    ;---------------------------------------
  3245
  3246 14EF 20 46 10		        JSR     DO_NPWD         ; Curr dir for drive now in RBUF
  3247
  3248 14F2 AD 00 18		        LDA     RBUF            ; Quit if not TNFS. Only TNFS is affected.
  3249 14F5 C9 54		        CMP     #'T'            ; TODO More letters needed if...
  3250 14F7 D0 28		        BNE     REMOUNT_DONE    ; ...another Txxx protocol exists
  3251
  3252 14F9 A9 4E		        LDA     #'N'
  3253 14FB 8D 00 18		        STA     RBUF+0
  3254 14FE AD E6 16		        LDA     DOSDR           ; Get drive number
  3255 1501 09 30		        ORA     #'0'            ; Convert, say, 1 to '1'
  3256 1503 8D 01 18		        STA     RBUF+1
  3257 1506 A9 3A		        LDA     #':'
  3258 1508 8D 02 18		        STA     RBUF+2
  3259
  3260 150B A9 2A		        LDA     #CMD_MKDIR
  3261 150D 8D B1 0C		        STA     GENDCB+2
  3262 1510 A9 00		        LDA     #<RBUF          ; TODO Is this needed
  3263 1512 8D B3 0C		        STA     GENDCB+4        ; TODO or is it hardcoded in DO_GENERIC?
  3264 1515 A9 18		        LDA     #>RBUF
  3265 1517 8D B4 0C		        STA     GENDCB+5
  3266
  3267 151A A9 AF		        LDA     #<GENDCB
  3268 151C A0 0C		        LDY     #>GENDCB
  3269 151E 4C A5 07		        JMP     DOSIOV
  3270
  3271 1521			REMOUNT_DONE:
  3272 1521 60			        RTS
  3273
  3274 				;---------------------------------------
  3275 1522			PREPEND_DRIVE:
  3276 				;---------------------------------------
  3277 				        ; Inject "Nn:" in front of a plain filename
  3278 				        ; before passing it to the FujiNet
  3279 1522 A0 00		        LDY     #$00
  3280 1524 A9 4E		        LDA     #'N'
  3281 1526 D1 F3		        CMP     (INBUFF),Y  ; Does arg1 already begin with N?
  3282
  3283 1528 A0 02		        LDY     #$02
  3284 152A A9 3A		        LDA     #':'
  3285 152C D1 F3		        CMP     (INBUFF),Y
  3286 152E F0 1C		        BEQ     PREPEND_DRIVE_DONE
  3287 1530 88			        DEY
  3288 1531 D1 F3		        CMP     (INBUFF),Y
  3289 1533 F0 17		        BEQ     PREPEND_DRIVE_DONE
  3290
  3291 				        ; Move input buffer pointer back 3 bytes
  3292 1535 38			        SEC
  3293 1536 A5 F3		        LDA     INBUFF
  3294 1538 E9 03		        SBC     #$03
  3295 153A 85 F3		        STA     INBUFF
  3296 153C A5 F4		        LDA     INBUFF+1
  3297 153E E9 00		        SBC     #$00
  3298 1540 85 F4		        STA     INBUFF+1
  3299
  3300 				        ; Inject PRMPT to front of arg1
  3301 1542 A0 03		        LDY     #$03
  3302 1544			PREPEND_DRIVE_LOOP:
  3303 1544 B9 76 15		        LDA     PRMPT,Y
  3304 1547 88			        DEY
  3305 1548 91 F3		        STA     (INBUFF),Y
  3306 154A D0 F8		        BNE     PREPEND_DRIVE_LOOP
  3307
  3308 154C			PREPEND_DRIVE_DONE:
  3309 154C A0 01		        LDY     #$01
  3310 154E 60			        RTS             ; Y = $00 here
  3311
  3312 				;---------------------------------------
  3313 154F			APPEND_SLASH:
  3314 				;---------------------------------------
  3315 				    ;---------------------------------------
  3316 				    ; Skip if relative path (..)
  3317 				    ;---------------------------------------
  3318 154F A0 00		        LDY     #$00
  3319 1551 A9 2E		        LDA     #'.'
  3320 1553 D1 F3		        CMP     (INBUFF),Y
  3321 1555 F0 1E		        BEQ     APPEND_SLASH_DONE
  3322
  3323 1557 A0 FF		        LDY     #$FF        ; Iterate thru arg2 until EOF
  3324 1559			APPEND_SLASH_LOOP:
  3325 1559 C8			        INY                 ; Zero on 1st pass
  3326 155A B1 F3		        LDA     (INBUFF),Y
  3327 155C C9 9B		        CMP     #EOL
  3328 155E D0 F9		        BNE     APPEND_SLASH_LOOP
  3329
  3330 1560 88			        DEY                 ; Move pointer back one character
  3331 1561 B1 F3		        LDA     (INBUFF),Y
  3332 1563 C9 2F		        CMP     #'/'        ; If already slash then skip rest
  3333 1565 F0 0E		        BEQ     APPEND_SLASH_DONE
  3334 1567 C9 3A		        CMP     #':'        ; If a drive, skip
  3335 1569 F0 0A		        BEQ     APPEND_SLASH_DONE
  3336
  3337 156B C8			        INY                 ; Else inject '/' + EOL
  3338 156C A9 2F		        LDA     #'/'
  3339 156E 91 F3		        STA     (INBUFF),Y
  3340 1570 C8			        INY
  3341 1571 A9 9B		        LDA     #EOL
  3342 1573 91 F3		        STA     (INBUFF),Y
  3343
  3344 1575			APPEND_SLASH_DONE:
  3345 1575 60			        RTS
  3346
  3347 1576			PRMPT:
  3348 1576 9B 4E 20 3A		        .BYTE   EOL,'N :'
  3349
  3350 				;;; End CP ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  3351 				;;; Variables
  3352
  3353 157A			        .ENUM   CMD_IDX
  3354 				        ;---------------
  3355 = 0000			                NCD                 ;  0
  3356 = 0001			                COPY                ;  1
  3357 = 0002			                DIR                 ;  2
  3358 = 0003			                DEL                 ;  3
  3359 = 0004			                LOAD                ;  4
  3360 = 0005			                LOCK                ;  5
  3361 = 0006			                LOGIN               ;  6
  3362 = 0007			                MKDIR               ;  7
  3363 = 0008			                NPWD                ;  8
  3364 = 0009			                NTRANS              ;  9
  3365 = 000A			                RENAME              ; 10
  3366 = 000B			                RMDIR               ; 11
  3367 = 000C			                SUBMIT              ; 12
  3368 = 000D			                TYPE                ; 13
  3369 = 000E			                UNLOCK              ; 14
  3370 = 000F			                AUTORUN             ; 15
  3371 = 0010			                CAR                 ; 16
  3372 = 0011			                CLS                 ; 17
  3373 = 0012			                COLD                ; 18
  3374 = 0013			                HELP                ; 19
  3375 = 0014			                NOBASIC             ; 20
  3376 = 0015			                NOSCREEN            ; 21
  3377 = 0016			                PRINT               ; 22
  3378 = 0017			                REENTER             ; 23
  3379 = 0018			                REM                 ; 24
  3380 = 0019			                RUN                 ; 25
  3381 = 001A			                SCREEN              ; 26
  3382 = 001B			                WARM                ; 27
  3383 = 001C			                XEP                 ; 28
  3384 = 001D			                DRIVE_CHG           ; 
  3385 				        .ENDE
  3386
  3387 157A			CMD_DCOMND:
  3388 157A 2C			        .BYTE   CMD_CD              ;  0 NCD
  3389 157B A1			        .BYTE   CMD_COPY            ;  1 COPY
  3390 157C 02			        .BYTE   CMD_DIR             ;  2 DIR
  3391 157D 21			        .BYTE   CMD_DEL             ;  3 DEL
  3392 157E 28			        .BYTE   CMD_LOAD            ;  4 LOAD
  3393 157F FD			        .BYTE   CMD_LOGIN           ;  5 LOAD
  3394 1580 23			        .BYTE   CMD_LOCK            ;  6 LOCK
  3395 1581 2A			        .BYTE   CMD_MKDIR           ;  7 MKDIR
  3396 1582 30			        .BYTE   CMD_NPWD            ;  8 NPWD
  3397 1583 54			        .BYTE   CMD_NTRANS          ;  9 NTRANS
  3398 1584 20			        .BYTE   CMD_RENAME          ; 10 RENAME
  3399 1585 2B			        .BYTE   CMD_RMDIR           ; 11 RMDIR
  3400 1586 F0			        .BYTE   CMD_SUBMIT          ; 12 SUBMIT
  3401 1587 F0			        .BYTE   CMD_TYPE            ; 13 TYPE
  3402 1588 24			        .BYTE   CMD_UNLOCK          ; 14 UNLOCK
  3403 1589 F0			        .BYTE   CMD_AUTORUN         ; 15 AUTORUN
  3404 158A F0			        .BYTE   CMD_CAR             ; 16 CAR
  3405 158B F0			        .BYTE   CMD_CLS             ; 17 CLS
  3406 158C F0			        .BYTE   CMD_COLD            ; 18 COLD
  3407 158D F0			        .BYTE   CMD_HELP            ; 19 HELP
  3408 158E F0			        .BYTE   CMD_NOBASIC         ; 20 NOBASIC
  3409 158F F0			        .BYTE   CMD_NOSCREEN        ; 21 NOSCREEN
  3410 1590 F0			        .BYTE   CMD_PRINT           ; 22 PRINT
  3411 1591 F0			        .BYTE   CMD_REENTER         ; 23 REENTER
  3412 1592 F0			        .BYTE   CMD_REM             ; 24 REM
  3413 1593 F0			        .BYTE   CMD_RUN             ; 25 RUN
  3414 1594 F0			        .BYTE   CMD_SCREEN          ; 26 SCREEN
  3415 1595 F0			        .BYTE   CMD_WARM            ; 27 WARM
  3416 1596 F0			        .BYTE   CMD_XEP             ; 28 XEP
  3417 1597 01			        .BYTE   CMD_DRIVE_CHG       ; 29
  3418
  3419 1598			COMMAND:
  3420 1598 4E 43 C4		        .CB     "NCD"               ;  0 NCD
  3421 159B 00			        .BYTE   CMD_IDX.NCD            
  3422
  3423 159C 43 4F 50 D9		        .CB     "COPY"              ;  1 COPY
  3424 15A0 01			        .BYTE   CMD_IDX.COPY           
  3425
  3426 15A1 44 49 D2		        .CB     "DIR"               ;  2 DIR
  3427 15A4 02			        .BYTE   CMD_IDX.DIR              
  3428
  3429 15A5 44 45 CC		        .CB     "DEL"               ;  3 DEL
  3430 15A8 03			        .BYTE   CMD_IDX.DEL              
  3431
  3432 15A9 4C 4F 41 C4		        .CB     "LOAD"              ;  4 LOAD
  3433 15AD 04			        .BYTE   CMD_IDX.LOAD             
  3434
  3435 15AE 4C 4F 43 CB		        .CB     "LOCK"              ;  5 LOCK
  3436 15B2 05			        .BYTE   CMD_IDX.LOCK             
  3437
  3438 15B3 4C 4F 47 49 CE	        .CB     "LOGIN"             ;  6 LOGIN
  3439 15B8 06			        .BYTE   CMD_IDX.LOGIN              
  3440 				                                        
  3441 15B9 4D 4B 44 49 D2	        .CB     "MKDIR"             ;  7 MKDIR
  3442 15BE 07			        .BYTE   CMD_IDX.MKDIR           
  3443
  3444 15BF 4E 50 57 C4		        .CB     "NPWD"              ;  8 NPWD
  3445 15C3 08			        .BYTE   CMD_IDX.NPWD             
  3446
  3447 15C4 4E 54 52 41 4E D3	        .CB     "NTRANS"            ;  9 NTRANS
  3448 15CA 09			        .BYTE   CMD_IDX.NTRANS            
  3449 				                                        
  3450 15CB 52 45 4E 41 4D C5	        .CB     "RENAME"            ; 10 RENAME
  3451 15D1 0A			        .BYTE   CMD_IDX.RENAME          
  3452 				                                        
  3453 15D2 52 4D 44 49 D2	        .CB     "RMDIR"             ; 11 RMDIR
  3454 15D7 0B			        .BYTE   CMD_IDX.RMDIR           
  3455 				                                        
  3456 15D8 53 55 42 4D 49 D4	        .CB     "SUBMIT"            ; 12 SUBMIT
  3457 15DE 0C			        .BYTE   CMD_IDX.SUBMIT             
  3458 				                                        
  3459 15DF 54 59 50 C5		        .CB     "TYPE"              ; 13 SUBMIT
  3460 15E3 0D			        .BYTE   CMD_IDX.TYPE              
  3461 				                                        
  3462 15E4 55 4E 4C 4F 43 CB	        .CB     "UNLOCK"            ; 14 UNLOCK
  3463 15EA 0E			        .BYTE   CMD_IDX.UNLOCK            
  3464 				                                        
  3465 15EB 41 55 54 4F 52 55 +         .CB     "AUTORUN"           ; 28 AUTORUN
  3466 15F2 0F			        .BYTE   CMD_IDX.AUTORUN
  3467
  3468 15F3 43 41 D2		        .CB     "CAR"               ; 15 CAR
  3469 15F6 10			        .BYTE   CMD_IDX.CAR             
  3470 				                                        
  3471 15F7 43 4C D3		        .CB     "CLS"               ; 16 CLS
  3472 15FA 11			        .BYTE   CMD_IDX.CLS           
  3473
  3474 15FB 43 4F 4C C4		        .CB     "COLD"              ; 17 COLD
  3475 15FF 12			        .BYTE   CMD_IDX.COLD              
  3476
  3477 1600 48 45 4C D0		        .CB     "HELP"              ; 18 HELP
  3478 1604 13			        .BYTE   CMD_IDX.HELP               
  3479 				                                       
  3480 1605 4E 4F 42 41 53 49 +         .CB     "NOBASIC"           ; 19 NOBASIC
  3481 160C 14			        .BYTE   CMD_IDX.NOBASIC           
  3482 				                                          
  3483 160D 40 4E 4F 53 43 52 +         .CB     "@NOSCREEN"         ; 20 @NOSCREEN
  3484 1616 15			        .BYTE   CMD_IDX.NOSCREEN         
  3485 				                                        
  3486 1617 50 52 49 4E D4	        .CB     "PRINT"             ; 21 PRINT
  3487 161C 16			        .BYTE   CMD_IDX.PRINT           
  3488 				                                        
  3489 161D 52 45 45 4E 54 45 +         .CB     "REENTER"           ; 22 REENTER
  3490 1624 17			        .BYTE   CMD_IDX.REENTER         
  3491 				                                        
  3492 1625 52 45 CD		        .CB     "REM"               ; 23 REM
  3493 1628 18			        .BYTE   CMD_IDX.REM             
  3494 				                                        
  3495 1629 52 55 CE		        .CB     "RUN"               ; 24 RUN
  3496 162C 19			        .BYTE   CMD_IDX.RUN             
  3497 				                                        
  3498 162D 40 53 43 52 45 45 +         .CB     "@SCREEN"           ; 25 @SCREEN
  3499 1634 1A			        .BYTE   CMD_IDX.SCREEN          
  3500 				                                        
  3501 1635 57 41 52 CD		        .CB     "WARM"              ; 26 WARM
  3502 1639 1B			        .BYTE   CMD_IDX.WARM            
  3503 				                                        
  3504 163A 58 45 D0		        .CB     "XEP"               ; 27 XEP
  3505 163D 1C			        .BYTE   CMD_IDX.XEP            
  3506 				                                        
  3507 				; Aliases
  3508 163E 43 C4		        .CB     "CD"                ; CD = NCD
  3509 1640 00			        .BYTE   CMD_IDX.NCD           
  3510
  3511 1641 43 57 C4		        .CB     "CWD"               ; CWD = NCD
  3512 1644 00			        .BYTE   CMD_IDX.NCD           
  3513
  3514 1645 45 52 41 53 C5	        .CB     "ERASE"             ; ERASE = DEL
  3515 164A 03			        .BYTE   CMD_IDX.DEL           
  3516
  3517 164B 45 52 C1		        .CB     "ERA"               ; ERA = DEL
  3518 164E 03			        .BYTE   CMD_IDX.DEL           
  3519
  3520 164F D8			        .CB     "X"                 ; X = LOAD
  3521 1650 04			        .BYTE   CMD_IDX.LOAD
  3522
  3523 1651 50 57 C4		        .CB     "PWD"               ; PWD = NPWD
  3524 1654 08			        .BYTE   CMD_IDX.NPWD             
  3525
  3526 1655 52 45 C5		        .CB     "REE"               ; R = REENTER
  3527 1658 17			        .BYTE   CMD_IDX.REENTER             
  3528
  3529 1659 52 45 CE		        .CB     "REN"               ; REN = RENAME
  3530 165C 0A			        .BYTE   CMD_IDX.RENAME
  3531
  3532 165D 53 4F 55 52 43 C5	        .CB     "SOURCE"            ; SOURCE = SUBMIT
  3533 1663 0C			        .BYTE   CMD_IDX.SUBMIT
  3534
  3535 1664 C0			        .CB     "@"                 ; @ = SUBMIT
  3536 1665 0C			        .BYTE   CMD_IDX.SUBMIT
  3537
  3538 1666 A3			        .CB     "#"                 ; # = REM
  3539 1667 18			        .BYTE   CMD_IDX.REM
  3540
  3541 1668 A7			        .CB     "'"                 ; ' = REM
  3542 1669 18			        .BYTE   CMD_IDX.REM
  3543
  3544 				        ; Drive Change intentionally omitted
  3545
  3546 = 00D1			COMMAND_SIZE = * - COMMAND - 1
  3547 166A FF			        .BYTE   $FF
  3548
  3549 166B			CMD_TAB_L:
  3550 166B 4D			        .BYTE   <(DO_GENERIC-1)     ;  0 NCD
  3551 166C BA			        .BYTE   <(DO_COPY-1)        ;  1 COPY
  3552 166D C0			        .BYTE   <(DO_DIR-1)         ;  2 DIR
  3553 166E 4D			        .BYTE   <(DO_GENERIC-1)     ;  3 DEL
  3554 166F AA			        .BYTE   <(DO_LOAD-1)        ;  4 LOAD
  3555 1670 0E			        .BYTE   <(DO_LOCK-1)        ;  5 LOCK
  3556 1671 14			        .BYTE   <(DO_LOGIN-1)       ;  6 LOGIN
  3557 1672 4D			        .BYTE   <(DO_GENERIC-1)     ;  7 MKDIR
  3558 1673 45			        .BYTE   <(DO_NPWD-1)        ;  8 NPWD
  3559 1674 88			        .BYTE   <(DO_NTRANS-1)      ;  9 NTRANS
  3560 1675 4D			        .BYTE   <(DO_GENERIC-1)     ; 10 RENAME
  3561 1676 4D			        .BYTE   <(DO_GENERIC-1)     ; 11 RMDIR
  3562 1677 BB			        .BYTE   <(DO_SUBMIT-1)      ; 12 SUBMIT
  3563 1678 40			        .BYTE   <(DO_TYPE-1)        ; 13 TYPE
  3564 1679 DE			        .BYTE   <(DO_UNLOCK-1)      ; 14 UNLOCK
  3565 167A 0B			        .BYTE   <(DO_AUTORUN-1)     ; 15 AUTORUN
  3566 167B E4			        .BYTE   <(DO_CAR-1)         ; 16 CAR
  3567 167C 0D			        .BYTE   <(DO_CLS-1)         ; 17 CLS
  3568 167D 16			        .BYTE   <(DO_COLD-1)        ; 18 COLD
  3569 167E 19			        .BYTE   <(DO_HELP-1)        ; 19 HELP
  3570 167F C7			        .BYTE   <(DO_NOBASIC-1)     ; 20 NOBASIC
  3571 1680 08			        .BYTE   <(DO_NOSCREEN-1)    ; 21 NOSCREEN
  3572 1681 14			        .BYTE   <(DO_PRINT-1)       ; 22 PRINT
  3573 1682 22			        .BYTE   <(DO_REENTER-1)     ; 23 REENTER
  3574 1683 6C			        .BYTE   <(DO_REM-1)         ; 24 REM
  3575 1684 6D			        .BYTE   <(DO_RUN-1)         ; 25 RUN
  3576 1685 0E			        .BYTE   <(DO_SCREEN-1)      ; 26 SCREEN
  3577 1686 BB			        .BYTE   <(DO_WARM-1)        ; 27 WARM
  3578 1687 BE			        .BYTE   <(DO_XEP-1)         ; 28 WARM
  3579 1688 0C			        .BYTE   <(DO_DRIVE_CHG-1)   ; 29
  3580
  3581 1689			CMD_TAB_H:
  3582 1689 0C			        .BYTE   >(DO_GENERIC-1)     ;  0 NCD
  3583 168A 0C			        .BYTE   >(DO_COPY-1)        ;  1 COPY
  3584 168B 0C			        .BYTE   >(DO_DIR-1)         ;  2 DIR
  3585 168C 0C			        .BYTE   >(DO_GENERIC-1)     ;  3 DEL
  3586 168D 0D			        .BYTE   >(DO_LOAD-1)        ;  4 LOAD
  3587 168E 10			        .BYTE   >(DO_LOCK-1)        ;  5 LOCK
  3588 168F 10			        .BYTE   >(DO_LOGIN-1)       ;  6 LOGIN
  3589 1690 0C			        .BYTE   >(DO_GENERIC-1)     ;  7 MKDIR
  3590 1691 10			        .BYTE   >(DO_NPWD-1)        ;  8 NPWD
  3591 1692 10			        .BYTE   >(DO_NTRANS-1)      ;  9 NTRANS
  3592 1693 0C			        .BYTE   >(DO_GENERIC-1)     ; 10 RENAME
  3593 1694 0C			        .BYTE   >(DO_GENERIC-1)     ; 11 RMDIR
  3594 1695 11			        .BYTE   >(DO_SUBMIT-1)      ; 12 SUBMIT
  3595 1696 12			        .BYTE   >(DO_TYPE-1)        ; 13 TYPE
  3596 1697 12			        .BYTE   >(DO_UNLOCK-1)      ; 14 UNLOCK
  3597 1698 11			        .BYTE   >(DO_AUTORUN-1)     ; 15 AUTORUN
  3598 1699 12			        .BYTE   >(DO_CAR-1)         ; 16 CAR
  3599 169A 13			        .BYTE   >(DO_CLS-1)         ; 17 CLS
  3600 169B 13			        .BYTE   >(DO_COLD-1)        ; 18 COLD
  3601 169C 13			        .BYTE   >(DO_HELP-1)        ; 19 HELP
  3602 169D 13			        .BYTE   >(DO_NOBASIC-1)     ; 20 NOBASIC
  3603 169E 14			        .BYTE   >(DO_NOSCREEN-1)    ; 21 NOSCREEN
  3604 169F 14			        .BYTE   >(DO_PRINT-1)       ; 22 PRINT
  3605 16A0 14			        .BYTE   >(DO_REENTER-1)     ; 23 REENTER
  3606 16A1 14			        .BYTE   >(DO_REM-1)         ; 24 REM
  3607 16A2 14			        .BYTE   >(DO_RUN-1)         ; 25 RUN
  3608 16A3 14			        .BYTE   >(DO_SCREEN-1)      ; 26 SCREEN
  3609 16A4 14			        .BYTE   >(DO_WARM-1)        ; 27 WARM
  3610 16A5 14			        .BYTE   >(DO_XEP-1)         ; 28 WARM
  3611 16A6 0C			        .BYTE   >(DO_DRIVE_CHG-1)   ; 29
  3612
  3613 				        ; DEVHDL TABLE FOR N:
  3614
  3615 16A7 BD 07		CIOHND  .WORD   OPEN-1
  3616 16A9 0B 08		        .WORD   CLOSE-1
  3617 16AB 2C 08		        .WORD   GET-1
  3618 16AD 8D 08		        .WORD   PUT-1
  3619 16AF ED 08		        .WORD   STATUS-1
  3620 16B1 53 09		        .WORD   SPEC-1
  3621
  3622 				       ; BANNERS
  3623
  3624 16B3 23 46 55 4A 49 4E + BREADY  .BYTE   '#FUJINET NOS v0.4.0-alpha',EOL
  3625 16CD 23 46 55 4A 49 4E + BERROR  .BYTE   '#FUJINET ERROR',EOL
  3626
  3627 				        ; MESSAGES
  3628
  3629 16DC 4E 23 3F 9B		CDERR   .BYTE   'N#?',EOL
  3630
  3631 				        ; STRING CONSTANTS
  3632
  3633 16E0			MISSING_FILE_STR:
  3634 16E0 46 49 4C 45 3F 9B	        .BYTE   'FILE?',EOL
  3635
  3636 				        ; VARIABLES
  3637
  3638 16E6 01			DOSDR       .BYTE   $01     ; DOS DRIVE
  3639 16E7 01			CMD         .BYTE   $01
  3640 16E8 01			CMDPRV      .BYTE   $01
  3641 16E9 01			ECHO_FLG    .BYTE   $01     ; Echo batch cmds (1=enabled,0=disabled)
  3642 16EA 00			AUTORUN_FLG .BYTE   $00     ; Checked at DOS entry. Runs only on first pass
  3643
  3644 16EB 01			TRIP    .BYTE   $01         ; INTR FLAG
  3645 16EC 00 00 00 00		RLEN    :MAXDEV .BYTE $00   ; RCV LEN
  3646 16F0 00 00 00 00		ROFF    :MAXDEV .BYTE $00   ; RCV OFFSET
  3647 16F4 00 00 00 00		TOFF    :MAXDEV .BYTE $00   ; TRX OFFSET
  3648 16F8 01			INQDS   .BYTE   $01         ; DSTATS INQ
  3649
  3650 16F9 00 00 00 00		DVS2    :MAXDEV .BYTE $00   ; DVSTAT+2 SAVE
  3651 16FD 00 00 00 00		DVS3    :MAXDEV .BYTE $00   ; DVSTAT+3 SAVE
  3652
  3653 				       ; BUFFERS (PAGE ALIGNED)
  3654 1701 00 00 00 00 00 00 +         .ALIGN  $100, $00
  3655 1800			BOOTEND:
  3656
  3657 1800 00 00 00 00 00 00 + RBUF:   :$80 .BYTE $00      ; 128 bytes
  3658 1880 00 00 00 00 00 00 + TBUF:   :$80 .BYTE $00      ; 128 bytes
  3659
  3660 				; Binary loader working variables
  3661 = 1800			BAL     = RBUF
  3662 = 1801			BAH     = RBUF+1    ;
  3663 = 1880			STL     = TBUF      ; Payload Start address
  3664 = 1881			STH     = TBUF+1
  3665 = 1882			ENL     = TBUF+2    ; Payload End address
  3666 = 1883			ENH     = TBUF+3
  3667 = 1884			BLL     = TBUF+4    ; Payload Buffer Length
  3668 = 1885			BLH     = TBUF+5
  3669 = 1886			HEADL   = TBUF+6    ; Bytes read from existing cache
  3670 = 1887			HEADH   = TBUF+7
  3671 = 1888			BODYL   = TBUF+8    ; Total bytes read in contiguous 512-byte blocks
  3672 = 1889			BODYH   = TBUF+9
  3673 = 188A			TAILL   = TBUF+10   ; Bytes read from last cache
  3674 = 188B			TAILH   = TBUF+11
  3675 = 188C			BODYSZL = TBUF+12   ; # Bytes to read at a time in Body
  3676 = 188D			BODYSZH = TBUF+13
  3677
  3678 = 1900			PGEND   = *
  3679
  3680 				; =================================================================
  3681 				; VTOC and Directory
  3682 				;
  3683
  3684 				; $10 is the added ATR-header
  3685 1900 00 00 00 00 00 00 + :($B390-*+HDR-$10) DTA $00
  3686 BA80			VTOCSTA:
  3687 BA80 02 BD 02		    DTA $02,$BD,$02
  3688 BA83			VTOCEND:
  3689
  3690 				; Fill the remaining bytes of the VTOC sector
  3691 BA83 00 00 00 00 00 00 +     :($80+VTOCSTA-VTOCEND) DTA $00
  3692
  3693 BB00			DIRSTA:
  3694 BB00 60 C3 02 04 00 30 +     DTA $60,$C3,$02,$04,$00,C"0**********"
  3695 BB10 60 C3 02 04 00 31 +     DTA $60,$C3,$02,$04,$00,C"1 FujiNet  "
  3696 BB20 60 C3 02 04 00 32 +     DTA $60,$C3,$02,$04,$00,C"2 Network  "
  3697 BB30 60 C3 02 04 00 33 +     DTA $60,$C3,$02,$04,$00,C"3   OS     "
  3698 BB40 60 C3 02 04 00 34 +     DTA $60,$C3,$02,$04,$00,C"4          "
  3699 BB50 60 C3 02 04 00 35 +     DTA $60,$C3,$02,$04,$00,C"5 v0.4.0   "
  3700 BB60 60 C3 02 04 00 36 +     DTA $60,$C3,$02,$04,$00,C"6  alpha   "
  3701 BB70 60 C3 02 04 00 37 +     DTA $60,$C3,$02,$04,$00,C"7**********"
  3702 BB80 C0			    DTA $C0
  3703 BB81			DIREND:
  3704
  3705 				; Fill the remaining sectors of the directory
  3706 BB81 00 00 00 00 00 00 +     :($400+DIRSTA-DIREND) DTA $00
  3707
  3708 				; Sectors behind directory
  3709 BF00 00 00 00 00 00 00 +     :($80*352) DTA $00
  3710
  3711 				       END
