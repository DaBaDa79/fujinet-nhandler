mads 2.1.0
Source: nos.s
     1 				        ;; nos FujiNet Operating System
     2 				        ;; Compile with MADS
     3
     4 				        ;; Authors: Thomas Cherryhomes
     5 				        ;;   <thom.cherryhomes@gmail.com>
     6
     7 				        ;; Michael Sternberg
     8 				        ;;   <mhsternberg@gmail.com>
     9
    10
    11 				        ;; Optimizations being done by djaybee!
    12 				        ;; Thank you so much!
    13
    14 				        ;; If SYNCALC is defined, then holes for Syncalc are inserted
    15 				;SYNCALC	=	1
    16 				        ;; If SYNCALD is defined, then CLI commands are removed
    17 				;SYNCALD	=	1
    18
    19 = 000A			DOSVEC  =   $0A         ; DOSVEC
    20 = 000C			DOSINI  =   $0C         ; DOSINI
    21
    22 				        ;; CURRENT IOCB IN ZERO PAGE
    23 = 0020			ZIOCB   =   $20         ; ZP IOCB
    24 = 0020			ZICHID  =   ZIOCB       ; ID
    25 = 0021			ZICDNO  =   ZIOCB+1     ; UNIT #
    26 = 0022			ZICCOM  =   ZIOCB+2     ; COMMAND
    27 = 0023			ZICSTA  =   ZIOCB+3     ; STATUS
    28 = 0024			ZICBAL  =   ZIOCB+4     ; BUF ADR LOW
    29 = 0025			ZICBAH  =   ZIOCB+5     ; BUF ADR HIGH
    30 = 0026			ZICPTL  =   ZIOCB+6     ; PUT ADDR L
    31 = 0027			ZICPTH  =   ZIOCB+7     ; PUT ADDR H
    32 = 0028			ZICBLL  =   ZIOCB+8     ; BUF LEN LOW
    33 = 0029			ZICBLH  =   ZIOCB+9     ; BUF LEN HIGH
    34 = 002A			ZICAX1  =   ZIOCB+10    ; AUX 1
    35 = 002B			ZICAX2  =   ZIOCB+11    ; AUX 2
    36 = 002C			ZICAX3  =   ZIOCB+12    ; AUX 3
    37 = 002D			ZICAX4  =   ZIOCB+13    ; AUX 4
    38 = 002E			ZICAX5  =   ZIOCB+14    ; AUX 5
    39 = 002F			ZICAX6  =   ZIOCB+15    ; AUX 6
    40
    41 = 0052			LMARGN  =   $52         ; Left margin
    42 = 00D4			FR0     =   $D4         ; Floating Point register 0 (used during Hex->ASCII conversion)
    43 = 00F2			CIX     =   $F2         ; Inbuff cursor
    44 = 00F3			INBUFF  =   $F3         ; Ptr to input buffer ($0580)
    45
    46 				;---------------------------------------
    47 				; INTERRUPT VECTORS
    48 				; AND OTHER PAGE 2 VARS
    49 				;---------------------------------------
    50
    51 = 0202			VPRCED  =   $0202       ; PROCEED VCTR
    52 = 02C6			COLOR2  =   $02C6       ; MODEF BKG C
    53 = 02E0			RUNAD   =   $02E0       ; RUN ADDRESS
    54 = 02E2			INITAD  =   $02E2       ; INIT ADDRESS
    55 = 02E7			MEMLO   =   $02E7       ; MEM LO
    56 = 02EA			DVSTAT  =   $02EA       ; 4 BYTE STATS
    57
    58 				;---------------------------------------
    59 				; PAGE 3
    60 				; DEVICE CONTROL BLOCK (DCB)
    61 				;---------------------------------------
    62
    63 = 0300			DCB     =   $0300       ; BASE
    64 = 0300			DDEVIC  =   DCB         ; DEVICE #
    65 = 0301			DUNIT   =   DCB+1       ; UNIT #
    66 = 0302			DCOMND  =   DCB+2       ; COMMAND
    67 = 0303			DSTATS  =   DCB+3       ; STATUS/DIR
    68 = 0304			DBUFL   =   DCB+4       ; BUF ADR L
    69 = 0305			DBUFH   =   DCB+5       ; BUF ADR H
    70 = 0306			DTIMLO  =   DCB+6       ; TIMEOUT (S)
    71 = 0307			DRSVD   =   DCB+7       ; NOT USED
    72 = 0308			DBYTL   =   DCB+8       ; BUF LEN L
    73 = 0309			DBYTH   =   DCB+9       ; BUF LEN H
    74 = 030A			DAUXL   =   DCB+10      ; AUX BYTE L
    75 = 030B			DAUXH   =   DCB+11      ; AUX BYTE H
    76
    77 = 031A			HATABS  =   $031A       ; HANDLER TBL
    78
    79 				;---------------------------------------
    80 				; IOCB'S * 8
    81 				;---------------------------------------
    82
    83 = 0340			IOCB    =   $0340       ; IOCB BASE
    84 = 0340			ICHID   =   IOCB        ; ID
    85 = 0341			ICDNO   =   IOCB+1      ; UNIT #
    86 = 0342			ICCOM   =   IOCB+2      ; COMMAND
    87 = 0343			ICSTA   =   IOCB+3      ; STATUS
    88 = 0344			ICBAL   =   IOCB+4      ; BUF ADR LOW
    89 = 0345			ICBAH   =   IOCB+5      ; BUF ADR HIGH
    90 = 0346			ICPTL   =   IOCB+6      ; PUT ADDR L
    91 = 0347			ICPTH   =   IOCB+7      ; PUT ADDR H
    92 = 0348			ICBLL   =   IOCB+8      ; BUF LEN LOW
    93 = 0349			ICBLH   =   IOCB+9      ; BUF LEN HIGH
    94 = 034A			ICAX1   =   IOCB+10     ; AUX 1
    95 = 034B			ICAX2   =   IOCB+11     ; AUX 2
    96 = 034C			ICAX3   =   IOCB+12     ; AUX 3
    97 = 034D			ICAX4   =   IOCB+13     ; AUX 4
    98 = 034E			ICAX5   =   IOCB+14     ; AUX 5
    99 = 034F			ICAX6   =   IOCB+15     ; AUX 6
   100
   101 = 0054			ROWCRS  =   $0054
   102 = 02BB			SCRFLG  =   $02BB       ; Scroll flag
   103 = 02FC			CH      =   $02FC       ; Hardware code for last key pressed
   104 = 02F2			CH1     =   $02F2       ; Prior keyboard character code
   105 = 0582			LNBUF   =   $0582       ; Line Buffer (128 bytes)
   106
   107 				;---------------------------------------
   108 				; HARDWARE REGISTERS
   109 				;---------------------------------------
   110
   111 = D301			PORTB   =   $D301       ; On XL/XE, used to enable/disable BASIC
   112 = D302			PACTL   =   $D302       ; PIA CTRL A
   113
   114 				;---------------------------------------
   115 				; MATH PACK VECTORS
   116 				;---------------------------------------
   117 = D8E6			FASC    =   $D8E6       ; Floating point to ASCII
   118 = D9AA			IFP     =   $D9AA       ; Integer to floating point
   119
   120 				;---------------------------------------
   121 				; OS ROM VECTORS
   122 				;---------------------------------------
   123
   124 = E456			CIOV    =   $E456       ; CIO ENTRY
   125 = E459			SIOV    =   $E459       ; SIO ENTRY
   126 = E474			WARMSV  =   $E474       ; Warmstart entry point
   127 = E477			COLDSV  =   $E477       ; Coldstart entry point
   128
   129 				;---------------------------------------
   130 				; CONSTANTS
   131 				;---------------------------------------
   132
   133 = 0005			GETREC  =   $05         ; CIO CMD TO GET RECORD
   134 = 0009			PUTREC  =   $09         ; CIO CMD TO PUT RECORD
   135 = 000B			PUTCHR  =   $0B         ; CIO CMD TO PUT CHAR
   136
   137 = 0071			DEVIDN  =   $71         ; SIO DEVID
   138 = 0040			DSREAD  =   $40         ; FUJI->ATARI
   139 = 0080			DSWRIT  =   $80         ; ATARI->FUJI
   140 = 0004			MAXDEV  =   4           ; # OF N: DEVS
   141 = 0088			EOF     =   $88         ; ERROR 136
   142
   143 = 009B			EOL     =   $9B         ; EOL CHAR
   144 = 000D			CR      =   $0D         ; Carrige Return
   145 = 000A			LF      =   $0A         ; Linefeed
   146
   147 = 001C			ESC_KEY =   $1C         ; Hardware code for ESC
   148 = 0021			SPC_KEY =   $21         ; Hardware code for SPACE
   149
   150 = 0004			OINPUT  =   $04         ; CIO/SIO direction
   151 = 0008			OOUTPUT =   $08         ; CIO/SIO direction
   152
   153 				; FujiNet SIO command bytes
   154 = 0001			CMD_DRIVE_CHG       = $01
   155 = 002C			CMD_CD              = $2C
   156 = 00A1			CMD_COPY            = $A1
   157 = 0002			CMD_DIR             = $02
   158 = 0021			CMD_DEL             = $21
   159 = 0028			CMD_LOAD            = $28
   160 = 0023			CMD_LOCK            = $23
   161 = 00FD			CMD_LOGIN           = $FD
   162 = 002A			CMD_MKDIR           = $2A
   163 = 0030			CMD_NPWD            = $30
   164 = 0054			CMD_NTRANS          = 'T'
   165 = 00FE			CMD_PASSWD          = $FE
   166 = 0020			CMD_RENAME          = $20
   167 = 002B			CMD_RMDIR           = $2B
   168 = 00F0			CMD_SUBMIT          = $F0
   169 = 00F0			CMD_TYPE            = $F0
   170 = 0024			CMD_UNLOCK          = $24
   171 = 00F0			CMD_CAR             = $F0
   172 = 00F0			CMD_CLS             = $F0
   173 = 00F0			CMD_COLD            = $F0
   174 = 00F0			CMD_HELP            = $F0
   175 = 00F0			CMD_NOBASIC         = $F0
   176 = 00F0			CMD_NOSCREEN        = $F0
   177 = 00F0			CMD_PRINT           = $F0
   178 = 00F0			CMD_REENTER         = $F0
   179 = 00F0			CMD_REM             = $F0
   180 = 00F0			CMD_RUN             = $F0
   181 = 00F0			CMD_SCREEN          = $F0
   182 = 00F0			CMD_WARM            = $F0
   183
   184 				;;; Macros ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   185
   186 				        .MACRO DCBC
   187 				        .LOCAL
   188 				        LDY     #$0C
   189 				?DCBL   LDA     %%1,Y
   190 				        STA     DCB,Y
   191 				        DEY
   192 				        BPL     ?DCBL
   193 				        .ENDL
   194 				        .ENDM
   195
   196 				; ATR Header
   197 					ORG	$6f0
   198 				        OPT     h-
   199 				;        ORG     $0700
   200 06F0 96 02 80 16 80		DTA	$96,$02,$80,$16,$80
   201 06F5 00 00 00 00 00 00 + 	:11 DTA	$00
   202
   203 				;;; Initialization ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   204
   205 				;        ORG     $0700
   206 				;        OPT     h-
   207
   208 0700 00			HDR:    .BYTE   $00                 ; BLFAG: Boot flag equals zero (unused)
   209 0701 1E			        .BYTE   [BOOTEND-HDR]/128   ; BRCNT: Number of consecutive sectors to read
   210 0702 00 07		        .WORD   HDR                 ; BLDADR: Boot sector load address ($700).
   211 0704 C0 E4		        .WORD   $E4C0               ; BIWTARR: Init addr (addr of RTS in ROM)
   212
   213 				;HDR:    .BYTE   $00                 ; BLFAG: Boot flag equals zero (unused)
   214 				;        .BYTE   [PGEND-HDR]/128-2   ; BRCNT: Number of consecutive sectors to read
   215 				;        .WORD   $0700               ; BLDADR: Boot sector load address ($700).
   216 				;        .WORD   $E4C0               ; BIWTARR: Init addr (addr of RTS in ROM)
   217
   218 0706 4C 09 07			JMP	START
   219 				;	ORG	*+$64
   220
   221 				.ifdef SYNCALC
   222 					:($076B-*) DTA $00
   223 				.endif
   224
   225 0709 A5 0C		START:  LDA     DOSINI
   226 070B 8D 27 07		        STA     RESET+1
   227 070E A5 0D		        LDA     DOSINI+1
   228 0710 8D 28 07		        STA     RESET+2
   229
   230 0713 A9 26		        LDA     #<RESET
   231 0715 85 0C		        STA     DOSINI
   232 0717 A9 07		        LDA     #>RESET
   233 0719 85 0D		        STA     DOSINI+1
   234 071B A9 CE		        LDA     #<DOS       ; Point to DOS & CP below
   235 071D 85 0A		        STA     DOSVEC
   236 071F A9 0A		        LDA     #>DOS
   237 0721 85 0B		        STA     DOSVEC+1
   238
   239 0723 4C 39 07		        JMP     ALTMEML     ; Alter MEMLO
   240
   241 0726 20 FF FF		RESET:  JSR     $FFFF       ; Jump to extant DOSINI
   242
   243 0729 A9 4E		        LDA     #'N'
   244 072B 8D 00 16		        STA     RBUF
   245 072E 20 44 07		        JSR     IHTBS       ; Insert into HATABS
   246
   247 0731 A9 44		        LDA     #'D'
   248 0733 8D 00 16		        STA     RBUF
   249 0736 20 44 07		        JSR     IHTBS       ; Clone N: as D: for compatibility
   250
   251 				;---------------------------------------
   252 				;  Alter MEMLO
   253 				;---------------------------------------
   254 0739			ALTMEML:
   255 0739 A9 00		        LDA     #<PGEND
   256 073B 8D E7 02		        STA     MEMLO
   257 073E A9 17		        LDA     #>PGEND
   258 0740 8D E8 02		        STA     MEMLO+1
   259
   260 				        ;; Back to DOS
   261
   262 0743 60			        RTS
   263
   264 				;---------------------------------------
   265 				; Insert entry into HATABS
   266 				;---------------------------------------
   267
   268 0744			IHTBS:
   269 0744 A0 00		        LDY     #$00
   270 0746 B9 1A 03		IH1     LDA     HATABS,Y
   271 0749 F0 0C		        BEQ     HFND
   272 				        ;CMP     #'N'
   273 074B CD 00 16		        CMP     RBUF
   274 074E F0 07		        BEQ     HFND
   275 0750 C8			        INY
   276 0751 C8			        INY
   277 0752 C8			        INY
   278 0753 C0 21		        CPY     #11*3
   279 0755 90 EF		        BCC     IH1
   280
   281 				        ;; Found a slot
   282
   283 0757			HFND:
   284 				        ;LDA     #'N'
   285 				;--
   286 0757 AD 00 16		        LDA     RBUF
   287 075A AA			        TAX
   288 				;--
   289 075B 99 1A 03		        STA     HATABS,Y
   290 075E A9 80		        LDA     #<CIOHND
   291 0760 99 1B 03		        STA     HATABS+1,Y
   292 0763 A9 15		        LDA     #>CIOHND
   293 0765 99 1C 03		        STA     HATABS+2,Y
   294
   295 0768 E0 44		        CPX     #'D'
   296 076A F0 01		        BEQ     HATABS_CONT
   297 076C 60			        RTS
   298
   299 076D			HATABS_CONT:
   300 				        ;; And we're done with HATABS
   301
   302 				        ;; Query FUJINET
   303
   304 076D 20 24 09		        JSR     STPOLL
   305
   306 				        ;; Output Ready/Error
   307
   308 0770			OBANR:
   309 0770 A2 00		        LDX     #$00        ; IOCB #0
   310 0772 A9 09		        LDA     #PUTREC
   311 0774 9D 42 03		        STA     ICCOM,X
   312 0777 A9 28		        LDA     #$28        ; 40 CHARS Max
   313 0779 9D 48 03		        STA     ICBLL,X
   314 077C 8A			        TXA
   315 077D 9D 49 03		        STA     ICBLH,X
   316 0780 AD 03 03		        LDA     DSTATS      ; Check DSTATS
   317 0783 10 06		        BPL     OBRDY       ; < 128 = Ready
   318
   319 				        ;; Status returned error.
   320
   321 0785			OBERR:
   322 0785 A9 A6		        LDA     #<BERROR
   323 0787 A0 15		        LDY     #>BERROR
   324 0789 50 04		        BVC     OBCIO
   325
   326 				        ;; Status returned ready.
   327
   328 078B			OBRDY:
   329 078B A9 8C		        LDA     #<BREADY
   330 078D A0 15		        LDY     #>BREADY
   331
   332 078F			OBCIO:
   333 078F 9D 44 03		        STA     ICBAL,X
   334 0792 98			        TYA
   335 0793 9D 45 03		        STA     ICBAH,X
   336
   337 0796 20 56 E4		        JSR     CIOV
   338
   339 				        ;; Vector in proceed interrupt
   340
   341 0799			SPRCED:
   342 0799 A9 5D		        LDA     #<PRCVEC
   343 079B 8D 02 02		        STA     VPRCED
   344 079E A9 0A		        LDA     #>PRCVEC
   345 07A0 8D 03 02		        STA     VPRCED+1
   346
   347 				        ;; And we are done, back to DOS.
   348 07A3 18			        CLC
   349 07A4 60			        RTS
   350
   351 				;;; End Initialization Code ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   352
   353 				; Copy command's template DCB struct to OS's DCB struct (12 bytes)
   354 07A5			DOSIOV:
   355 07A5 8D AE 07		        STA     DODCBL+1
   356 07A8 8C AF 07		        STY     DODCBL+2
   357 07AB A0 0C		        LDY     #$0C
   358 07AD B9 FF FF		DODCBL  LDA     $FFFF,Y
   359 07B0 99 00 03		        STA     DCB,Y
   360 07B3 88			        DEY
   361 07B4 10 F7		        BPL     DODCBL
   362
   363 07B6			SIOVDST:
   364 07B6 20 59 E4		        JSR     SIOV
   365 07B9 AC 03 03		        LDY     DSTATS
   366 07BC 98			        TYA
   367 07BD 60			        RTS
   368
   369
   370 				;---------------------------------------
   371 				; CIO OPEN
   372 				;---------------------------------------
   373
   374 07BE			OPEN:
   375 				        ;; Prepare DCB
   376
   377 07BE 20 59 0A		        JSR     GDIDX       ; Get Device ID in X (0-3)
   378 07C1 A5 21		        LDA     ZICDNO      ; IOCB UNIT # (1-4)
   379 07C3 8D 01 08		        STA     OPNDCB+1    ; Store in DUNIT
   380 07C6 A5 24		        LDA     ZICBAL      ; Get filename buffer
   381 07C8 8D 04 08		        STA     OPNDCB+4    ; stuff in DBUF
   382 07CB A5 25		        LDA     ZICBAH      ; ...
   383 07CD 8D 05 08		        STA     OPNDCB+5    ; ...
   384 07D0 A5 2A		        LDA     ZICAX1      ; Get desired AUX1/AUX2
   385 07D2 8D 0A 08		        STA     OPNDCB+10   ; Save them, and store in DAUX1/DAUX2
   386 07D5 A5 2B		        LDA     ZICAX2      ; ...
   387 07D7 8D 0B 08		        STA     OPNDCB+11   ; ...
   388
   389 				        ;;  Copy DCB template to DCB
   390
   391 07DA A9 00		        LDA     #<OPNDCB
   392 07DC A0 08		        LDY     #>OPNDCB
   393
   394 				        ;;  Send to #FujiNet
   395
   396 07DE 20 A5 07		        JSR     DOSIOV
   397
   398 				        ;; Return DSTATS, unless 144, then get extended error
   399
   400 07E1			OPCERR:
   401 07E1 C0 90		        CPY     #$90        ; ERR 144?
   402 07E3 D0 06		        BNE     OPDONE      ; NOPE. RETURN DSTATS
   403
   404 				        ;; 144 - get extended error
   405
   406 07E5 20 24 09		        JSR     STPOLL      ; POLL FOR STATUS
   407 07E8 AC ED 02		        LDY     DVSTAT+3
   408
   409 				       ; RESET BUFFER LENGTH + OFFSET
   410
   411 07EB			OPDONE:
   412 07EB A9 01		        LDA     #$01
   413 07ED 8D C3 15		        STA     TRIP
   414 07F0 20 59 0A		        JSR     GDIDX
   415 07F3 A9 00		        LDA     #$00
   416 07F5 9D C4 15		        STA     RLEN,X
   417 07F8 9D CC 15		        STA     TOFF,X
   418 07FB 9D C8 15		        STA     ROFF,X
   419 07FE 98			        TYA
   420 07FF 60			        RTS                ; AY = ERROR
   421
   422 0800			OPNDCB:
   423 0800 71			        .BYTE   DEVIDN  ; DDEVIC
   424 0801 FF			        .BYTE   $FF     ; DUNIT
   425 0802 4F			        .BYTE   'O'     ; DCOMND
   426 0803 80			        .BYTE   $80     ; DSTATS
   427 0804 FF			        .BYTE   $FF     ; DBUFL
   428 0805 FF			        .BYTE   $FF     ; DBUFH
   429 0806 0F			        .BYTE   $0F     ; DTIMLO
   430 0807 00			        .BYTE   $00     ; DRESVD
   431 0808 00			        .BYTE   $00     ; DBYTL
   432 0809 01			        .BYTE   $01     ; DBYTH
   433 080A FF			        .BYTE   $FF     ; DAUX1
   434 080B FF			        .BYTE   $FF     ; DAUX2
   435
   436 				; End CIO OPEN
   437 				;---------------------------------------
   438
   439 				;---------------------------------------
   440 				; CIO CLOSE 
   441 				;---------------------------------------
   442
   443 080C			CLOSE:
   444 080C 20 50 0A		        JSR     DIPRCD      ; Disable Interrupts
   445 080F 20 59 0A		        JSR     GDIDX
   446 0812 20 AF 08		        JSR     PFLUSH      ; Do a Put Flush if needed.
   447
   448 0815 A5 21		        LDA     ZICDNO      ; IOCB Unit #
   449 0817 8D 22 08		        STA     CLODCB+1    ; to DCB...
   450
   451 081A A9 21		        LDA     #<CLODCB
   452 081C A0 08		        LDY     #>CLODCB
   453
   454 081E 4C A5 07		        JMP     DOSIOV
   455
   456 0821 71			CLODCB .BYTE    DEVIDN      ; DDEVIC
   457 0822 FF			       .BYTE    $FF         ; DUNIT
   458 0823 43			       .BYTE    'C'         ; DCOMND
   459 0824 00			       .BYTE    $00         ; DSTATS
   460 0825 00			       .BYTE    $00         ; DBUFL
   461 0826 00			       .BYTE    $00         ; DBUFH
   462 0827 0F			       .BYTE    $0F         ; DTIMLO
   463 0828 00			       .BYTE    $00         ; DRESVD
   464 0829 00			       .BYTE    $00         ; DBYTL
   465 082A 00			       .BYTE    $00         ; DBYTH
   466 082B 00			       .BYTE    $00         ; DAUX1
   467 082C 00			       .BYTE    $00         ; DAUX2
   468
   469 				; End CIO CLOSE
   470 				;---------------------------------------
   471
   472 				;---------------------------------------
   473 				; CIO GET
   474 				;---------------------------------------
   475
   476 082D 20 59 0A		GET:    JSR     GDIDX       ; IOCB UNIT #-1 into X
   477 0830 BD C4 15		        LDA     RLEN,X      ; Get # of RX chars waiting
   478 0833 D0 2B		        BNE     GETDISC     ; LEN > 0?
   479
   480 				        ;; If RX buffer is empty, get # of chars waiting...
   481
   482 0835 20 24 09		        JSR     STPOLL      ; Status Poll
   483 0838 20 59 0A		        JSR     GDIDX       ; IOCB UNIT -1 into X (because Poll trashes X)
   484 083B AD EA 02		        LDA     DVSTAT      ; # of bytes waiting (0-127)
   485 083E 9D C4 15		        STA     RLEN,X      ; Store in RX Len
   486 0841 F0 22		        BEQ     RETEOF
   487
   488 0843 A5 21		GETDO:  LDA     ZICDNO      ; Get IOCB UNIT #
   489 0845 8D 83 08		        STA     GETDCB+1    ; Store into DUNIT
   490 0848 AD EA 02		        LDA     DVSTAT      ; # of bytes waiting
   491 084B 8D 8A 08		        STA     GETDCB+8    ; Store into DBYT...
   492 084E 8D 8C 08		        STA     GETDCB+10   ; and DAUX1...
   493
   494 0851 A9 82		        LDA     #<GETDCB
   495 0853 A0 08		        LDY     #>GETDCB
   496
   497 0855 20 A5 07		        JSR     DOSIOV
   498
   499 				        ;; Clear the Receive buffer offset.
   500
   501 0858 20 59 0A		        JSR     GDIDX       ; IOCB UNIT #-1 into X
   502 085B A9 00		        LDA     #$00
   503 085D 9D C8 15		        STA     ROFF,X
   504
   505 0860			GETDISC:
   506 				        ;LDA     DVSTAT+2    ; Did we disconnect?
   507 0860 AD ED 02		        LDA     DVSTAT+3    ; Did we disconnect?
   508 0863 D0 04		        BNE     GETUPDP     ; nope, update the buffer cursor.
   509
   510 				        ;; We disconnected, emit an EOF.
   511
   512 0865			RETEOF:
   513 0865 A0 88		        LDY     #EOF
   514 0867 98			        TYA
   515 0868 60			        RTS                 ; buh-bye.
   516
   517 0869			GETUPDP:
   518 0869 DE C4 15		        DEC     RLEN,X      ; Decrement RX length.
   519 086C BC C8 15		        LDY     ROFF,X      ; Get RX offset cursor.
   520
   521 				        ;; Return Next char from appropriate RX buffer.
   522
   523 086F B9 00 16		        LDA     RBUF,Y
   524
   525 				        ;; Increment RX offset
   526
   527 0872 FE C8 15		GX:     INC     ROFF,X      ; Increment RX offset.
   528 0875 A8			        TAY                 ; stuff returned val into Y temporarily.
   529
   530 				        ;; If requested RX buffer is empty, reset TRIP.
   531
   532 0876 BD C4 15		        LDA     RLEN,X
   533 0879 D0 03		        BNE     GETDONE
   534 087B 8D C3 15		        STA     TRIP
   535
   536 				        ;; Return byte back to CIO.
   537
   538 087E			GETDONE:
   539 087E 98			        TYA                 ; Move returned val back.
   540 087F A0 01		        LDY     #$01        ; SUCCESS
   541
   542 0881 60			        RTS                 ; DONE...
   543
   544 0882			GETDCB:
   545 0882 71			       .BYTE    DEVIDN      ; DDEVIC
   546 0883 FF			       .BYTE    $FF         ; DUNIT
   547 0884 52			       .BYTE    'R'         ; DCOMND
   548 0885 40			       .BYTE    $40         ; DSTATS
   549 0886 00			       .BYTE    <RBUF       ; DBUFL
   550 0887 16			       .BYTE    >RBUF       ; DBUFH
   551 0888 0F			       .BYTE    $0F         ; DTIMLO
   552 0889 00			       .BYTE    $00         ; DRESVD
   553 088A FF			       .BYTE    $FF         ; DBYTL
   554 088B 00			       .BYTE    $00         ; DBYTH
   555 088C FF			       .BYTE    $FF         ; DAUX1
   556 088D 00			       .BYTE    $00         ; DAUX2
   557
   558 				; End CIO GET
   559 				;---------------------------------------
   560
   561 				;---------------------------------------
   562 				; CIO PUT
   563 				;---------------------------------------
   564
   565 088E			PUT:    ;; Add to TX buffer.
   566
   567 088E 20 59 0A		        JSR     GDIDX
   568 0891 BC CC 15		        LDY     TOFF,X      ; GET TX cursor.
   569 0894 99 80 16		        STA     TBUF,Y      ; TX Buffer
   570
   571 0897 FE CC 15		POFF:   INC     TOFF,X      ; Increment TX cursor
   572 089A A0 01		        LDY     #$01        ; SUCCESSFUL
   573
   574 				        ;; Do a PUT FLUSH if EOL or buffer full.
   575
   576 089C C9 9B		        CMP     #EOL        ; EOL?
   577 089E F0 0B		        BEQ     FLUSH       ; FLUSH BUFFER
   578 08A0 20 59 0A		        JSR     GDIDX       ; GET OFFSET
   579 08A3 BD CC 15		        LDA     TOFF,X
   580 08A6 C9 7F		        CMP     #$7F        ; LEN = $FF?
   581 08A8 F0 01		        BEQ     FLUSH       ; FLUSH BUFFER
   582 08AA 60			        RTS
   583
   584 				       ; FLUSH BUFFER, IF ASKED.
   585
   586 08AB 20 AF 08		FLUSH:  JSR     PFLUSH      ; FLUSH BUFFER
   587 08AE 60			        RTS
   588
   589 08AF			PFLUSH:
   590
   591 				       ; CHECK CONNECTION, AND EOF
   592 				       ; IF DISCONNECTED.
   593
   594 08AF 20 24 09		        JSR     STPOLL      ; GET STATUS
   595 08B2 AD ED 02		        LDA     DVSTAT+3
   596 08B5 F0 AE		        BEQ     RETEOF
   597
   598 08B7 20 59 0A		PF1:    JSR     GDIDX       ; GET DEV X
   599 08BA BD CC 15		        LDA     TOFF,X
   600 08BD D0 03		        BNE     PF2
   601 08BF 4C DF 08		        JMP     PDONE
   602
   603 				       ; FILL OUT DCB FOR PUT FLUSH
   604
   605 08C2 A5 21		PF2:    LDA     ZICDNO
   606 08C4 8D E3 08		        STA     PUTDCB+1
   607
   608 				       ; FINISH DCB AND DO SIOV
   609
   610 08C7 BD CC 15		TBX:    LDA     TOFF,X
   611 08CA 8D EA 08		        STA     PUTDCB+8
   612 08CD 8D EC 08		        STA     PUTDCB+10
   613
   614 08D0 A9 E2		        LDA     #<PUTDCB
   615 08D2 A0 08		        LDY     #>PUTDCB
   616 08D4 20 A5 07		        JSR     DOSIOV
   617
   618 				        ; CLEAR THE OFFSET CURSOR
   619 				        ; AND LENGTH
   620
   621 08D7 20 59 0A		        JSR     GDIDX
   622 08DA A9 00		        LDA     #$00
   623 08DC 9D CC 15		        STA     TOFF,X
   624
   625 08DF A0 01		PDONE:  LDY     #$01
   626 08E1 60			        RTS
   627
   628 08E2 71			PUTDCB .BYTE    DEVIDN      ; DDEVIC
   629 08E3 FF			       .BYTE    $FF         ; DUNIT
   630 08E4 57			       .BYTE    'W'         ; DCOMND
   631 08E5 80			       .BYTE    $80         ; DSTATS
   632 08E6 80			       .BYTE    $80         ; DBUFL
   633 08E7 16			       .BYTE    >TBUF       ; DBUFH
   634 08E8 0F			       .BYTE    $0F         ; DTIMLO
   635 08E9 00			       .BYTE    $00         ; DRESVD
   636 08EA FF			       .BYTE    $FF         ; DBYTL
   637 08EB 00			       .BYTE    $00         ; DBYTH
   638 08EC FF			       .BYTE    $FF         ; DAUX1
   639 08ED 00			       .BYTE    $00         ; DAUX2
   640
   641 				; End CIO PUT
   642 				;---------------------------------------
   643
   644 				;---------------------------------------
   645 				; CIO STATUS 
   646 				;---------------------------------------
   647
   648 08EE 20 47 0A		STATUS: JSR     ENPRCD      ; ENABLE PRCD
   649 08F1 20 59 0A		        JSR     GDIDX       ; GET DEVICE#
   650 08F4 BD C4 15		        LDA     RLEN,X      ; GET RLEN
   651 08F7 D0 05		        BNE     STSLEN      ; RLEN > 0?
   652 08F9 AD C3 15		        LDA     TRIP
   653 08FC D0 15		        BNE     STTRI1      ; TRIP = 1?
   654
   655 				        ; NO TRIP, RETURN SAVED LEN
   656
   657 08FE BD C4 15		STSLEN: LDA     RLEN,X      ; GET RLEN
   658 0901 8D EA 02		        STA     DVSTAT      ; RET IN DVSTAT
   659
   660 				        ; If you don't need to preserve Y then use it instead of A
   661 0904 A9 00		        LDA     #$00
   662 0906 8D EB 02		        STA     DVSTAT+1
   663
   664 				        ; and INY here
   665 0909 A9 01		        LDA     #$01
   666 090B 8D EC 02		        STA     DVSTAT+2
   667 090E 8D ED 02		        STA     DVSTAT+3
   668
   669 0911 D0 0B		        BNE     STDONE
   670
   671 				        ; DO POLL AND UPDATE RCV LEN
   672
   673 0913 20 24 09		STTRI1: JSR     STPOLL      ; POLL FOR ST
   674 0916 9D C4 15		        STA     RLEN,X
   675
   676 				        ; UPDATE TRIP FLAG
   677
   678 0919 D0 03		STTRIU: BNE     STDONE
   679 091B 8D C3 15		        STA     TRIP        ; RLEN = 0
   680
   681 				        ; RETURN CONNECTED? FLAG.
   682
   683 091E AD EC 02		STDONE: LDA     DVSTAT+2
   684 0921 A0 01		        LDY     #$01
   685 0923 60			        RTS
   686
   687 				       ; ASK FUJINET FOR STATUS
   688
   689 0924			STPOLL:
   690 0924 A5 21		        LDA     ZICDNO      ; IOCB #
   691 0926 8D 49 09		        STA     STADCB+1
   692
   693 0929 A9 48		        LDA     #<STADCB
   694 092B A0 09		        LDY     #>STADCB
   695
   696 092D 20 A5 07		        JSR     DOSIOV
   697
   698 				        ;; > 127 bytes? make it 127 bytes.
   699
   700 0930 AD EB 02		        LDA     DVSTAT+1
   701 0933 D0 07		        BNE     STADJ
   702 0935 AD EA 02		        LDA     DVSTAT
   703 0938 30 02		        BMI     STADJ
   704 093A 50 08		        BVC     STP2        ; <= 127 bytes...
   705
   706 093C A9 7F		STADJ   LDA     #$7F
   707 093E 8D EA 02		        STA     DVSTAT
   708 				        
   709 0941 8D EB 02		        STA     DVSTAT+1
   710
   711 				       ; A = CONNECTION STATUS
   712
   713 0944 AD EC 02		STP2:   LDA     DVSTAT+2
   714 0947 60			        RTS
   715
   716 0948 71			STADCB: .BYTE   DEVIDN      ; DDEVIC
   717 0949 FF			        .BYTE   $FF         ; DUNIT
   718 094A 53			        .BYTE   'S'         ; DCOMND
   719 094B 40			        .BYTE   $40         ; DSTATS
   720 094C EA			        .BYTE   <DVSTAT     ; DBUFL
   721 094D 02			        .BYTE   >DVSTAT     ; DBUFH
   722 094E 0F			        .BYTE   $0F         ; DTIMLO
   723 094F 00			        .BYTE   $00         ; DRESVD
   724 0950 04			        .BYTE   $04         ; DBYTL
   725 0951 00			        .BYTE   $00         ; DBYTH
   726 0952 00			        .BYTE   $00         ; DAUX1
   727 0953 00			        .BYTE   $00         ; DAUX2
   728
   729 				; End CIO STATUS
   730 				;---------------------------------------
   731
   732 				;---------------------------------------
   733 				; CIO SPECIAL
   734 				;---------------------------------------
   735
   736 0954			SPEC:   ; HANDLE LOCAL COMMANDS.
   737
   738 0954 A5 22		        LDA     ZICCOM
   739 0956 C9 0F		        CMP     #$0F        ; 15 = FLUSH
   740 0958 D0 06		        BNE     S1          ; NO.
   741 095A 20 AF 08		        JSR     PFLUSH      ; DO FLUSH
   742 095D A0 01		        LDY     #$01        ; SUCCESS
   743 095F 60			        RTS
   744
   745 0960 C9 28		S1:     CMP     #40         ; 40 = LOAD AND EXECUTE
   746 0962 F0 03		        BEQ     S2          ; YES.
   747 0964 4C 68 09		        JMP     S3          ; NO. SKIP OVER spec40
   748
   749 0967 60			S2:     RTS
   750 				       ; HANDLE SIO COMMANDS.
   751 				       ; GET DSTATS FOR COMMAND
   752 0968			S3:
   753 0968 A5 21		        LDA     ZICDNO
   754 096A 8D B0 09		        STA     SPEDCB+1
   755 096D A5 22		        LDA     ZICCOM
   756 096F 8D B9 09		        STA     SPEDCB+10
   757
   758 0972 A9 AF		        LDA     #<SPEDCB
   759 0974 A0 09		        LDY     #>SPEDCB
   760 0976 20 A5 07		        JSR     DOSIOV
   761
   762 0979 30 0A		        BMI     :DSERR
   763
   764 				       ; WE GOT A DSTATS INQUIRY
   765 				       ; IF $FF, THE COMMAND IS
   766 				       ; INVALID
   767
   768 097B AD D0 15		DSOK:   LDA     INQDS
   769 097E C9 FF		        CMP     #$FF        ; INVALID?
   770 0980 D0 04		        BNE     DSGO        ; DO THE CMD
   771 0982 A0 92		        LDY     #$92        ; UNIMP CMD
   772 0984 98			        TYA
   773 0985			DSERR:
   774 0985 60			        RTS
   775
   776 				        ;; Do the special, since we want to pass in all the IOCB
   777 				        ;; Parameters to the DCB, This is being done long-hand.
   778
   779 0986 A5 22		DSGO:   LDA     ZICCOM
   780 0988 48			        PHA
   781 0989 A9 00		        LDA     #$00
   782 098B 48			        PHA
   783 098C AD D0 15		        LDA     INQDS
   784 098F 48			        PHA
   785 0990 A9 01		        LDA     #$01
   786 0992 48			        PHA
   787 0993 A5 24		        LDA     ZICBAL
   788 0995 48			        PHA
   789 0996 A5 2A		        LDA     ZICAX1
   790 0998 48			        PHA
   791 0999 A5 25		        LDA     ZICBAH
   792 099B 48			        PHA
   793 099C A5 2B		        LDA     ZICAX2
   794 099E 48			        PHA
   795 099F A0 03		        LDY     #$03
   796 09A1			DSGOL:
   797 09A1 68			        PLA
   798 09A2 99 08 03		        STA     DBYTL,Y
   799 09A5 68			        PLA
   800 09A6 99 02 03		        STA     DCOMND,Y
   801 09A9 88			        DEY
   802 09AA 10 F5		        BPL     DSGOL
   803
   804 09AC 4C B6 07		        JMP     SIOVDST
   805
   806 				        ;; Return DSTATS in Y and A
   807
   808 09AF 71			SPEDCB  .BYTE   DEVIDN      ; DDEVIC
   809 09B0 FF			        .BYTE   $FF         ; DUNIT
   810 09B1 FF			        .BYTE   $FF         ; DCOMND ; inq
   811 09B2 40			        .BYTE   $40         ; DSTATS
   812 09B3 D0			        .BYTE   <INQDS      ; DBUFL
   813 09B4 15			        .BYTE   >INQDS      ; DBUFH
   814 09B5 0F			        .BYTE   $0F         ; DTIMLO
   815 09B6 00			        .BYTE   $00         ; DRESVD
   816 09B7 01			        .BYTE   $01         ; DBYTL
   817 09B8 00			        .BYTE   $00         ; DBYTH
   818 09B9 FF			        .BYTE   $FF         ; DAUX1
   819 09BA FF			        .BYTE   $FF         ; DAUX2
   820
   821 				; End CIO SPECIAL
   822 				;---------------------------------------
   823
   824 				.ifdef SYNCALC
   825 					:($0ABD-*) DTA $00
   826 				.endif
   827
   828 				;#######################################
   829 				;#                                     #
   830 				;#             CIO Functions           # 
   831 				;#                                     #
   832 				;#######################################
   833
   834
   835 				;---------------------------------------
   836 09BB			CIOCLOSE:
   837 				;---------------------------------------
   838 				    ; X must contain IOCB offset ($10,$20,..)
   839 09BB A9 0C		        LDA     #$0C            ; Close #1 first
   840 09BD 9D 42 03		        STA     ICCOM,X
   841 09C0 4C 56 E4		        JMP     CIOV
   842
   843 				;---------------------------------------
   844 09C3			CIOOPEN:
   845 				;---------------------------------------
   846 				    ; Input: 
   847 				    ; X = IOCB offset ($10,$20,..)
   848 				    ; Y = data direction (4=inp,8=out,12=i/o)
   849 				    ; INBUFF contains ICBAL/H
   850 09C3 A9 03		        LDA     #$03            ; 3 = CIO 'OPEN FILE'
   851 09C5 9D 42 03		        STA     ICCOM,X
   852 09C8 A5 F3		        LDA     INBUFF          ; Pointer to filename
   853 09CA 9D 44 03		        STA     ICBAL,X
   854 09CD A5 F4		        LDA     INBUFF+1        ; Pointer to filename
   855 09CF 9D 45 03		        STA     ICBAH,X
   856 09D2 98			        TYA
   857 09D3 9D 4A 03		        STA     ICAX1,X         ; Data direction
   858 09D6 A9 00		        LDA     #$00
   859 09D8 9D 4B 03		        STA     ICAX2,X         ; Unused
   860 09DB 20 56 E4		        JSR     CIOV            ; Call CIO
   861
   862 09DE			CIOOPEN_DONE:
   863 09DE 60			        RTS
   864
   865 				;---------------------------------------
   866 09DF			CIOSTATUS:
   867 				;---------------------------------------
   868 09DF A9 0D		        LDA     #$0D
   869 09E1 9D 42 03		        STA     ICCOM,X
   870 09E4 20 56 E4		        JSR     CIOV
   871 09E7 10 03		        BPL     CIOSTATUS_DONE
   872 09E9 20 96 0A		        JSR     PRINT_ERROR
   873
   874 09EC			CIOSTATUS_DONE:
   875 09EC 60			        RTS
   876 				        
   877
   878 				;---------------------------------------
   879 09ED			CIOGET:
   880 				;---------------------------------------
   881 				    ; Input: 
   882 				    ; X = IOCB offset ($10,$20,..)
   883 				    ; A = ICBLL
   884 				    ; Y = ICBLH
   885 				    ; INBUFF contains ICBAL/H
   886 09ED 48			        PHA                 ; Stash Buffer length Lo
   887 09EE A9 07		        LDA     #$07        ; GET BYTES command
   888 09F0 9D 42 03		        STA     ICCOM,X
   889 09F3 A5 F3		        LDA     INBUFF      ; Get buffer addr from pointer
   890 09F5 9D 44 03		        STA     ICBAL,X
   891 09F8 A5 F4		        LDA     INBUFF+1
   892 09FA 9D 45 03		        STA     ICBAH,X
   893 09FD 68			        PLA                 ; Retrieve Buffer length Lo
   894 09FE 9D 48 03		        STA     ICBLL,X
   895 0A01 98			        TYA                 ; Get Buffer length Hi
   896 0A02 9D 49 03		        STA     ICBLH,X
   897 0A05 20 56 E4		        JSR     CIOV        ; Bon voyage
   898 0A08 10 00		        BPL     CIOGET_DONE
   899 				;        JMP     PRINT_ERROR
   900
   901 0A0A			CIOGET_DONE:
   902 0A0A 60			        RTS
   903
   904 				;---------------------------------------
   905 0A0B			CIOPUT:
   906 				;---------------------------------------
   907 				    ; Input: 
   908 				    ; X = IOCB offset ($10,$20,..)
   909 				    ; A = ICBLL
   910 				    ; Y = ICBLH
   911 				    ; INBUFF contains ICBAL/H
   912 0A0B 48			        PHA                 ; Stash Buffer length Lo
   913 0A0C A9 0B		        LDA     #$0B        ; PUT BYTES command
   914 0A0E 9D 42 03		        STA     ICCOM,X
   915 0A11 A5 F3		        LDA     INBUFF      ; Get buffer addr from pointer
   916 0A13 9D 44 03		        STA     ICBAL,X
   917 0A16 A5 F4		        LDA     INBUFF+1
   918 0A18 9D 45 03		        STA     ICBAH,X
   919 0A1B 68			        PLA                 ; Retrieve Buffer length Lo
   920 0A1C 9D 48 03		        STA     ICBLL,X
   921 0A1F 98			        TYA                 ; Get Buffer length Hi
   922 0A20 9D 49 03		        STA     ICBLH,X
   923 0A23 20 56 E4		        JSR     CIOV        ; Bon voyage
   924 0A26 10 00		        BPL     CIOPUT_DONE
   925 				;        JMP     PRINT_ERROR
   926
   927 0A28			CIOPUT_DONE:
   928 0A28 60			        RTS
   929
   930 				;---------------------------------------
   931 0A29			CIOGETREC:
   932 				;---------------------------------------
   933 				    ; Input: 
   934 				    ; X = IOCB offset ($10,$20,..)
   935 				    ; A = ICBLL
   936 				    ; Y = ICBLH
   937 				    ; INBUFF contains ICBAL/H
   938 0A29 48			        PHA                 ; Stash Buffer length Lo
   939 0A2A A9 05		        LDA     #$05        ; GET RECORD command
   940 0A2C 9D 42 03		        STA     ICCOM,X
   941 0A2F A5 F3		        LDA     INBUFF      ; Get buffer addr from pointer
   942 0A31 9D 44 03		        STA     ICBAL,X
   943 0A34 A5 F4		        LDA     INBUFF+1
   944 0A36 9D 45 03		        STA     ICBAH,X
   945 0A39 68			        PLA                 ; Retrieve Buffer length Lo
   946 0A3A 9D 48 03		        STA     ICBLL,X
   947 0A3D 98			        TYA                 ; Get Buffer length Hi
   948 0A3E 9D 49 03		        STA     ICBLH,X
   949
   950 0A41 20 56 E4		        JSR     CIOV        ; Bon voyage
   951 0A44 10 00		        BPL     CIOGETREC_DONE
   952 				;        JMP     PRINT_ERROR
   953
   954 0A46			CIOGETREC_DONE:
   955 0A46 60			        RTS
   956
   957 				;#######################################
   958 				;#                                     #
   959 				;#          Utility Functions          #
   960 				;#                                     #
   961 				;#######################################
   962 				        ; ENABLE PROCEED INTERRUPT
   963
   964 0A47 AD 02 D3		ENPRCD: LDA     PACTL
   965 0A4A 09 01		        ORA     #$01        ; ENABLE BIT 0
   966 0A4C 8D 02 D3		        STA     PACTL
   967 0A4F 60			        RTS
   968
   969 				       ; DISABLE PROCEED INTERRUPT
   970
   971 0A50 AD 02 D3		DIPRCD: LDA     PACTL
   972 0A53 29 FE		        AND     #$FE        ; DISABLE BIT0
   973 0A55 8D 02 D3		        STA     PACTL
   974 0A58 60			        RTS
   975
   976 				       ; GET ZIOCB DEVNO - 1 INTO X
   977
   978 0A59 A6 21		GDIDX:  LDX     ZICDNO      ; IOCB UNIT #
   979 0A5B CA			        DEX                 ; - 1
   980 0A5C 60			        RTS
   981
   982 				;---------------------------------------
   983 				; Proceed Vector
   984 				;---------------------------------------
   985
   986 0A5D A9 01		PRCVEC: LDA     #$01
   987 0A5F 8D C3 15		        STA     TRIP
   988 0A62 68			        PLA
   989 0A63 40			        RTI
   990
   991 				; End Proceed Vector
   992 				;---------------------------------------
   993
   994 				;---------------------------------------
   995 				; Reset LNBUF
   996 				;---------------------------------------
   997 				; Normally this routine is at $DA51
   998 				; But some programs will bank-switch
   999 				; that portion of ROM to RAM
  1000 				;---------------------------------------
  1001
  1002 0A64 A9 05		LDBUFA: LDA     #$05
  1003 0A66 85 F4		        STA     INBUFF+1
  1004 				;        LDA     #$80
  1005 0A68 A9 82		        LDA     #$82
  1006 0A6A 85 F3		        STA     INBUFF
  1007 0A6C 60			        RTS
  1008
  1009 				; End Reset LNBUF
  1010 				;---------------------------------------
  1011
  1012 				;---------------------------------------
  1013 				; Skip spaces
  1014 				;---------------------------------------
  1015 				; Normally this routine is at $DBA1
  1016 				; But some programs will bank-switch
  1017 				; that portion of ROM to RAM
  1018 				;---------------------------------------
  1019
  1020 0A6D A4 F2		SKPSPC: LDY     CIX
  1021 0A6F A9 20		        LDA     #$20
  1022 0A71 D1 F3		@:      CMP     (INBUFF),Y
  1023 0A73 D0 03		        BNE     @+
  1024 0A75 C8			        INY
  1025 0A76 D0 F9		        BNE     @-
  1026 0A78 84 F2		@:      STY     CIX
  1027 0A7A 60			        RTS
  1028
  1029 				; End SKPSPC
  1030 				;---------------------------------------
  1031
  1032 				;---------------------------------------
  1033 				; Print EOL-terminated string
  1034 				; A: String Buffer Lo
  1035 				; Y: String Buffer Hi
  1036 				;---------------------------------------
  1037 0A7B			PRINT_STRING:
  1038
  1039 0A7B A2 00		        LDX     #$00
  1040 				    ;---------------------------------------
  1041 				    ; String Buffer
  1042 				    ;---------------------------------------
  1043 0A7D 9D 44 03		        STA     ICBAL,X
  1044 0A80 98			        TYA
  1045 0A81 9D 45 03		        STA     ICBAH,X
  1046
  1047 				    ;---------------------------------------
  1048 				    ; String Length
  1049 				    ;---------------------------------------
  1050 0A84 A9 80		        LDA     #$80
  1051 0A86 9D 48 03		        STA     ICBLL,X
  1052 0A89 A9 00		        LDA     #$00
  1053 0A8B 9D 49 03		        STA     ICBLH,X
  1054
  1055 				    ;---------------------------------------
  1056 				    ; Call to CIO
  1057 				    ;---------------------------------------
  1058 0A8E A9 09		        LDA     #PUTREC
  1059 0A90 9D 42 03		        STA     ICCOM,X
  1060 0A93 4C 56 E4		        JMP     CIOV
  1061
  1062 				;---------------------------------------
  1063 				; Print integer error number from DOSIOV
  1064 				; Y: Return code from DOSIOV
  1065 				;---------------------------------------
  1066 0A96			PRINT_ERROR:
  1067 0A96 C0 01		        CPY     #$01        ; Exit if success (1)
  1068 0A98 F0 33		        BEQ     PRINT_ERROR_DONE
  1069
  1070 				    ;-----------------------------------
  1071 				    ; If error code = 144, then get
  1072 				    ; extended code from DVSTAT
  1073 				    ;-----------------------------------
  1074 0A9A C0 90		        CPY     #144
  1075 0A9C D0 0A		        BNE     PRINT_ERROR_NEXT
  1076
  1077 0A9E A9 48		        LDA     #<STADCB
  1078 0AA0 A0 09		        LDY     #>STADCB
  1079 0AA2 20 A5 07		        JSR     DOSIOV
  1080 0AA5 AC ED 02		        LDY     DVSTAT+3    ;
  1081
  1082 0AA8			PRINT_ERROR_NEXT:
  1083 				    ;-----------------------------------
  1084 				    ; Convert error code to ASCII
  1085 				    ;-----------------------------------
  1086 0AA8 84 D4		        STY     FR0
  1087 0AAA A9 00		        LDA     #$00
  1088 0AAC 85 D5		        STA     FR0+1
  1089 0AAE 20 AA D9		        JSR     IFP         ; Convert error from int to floating point
  1090 0AB1 20 E6 D8		        JSR     FASC        ; Convert floating point to ASCII
  1091
  1092 				    ;---------------------------------------
  1093 				    ; Find last char in ASCII error (noted by high bit)
  1094 				    ; Unset high bit & append EOL
  1095 				    ;---------------------------------------
  1096 0AB4 A0 FF		        LDY     #$FF        ; Init counter = 0
  1097
  1098 0AB6 C8			@       INY
  1099 0AB7 B1 F3		        LDA     (INBUFF),Y
  1100 0AB9 C9 80		        CMP     #$80
  1101 0ABB 90 F9		        BCC     @-
  1102
  1103 0ABD 29 7F		        AND     #$7F        ; Clear high bit
  1104 0ABF 91 F3		        STA     (INBUFF),Y
  1105 0AC1 C8			        INY
  1106 0AC2 A9 9B		        LDA     #EOL        ; Append EOL
  1107 0AC4 91 F3		        STA     (INBUFF),Y
  1108
  1109 0AC6 A5 F3		        LDA     INBUFF
  1110 0AC8 A4 F4		        LDY     INBUFF+1
  1111 0ACA 4C 7B 0A		        JMP     PRINT_STRING
  1112
  1113 0ACD			PRINT_ERROR_DONE:
  1114 0ACD 60			        RTS
  1115
  1116 				; End Utility Functions
  1117 				;---------------------------------------
  1118
  1119
  1120 				;#######################################
  1121 				;#                                     #
  1122 				;#       COMMAND PROCESSOR (CP)        #
  1123 				;#                                     #
  1124 				;#######################################
  1125
  1126 				;---------------------------------------
  1127 				; DOS Entry point
  1128 				;---------------------------------------
  1129
  1130 0ACE 20 D4 0A		DOS:    JSR     CP          ; Command Processor
  1131 0AD1 4C CE 0A		        JMP     DOS         ; Keep looping
  1132
  1133 				;---------------------------------------
  1134 				; Main loop
  1135 				;---------------------------------------
  1136
  1137 0AD4			CP:
  1138 0AD4 A9 FF		        LDA     #$FF        ; Clear command
  1139 0AD6 8D C0 15		        STA     CMD
  1140
  1141 0AD9 20 E8 0A		        JSR     SHOWPROMPT
  1142 0ADC 20 0D 0B		        JSR     GETCMD
  1143 0ADF 20 7C 0B		        JSR     PARSECMD
  1144 0AE2 30 03		        BMI     CP_DONE     ; Skip DOCMD if CMD == $FF
  1145 0AE4 20 F2 0B		        JSR     DOCMD
  1146 0AE7			CP_DONE:
  1147 0AE7 60			        RTS
  1148
  1149 				;---------------------------------------
  1150 				; Show Command Prompt (Nn:)
  1151 				; Leading EOF requires special CIOV call
  1152 				;---------------------------------------
  1153
  1154 				;---------------------------------------
  1155 0AE8			SHOWPROMPT:
  1156 				;---------------------------------------
  1157
  1158 0AE8 AD BF 15		        LDA     DOSDR       ; Get the 1,2,... for N1,N2,...
  1159 0AEB 09 30		        ORA     #'0'        ; Convert, say, 1 to '1'
  1160 0AED 8D 6E 14		        STA     PRMPT+2     ; Store in after EOL and N
  1161
  1162 0AF0 A2 00		        LDX     #$00
  1163 0AF2 A9 0B		        LDA     #PUTCHR
  1164 0AF4 9D 42 03		        STA     ICCOM,X
  1165
  1166 0AF7 A9 6C		        LDA     #<PRMPT
  1167 0AF9 9D 44 03		        STA     ICBAL,X
  1168 0AFC A9 14		        LDA     #>PRMPT
  1169
  1170 0AFE 9D 45 03		        STA     ICBAH,X
  1171 0B01 A9 04		        LDA     #4          ; Prompt length = 4
  1172 0B03 9D 48 03		        STA     ICBLL,X
  1173 0B06 8A			        TXA                 ; Still zero
  1174 0B07 9D 49 03		        STA     ICBLH,X
  1175
  1176 0B0A 4C 56 E4		        JMP     CIOV
  1177
  1178 				;---------------------------------------
  1179 0B0D			GETCMD:
  1180 				;---------------------------------------
  1181 0B0D A2 00		        LDX     #$00
  1182 0B0F A9 05		        LDA     #GETREC
  1183 0B11 9D 42 03		        STA     ICCOM,X
  1184 0B14 A9 82		        LDA     #<LNBUF
  1185 0B16 9D 44 03		        STA     ICBAL,X
  1186 0B19 A9 05		        LDA     #>LNBUF
  1187 0B1B 9D 45 03		        STA     ICBAH,X
  1188 0B1E A9 7F		        LDA     #$7F
  1189 0B20 9D 48 03		        STA     ICBLL,X
  1190 0B23 20 56 E4		        JSR     CIOV
  1191
  1192 0B26			GETCMDTEST:
  1193 0B26 A0 00		        LDY #$00
  1194 0B28 84 F2		        STY CIX
  1195 0B2A 20 64 0A		        JSR LDBUFA      ; Reset LNBUF to $0580
  1196 0B2D 20 6D 0A		        JSR SKPSPC      ; Advance CIX to next space
  1197
  1198 				    ;---------------------------------------
  1199 				    ; CMDSEP is an sequence of bytes contains
  1200 				    ; indexes to chars following spaces
  1201 				    ; Iterate to clear CMDSEP bytes
  1202 				    ;---------------------------------------
  1203 0B30 98			        TYA                 ; A = 0
  1204 0B31 A2 02		        LDX     #$02        ; for X = 2 to 0 step -1
  1205 0B33			GETLOOP:
  1206 0B33 9D 78 0B		        STA     CMDSEP,X
  1207 0B36 CA			        DEX
  1208 0B37 10 FA		        BPL     GETLOOP     ; next X
  1209
  1210 				    ; Initial Delimiter to space
  1211 0B39 A9 20		        LDA     #' '
  1212 0B3B 8D 7B 0B		        STA     DELIM
  1213
  1214 				    ;---------------------------------------
  1215 				    ; Loop until EOL is encountered
  1216 				    ;---------------------------------------
  1217 0B3E E8			        INX                 ; Reset X to 0
  1218 0B3F			GETCMD_LOOP:
  1219 0B3F B1 F3		        LDA     (INBUFF),Y
  1220 0B41 C9 9B		        CMP     #EOL        ; Found EOL?
  1221 0B43 F0 32		        BEQ     GETCMD_DONE ; yes. skip
  1222 0B45 CD 7B 0B		        CMP     DELIM       ; Found space?
  1223 0B48 F0 03		        BEQ     GETCMD_REPL ; yes. Replace it
  1224 0B4A C8			        INY
  1225 0B4B D0 F2		        BNE     GETCMD_LOOP ; "always" non-zero
  1226
  1227 				    ;---------------------------------------
  1228 				    ; March through the cmd line and note
  1229 				    ; the positions of any args as delimited
  1230 				    ; by spaces or quotes. positions saved
  1231 				    ; in CMDSEP,X
  1232 				    ;---------------------------------------
  1233 0B4D			GETCMD_REPL:
  1234 0B4D A9 9B		        LDA     #EOL
  1235 0B4F 91 F3		        STA     (INBUFF),Y
  1236 0B51 C8			        INY
  1237 0B52 B1 F3		        LDA     (INBUFF),Y  ; Skip any run of spaces
  1238 0B54 C9 20		        CMP     #' '
  1239 0B56 F0 F5		        BEQ     GETCMD_REPL ; Keep skipping spaces
  1240
  1241 				    ; Here if any run of spaces has ended
  1242 				    ; Are we standing on a double-quote?
  1243 0B58 C9 22		        CMP     #'"'
  1244 0B5A D0 12		        BNE     GETCMD_WR_OFFSET  ; No. Skip ahead
  1245
  1246 				    ; Here if curr char is a double-quote
  1247 0B5C C8			        INY                 ; Advance the command line index
  1248 0B5D A9 22		        LDA     #'"'        ; Is the curr delim a double-quote?
  1249 0B5F CD 7B 0B		        CMP     DELIM       ; If not, change delim to double-quote
  1250 0B62 D0 07		        BNE     GETCMD_DQ_DELIM
  1251
  1252 				    ; Here if curr delim is a double-quote
  1253 				    ; Switch delim to space
  1254 0B64 A9 20		        LDA     #' '
  1255 0B66 8D 7B 0B		        STA     DELIM
  1256 0B69 D0 03		        BNE     GETCMD_WR_OFFSET
  1257
  1258 				    ; Here if curr delim is space
  1259 				    ; Switch delim to double-quote
  1260 0B6B			GETCMD_DQ_DELIM:
  1261 0B6B 8D 7B 0B		        STA     DELIM
  1262
  1263 				    ; Note the position for the curr command-line arg
  1264 0B6E			GETCMD_WR_OFFSET:
  1265 0B6E 98			        TYA
  1266 0B6F 9D 78 0B		        STA     CMDSEP,X
  1267 0B72 E8			        INX
  1268 0B73 E0 03		        CPX     #$03
  1269 0B75 90 C8		        BCC     GETCMD_LOOP ; Continue searching
  1270
  1271 0B77			GETCMD_DONE:
  1272 0B77 60			        RTS
  1273
  1274 				.ifdef SYNCALC
  1275 					:($0D15-*) DTA $00
  1276 				.endif
  1277
  1278 0B78 FF FF FF		CMDSEP: .BYTE $FF,$FF,$FF
  1279 0B7B 20			DELIM:  .BYTE ' '
  1280
  1281 				;---------------------------------------
  1282 0B7C			PARSECMD:
  1283 				;---------------------------------------
  1284 0B7C AD 82 05		        LDA     LNBUF
  1285 0B7F C9 9B		        CMP     #EOL        ; Quit immediately if no cmd
  1286 0B81 F0 09		        BEQ     PARSECMD_DONE
  1287
  1288 0B83 20 A1 0B		        JSR     PARSE_INTRINSIC_COMMAND
  1289 0B86 20 DB 0B		        JSR     PARSE_DRIVE_CHANGE
  1290 0B89 20 8D 0B		        JSR     PRINT_UNK_CMD
  1291 0B8C			PARSECMD_DONE:
  1292 0B8C 60			        RTS
  1293
  1294 0B8D			PRINT_UNK_CMD:
  1295 0B8D AD C0 15		        LDA     CMD
  1296 0B90 C9 FF		        CMP     #$FF
  1297 0B92 D0 07		        BNE     PRINT_UNK_CMD_DONE
  1298 0B94 A9 9C		        LDA     #<UNK_CMD_ERR
  1299 0B96 A0 0B		        LDY     #>UNK_CMD_ERR
  1300 0B98 20 7B 0A		        JSR     PRINT_STRING
  1301 0B9B			PRINT_UNK_CMD_DONE:
  1302 0B9B 60			        RTS
  1303
  1304 0B9C			UNK_CMD_ERR:
  1305 0B9C 43 4D 44 3F 9B	        .BYTE   'CMD?',EOL
  1306
  1307 				;---------------------------------------
  1308 0BA1			PARSE_INTRINSIC_COMMAND:
  1309 				;---------------------------------------
  1310 0BA1 A2 00		        LDX     #$00        ; Initialize X for command code indexing
  1311 0BA3 A0 00		        LDY     #$00
  1312 0BA5 84 F2		        STY     CIX
  1313 0BA7 20 64 0A		        JSR     LDBUFA      ; Set INBUFF to $0580
  1314 0BAA 20 6D 0A		        JSR     SKPSPC      ; Skip whitespace
  1315
  1316 0BAD			PARSE_INTRINSIC_NEXT_CHAR:
  1317 0BAD B1 F3		        LDA     (INBUFF),Y
  1318 0BAF 29 7F		        AND     #$7F
  1319 0BB1 5D 8C 14		        EOR     COMMAND,X   ; X initialized to 0 in caller
  1320 0BB4 C8			        INY
  1321 0BB5 0A			        ASL
  1322 0BB6 F0 0B		        BEQ     PARSE_INTRINSIC_CHAR_OK
  1323
  1324 				        ; Skip to next command
  1325
  1326 0BB8			PARSE_INTRINSIC_NEXT_COMMAND:
  1327 0BB8 BD 8C 14		        LDA     COMMAND,X
  1328 0BBB 0A			        ASL
  1329 0BBC E8			        INX
  1330 0BBD 90 F9		        BCC     PARSE_INTRINSIC_NEXT_COMMAND
  1331 0BBF A4 F2		        LDY     CIX
  1332 0BC1 E0 BA		        CPX     #COMMAND_SIZE
  1333
  1334 0BC3			PARSE_INTRINSIC_CHAR_OK:
  1335 0BC3 E8			        INX
  1336 0BC4 90 E7		        BCC     PARSE_INTRINSIC_NEXT_CHAR
  1337 0BC6 84 F2		        STY     CIX
  1338 0BC8 B1 F3		        LDA     (INBUFF),Y
  1339 0BCA 30 05		        BMI     PARSE_INTRINSIC_RET
  1340
  1341 0BCC 20 6D 0A		        JSR     SKPSPC
  1342
  1343 0BCF			PARSE_INTRINSIC_RET_ERROR:
  1344 0BCF A2 BB		        LDX     #COMMAND_SIZE+1
  1345 0BD1			PARSE_INTRINSIC_RET:
  1346 0BD1 BD 8C 14		        LDA     COMMAND,X
  1347 0BD4 8D C0 15		        STA     CMD
  1348 0BD7 8D C1 15		        STA     CMDPRV
  1349 0BDA			PARSE_INTRINSIC_DONE:
  1350 0BDA 60			        RTS
  1351
  1352 				; End of PARSE_INTRINSIC_COMMAND
  1353 				;---------------------------------------
  1354
  1355 				;---------------------------------------
  1356 0BDB			PARSE_DRIVE_CHANGE:
  1357 				;---------------------------------------
  1358 0BDB A2 03		        LDX     #$03        ; Check for EOL in pos 3
  1359 0BDD BD 82 05		        LDA     LNBUF,X
  1360 0BE0 C9 9B		        CMP     #EOL
  1361 0BE2 D0 0D		        BNE     PARSE_DRIVE_CHANGE_DONE
  1362 0BE4 CA			        DEX                 ; go back one char
  1363 0BE5 BD 82 05		        LDA     LNBUF,X
  1364 0BE8 C9 3A		        CMP     #':'        ; Check for colon.
  1365 0BEA D0 05		        BNE     PARSE_DRIVE_CHANGE_DONE
  1366 0BEC A9 1B		        LDA     #CMD_IDX.DRIVE_CHG
  1367 0BEE 8D C0 15		        STA     CMD
  1368 0BF1			PARSE_DRIVE_CHANGE_DONE:
  1369 0BF1 60			        RTS
  1370
  1371 				;---------------------------------------
  1372 0BF2			DOCMD:
  1373 				;---------------------------------------
  1374 0BF2 AE C0 15		        LDX     CMD
  1375 0BF5 30 08		        BMI     DOCMD_DONE      ; Unassigned command = $FF
  1376 0BF7 BD 64 15		        LDA     CMD_TAB_H,X     ; Get hi-byte of subroutine's addr
  1377 0BFA 48			        PHA                     ; Push it to the stack
  1378 0BFB BD 48 15		        LDA     CMD_TAB_L,X     ; Get lo-byte of subroutine's addr
  1379 0BFE 48			        PHA                     ; Push it to the stack
  1380 0BFF			DOCMD_DONE:
  1381 0BFF 60			        RTS                     ; Use stack & RTS to jump to subroutine
  1382
  1383 				; End of DOCMD
  1384 				;---------------------------------------
  1385
  1386 				;---------------------------------------
  1387 0C00			DO_DRIVE_CHG:
  1388 				;---------------------------------------
  1389 0C00 AD 82 05		        LDA     LNBUF
  1390 0C03 8D 6D 14		        STA     PRMPT+1
  1391 0C06 AD 83 05		        LDA     LNBUF+1
  1392 0C09 C9 31		        CMP     #'1'        ; Skip if '0' or less
  1393 0C0B 90 0A		        BCC     DO_DRIVE_CHG_ERROR
  1394 0C0D C9 39		        CMP     #'9'        ; Skip if '9' or more
  1395 0C0F B0 06		        BCS     DO_DRIVE_CHG_ERROR
  1396 0C11 29 0F		        AND     #$0F        ; Convert, say, to 1-8
  1397 0C13 8D BF 15		        STA     DOSDR
  1398 0C16 60			        RTS
  1399 0C17			DO_DRIVE_CHG_ERROR:
  1400 0C17 A9 B5		        LDA     #<CDERR
  1401 0C19 A0 15		        LDY     #>CDERR
  1402 0C1B 4C 7B 0A		        JMP     PRINT_STRING
  1403
  1404 				; End of DOCMD
  1405
  1406 				;---------------------------------------
  1407 				; Returns DOSDR in X
  1408 				; If arg1 contains Nn: then reg X = n
  1409 				; Otherwise X = DOSDR (from curr prompt)
  1410 				;---------------------------------------
  1411 0C1E			GET_DOSDR:
  1412 				;---------------------------------------
  1413
  1414 0C1E 20 64 0A		        JSR     LDBUFA      ; Reset INBUFF to LNBUF
  1415 0C21 AE BF 15		        LDX     DOSDR       ; Set DUNIT(X) to curr drive
  1416
  1417 				    ;---------------------------------------
  1418 				    ; Consider arg1 = N2:TNFS://localhost/
  1419 				    ; Check arg1 for ":" in 3rd position
  1420 				    ; if found then use char in 2nd position ('2') as DOSDR
  1421 				    ; First, change INBUFF to point to beg. of 1st arg
  1422 				    ;---------------------------------------
  1423 0C24 AD 78 0B		        LDA     CMDSEP              ; arg offset
  1424 0C27 F0 17		        BEQ     GET_DOSDR_DONE      ; first, if arg1 not pop, leave X as-is & quit
  1425
  1426 0C29 18			        CLC                         ; Advance pointer to LNBUF
  1427 0C2A 65 F3		        ADC     INBUFF
  1428 0C2C 85 F3		        STA     INBUFF
  1429 0C2E 90 02		        BCC     GET_DOSDR_NEXT
  1430 0C30 E6 F4		        INC     INBUFF+1
  1431
  1432 0C32			GET_DOSDR_NEXT:
  1433 0C32 A0 02		        LDY     #$02            ; Check for ':' in 3rd pos
  1434 0C34 B1 F3		        LDA     (INBUFF),Y
  1435 0C36 C9 3A		        CMP     #':'
  1436 0C38 D0 06		        BNE     GET_DOSDR_DONE  ; Not found, skip & use default
  1437 0C3A 88			        DEY
  1438 0C3B B1 F3		        LDA     (INBUFF),Y
  1439 0C3D 29 0F		        AND     #$0F            ; Convert, say, '2' to 2
  1440 0C3F AA			        TAX                     ; Return DOSDR in X
  1441
  1442 0C40			GET_DOSDR_DONE:
  1443 0C40 60			        RTS
  1444
  1445 				;---------------------------------------
  1446 0C41			DO_GENERIC:
  1447 				;---------------------------------------
  1448
  1449 				    ;---------------------------------------
  1450 				    ; SIO call for NCD,{MK,RM}DIR,DEL,RENAME
  1451 				    ;---------------------------------------
  1452
  1453 				    ;---------------------------------------
  1454 				    ; Get Fujinet SIO command (~ $21 for DEL)
  1455 				    ; X = table index from caller
  1456 				    ;---------------------------------------
  1457 0C41 BD 70 14		        LDA     CMD_DCOMND,X
  1458 0C44 8D A4 0C		        STA     GENDCB+2
  1459
  1460 				    ;---------------------------------------
  1461 				    ; Get DOSDR from either arg1 or curr drive
  1462 				    ;---------------------------------------
  1463 0C47 20 1E 0C		        JSR     GET_DOSDR    ; X will contain int of n in Nn:
  1464 0C4A 8E A3 0C		        STX     GENDCB+1
  1465 0C4D 20 18 14		        JSR     PREPEND_DRIVE
  1466
  1467 				    ;---------------------------------------
  1468 				    ; If this is NCD ensure a '/' char is the last char
  1469 				    ;---------------------------------------
  1470 0C50 AD A4 0C		        LDA     GENDCB+2
  1471 0C53 C9 2C		        CMP     #CMD_CD         ; Is this an NCD command?
  1472 0C55 D0 08		        BNE     DO_GENERIC_NEXT ; No. skip
  1473
  1474 0C57 AD 78 0B		        LDA     CMDSEP
  1475 0C5A F0 2C		        BEQ     NCD_ERROR
  1476 0C5C 20 45 14		        JSR     APPEND_SLASH    ; Append '/' to path if missing
  1477
  1478 0C5F			DO_GENERIC_NEXT:
  1479 				    ;---------------------------------------
  1480 				    ; Populate the DCB
  1481 				    ;---------------------------------------
  1482 0C5F AD BF 15		        LDA     DOSDR
  1483 0C62 8D 49 09		        STA     STADCB+1
  1484 0C65 A5 F3		        LDA     INBUFF
  1485 0C67 8D A6 0C		        STA     GENDCB+4
  1486 0C6A A5 F4		        LDA     INBUFF+1
  1487 0C6C 8D A7 0C		        STA     GENDCB+5
  1488
  1489 				    ;---------------------------------------
  1490 				    ; Send the command to FujiNet
  1491 				    ;---------------------------------------
  1492 0C6F A9 A2		        LDA     #<GENDCB
  1493 0C71 A0 0C		        LDY     #>GENDCB
  1494 0C73 20 A5 07		        JSR     DOSIOV
  1495 0C76 20 96 0A		        JSR     PRINT_ERROR
  1496
  1497 0C79			GEN_UNMOUNT:
  1498 				    ;---------------------------------------
  1499 				    ; if DEL or RENAME, then remount drive
  1500 				    ;---------------------------------------
  1501 0C79 AD C1 15		        LDA     CMDPRV
  1502 0C7C C9 03		        CMP     #CMD_IDX.DEL
  1503 0C7E F0 04		        BEQ     GEN_REMOUNT
  1504 0C80 C9 0A		        CMP     #CMD_IDX.RENAME
  1505 0C82 D0 03		        BNE     GENDONE
  1506 0C84			GEN_REMOUNT:
  1507 0C84 4C E5 13		        JMP     REMOUNT_DRIVE
  1508
  1509 0C87			GENDONE:
  1510 0C87 60			        RTS
  1511
  1512 				;---------------------------------------
  1513 0C88			NCD_ERROR:
  1514 				;---------------------------------------
  1515 0C88 A9 9C		        LDA     #<NCD_ERROR_STR
  1516 0C8A A0 0C		        LDY     #>NCD_ERROR_STR
  1517 0C8C 20 7B 0A		        JSR     PRINT_STRING
  1518 0C8F A0 01		        LDY     #$01        ; Return error
  1519 0C91 60			        RTS
  1520 				    ;---------------------------------------
  1521 				    ; Close 
  1522 				    ;---------------------------------------
  1523 0C92 A2 10		        LDX     #$10            ; File #1
  1524 0C94 A9 0C		        LDA     #$0C            ; Close #1 first
  1525 0C96 9D 42 03		        STA     ICCOM,X
  1526 0C99 20 56 E4		        JSR     CIOV
  1527
  1528 0C9C			NCD_ERROR_STR:
  1529 0C9C 50 41 54 48 3F 9B	        .BYTE   'PATH?',EOL
  1530
  1531 				;---------------------------------------
  1532 0CA2			GENDCB:
  1533 0CA2 71			        .BYTE      DEVIDN  ; DDEVIC
  1534 0CA3 FF			        .BYTE      $FF     ; DUNIT
  1535 0CA4 FF			        .BYTE      $FF     ; DCOMND
  1536 0CA5 80			        .BYTE      $80     ; DSTATS
  1537 0CA6 FF			        .BYTE      $FF     ; DBUFL
  1538 0CA7 FF			        .BYTE      $FF     ; DBUFH
  1539 0CA8 1F			        .BYTE      $1F     ; DTIMLO
  1540 0CA9 00			        .BYTE      $00     ; DRESVD
  1541 0CAA 00			        .BYTE      $00     ; DBYTL
  1542 0CAB 01			        .BYTE      $01     ; DBYTH
  1543 0CAC 00			        .BYTE      $00     ; DAUX1
  1544 0CAD 00			        .BYTE      $00     ; DAUX2
  1545
  1546 				; End of DO_GENERIC
  1547 				;---------------------------------------
  1548
  1549 				;;---------------------------------------
  1550 				;DO_COPY:
  1551 				;;---------------------------------------
  1552 				;
  1553 				;        LDA     #$20
  1554 				;        STA     COLOR2
  1555 				;
  1556 				;        LDA     #<CPYDCB
  1557 				;        LDY     #>CPYDCB
  1558 				;        JSR     DOSIOV
  1559 				;
  1560 				;        LDA     #$20
  1561 				;        STA     COLOR2
  1562 				;
  1563 				;        RTS
  1564 				;
  1565 				;CPYDCB:
  1566 				;        .BYTE      DEVIDN  ; DDEVIC
  1567 				;        .BYTE      $FF     ; DUNIT
  1568 				;        .BYTE      $D8     ; DCOMND
  1569 				;        .BYTE      $80     ; DSTATS
  1570 				;        .BYTE      <COPYSPEC  ; DBUFL
  1571 				;        .BYTE      >COPYSPEC ; DBUFH
  1572 				;        .BYTE      $FE     ; DTIMLO
  1573 				;        .BYTE      $00     ; DRESVD
  1574 				;        .BYTE      $00     ; DBYTL
  1575 				;        .BYTE      $01     ; DBYTH
  1576 				;        .BYTE      3       ; DAUX1
  1577 				;        .BYTE      2       ; DAUX2
  1578 				;
  1579 				;COPYSPEC:
  1580 				;        .BYTE 'iss.po|iss.po',$00
  1581
  1582 				;---------------------------------------
  1583 0CAE			DO_COPY:
  1584 				;---------------------------------------
  1585 0CAE A9 B0		        LDA     #$B0
  1586 0CB0 8D C6 02		        STA     COLOR2
  1587 0CB3 60			        RTS
  1588
  1589 				;        JSR     COPY_PARSE_FILES    ; locate comma, replace with EOL
  1590 				;        BMI     COPY_DONE
  1591 				;
  1592 				;        LDA     CMDSEP
  1593 				;        STA     CMDSEP+2
  1594 				;
  1595 				;        LDA     CMDSEP+1
  1596 				;        STA     CMDSEP
  1597 				;
  1598 				;        JSR     COPY_OPEN_DEST      ; use CIO to open file 2 for write
  1599 				;        BMI     COPY_DONE
  1600 				;
  1601 				;        LDA     CMDSEP+2
  1602 				;        STA     CMDSEP
  1603 				;        JSR     COPY_OPEN_SRC       ; use CIO to open file 1 for read
  1604 				;        BMI     COPY_DONE
  1605 				;
  1606 				;@:      JSR     COPY_GET_SRC
  1607 				;        JSR     COPY_PUT_DEST
  1608 				;        ;BNE     @-
  1609 				;
  1610 				;COPY_DONE:
  1611 				;    ; Close files
  1612 				;        LDX     #$10
  1613 				;        JSR     CIOCLOSE
  1614 				;        LDX     #$20
  1615 				;        JMP     CIOCLOSE
  1616 				;
  1617 				;;---------------------------------------
  1618 				;COPY_PARSE_FILES:
  1619 				;;---------------------------------------
  1620 				;    ; Find position of comma in line buffer
  1621 				;    ; Return X = position of comma
  1622 				;    ;---------------------------------------
  1623 				;        LDX     CMDSEP
  1624 				;COPY_PARSE_LOOP:
  1625 				;        LDA     LNBUF,X
  1626 				;        CMP     #','
  1627 				;        BEQ     COPY_PARSE_FILES_DONE
  1628 				;        CMP     #EOL
  1629 				;        BEQ     COPY_SHOW_USAGE
  1630 				;        INX
  1631 				;        BNE     COPY_PARSE_LOOP
  1632 				;COPY_PARSE_FILES_DONE:
  1633 				;    ;---------------------------------------
  1634 				;    ; Here if comma found.
  1635 				;    ; Inject EOL where the comma was found
  1636 				;    ;---------------------------------------
  1637 				;        LDA     #EOL
  1638 				;        STA     LNBUF,X
  1639 				;        INX                 ; Advance to start of 2nd arg
  1640 				;        STX     CMDSEP+1    ; Point to 2nd arg now
  1641 				;        RTS
  1642 				;    ;---------------------------------------
  1643 				;    ; Here if no comma found.
  1644 				;    ; Print usage
  1645 				;    ;---------------------------------------
  1646 				;COPY_SHOW_USAGE:
  1647 				;        LDA     #<COPY_SHOW_USAGE_STR
  1648 				;        LDY     #>COPY_SHOW_USAGE_STR
  1649 				;        JSR     PRINT_STRING
  1650 				;        LDY     #$FF
  1651 				;        RTS
  1652 				;
  1653 				;COPY_SHOW_USAGE_STR:
  1654 				;        .BYTE   'COPY SOURCE,DEST',EOL
  1655 				;
  1656 				;; End of COPY_COMMA_POS:
  1657 				;;---------------------------------------
  1658 				;
  1659 				;;---------------------------------------
  1660 				;COPY_OPEN_SRC:
  1661 				;;---------------------------------------
  1662 				;        JSR     GET_DOSDR       ; Get DUNIT
  1663 				;        JSR     PREPEND_DRIVE
  1664 				;
  1665 				;        LDX     #$10            ; File #1
  1666 				;        JSR     CIOCLOSE        ; Assert file #1 is closed
  1667 				;        LDY     #$04            ; Open for input
  1668 				;        JSR     CIOOPEN         ; Open filename @ (INBUFF)
  1669 				;        BPL     COPY_OPEN_SRC_DONE
  1670 				;
  1671 				;        LDA     #<COPY_OPEN_SRC_ERR_STR
  1672 				;        LDY     #>COPY_OPEN_SRC_ERR_STR
  1673 				;        JMP     PRINT_STRING
  1674 				;
  1675 				;COPY_OPEN_SRC_DONE:
  1676 				;        RTS
  1677 				;        
  1678 				;COPY_OPEN_SRC_ERR_STR:
  1679 				;        .BYTE   'UNABLE TO OPEN SOURCE',EOL
  1680 				;
  1681 				;;End of COPY_OPEN_SRC
  1682 				;;---------------------------------------
  1683 				;
  1684 				;;---------------------------------------
  1685 				;COPY_OPEN_DEST:
  1686 				;;---------------------------------------
  1687 				;    ; Advance offset to arg2
  1688 				;        
  1689 				;@:      JSR     GET_DOSDR       ; Get DUNIT
  1690 				;        JSR     PREPEND_DRIVE
  1691 				;
  1692 				;        LDX     #$20            ; Assert file #2 is closed
  1693 				;        JSR     CIOCLOSE
  1694 				;
  1695 				;        LDY     #$08            ; Open for write
  1696 				;        JSR     CIOOPEN
  1697 				;        BPL     COPY_OPEN_DEST_DONE  ; If success, skip ahead
  1698 				;
  1699 				;        LDA     #<COPY_OPEN_DEST_ERR_STR
  1700 				;        LDY     #>COPY_OPEN_DEST_ERR_STR
  1701 				;        JMP     PRINT_STRING
  1702 				;
  1703 				;COPY_OPEN_DEST_DONE:
  1704 				;        RTS
  1705 				;        
  1706 				;COPY_OPEN_DEST_ERR_STR:
  1707 				;        .BYTE   'UNABLE TO OPEN DEST',EOL
  1708 				;
  1709 				;;End of COPY_OPEN_SRC
  1710 				;;---------------------------------------
  1711 				;
  1712 				;;---------------------------------------
  1713 				;COPY_GET_SRC:
  1714 				;;---------------------------------------
  1715 				;        ;LDX     #$10
  1716 				;        ;JSR     CIOSTATUS
  1717 				;
  1718 				;        LDX     #$10
  1719 				;        LDA     #<TBUF
  1720 				;        STA     INBUFF      ; Buffer addr Lo
  1721 				;        LDA     #>TBUF
  1722 				;        STA     INBUFF+1    ; Buffer addr Hi
  1723 				;        LDA     #$80        ; Buffer size Lo
  1724 				;        LDY     #$00        ; Buffer size Hi
  1725 				;        JSR     CIOGET
  1726 				;        BPL     COPY_GET_SRC_DONE
  1727 				;        CPY     #EOF
  1728 				;        BEQ     COPY_GET_SRC_DONE
  1729 				; 
  1730 				;        LDA     #<COPY_GET_SRC_STR
  1731 				;        LDY     #>COPY_GET_SRC_STR
  1732 				;        JMP     PRINT_STRING
  1733 				;
  1734 				;COPY_GET_SRC_DONE:
  1735 				;        RTS
  1736 				;
  1737 				;COPY_GET_SRC_STR:
  1738 				;        .BYTE   'ERROR READING FROM SOURCE',EOL
  1739 				;
  1740 				;;---------------------------------------
  1741 				;COPY_PUT_DEST:
  1742 				;;---------------------------------------
  1743 				;        ;LDX     #$20
  1744 				;        ;JSR     CIOSTATUS
  1745 				;
  1746 				;        LDX     #$20
  1747 				;        LDA     #<TBUF
  1748 				;        STA     INBUFF      ; Buffer addr Lo
  1749 				;        LDA     #>TBUF
  1750 				;        STA     INBUFF+1    ; Buffer addr Hi
  1751 				;        LDA     #$06        ; Buffer size Lo
  1752 				;        LDY     #$00        ; Buffer size Hi
  1753 				;        JSR     CIOPUT
  1754 				;        BPL     COPY_PUT_DEST_DONE
  1755 				;        CPY     #EOF
  1756 				;        BEQ     COPY_PUT_DEST_DONE
  1757 				; 
  1758 				;        LDA     #<COPY_PUT_DEST_STR
  1759 				;        LDY     #>COPY_PUT_DEST_STR
  1760 				;        JMP     PRINT_STRING
  1761 				;
  1762 				;COPY_PUT_DEST_DONE:
  1763 				;        RTS
  1764 				;
  1765 				;COPY_PUT_DEST_STR:
  1766 				;        .BYTE   'ERROR WRITING TO DEST',EOL
  1767 				;
  1768
  1769 				;---------------------------------------
  1770 0CB4			DO_DIR:
  1771 				;---------------------------------------
  1772 0CB4 20 14 0D		        JSR     DIR_INIT    ; set dunits
  1773 0CB7 20 24 0D		        JSR     DIR_OPEN    ; open with dir request
  1774 0CBA C0 01		        CPY     #$01        ; success (1) ?
  1775 0CBC F0 03		        BEQ     DIR_LOOP    ; if success, jump ahead
  1776 0CBE 4C 96 0A		        JMP     PRINT_ERROR ; exit
  1777
  1778 0CC1			DIR_LOOP:
  1779
  1780 				    ;---------------------------------------
  1781 				    ; Send Status request to SIO
  1782 				    ;---------------------------------------
  1783 0CC1 A9 48		        LDA     #<STADCB
  1784 0CC3 A0 09		        LDY     #>STADCB
  1785 0CC5 20 A5 07		        JSR     DOSIOV
  1786
  1787 				    ;---------------------------------------
  1788 				    ; Status returns DVSTAT
  1789 				    ;---------------------------------------
  1790 0CC8 A2 00		        LDX     #$00
  1791 0CCA EC EB 02		        CPX     DVSTAT+1    ; if byte count < 255 (that is, hi=0)
  1792 0CCD F0 09		        BEQ     DIR_LT_255  ; then skip
  1793
  1794 				    ;---------------------------------------
  1795 				    ; Branch 1: Read 255 bytes (max)
  1796 				    ;---------------------------------------
  1797 0CCF CA			        DEX                 ; X now 255 (Read FF Bytes)
  1798 0CD0 8E 10 0D		        STX     DIRRDCB+8   ; DBYTL
  1799 0CD3 8E 12 0D		        STX     DIRRDCB+10  ; DAUX1
  1800 0CD6 30 0B		        BMI     DIR_NEXT1   ; "always" true. skip down SIO call
  1801
  1802 				    ;---------------------------------------
  1803 				    ; Branch 2: Read < 255 bytes
  1804 				    ;---------------------------------------
  1805 0CD8			DIR_LT_255:
  1806 0CD8 AD EA 02		        LDA     DVSTAT      ; Get count of bytes remaining
  1807 0CDB F0 6C		        BEQ     DIR_ERROR   ; If here then DVSTAT = $0000 (error)
  1808 0CDD 8D 10 0D		        STA     DIRRDCB+8   ; DBYTL
  1809 0CE0 8D 12 0D		        STA     DIRRDCB+10  ; DAUX1
  1810
  1811 				    ;-------------------------
  1812 				    ; Send Read request to SIO
  1813 				    ;-------------------------
  1814 0CE3			DIR_NEXT1:
  1815 0CE3 A9 08		        LDA     #<DIRRDCB
  1816 0CE5 A0 0D		        LDY     #>DIRRDCB
  1817 0CE7 20 A5 07		        JSR     DOSIOV      ; Fetch directory listing
  1818 0CEA 20 79 0D		        JSR     DIR_PRINT   ; xfer payload to screen
  1819
  1820 				    ;---------------------------------------
  1821 				    ; Pause output if SPACE key code found
  1822 				    ;---------------------------------------
  1823 0CED			DIR_WAIT:
  1824 0CED AD FC 02		        LDA     CH
  1825 0CF0 C9 21		        CMP     #SPC_KEY
  1826 0CF2 F0 F9		        BEQ     DIR_WAIT
  1827
  1828 				    ;---------------------------------------
  1829 				    ; Exit loop if ESC key code found
  1830 				    ;---------------------------------------
  1831 0CF4 AD FC 02		        LDA     CH
  1832 0CF7 C9 1C		        CMP     #ESC_KEY    ; hardware code for ESC key
  1833 0CF9 F0 05		        BEQ     DIR_NEXT
  1834
  1835 				    ;---------------------------------------
  1836 				    ; Loop if more data to read
  1837 				    ;---------------------------------------
  1838 0CFB AD EB 02		        LDA     DVSTAT+1    ; Was there more to read (that is, was hi>0)?
  1839 0CFE D0 C1		        BNE     DIR_LOOP    ; If yes, then do it again
  1840
  1841 0D00			DIR_NEXT:
  1842 0D00 A9 FF		        LDA     #$FF        ; Clear key
  1843 0D02 8D FC 02		        STA     CH
  1844 0D05 4C 97 0D		        JMP     DIR_CLOSE
  1845
  1846 0D08			DIRRDCB:
  1847 0D08 71			        .BYTE   DEVIDN      ; DDEVIC
  1848 0D09 FF			        .BYTE   $FF         ; DUNIT
  1849 0D0A 52			        .BYTE   'R'         ; DCOMND
  1850 0D0B 40			        .BYTE   $40         ; DSTATS
  1851 0D0C 00			        .BYTE   <RBUF       ; DBUFL
  1852 0D0D 16			        .BYTE   >RBUF       ; DBUFH
  1853 0D0E 1F			        .BYTE   $1F         ; DTIMLO
  1854 0D0F 00			        .BYTE   $00         ; DRESVD
  1855 0D10 00			        .BYTE   $00         ; DBYTL
  1856 0D11 00			        .BYTE   $00         ; DBYTH
  1857 0D12 00			        .BYTE   $00         ; DAUX1
  1858 0D13 00			        .BYTE   $00         ; DAUX2
  1859
  1860 				;---------------------------------------
  1861 				; Set DUNITs in all DCBs used by DIR
  1862 				;---------------------------------------
  1863 0D14			DIR_INIT:
  1864 				;---------------------------------------
  1865 0D14 20 1E 0C		        JSR     GET_DOSDR   ; On return, X <- n in Nn:
  1866 0D17 8E 6E 0D		        STX     DIRODCB+1   ; DUNIT for Open
  1867 0D1A 8E 49 09		        STX     STADCB+1    ; DUNIT for Status
  1868 0D1D 8E 09 0D		        STX     DIRRDCB+1   ; DUNIT for Read
  1869 0D20 8E 22 08		        STX     CLODCB+1    ; DUNIT for Close
  1870 0D23 60			        RTS
  1871
  1872 				;---------------------------------------
  1873 0D24			DIR_OPEN:
  1874 				;---------------------------------------
  1875 0D24 20 18 14		        JSR     PREPEND_DRIVE
  1876
  1877 				    ;-----------------------------------
  1878 				    ; Default to arg1
  1879 				    ;-----------------------------------
  1880 0D27 A6 F3		        LDX     INBUFF
  1881 0D29 A4 F4		        LDY     INBUFF+1
  1882
  1883 				    ;-----------------------------------
  1884 				    ; But use Nn:*.* if no arg1
  1885 				    ;-----------------------------------
  1886 0D2B AD 78 0B		        LDA     CMDSEP          ; 0 means no arg1
  1887 0D2E D0 0C		        BNE     DIR_OPEN_NEXT   ; If arg1 present then skip
  1888
  1889 				    ;-----------------------------------
  1890 				    ; Here if no arg1
  1891 				    ;-----------------------------------
  1892 0D30 A2 66		        LDX     #<DIR_OPEN_STR
  1893 0D32 A0 0D		        LDY     #>DIR_OPEN_STR
  1894
  1895 0D34 AD BF 15		        LDA     DOSDR
  1896 0D37 09 30		        ORA     #'0'            ; Convert, say, 1 to '1'
  1897 0D39 8D 67 0D		        STA     DIR_OPEN_STR+1  ; Inject DOSDR into string
  1898
  1899 0D3C			DIR_OPEN_NEXT:
  1900 0D3C 8E 71 0D		        STX     DIRODCB+4       ; DBUFL
  1901 0D3F 8C 72 0D		        STY     DIRODCB+5       ; DBUFH
  1902
  1903 0D42 A9 6D		        LDA     #<DIRODCB
  1904 0D44 A0 0D		        LDY     #>DIRODCB
  1905 0D46 4C A5 07		        JMP     DOSIOV
  1906
  1907 				;---------------------------------------
  1908 0D49			DIR_ERROR:
  1909 				;---------------------------------------
  1910 0D49 A9 53		        LDA     #<DIR_ERROR_STR
  1911 0D4B A0 0D		        LDY     #>DIR_ERROR_STR
  1912 0D4D 20 7B 0A		        JSR     PRINT_STRING
  1913 0D50 A0 01		        LDY     #$01            ; Return error
  1914 0D52 60			        RTS
  1915
  1916 0D53			DIR_ERROR_STR:
  1917 0D53 55 4E 41 42 4C 45 +         .BYTE   'UNABLE TO READ DIR',EOL
  1918
  1919 0D66			DIR_OPEN_STR:
  1920 0D66 4E 20 3A 2A 2E 2A +         .BYTE   'N :*.*',EOL
  1921
  1922 0D6D			DIRODCB:
  1923 0D6D 71			        .BYTE   DEVIDN          ; DDEVIC
  1924 0D6E FF			        .BYTE   $FF             ; DUNIT
  1925 0D6F 4F			        .BYTE   'O'             ; DCOMND
  1926 0D70 80			        .BYTE   $80             ; DSTATS
  1927 0D71 FF			        .BYTE   $FF             ; DBUFL
  1928 0D72 FF			        .BYTE   $FF             ; DBUFH
  1929 0D73 1F			        .BYTE   $1F             ; DTIMLO
  1930 0D74 00			        .BYTE   $00             ; DRESVD
  1931 0D75 00			        .BYTE   $00             ; DBYTL
  1932 0D76 01			        .BYTE   $01             ; DBYTH
  1933 0D77 06			        .BYTE   $06             ; DAUX1
  1934 0D78 80			        .BYTE   $80             ; DAUX2 (Long Dir)
  1935
  1936 				; End of DIR_OPEN
  1937 				;---------------------------------------
  1938
  1939 				;---------------------------------------
  1940 0D79			DIR_PRINT:
  1941 				;---------------------------------------
  1942 				        ; Print results using CIO
  1943 0D79 A2 00		        LDX     #$00
  1944 0D7B A9 0B		        LDA     #PUTCHR
  1945 0D7D 9D 42 03		        STA     ICCOM,X
  1946
  1947 				        ; Fill out buffer loc
  1948 0D80 A9 00		        LDA     #<RBUF
  1949 0D82 9D 44 03		        STA     ICBAL,X
  1950 0D85 A9 16		        LDA     #>RBUF
  1951 0D87 9D 45 03		        STA     ICBAH,X
  1952
  1953 				        ; Fill out size loc
  1954 0D8A AD 10 0D		        LDA     DIRRDCB+8
  1955 0D8D 9D 48 03		        STA     ICBLL,X
  1956 0D90 8A			        TXA
  1957 0D91 9D 49 03		        STA     ICBLH,X
  1958 0D94 4C 56 E4		        JMP     CIOV
  1959
  1960 				;---------------------------------------
  1961 0D97			DIR_CLOSE:
  1962 				;---------------------------------------
  1963 				        ; Close
  1964 0D97 A9 21		        LDA     #<CLODCB
  1965 0D99 A0 08		        LDY     #>CLODCB
  1966 0D9B 4C A5 07		        JMP     DOSIOV
  1967
  1968 				;---------------------------------------
  1969 0D9E			DO_LOAD:
  1970 				;---------------------------------------
  1971 				    ; Binary Loader based on work by Richard J. Kalagher 07-AUG-1983
  1972
  1973 				    ; Open file
  1974 0D9E AD 78 0B		        LDA     CMDSEP          ; Quit if no arg1
  1975 0DA1 D0 03		        BNE     LOAD_NEXT1
  1976 0DA3 4C FF 0F		        JMP     LOAD_ERROR
  1977
  1978 0DA6			LOAD_NEXT1:
  1979 				    ; Point INBUFF to start of filename
  1980 0DA6 18			        CLC
  1981 0DA7 65 F3		        ADC     INBUFF          ; [A] contains offset to arg1
  1982 0DA9 85 F3		        STA     INBUFF
  1983 0DAB 90 02		        BCC     LOAD_NEXT2
  1984 0DAD E6 F4		        INC     INBUFF+1
  1985
  1986 0DAF			LOAD_NEXT2:
  1987 0DAF 20 2C 0E		        JSR     LOAD_NTRANS     ; Disable any EOL transation
  1988 0DB2 20 E8 0D		        JSR     LOAD_SETUP      ; Set up run and init to RTS
  1989 0DB5 A9 04		        LDA     #OINPUT         ; A arg needed in LOAD_OPEN
  1990 0DB7 20 FE 0D		        JSR     LOAD_OPEN       ; Open the file
  1991 0DBA C0 01		        CPY     #$01            ; Quit if unable to open
  1992 0DBC D0 29		        BNE     R
  1993 0DBE 20 3A 0E		GETFIL: JSR     LOAD_READ2      ; Get two bytes (binary header)
  1994 0DC1 20 F3 0D		        JSR     LOAD_INIT       ; Set init default
  1995 0DC4 20 61 0E		        JSR     LOAD_CHKFF      ; Check if header (and start addr, too)
  1996 0DC7 20 84 0E		        JSR     LOAD_STRAD      ; Put start address in
  1997 0DCA 20 3A 0E		        JSR     LOAD_READ2      ; Get to more butes (end addr)
  1998 0DCD 20 91 0E		        JSR     LOAD_ENDAD      ; Put end address in
  1999 0DD0 20 9E 0E		        JSR     LOAD_BUFLEN     ; Calculate buffer length
  2000 0DD3 20 C3 0E		        JSR     LOAD_GETDAT     ; Get the data record
  2001 0DD6 10 03		        BPL     @+
  2002 0DD8 20 E4 0D		        JSR     JSTART
  2003 0DDB 20 E1 0D		@:      JSR     JINIT           ; Attempt initialization
  2004 0DDE 4C BE 0D		        JMP     GETFIL
  2005 0DE1 6C E2 02		JINIT:  JMP     (INITAD)        ; Will either RTS or perform INIT
  2006 0DE4			JSTART: ;JSR     JINIT           ; Some binfiles launch from INITAD
  2007 0DE4 6C E0 02		        JMP     (RUNAD)         ; Godspeed.
  2008
  2009 0DE7 60			R:      RTS                     ; Stunt-double for (INITAD),(RUNAD)
  2010
  2011 				;---------------------------------------
  2012 0DE8			LOAD_SETUP:
  2013 				;---------------------------------------
  2014 0DE8 A9 E7		        LDA     #<R
  2015 0DEA 8D E0 02		        STA     RUNAD
  2016 0DED A9 0D		        LDA     #>R
  2017 0DEF 8D E1 02		        STA     RUNAD+1
  2018 0DF2 60			        RTS
  2019
  2020 				;---------------------------------------
  2021 0DF3			LOAD_INIT:
  2022 				;---------------------------------------
  2023 0DF3 A9 E7		        LDA     #<R
  2024 0DF5 8D E2 02		        STA     INITAD
  2025 0DF8 A9 0D		        LDA     #>R
  2026 0DFA 8D E3 02		        STA     INITAD+1
  2027 0DFD 60			        RTS
  2028
  2029
  2030 				;---------------------------------------
  2031 0DFE			LOAD_OPEN:
  2032 				;---------------------------------------
  2033 0DFE 48			        PHA                     ; A = data direction (4=in, 8=out)
  2034 0DFF 20 1E 0C		        JSR     GET_DOSDR       ; Get DUNIT
  2035 0E02 8E 01 08		        STX     OPNDCB+1        ; Set DUNIT
  2036 0E05 8E 83 08		        STX     GETDCB+1        ; Set DUNIT FOR READ
  2037 0E08 20 18 14		        JSR     PREPEND_DRIVE
  2038
  2039 0E0B A5 F3		        LDA     INBUFF          ; Register location of filename
  2040 0E0D 8D 04 08		        STA     OPNDCB+4
  2041 0E10 A5 F4		        LDA     INBUFF+1
  2042 0E12 8D 05 08		        STA     OPNDCB+5
  2043
  2044 0E15 68			        PLA                     ; A = data direction (4=in, 8=out)
  2045 0E16 8D 0A 08		        STA     OPNDCB+10
  2046 0E19 A9 00		        LDA     #$00            ; AUX2: No translation
  2047 0E1B 8D 0B 08		        STA     OPNDCB+11
  2048
  2049 0E1E A9 00		        LDA     #<OPNDCB
  2050 0E20 A0 08		        LDY     #>OPNDCB
  2051
  2052 0E22 20 A5 07		        JSR     DOSIOV
  2053 0E25 48			        PHA
  2054 0E26 20 96 0A		        JSR     PRINT_ERROR
  2055 0E29 68			        PLA
  2056 0E2A A8			        TAY
  2057
  2058 0E2B 60			        RTS
  2059
  2060 				;---------------------------------------
  2061 0E2C			LOAD_NTRANS:
  2062 				;---------------------------------------
  2063 				    ; Disable any EOL transation otherwise
  2064 				    ; binary data will be corrupted during load
  2065 				    ;---------------------------------------
  2066 0E2C 20 1E 0C		        JSR     GET_DOSDR       ; Get DUNIT
  2067 0E2F 8E F8 10		        STX     NTRDCB+1        ; Set DUNIT
  2068 0E32 A9 00		        LDA     #$00
  2069 0E34 8D 02 11		        STA     NTRDCB+11       ; Translation mode (0 = NONE)
  2070 0E37 4C C4 10		        JMP     NTRANS_CALL     ; Reuse code in DO_NTRANS
  2071
  2072 				;---------------------------------------
  2073 0E3A			LOAD_READ2:
  2074 				;---------------------------------------
  2075
  2076 0E3A A9 02		        LDA     #$02
  2077 0E3C 8D 8A 08		        STA     GETDCB+8
  2078 0E3F 8D 8C 08		        STA     GETDCB+10
  2079
  2080 0E42 A9 00		        LDA     #$00
  2081 0E44 8D 8B 08		        STA     GETDCB+9
  2082 0E47 8D 8D 08		        STA     GETDCB+11
  2083
  2084 0E4A A9 82		        LDA     #<GETDCB
  2085 0E4C A0 08		        LDY     #>GETDCB
  2086
  2087 0E4E 20 A5 07		        JSR     DOSIOV
  2088 0E51 20 96 0A		        JSR     PRINT_ERROR
  2089
  2090 0E54 AD 83 08		        LDA     GETDCB+1
  2091 0E57 8D 49 09		        STA     STADCB+1
  2092 0E5A A9 48		        LDA     #<STADCB
  2093 0E5C A0 09		        LDY     #>STADCB
  2094 0E5E 4C A5 07		        JMP     DOSIOV
  2095
  2096 				;---------------------------------------
  2097 0E61			LOAD_CHKFF:
  2098 				;---------------------------------------
  2099 				    ; Check for binary file signature ($FF $FF)
  2100 0E61 AE 00 16		        LDX     BAL
  2101 0E64 E8			        INX
  2102 0E65 F0 01		        BEQ     TEST2
  2103 0E67 60			        RTS
  2104 0E68 AE 01 16		TEST2:  LDX     BAH
  2105 0E6B E8			        INX
  2106 0E6C F0 01		        BEQ     ITSFF
  2107 0E6E 60			        RTS
  2108 0E6F 4C 3A 0E		ITSFF:  JMP     LOAD_READ2  ; Get start address and return
  2109
  2110 				;        LDA     #<LOAD_ERROR_STR2
  2111 				;        LDY     #>LOAD_ERROR_STR2
  2112 				;        JMP     PRINT_STRING
  2113
  2114 0E72			LOAD_ERROR_STR2:
  2115 0E72 4E 4F 54 20 41 20 +         .BYTE   'NOT A BINARY FILE',EOL
  2116
  2117 				;---------------------------------------
  2118 0E84			LOAD_STRAD:
  2119 				;---------------------------------------
  2120 				    ; Save payload start address
  2121 0E84 AD 00 16		        LDA     RBUF
  2122 0E87 8D 80 16		        STA     STL
  2123 0E8A AD 01 16		        LDA     RBUF+1
  2124 0E8D 8D 81 16		        STA     STH
  2125 0E90 60			        RTS
  2126
  2127 				;---------------------------------------
  2128 0E91			LOAD_ENDAD:
  2129 				;---------------------------------------
  2130 				    ; Save payload end address
  2131 0E91 AD 00 16		        LDA     RBUF
  2132 0E94 8D 82 16		        STA     ENL
  2133 0E97 AD 01 16		        LDA     RBUF+1
  2134 0E9A 8D 83 16		        STA     ENH
  2135 0E9D 60			        RTS
  2136
  2137 				;---------------------------------------
  2138 0E9E			LOAD_BUFLEN:
  2139 				;---------------------------------------
  2140 				    ; Calculate buffer length (end-start+1)
  2141
  2142 				    ; Calc buffer size Lo
  2143 0E9E AD 82 16		        LDA     ENL
  2144 0EA1 38			        SEC
  2145 0EA2 ED 80 16		        SBC     STL
  2146 0EA5 8D 84 16		        STA     BLL     ; Buffer Length Lo
  2147
  2148 				    ; Calc buffer size Hi
  2149 0EA8 AD 83 16		        LDA     ENH     ; Calc buffer size Hi
  2150 0EAB ED 81 16		        SBC     STH
  2151 0EAE 8D 85 16		        STA     BLH     ; Buffer Length Hi
  2152
  2153 				    ; Add 1
  2154 0EB1 18			        CLC
  2155 0EB2 AD 84 16		        LDA     BLL
  2156 0EB5 69 01		        ADC     #$01
  2157 0EB7 8D 84 16		        STA     BLL
  2158
  2159 0EBA AD 85 16		        LDA     BLH
  2160 0EBD 69 00		        ADC     #$00    ; Take care of any carry
  2161 0EBF 8D 85 16		        STA     BLH
  2162
  2163 0EC2 60			        RTS
  2164
  2165 				;---------------------------------------
  2166 0EC3			LOAD_GETDAT:
  2167 				;---------------------------------------
  2168 				    ; Definitions:
  2169 				    ; HEAD = requested bytes that will be found in current cache (< 512 bytes)
  2170 				    ; BODY = contiguous 512 byte sections. BODY = n * 512 bytes)
  2171 				    ; TAIL = any bytes remaining after BODY (< 512 bytes)
  2172
  2173 0EC3 20 1E 0C		        JSR     GET_DOSDR
  2174 0EC6 8E E7 0F		        STX     BINDCB+1
  2175
  2176 				    ; Check if bytes requested BL < DVSTAT (bytes waiting in cache)
  2177 0EC9 AD EA 02		        LDA     DVSTAT
  2178 0ECC CD 84 16		        CMP     BLL
  2179 0ECF AD EB 02		        LDA     DVSTAT+1
  2180 0ED2 ED 85 16		        SBC     BLH
  2181 0ED5 B0 4C		        BCS     GETDAT_OPT2     ; BL <= BW (bytes waiting)
  2182
  2183 0ED7			GETDAT_OPT1:
  2184 				    ;--------------------------------
  2185 				    ; Here if bytes requested > bytes 
  2186 				    ; remaining in cache
  2187 				    ;--------------------------------
  2188
  2189 				    ;-------------------------------
  2190 				    ; Head = BW (bytes waiting)
  2191 				    ;-------------------------------
  2192 0ED7 AD EA 02		        LDA     DVSTAT
  2193 0EDA 8D 86 16		        STA     HEADL
  2194 0EDD AD EB 02		        LDA     DVSTAT+1
  2195 0EE0 8D 87 16		        STA     HEADH
  2196
  2197 				    ;-------------------------------
  2198 				    ; Tail = (BL - HEAD) mod 512
  2199 				    ;-------------------------------
  2200 0EE3 38			        SEC
  2201 0EE4 AD 84 16		        LDA     BLL
  2202 0EE7 ED 86 16		        SBC     HEADL
  2203 0EEA 29 FF		        AND     #$FF
  2204 0EEC 8D 8A 16		        STA     TAILL
  2205 0EEF AD 85 16		        LDA     BLH
  2206 0EF2 ED 87 16		        SBC     HEADH
  2207 0EF5 29 01		        AND     #$01
  2208 0EF7 8D 8B 16		        STA     TAILH
  2209
  2210 				    ;-----------------------------------
  2211 				    ; Body = BL - HEAD - TAIL
  2212 				    ;-----------------------------------
  2213 				        ; 1. Body = BL - HEAD
  2214 				        ;-------------------------------
  2215 0EFA 38			        SEC
  2216 0EFB AD 84 16		        LDA     BLL
  2217 0EFE ED 86 16		        SBC     HEADL
  2218 0F01 8D 88 16		        STA     BODYL
  2219 0F04 AD 85 16		        LDA     BLH
  2220 0F07 ED 87 16		        SBC     HEADH
  2221 0F0A 8D 89 16		        STA     BODYH
  2222
  2223 				        ;-------------------------------
  2224 				        ; 2. Body = Body - HEAD
  2225 				        ;-------------------------------
  2226 0F0D 38			        SEC
  2227 0F0E AD 88 16		        LDA     BODYL
  2228 0F11 ED 8A 16		        SBC     TAILL
  2229 0F14 8D 88 16		        STA     BODYL
  2230 0F17 AD 89 16		        LDA     BODYH
  2231 0F1A ED 8B 16		        SBC     TAILH
  2232 0F1D 8D 89 16		        STA     BODYH
  2233
  2234 0F20 4C 3D 0F		        JMP     GETDAT_READ
  2235
  2236 0F23			GETDAT_OPT2:
  2237 				    ;--------------------------------
  2238 				    ; Here if bytes requested <= bytes 
  2239 				    ; remaining in cache
  2240 				    ;--------------------------------
  2241 				    ; Head = BL, TAIL = BODY = 0
  2242 				    ;--------------------------------
  2243 0F23 AD 84 16		        LDA     BLL
  2244 0F26 8D 86 16		        STA     HEADL
  2245 0F29 AD 85 16		        LDA     BLH
  2246 0F2C 8D 87 16		        STA     HEADH
  2247 0F2F A9 00		        LDA     #$00
  2248 0F31 8D 8A 16		        STA     TAILL
  2249 0F34 8D 8B 16		        STA     TAILH
  2250 0F37 8D 88 16		        STA     BODYL
  2251 0F3A 8D 89 16		        STA     BODYH
  2252
  2253 				;---------------------------------------
  2254 0F3D			GETDAT_READ:
  2255 				;---------------------------------------
  2256 				    ;---------------------------------------
  2257 				    ; Read HEAD bytes
  2258 				    ;---------------------------------------
  2259 0F3D AD 86 16		        LDA     HEADL
  2260 0F40 8D 84 16		        STA     BLL
  2261 0F43 AD 87 16		        LDA     HEADH
  2262 0F46 8D 85 16		        STA     BLH
  2263 0F49 20 7D 0F		        JSR     GETDAT_DOSIOV
  2264 0F4C 10 01		        BPL     GETDAT_BODY ; Skip ahead if no problems
  2265 0F4E 60			        RTS                 ; Bail if error
  2266
  2267 				    ;---------------------------------------
  2268 				    ; Read BODY bytes
  2269 				    ;---------------------------------------
  2270 0F4F			GETDAT_BODY:
  2271 0F4F AE 89 16		        LDX     BODYH
  2272 0F52			GETDAT_BODY_LOOP:
  2273 0F52 F0 1A		        BEQ     GETDAT_TAIL ; Skip if less than a page to read
  2274
  2275 0F54 A9 00		        LDA     #$00
  2276 0F56 8D 84 16		        STA     BLL         ; Buffer length
  2277 0F59 A9 02		        LDA     #$02        ; 512 bytes at a time
  2278 0F5B 8D 85 16		        STA     BLH
  2279
  2280 0F5E 8A			        TXA                 ; Stash our loop index (X)
  2281 0F5F 48			        PHA                 ; onto the stack
  2282 0F60 20 7D 0F		        JSR     GETDAT_DOSIOV   
  2283 0F63 10 03		        BPL     @+          ; Skip ahead if no problems
  2284 0F65 68			        PLA                 ; Here if problem. Clean up stack
  2285 0F66 98			        TYA                 ; Reset N status flag before returning
  2286 0F67 60			        RTS                 ; Bail if error
  2287
  2288 0F68 68			@:      PLA                 ; Retrieve our loop index
  2289 0F69 AA			        TAX                 ; and xfer it back into X
  2290 0F6A CA			        DEX                 ; -2 (we pull 0200 bytes at a time)
  2291 0F6B CA			        DEX                 ; 
  2292 0F6C D0 E4		        BNE     GETDAT_BODY_LOOP
  2293
  2294 0F6E			GETDAT_TAIL:
  2295 				    ;---------------------------------------
  2296 				    ; Read TAIL bytes
  2297 				    ;---------------------------------------
  2298 0F6E AD 8A 16		        LDA     TAILL
  2299 0F71 8D 84 16		        STA     BLL
  2300 0F74 AD 8B 16		        LDA     TAILH
  2301 0F77 8D 85 16		        STA     BLH
  2302 0F7A 4C 7D 0F		        JMP     GETDAT_DOSIOV
  2303
  2304 				;---------------------------------------
  2305 0F7D			GETDAT_DOSIOV:
  2306 				;---------------------------------------
  2307 				    ; Bail if BL = 0
  2308 0F7D AD 84 16		        LDA     BLL
  2309 0F80 D0 05		        BNE     @+
  2310 0F82 AD 85 16		        LDA     BLH
  2311 0F85 F0 5C		        BEQ     GETDAT_DONE
  2312
  2313 0F87			@:
  2314 				    ; SIO READ
  2315 0F87 AD 80 16		        LDA     STL
  2316 0F8A 8D EA 0F		        STA     BINDCB+4    ; Start Address Lo
  2317 0F8D AD 81 16		        LDA     STH
  2318 0F90 8D EB 0F		        STA     BINDCB+5    ; Start Address Hi
  2319 0F93 AD 84 16		        LDA     BLL
  2320 0F96 8D EE 0F		        STA     BINDCB+8    ; Buffer Size Lo
  2321 0F99 8D F0 0F		        STA     BINDCB+10
  2322 0F9C AD 85 16		        LDA     BLH
  2323 0F9F 8D EF 0F		        STA     BINDCB+9    ; Buffer Size Hi
  2324 0FA2 8D F1 0F		        STA     BINDCB+11
  2325
  2326 				    ;---------------------------------------
  2327 				    ; Send Read request to SIO
  2328 				    ;---------------------------------------
  2329 0FA5 A9 E6		        LDA     #<BINDCB
  2330 0FA7 A0 0F		        LDY     #>BINDCB
  2331 0FA9 20 A5 07		        JSR     DOSIOV
  2332 0FAC 20 96 0A		        JSR     PRINT_ERROR
  2333
  2334 				        ; Note: STADCB+1 SET DURING READ2
  2335 0FAF A9 48		        LDA     #<STADCB
  2336 0FB1 A0 09		        LDY     #>STADCB
  2337 0FB3 20 A5 07		        JSR     DOSIOV
  2338
  2339 				    ; Advance Starting Address
  2340 				    ; ST = ST + PAYLOAD
  2341 0FB6 18			        CLC
  2342 0FB7 AD 80 16		        LDA     STL
  2343 0FBA 6D 84 16		        ADC     BLL
  2344 0FBD 8D 80 16		        STA     STL
  2345
  2346 0FC0 AD 81 16		        LDA     STH
  2347 0FC3 6D 85 16		        ADC     BLH
  2348 0FC6 8D 81 16		        STA     STH
  2349
  2350 0FC9			GETDAT_DOSIOV_DONE:
  2351 				    ; Skip if no bytes left to read
  2352 0FC9 AD EA 02		        LDA     DVSTAT
  2353 0FCC D0 15		        BNE     GETDAT_DONE
  2354 0FCE AD EB 02		        LDA     DVSTAT+1
  2355 0FD1 F0 06		        BEQ     @+
  2356
  2357 				    ; If at the start of a new case (Bytes waiting = 0200)
  2358 0FD3 C9 02		        CMP     #$02
  2359 0FD5 F0 02		        BEQ     @+
  2360 0FD7 D0 0A		        BNE     GETDAT_DONE
  2361 0FD9 A9 88		@:      LDA     #EOF        ; 
  2362 0FDB CD ED 02		        CMP     DVSTAT+3    ; Is status EOF?
  2363 0FDE D0 03		        BNE     GETDAT_DONE ; No?  Return 1
  2364 0FE0 A0 FF		        LDY     #$FF        ; Yes? Return -1
  2365 0FE2			GETDAT_RTS:
  2366 0FE2 60			        RTS
  2367
  2368 0FE3			GETDAT_DONE:        
  2369 0FE3 A0 01		        LDY     #$01        ; Return 0
  2370 0FE5 60			        RTS
  2371
  2372 0FE6			BINDCB:
  2373 0FE6 71			       .BYTE    DEVIDN      ; DDEVIC
  2374 0FE7 FF			       .BYTE    $FF         ; DUNIT
  2375 0FE8 52			       .BYTE    'R'         ; DCOMND
  2376 0FE9 40			       .BYTE    $40         ; DSTATS
  2377 0FEA FF			       .BYTE    $FF         ; DBUFL
  2378 0FEB FF			       .BYTE    $FF         ; DBUFH
  2379 0FEC 0F			       .BYTE    $0F         ; DTIMLO
  2380 0FED 00			       .BYTE    $00         ; DRESVD
  2381 0FEE FF			       .BYTE    $FF         ; DBYTL
  2382 0FEF FF			       .BYTE    $FF         ; DBYTH
  2383 0FF0 FF			       .BYTE    $FF         ; DAUX1
  2384 0FF1 FF			       .BYTE    $FF         ; DAUX2
  2385
  2386
  2387 				;---------------------------------------
  2388 0FF2			LOAD_CLOSE
  2389 				;---------------------------------------
  2390 0FF2 AD E7 0F		        LDA     BINDCB+1
  2391 0FF5 8D 22 08		        STA     CLODCB+1
  2392 0FF8 A9 21		        LDA     #<CLODCB
  2393 0FFA A0 08		        LDY     #>CLODCB
  2394 0FFC 4C A5 07		        JMP     DOSIOV
  2395
  2396 				;---------------------------------------
  2397 0FFF			LOAD_ERROR:
  2398 				;---------------------------------------
  2399 0FFF A9 B9		        LDA     #<MISSING_FILE_STR
  2400 1001 A0 15		        LDY     #>MISSING_FILE_STR
  2401 1003 4C 7B 0A		        JMP     PRINT_STRING
  2402
  2403 				;---------------------------------------
  2404 1006			DO_LOCK:
  2405 				;---------------------------------------
  2406 1006 A9 60		        LDA     #$60
  2407 1008 8D C6 02		        STA     COLOR2
  2408 100B 60			        RTS
  2409
  2410 				;---------------------------------------
  2411 100C			DO_LOGIN:
  2412 				;---------------------------------------
  2413 100C AE 78 0B		        LDX     CMDSEP          ; Check if there's any args
  2414 100F F0 01		        BEQ     LOGIN_ERROR    ; No. Show usage and quit
  2415
  2416 1011 60			        RTS
  2417
  2418 1012			LOGIN_ERROR:
  2419 1012 A9 19		        LDA     #<LOGIN_ERROR_STR
  2420 1014 A0 10		        LDY     #>LOGIN_ERROR_STR
  2421 1016 4C 7B 0A		        JMP     PRINT_STRING
  2422
  2423 1019			LOGIN_ERROR_STR:
  2424 1019 4C 4F 47 49 4E 20 +         .BYTE   'LOGIN [N[n]:] <USERNAME> <PASSWORD>',EOL
  2425 				;---------------------------------------
  2426 103D			DO_NPWD:
  2427 				;---------------------------------------
  2428 103D A9 9B		        LDA     #EOL        ; Truncate buffer
  2429 103F 8D 00 16		        STA     RBUF
  2430
  2431 1042 20 1E 0C		        JSR     GET_DOSDR   ; X will contain n in Nn:
  2432 1045 8E 75 10		        STX     PWDDCB+1
  2433
  2434 1048 A9 74		        LDA     #<PWDDCB
  2435 104A A0 10		        LDY     #>PWDDCB
  2436 104C 20 A5 07		        JSR     DOSIOV
  2437 104F 20 96 0A		        JSR     PRINT_ERROR
  2438
  2439 				    ;---------------------------------------
  2440 				    ; If we entered DO_NPWD from REMOUNT_DRIVE
  2441 				    ; then scipt printing output
  2442 				    ;---------------------------------------
  2443 1052 AD C1 15		        LDA     CMDPRV
  2444 1055 C9 03		        CMP     #CMD_IDX.DEL
  2445 1057 F0 1A		        BEQ     NPWD_DONE
  2446 1059 C9 0A		        CMP     #CMD_IDX.RENAME
  2447 105B F0 16		        BEQ     NPWD_DONE
  2448
  2449 105D			NPWD_LOOP:
  2450 105D A9 00		        LDA     #<RBUF
  2451 105F A0 16		        LDY     #>RBUF
  2452 1061 20 7B 0A		        JSR     PRINT_STRING
  2453
  2454 1064 A9 48		        LDA     #<STADCB
  2455 1066 A0 09		        LDY     #>STADCB
  2456 1068 20 A5 07		        JSR     DOSIOV
  2457 106B 20 96 0A		        JSR     PRINT_ERROR
  2458
  2459 				    ;---------------------------------------
  2460 				    ; Loop if more data to read
  2461 				    ;---------------------------------------
  2462 106E AD EB 02		        LDA     DVSTAT+1    ; Was there more to read (that is, was hi>0)?
  2463 1071 D0 EA		        BNE     NPWD_LOOP   ; If yes, then do it again
  2464
  2465 1073			NPWD_DONE:
  2466 1073 60			        RTS
  2467
  2468 1074			PWDDCB:
  2469 1074 71			        .BYTE      DEVIDN  ; DDEVIC
  2470 1075 FF			        .BYTE      $FF     ; DUNIT
  2471 1076 30			        .BYTE      $30     ; DCOMND
  2472 1077 40			        .BYTE      $40     ; DSTATS
  2473 1078 00			        .BYTE      <RBUF   ; DBUFL
  2474 1079 16			        .BYTE      >RBUF   ; DBUFH
  2475 107A 1F			        .BYTE      $1F     ; DTIMLO
  2476 107B 00			        .BYTE      $00     ; DRESVD
  2477 107C 00			        .BYTE      $00     ; DBYTL
  2478 107D 01			        .BYTE      $01     ; DBYTH
  2479 107E 00			        .BYTE      $00     ; DAUX1
  2480 107F 00			        .BYTE      $00     ; DAUX2
  2481
  2482 				; End of DO_NPWD
  2483 				;---------------------------------------
  2484
  2485 				.ifdef SYNCALC
  2486 					:($129B-*) DTA $00
  2487 				.endif
  2488
  2489 				.ifndef SYNCALD
  2490 				;---------------------------------------
  2491 1080			DO_NTRANS:
  2492 				;---------------------------------------
  2493 1080 AE 78 0B		        LDX     CMDSEP          ; Check if there's any args
  2494 1083 F0 49		        BEQ     NTRANS_ERROR    ; No. Show usage and quit
  2495
  2496 1085 AD BF 15		        LDA     DOSDR           ; Go with current drive for now
  2497 1088 8D F8 10		        STA     NTRDCB+1        ; it'll be overwritten later if req'd
  2498
  2499 				    ;---------------------------------------
  2500 				    ; Check for argc = 2
  2501 				    ;---------------------------------------
  2502 108B AC 78 0B		        LDY     CMDSEP          ; Stash offset to arg1 in Y
  2503 108E AE 79 0B		        LDX     CMDSEP+1        ; Is there an arg2?
  2504 1091 F0 21		        BEQ     PARSE_MODE      ; No. parse arg1 as mode (0-3)
  2505
  2506 				    ;---------------------------------------
  2507 				    ; Here if argc = 2 (arg1 = Nn: arg2 = mode)
  2508 				    ;---------------------------------------
  2509 1093 AE 78 0B		        LDX     CMDSEP          ; Get offset to arg1 (Nn:)
  2510 1096 BD 82 05		        LDA     LNBUF,X         ; Is arg1's (N[n]:) 1st char = 'N'?
  2511 1099 C9 4E		        CMP     #'N'            ;
  2512 109B D0 31		        BNE     NTRANS_ERROR    ; No? Then quit
  2513 109D BD 83 05		        LDA     LNBUF+1,X
  2514 10A0 C9 3A		        CMP     #':'            ; Is arg1's (N[n]:) 2nd char = ':'?
  2515 10A2 F0 10		        BEQ     PARSE_MODE      ; Yes, stick with default drive
  2516
  2517 				    ;---------------------------------------
  2518 				    ; Parse drive number
  2519 				    ;---------------------------------------
  2520 10A4 C9 31		        CMP     #'1'            ; Quit if n in Nn not 1..4
  2521 10A6 90 26		        BCC     NTRANS_ERROR    ; Quit if < '1'
  2522 10A8 C9 39		        CMP     #'9'
  2523 10AA B0 22		        BCS     NTRANS_ERROR    ; Quit if >= '9'
  2524 10AC 49 30		        EOR     #%00110000
  2525 10AE 8D F8 10		        STA     NTRDCB+1
  2526 10B1 AC 79 0B		        LDY     CMDSEP+1
  2527
  2528 				    ;---------------------------------------
  2529 				    ; Confirm valid parameter
  2530 				    ;---------------------------------------
  2531 10B4			PARSE_MODE:
  2532 10B4 B9 82 05		        LDA     LNBUF,Y         ; Quit if mode not 0..3
  2533 10B7 C9 30		        CMP     #'0'
  2534 10B9 90 13		        BCC     NTRANS_ERROR
  2535 10BB C9 34		        CMP     #'4'
  2536 10BD B0 0F		        BCS     NTRANS_ERROR
  2537 10BF 49 30		        EOR     #%00110000      ; Here if valid parameter
  2538 10C1 8D 02 11		        STA     NTRDCB+11       ; Assign parameter to DCB
  2539 				.endif
  2540 				; SYNCALD
  2541
  2542 				    ;---------------------------------------
  2543 				    ; Call SIO
  2544 				    ;---------------------------------------
  2545 10C4			NTRANS_CALL:
  2546 10C4 A9 F7		        LDA     #<NTRDCB
  2547 10C6 A0 10		        LDY     #>NTRDCB
  2548 10C8 20 A5 07		        JSR     DOSIOV
  2549 10CB 4C 96 0A		        JMP     PRINT_ERROR
  2550
  2551 10CE			NTRANS_ERROR:
  2552 10CE A9 D5		        LDA     #<NTRANS_ERROR_STR
  2553 10D0 A0 10		        LDY     #>NTRANS_ERROR_STR
  2554 10D2 4C 7B 0A		        JMP     PRINT_STRING
  2555
  2556 10D5			NTRANS_ERROR_STR:
  2557 10D5 4D 4F 44 45 3F 20 +         .BYTE   'MODE? 0=NONE, 1=CR, 2=LF, 3=CR/LF',EOL
  2558
  2559 10F7			NTRDCB:
  2560 10F7 71			        .BYTE      DEVIDN  ; DDEVIC
  2561 10F8 FF			        .BYTE      $FF     ; DUNIT
  2562 10F9 54			        .BYTE      'T'     ; DCOMND
  2563 10FA 00			        .BYTE      $00     ; DSTATS
  2564 10FB 00			        .BYTE      $00     ; DBUFL
  2565 10FC 00			        .BYTE      $00     ; DBUFH
  2566 10FD 1F			        .BYTE      $1F     ; DTIMLO
  2567 10FE 00			        .BYTE      $00     ; DRESVD
  2568 10FF 00			        .BYTE      $00     ; DBYTL
  2569 1100 00			        .BYTE      $00     ; DBYTH
  2570 1101 00			        .BYTE      $00     ; DAUX1
  2571 1102 00			        .BYTE      $00     ; DAUX2
  2572
  2573 				; End of DO_NTRANS
  2574 				;---------------------------------------
  2575
  2576 				.ifndef SYNCALD
  2577 				;---------------------------------------
  2578 1103			DO_SUBMIT:
  2579 				;---------------------------------------
  2580 1103 AD 78 0B		        LDA     CMDSEP
  2581 1106 D0 07		        BNE     SUBMIT_NEXT1
  2582
  2583 				    ; Filename required
  2584 1108 A9 B9		        LDA     #<MISSING_FILE_STR
  2585 110A A0 15		        LDY     #>MISSING_FILE_STR
  2586 110C 4C 7B 0A		        JMP     PRINT_STRING
  2587
  2588 110F			SUBMIT_NEXT1:
  2589
  2590 				    ; Default to NOSCREEN
  2591 110F A9 00		        LDA     #$00
  2592 1111 8D C2 15		        STA     CURSCR
  2593
  2594 				    ; Prep file path
  2595 1114 20 1E 0C		        JSR     GET_DOSDR       ; Get DUNIT
  2596 1117 20 18 14		        JSR     PREPEND_DRIVE
  2597
  2598 				    ; Assert FILE #1 is closed
  2599 111A A2 10		        LDX     #$10
  2600 111C 20 BB 09		        JSR     CIOCLOSE
  2601 				        
  2602 				    ; OPEN #1, 4, 0, file path
  2603 111F A2 10		        LDX     #$10            ; File #1
  2604 1121 A0 04		        LDY     #$04            ; Open for input
  2605 1123 20 C3 09		        JSR     CIOOPEN         ; Open filename @ (INBUFF)
  2606 1126 10 03		        BPL     SUBMIT_NEXT2
  2607 1128 4C 96 0A		        JMP     PRINT_ERROR
  2608
  2609 112B			SUBMIT_NEXT2:
  2610 112B 20 64 0A		        JSR     LDBUFA      ; Reset INBUFF to $0580
  2611 112E A9 FF		        LDA     #$FF        ; Clear command
  2612 1130 8D C0 15		        STA     CMD
  2613
  2614 				    ; INPUT #1, INBUFF
  2615 1133 A2 10		        LDX     #$10
  2616 1135 A0 04		        LDY     #$04
  2617 1137 20 29 0A		        JSR     CIOGETREC
  2618
  2619 				    ; Check for error
  2620 113A A2 10		        LDX     #$10
  2621 113C BD 43 03		        LDA     ICSTA,X
  2622 113F C9 88		        CMP     #EOF
  2623 1141 F0 1F		        BEQ     SUBMIT_DONE ; No error, try parsing cmd
  2624
  2625 1143			SUBMIT_NEXT3:
  2626 1143 AD C2 15		        LDA     CURSCR      ; Skip echo if SCREEN is disabled
  2627 1146 F0 0E		        BEQ     SUBMIT_NEXT4
  2628 1148 AD 82 05		        LDA     LNBUF
  2629 114B C9 40		        CMP     #'@'
  2630 114D F0 07		        BEQ     SUBMIT_NEXT4
  2631
  2632 				    ; Echo commands
  2633 114F A5 F3		        LDA     INBUFF
  2634 1151 A4 F4		        LDY     INBUFF+1
  2635 1153 20 7B 0A		        JSR     PRINT_STRING
  2636
  2637 1156			SUBMIT_NEXT4:
  2638 1156 20 26 0B		        JSR     GETCMDTEST
  2639 1159 20 7C 0B		        JSR     PARSECMD
  2640 115C 20 F2 0B		        JSR     DOCMD
  2641 115F 38			        SEC
  2642 1160 B0 C9		        BCS     SUBMIT_NEXT2
  2643
  2644 1162			SUBMIT_DONE
  2645 1162 A2 10		        LDX     #$10
  2646 1164 4C BB 09		        JMP     CIOCLOSE
  2647
  2648 				; End of DO_SUBMIT
  2649 				;---------------------------------------
  2650
  2651 				;---------------------------------------
  2652 1167			DO_TYPE:
  2653 				;---------------------------------------
  2654 1167 AD 78 0B		        LDA     CMDSEP
  2655 116A D0 07		        BNE     TYPE_SKIP
  2656
  2657 116C			TYPE_USAGE:
  2658 116C A9 B9		        LDA     #<MISSING_FILE_STR
  2659 116E A0 15		        LDY     #>MISSING_FILE_STR
  2660 1170 4C 7B 0A		        JMP     PRINT_STRING
  2661
  2662 1173			TYPE_SKIP:
  2663 1173 20 1E 0C		        JSR     GET_DOSDR       ; Get DUNIT
  2664 1176 20 18 14		        JSR     PREPEND_DRIVE
  2665
  2666 				    ; Assert input file closed
  2667 1179 A2 10		        LDX     #$10            ; File #1
  2668 117B 20 BB 09		        JSR     CIOCLOSE        ; Assert file #1 is closed
  2669
  2670 				    ; Open input file
  2671 117E A2 10		        LDX     #$10            ; File #1
  2672 1180 A0 04		        LDY     #$04            ; Open for input
  2673 1182 20 C3 09		        JSR     CIOOPEN         ; Open filename @ (INBUFF)
  2674 1185 10 08		        BPL     TYPE_NEXT
  2675
  2676 				    ; If open failed, Print error
  2677 1187 A2 10		        LDX     #$10            ; File #1
  2678 1189 BC 43 03		        LDY     ICSTA,X
  2679 118C 4C 96 0A		        JMP     PRINT_ERROR
  2680
  2681 118F			TYPE_NEXT:
  2682
  2683 				    ; Initialize pagination
  2684 118F 20 34 12		        JSR     DO_CLS
  2685 1192 A9 15		        LDA     #21
  2686 1194 8D BB 02		        STA     SCRFLG
  2687
  2688 1197			TYPE_LOOP:
  2689 				    ; Bail if ESC key is pressed
  2690 1197 AD FC 02		        LDA     CH
  2691 119A C9 1C		        CMP     #ESC_KEY
  2692 119C F0 49		        BEQ     TYPE_DONE
  2693
  2694 				    ; Check if page is full
  2695 119E AD BB 02		        LDA     SCRFLG
  2696 11A1 C9 16		        CMP     #22         ; if SCRFLG < 21
  2697 11A3 90 14		        BCC     TYPE_READ   ; then skip to read
  2698
  2699 				    ; Here if page is full
  2700 				    ; Wait for keypress
  2701 11A5 A9 FF		        LDA     #$FF    ; Clear keypress
  2702 11A7 8D FC 02		        STA     CH
  2703
  2704 11AA			TYPE_WAIT:
  2705 11AA AE FC 02		        LDX     CH
  2706 11AD E8			        INX
  2707 11AE F0 FA		        BEQ     TYPE_WAIT
  2708
  2709 11B0 E0 1C		        CPX     #ESC_KEY
  2710 11B2 F0 33		        BEQ     TYPE_DONE
  2711
  2712 				    ; Reset pagination
  2713 11B4 A9 00		        LDA     #$00
  2714 11B6 8D BB 02		        STA     SCRFLG
  2715
  2716 11B9			TYPE_READ:
  2717 				    ; Read from file
  2718 11B9 A2 10		        LDX     #$10
  2719 11BB A9 01		        LDA     #$01
  2720 11BD A0 00		        LDY     #$00
  2721 11BF 20 ED 09		        JSR     CIOGET
  2722
  2723 				    ; Quit if EOF
  2724 11C2 A2 10		        LDX     #$10
  2725 11C4 BD 43 03		        LDA     ICSTA,X
  2726 11C7 C9 88		        CMP     #EOF
  2727 11C9 F0 1C		        BEQ     TYPE_DONE
  2728
  2729 				    ; Convert CRLF or LF --> EOL
  2730 11CB A0 00		        LDY     #$00
  2731 11CD B1 F3		        LDA     (INBUFF),Y
  2732 11CF C9 0D		        CMP     #CR     ; Skip CR
  2733 11D1 F0 11		        BEQ     TYPE_NEXT3
  2734 11D3 C9 0A		        CMP     #LF     ; Convert LF --> EOL
  2735 11D5 D0 04		        BNE     TYPE_NEXT2
  2736 11D7 A9 9B		        LDA     #EOL
  2737 11D9 91 F3		        STA     (INBUFF),Y
  2738
  2739 11DB			TYPE_NEXT2:
  2740 				    ; Write to screen
  2741 11DB A2 00		        LDX     #$00
  2742 11DD A9 01		        LDA     #$01
  2743 11DF A0 00		        LDY     #$00
  2744 11E1 20 0B 0A		        JSR     CIOPUT
  2745
  2746 11E4			TYPE_NEXT3:
  2747 				    ; Do next
  2748 11E4 4C 97 11		        JMP     TYPE_LOOP
  2749 				        
  2750 11E7			TYPE_DONE:
  2751 11E7 A9 FF		        LDA     #$FF
  2752 11E9 8D FC 02		        STA     CH
  2753 11EC A2 10		        LDX     #$10            ; Close File #1
  2754 11EE 4C BB 09		        JMP     CIOCLOSE        ; 
  2755
  2756 11F1			TYPE_OPEN_ERR_STR:
  2757 11F1 55 4E 41 42 4C 45 +         .BYTE   'UNABLE TO OPEN FILE',EOL
  2758
  2759 				;---------------------------------------
  2760 1205			DO_UNLOCK:
  2761 				;---------------------------------------
  2762 1205 A9 90		        LDA     #$90
  2763 1207 8D C6 02		        STA     COLOR2
  2764 120A 60			        RTS
  2765
  2766 				;---------------------------------------
  2767 120B			DO_CAR:
  2768 				;---------------------------------------
  2769
  2770 				    ;---------------------------------------
  2771 				    ; Is cart address space RAM or ROM?
  2772 				    ;---------------------------------------
  2773 120B AD 00 A0		        LDA     $A000
  2774 120E EE 00 A0		        INC     $A000
  2775 1211 CD 00 A0		        CMP     $A000
  2776 1214 F0 0A		        BEQ     DO_CAR_NEXT
  2777
  2778 				    ;---------------------------------------
  2779 				    ; RAM found
  2780 				    ;---------------------------------------
  2781 1216 8D 00 A0		        STA     $A000
  2782 1219 A9 27		        LDA     #<DO_CAR_ERR
  2783 121B A0 12		        LDY     #>DO_CAR_ERR
  2784 121D 4C 7B 0A		        JMP     PRINT_STRING
  2785
  2786 1220			DO_CAR_NEXT
  2787 1220 A9 FF		        LDA     #$FF
  2788 1222 85 08		        STA     $08         ; Warmstart
  2789 1224 6C FA BF		        JMP     ($BFFA)
  2790
  2791 1227			DO_CAR_ERR:
  2792 1227 4E 4F 20 43 41 52 +         .BYTE   'NO CARTRIDGE',EOL
  2793
  2794 				;---------------------------------------
  2795 1234			DO_CLS:
  2796 				;---------------------------------------
  2797 1234 A9 3B		        LDA     #<CLS_STR
  2798 1236 A0 12		        LDY     #>CLS_STR
  2799 1238 4C 7B 0A		        JMP     PRINT_STRING
  2800
  2801 123B			CLS_STR:
  2802 123B 7D 9B		        .BYTE   125,EOL
  2803
  2804 				;---------------------------------------
  2805 123D			DO_COLD:
  2806 				;---------------------------------------
  2807 123D 4C 77 E4		        JMP     COLDSV
  2808
  2809 				.endif
  2810 				; SYNCALD
  2811 				.ifndef SYNCALC
  2812
  2813 				;---------------------------------------
  2814 1240			DO_HELP:
  2815 				;---------------------------------------
  2816 				    ; Append either "HELP" or arg1 to URL
  2817 1240 A2 00		        LDX     #$00        ; index to start of article buf
  2818 1242 AC 78 0B		        LDY     CMDSEP      ; index to cmd line arg
  2819 				        
  2820 1245			HELP_LOOP1:
  2821 1245 B1 F3		        LDA     (INBUFF),Y
  2822 1247 C9 9B		        CMP     #EOL
  2823 1249 F0 11		        BEQ     HELP_NEXT1  ; Exit loop at end of arg
  2824 124B E0 16		        CPX     #22
  2825 124D 10 2B		        BPL     HELP_DONE   ; Exit if arg is too long
  2826 124F 9D D6 12		        STA     HELP_ARTICLE,X
  2827 1252 E8			        INX
  2828 1253 C8			        INY
  2829 1254 D0 EF		        BNE     HELP_LOOP1  ; Always true
  2830
  2831 				    ; Append .DOC extension to article name
  2832 1256			HELP_EXT:
  2833 1256 2E 44 4F 43 9B 00	        .BYTE   '.DOC',EOL,$00
  2834
  2835 125C			HELP_NEXT1:
  2836 125C A0 00		        LDY     #$00
  2837
  2838 125E			HELP_LOOP2:
  2839 125E B9 56 12		        LDA     HELP_EXT,Y
  2840 1261 9D D6 12		        STA     HELP_ARTICLE,X  ; Store null term too
  2841 1264 F0 04		        BEQ     HELP_NEXT2      ; Skip ahead if terminator
  2842 1266 E8			        INX
  2843 1267 C8			        INY
  2844 1268 D0 F4		        BNE     HELP_LOOP2  ; Always true
  2845
  2846 126A			HELP_NEXT2:
  2847 				    ; Copy URL to LNBUFF
  2848 126A A2 00		        LDX     #$00    ; Index to start of HELP_URL
  2849 126C A0 05		        LDY     #$05    ; Index to start at arg1 for "TYPE "
  2850 				    
  2851 126E			HELP_LOOP3:
  2852 126E BD 82 12		        LDA     HELP_URL,X  ; Get source byte
  2853 1271 99 82 05		        STA     LNBUF,Y     ; Write to target location
  2854 1274 F0 04		        BEQ     HELP_DONE   ; Exit loop on null terminator
  2855 1276 E8			        INX                 ; Advance indices
  2856 1277 C8			        INY
  2857 1278 D0 F4		        BNE     HELP_LOOP3  ; Always true
  2858 				        
  2859 127A			HELP_DONE:        
  2860 127A A9 05		        LDA     #$05        ; Trick TYPE to look for URL in arg1
  2861 127C 8D 78 0B		        STA     CMDSEP
  2862 127F 4C 67 11		        JMP     DO_TYPE
  2863
  2864 1282			HELP_URL:
  2865 				;        .BYTE   'N8:HTTP://localhost:6502/'
  2866 1282 4E 38 3A 48 54 54 +         .BYTE   'N8:HTTPS://raw.githubusercontent.com/michaelsternberg/fujinet-nhandler/nos/nos/HELP/'
  2867 12D6			HELP_ARTICLE:
  2868 12D6 00 00 00 00 00 00 +         .BYTE   $00,$00,$00,$00, $00,$00,$00,$00
  2869 12DE 00 00 00 00 00 00 +         .BYTE   $00,$00,$00,$00, $00,$00,$00,$00
  2870 12E6 00 00 00 00 00 00 +         .BYTE   $00,$00,$00,$00, $00,$00,$00,$00
  2871
  2872 				.endif
  2873 				;SYNCALC
  2874 				.ifndef SYNCALD
  2875
  2876 				;---------------------------------------
  2877 12EE			DO_NOBASIC:
  2878 				;---------------------------------------
  2879 				    ; Quit if 400/800
  2880 12EE AD F7 FF		        LDA     $FFF7
  2881 12F1 C9 FF		        CMP     #$FF        ; ????
  2882 12F3 F0 21		        BEQ     NOBASIC_ERROR
  2883 12F5 C9 DD		        CMP     #$DD        ; OSA NTSC
  2884 12F7 F0 1D		        BEQ     NOBASIC_ERROR
  2885 12F9 C9 F3		        CMP     #$F3        ; OSB NTSC
  2886 12FB F0 19		        BEQ     NOBASIC_ERROR
  2887 12FD C9 D6		        CMP     #$D6        ; OSA PAL
  2888 12FF F0 15		        BEQ     NOBASIC_ERROR
  2889 1301 C9 22		        CMP     #$22        ; OSB PAL
  2890 1303 F0 11		        BEQ     NOBASIC_ERROR
  2891 1305 C9 0A		        CMP     #$0A        ; OSA 1200XL
  2892 1307 F0 0D		        BEQ     NOBASIC_ERROR
  2893 1309 C9 0B		        CMP     #$0B        ; OSB 1200XL
  2894 130B F0 09		        BEQ     NOBASIC_ERROR
  2895 				        
  2896 				    ; Disable BASIC
  2897 130D AD 01 D3		        LDA     PORTB
  2898 1310 09 02		        ORA     #%00000010  ; if Bit 1 = 1 then BASIC is disabled
  2899 1312 8D 01 D3		        STA     PORTB
  2900 1315 60			        RTS
  2901
  2902 				;---------------------------------------
  2903 1316			NOBASIC_ERROR:
  2904 				;---------------------------------------
  2905 1316 A9 1D		        LDA     #<NOBASIC_ERROR_STR
  2906 1318 A0 13		        LDY     #>NOBASIC_ERROR_STR
  2907 131A 4C 7B 0A		        JMP     PRINT_STRING
  2908
  2909 131D			NOBASIC_ERROR_STR:
  2910 131D 4E 4F 20 42 55 49 +         .BYTE   'NO BUILT-IN BASIC',EOL
  2911
  2912 				;---------------------------------------
  2913 132F			DO_NOSCREEN:
  2914 				;---------------------------------------
  2915 132F A9 00		        LDA     #$00
  2916 1331 8D C2 15		        STA     CURSCR
  2917 1334 60			        RTS
  2918
  2919 				;---------------------------------------
  2920 1335			DO_SCREEN:
  2921 				;---------------------------------------
  2922 1335 A9 01		        LDA     #$01
  2923 1337 8D C2 15		        STA     CURSCR
  2924 133A 60			        RTS
  2925
  2926 				;---------------------------------------
  2927 133B			DO_PRINT:
  2928 				;---------------------------------------
  2929 133B AD 78 0B		        LDA     CMDSEP
  2930 133E F0 08		        BEQ     PRINT_DONE
  2931
  2932 1340 18			        CLC
  2933 1341 65 F3		        ADC     INBUFF
  2934 1343 A4 F4		        LDY     INBUFF+1
  2935 1345 4C 7B 0A		        JMP     PRINT_STRING
  2936
  2937 1348			PRINT_DONE:
  2938 1348 60			        RTS
  2939
  2940 				;---------------------------------------
  2941 1349			DO_REENTER:
  2942 				;---------------------------------------
  2943 				    ; Jump to the address stored in RUNAD or INITAD
  2944 				    ; Do the one that isn't pointing to R (RUNAD first)
  2945
  2946 				    ; Skip it all if both contain $0000
  2947 1349 AD E2 02		        LDA     INITAD
  2948 134C D0 16		        BNE     DO_REENTER_CONT
  2949 134E AD E3 02		        LDA     INITAD+1
  2950 1351 D0 11		        BNE     DO_REENTER_CONT
  2951 1353 AD E0 02		        LDA     RUNAD
  2952 1356 D0 0C		        BNE     DO_REENTER_CONT
  2953 1358 AD E1 02		        LDA     RUNAD+1
  2954 135B D0 07		        BNE     DO_REENTER_CONT
  2955
  2956 135D A9 78		        LDA     #<DO_REENTER_ERR
  2957 135F A0 13		        LDY     #>DO_REENTER_ERR
  2958 1361 4C 7B 0A		        JMP     PRINT_STRING
  2959
  2960 1364			DO_REENTER_CONT:
  2961 1364 AD E0 02		        LDA     RUNAD
  2962 1367 C9 0D		        CMP     #>R
  2963 1369 D0 07		        BNE     DO_REENTER_RUNAD
  2964 136B AD E1 02		        LDA     RUNAD+1
  2965 136E C9 0D		        CMP     #>R
  2966 1370 F0 03		        BEQ     DO_REENTER_INITAD
  2967
  2968 1372			DO_REENTER_RUNAD:
  2969 1372 6C E0 02		        JMP     (RUNAD)     ; Godspeed
  2970
  2971 1375			DO_REENTER_INITAD:
  2972 1375 6C E2 02		        JMP     (INITAD)    ; Godspeed
  2973
  2974 1378			DO_REENTER_ERR:
  2975 1378 4E 4F 20 41 44 44 +         .BYTE   'NO ADDR IN INITAD OR RUNAD',EOL
  2976
  2977 				;---------------------------------------
  2978 1393			DO_REM:
  2979 				;---------------------------------------
  2980 1393 60			        RTS
  2981
  2982 				;---------------------------------------
  2983 1394			DO_RUN:
  2984 				;---------------------------------------
  2985 1394 AD 78 0B		        LDA     CMDSEP      ; Get position for address arg
  2986 1397 A8			        TAY                 ; Offset to arg used later
  2987 1398 18			        CLC
  2988 1399 69 04		        ADC     #$04
  2989 139B 8D 00 16		        STA     RBUF
  2990
  2991 				    ;---------------------------------------
  2992 				    ; ASCII hex char to integer conversion
  2993 				    ; algorithm borrowed from Apple II Monitor
  2994 				    ;---------------------------------------
  2995 139E A9 00		        LDA     #$00
  2996 13A0 85 F3		        STA     INBUFF      ; L
  2997 13A2 85 F4		        STA     INBUFF+1    ; H
  2998 13A4			NEXTHEX:
  2999 13A4 B9 82 05		        LDA     LNBUF,Y     ; Get character for hex test.
  3000 13A7 49 30		        EOR     #%00110000  ; Maps digits to $0-$9
  3001 13A9 C9 0A		        CMP     #$0A        ; Digit?
  3002 13AB 90 06		        BCC     DIG         ; Yes.
  3003 13AD 69 88		        ADC     #$88        ; Map letter "A"-"F" to $FA-FF.
  3004 13AF C9 FA		        CMP     #$FA        ; Hex letter?
  3005 13B1 90 17		        BCC     NOTHEX      ; No, character not hex.
  3006
  3007 13B3 0A			DIG:    ASL
  3008 13B4 0A			        ASL
  3009 13B5 0A			        ASL
  3010 13B6 0A			        ASL
  3011 13B7 A2 04		        LDX     #$04        ; Shift count.
  3012
  3013 13B9			HEXSHIFT:
  3014 13B9 0A			        ASL
  3015 13BA 26 F3		        ROL     INBUFF      ; Rotate into LSD.
  3016 13BC 26 F4		        ROL     INBUFF+1    ; Rotate into MSD's.
  3017 13BE CA			        DEX                 ; Done 4 shifts?
  3018 13BF D0 F8		        BNE     HEXSHIFT    ; No, loop.
  3019 13C1 C8			        INY                 ; Advance text index
  3020 13C2 CC 00 16		        CPY     RBUF        ; Processed 4 characters?
  3021 13C5 D0 DD		        BNE     NEXTHEX     ; No, get next character.
  3022
  3023 13C7 6C F3 00		        JMP     (INBUFF)    ; Goto requested address. Godspeed.
  3024
  3025 13CA			NOTHEX:
  3026 13CA A9 D1		        LDA     #<RUN_ERROR_STR
  3027 13CC A0 13		        LDY     #>RUN_ERROR_STR
  3028 13CE 4C 7B 0A		        JMP     PRINT_STRING
  3029
  3030 13D1			RUN_ERROR_STR:
  3031 13D1 41 44 44 52 3F 20 +         .BYTE   'ADDR? 0000..FFFF',EOL
  3032
  3033 				;---------------------------------------
  3034 13E2			DO_WARM:
  3035 				;---------------------------------------
  3036 13E2 4C 74 E4		        JMP     WARMSV
  3037 				.endif
  3038 				; SYNCALD
  3039
  3040 				;---------------------------------------
  3041 13E5			REMOUNT_DRIVE:
  3042 				;---------------------------------------
  3043
  3044 				    ;---------------------------------------
  3045 				    ; Workaround for timeout issue regarding idempotent commands that
  3046 				    ; unmount the server.  So far, these are DEL and RENAME. This
  3047 				    ; routine, remounts the TNFS URL by calling NPWD and attempts
  3048 				    ; a MKDIR on the returned mount point. Hopefully this is an
  3049 				    ; non-consequential operation since the directory already exists.
  3050 				    ;---------------------------------------
  3051
  3052 13E5 20 3D 10		        JSR     DO_NPWD         ; Curr dir for drive now in RBUF
  3053
  3054 13E8 AD 00 16		        LDA     RBUF            ; Quit if not TNFS. Only TNFS is affected.
  3055 13EB C9 54		        CMP     #'T'            ; TODO More letters needed if...
  3056 13ED D0 28		        BNE     REMOUNT_DONE    ; ...another Txxx protocol exists
  3057
  3058 13EF A9 4E		        LDA     #'N'
  3059 13F1 8D 00 16		        STA     RBUF+0
  3060 13F4 AD BF 15		        LDA     DOSDR           ; Get drive number
  3061 13F7 09 30		        ORA     #'0'            ; Convert, say, 1 to '1'
  3062 13F9 8D 01 16		        STA     RBUF+1
  3063 13FC A9 3A		        LDA     #':'
  3064 13FE 8D 02 16		        STA     RBUF+2
  3065
  3066 1401 A9 2A		        LDA     #CMD_MKDIR
  3067 1403 8D A4 0C		        STA     GENDCB+2
  3068 1406 A9 00		        LDA     #<RBUF          ; TODO Is this needed
  3069 1408 8D A6 0C		        STA     GENDCB+4        ; TODO or is it hardcoded in DO_GENERIC?
  3070 140B A9 16		        LDA     #>RBUF
  3071 140D 8D A7 0C		        STA     GENDCB+5
  3072
  3073 1410 A9 A2		        LDA     #<GENDCB
  3074 1412 A0 0C		        LDY     #>GENDCB
  3075 1414 4C A5 07		        JMP     DOSIOV
  3076
  3077 1417			REMOUNT_DONE:
  3078 1417 60			        RTS
  3079
  3080 				;---------------------------------------
  3081 1418			PREPEND_DRIVE:
  3082 				;---------------------------------------
  3083 				        ; Inject "Nn:" in front of a plain filename
  3084 				        ; before passing it to the FujiNet
  3085 1418 A0 00		        LDY     #$00
  3086 141A A9 4E		        LDA     #'N'
  3087 141C D1 F3		        CMP     (INBUFF),Y  ; Does arg1 already begin with N?
  3088
  3089 141E A0 02		        LDY     #$02
  3090 1420 A9 3A		        LDA     #':'
  3091 1422 D1 F3		        CMP     (INBUFF),Y
  3092 1424 F0 1C		        BEQ     PREPEND_DRIVE_DONE
  3093 1426 88			        DEY
  3094 1427 D1 F3		        CMP     (INBUFF),Y
  3095 1429 F0 17		        BEQ     PREPEND_DRIVE_DONE
  3096
  3097 				        ; Move input buffer pointer back 3 bytes
  3098 142B 38			        SEC
  3099 142C A5 F3		        LDA     INBUFF
  3100 142E E9 03		        SBC     #$03
  3101 1430 85 F3		        STA     INBUFF
  3102 1432 A5 F4		        LDA     INBUFF+1
  3103 1434 E9 00		        SBC     #$00
  3104 1436 85 F4		        STA     INBUFF+1
  3105
  3106 				        ; Inject PRMPT to front of arg1
  3107 1438 A0 03		        LDY     #$03
  3108 143A			PREPEND_DRIVE_LOOP:
  3109 143A B9 6C 14		        LDA     PRMPT,Y
  3110 143D 88			        DEY
  3111 143E 91 F3		        STA     (INBUFF),Y
  3112 1440 D0 F8		        BNE     PREPEND_DRIVE_LOOP
  3113
  3114 1442			PREPEND_DRIVE_DONE:
  3115 1442 A0 01		        LDY     #$01
  3116 1444 60			        RTS             ; Y = $00 here
  3117
  3118 				;---------------------------------------
  3119 1445			APPEND_SLASH:
  3120 				;---------------------------------------
  3121 				    ;---------------------------------------
  3122 				    ; Skip if relative path (..)
  3123 				    ;---------------------------------------
  3124 1445 A0 00		        LDY     #$00
  3125 1447 A9 2E		        LDA     #'.'
  3126 1449 D1 F3		        CMP     (INBUFF),Y
  3127 144B F0 1E		        BEQ     APPEND_SLASH_DONE
  3128
  3129 144D A0 FF		        LDY     #$FF        ; Iterate thru arg2 until EOF
  3130 144F			APPEND_SLASH_LOOP:
  3131 144F C8			        INY                 ; Zero on 1st pass
  3132 1450 B1 F3		        LDA     (INBUFF),Y
  3133 1452 C9 9B		        CMP     #EOL
  3134 1454 D0 F9		        BNE     APPEND_SLASH_LOOP
  3135
  3136 1456 88			        DEY                 ; Move pointer back one character
  3137 1457 B1 F3		        LDA     (INBUFF),Y
  3138 1459 C9 2F		        CMP     #'/'        ; If already slash then skip rest
  3139 145B F0 0E		        BEQ     APPEND_SLASH_DONE
  3140 145D C9 3A		        CMP     #':'        ; If a drive, skip
  3141 145F F0 0A		        BEQ     APPEND_SLASH_DONE
  3142
  3143 1461 C8			        INY                 ; Else inject '/' + EOL
  3144 1462 A9 2F		        LDA     #'/'
  3145 1464 91 F3		        STA     (INBUFF),Y
  3146 1466 C8			        INY
  3147 1467 A9 9B		        LDA     #EOL
  3148 1469 91 F3		        STA     (INBUFF),Y
  3149
  3150 146B			APPEND_SLASH_DONE:
  3151 146B 60			        RTS
  3152
  3153 146C			PRMPT:
  3154 146C 9B 4E 20 3A		        .BYTE   EOL,'N :'
  3155
  3156 				;;; End CP ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  3157 				;;; Variables
  3158
  3159 1470			        .ENUM   CMD_IDX
  3160 				        ;---------------
  3161 = 0000			                NCD                 ;  0
  3162 = 0001			                COPY                ;  1
  3163 = 0002			                DIR                 ;  2
  3164 = 0003			                DEL                 ;  3
  3165 = 0004			                LOAD                ;  4
  3166 = 0005			                LOCK                ;  5
  3167 = 0006			                LOGIN               ;  6
  3168 = 0007			                MKDIR               ;  7
  3169 = 0008			                NPWD                ;  8
  3170 				.ifndef SYNCALD
  3171 = 0009			                NTRANS              ;  9
  3172 = 000A			                RENAME              ; 10
  3173 = 000B			                RMDIR               ; 11
  3174 = 000C			                SUBMIT              ; 12
  3175 = 000D			                TYPE                ; 13
  3176 = 000E			                UNLOCK              ; 14
  3177 = 000F			                CAR                 ; 15
  3178 = 0010			                CLS                 ; 16
  3179 = 0011			                COLD                ; 17
  3180 				.endif
  3181 				.ifndef SYNCALC
  3182 = 0012			                HELP                ; 18
  3183 				.endif
  3184 				.ifndef SYNCALD
  3185 = 0013			                NOBASIC             ; 19
  3186 = 0014			                NOSCREEN            ; 20
  3187 = 0015			                PRINT               ; 21
  3188 = 0016			                REENTER             ; 22
  3189 = 0017			                REM                 ; 23
  3190 = 0018			                RUN                 ; 24
  3191 = 0019			                SCREEN              ; 25
  3192 = 001A			                WARM                ; 26
  3193 				.endif
  3194 = 001B			                DRIVE_CHG           ; 27
  3195 				        .ENDE
  3196
  3197 1470			CMD_DCOMND:
  3198 1470 2C			        .BYTE   CMD_CD              ;  0 NCD
  3199 1471 A1			        .BYTE   CMD_COPY            ;  1 COPY
  3200 1472 02			        .BYTE   CMD_DIR             ;  2 DIR
  3201 1473 21			        .BYTE   CMD_DEL             ;  3 DEL
  3202 1474 28			        .BYTE   CMD_LOAD            ;  4 LOAD
  3203 1475 FD			        .BYTE   CMD_LOGIN           ;  5 LOAD
  3204 1476 23			        .BYTE   CMD_LOCK            ;  6 LOCK
  3205 1477 2A			        .BYTE   CMD_MKDIR           ;  7 MKDIR
  3206 1478 30			        .BYTE   CMD_NPWD            ;  8 NPWD
  3207 				.ifndef SYNCALD
  3208 1479 54			        .BYTE   CMD_NTRANS          ;  9 NTRANS
  3209 147A 20			        .BYTE   CMD_RENAME          ; 10 RENAME
  3210 147B 2B			        .BYTE   CMD_RMDIR           ; 11 RMDIR
  3211 147C F0			        .BYTE   CMD_SUBMIT          ; 12 SUBMIT
  3212 147D F0			        .BYTE   CMD_TYPE            ; 13 TYPE
  3213 147E 24			        .BYTE   CMD_UNLOCK          ; 14 UNLOCK
  3214 147F F0			        .BYTE   CMD_CAR             ; 15 CAR
  3215 1480 F0			        .BYTE   CMD_CLS             ; 16 CLS
  3216 1481 F0			        .BYTE   CMD_COLD            ; 17 COLD
  3217 				.endif
  3218 				.ifndef SYNCALC
  3219 1482 F0			        .BYTE   CMD_HELP            ; 18 HELP
  3220 				.endif
  3221 				.ifndef SYNCALD
  3222 1483 F0			        .BYTE   CMD_NOBASIC         ; 19 NOBASIC
  3223 1484 F0			        .BYTE   CMD_NOSCREEN        ; 20 NOSCREEN
  3224 1485 F0			        .BYTE   CMD_PRINT           ; 21 PRINT
  3225 1486 F0			        .BYTE   CMD_REENTER         ; 22 REENTER
  3226 1487 F0			        .BYTE   CMD_REM             ; 23 REM
  3227 1488 F0			        .BYTE   CMD_RUN             ; 24 RUN
  3228 1489 F0			        .BYTE   CMD_SCREEN          ; 25 SCREEN
  3229 148A F0			        .BYTE   CMD_WARM            ; 26 WARM
  3230 				.endif
  3231 148B 01			        .BYTE   CMD_DRIVE_CHG       ; 27
  3232
  3233 148C			COMMAND:
  3234 148C 4E 43 C4		        .CB     "NCD"               ;  0 NCD
  3235 148F 00			        .BYTE   CMD_IDX.NCD            
  3236
  3237 1490 43 4F 50 D9		        .CB     "COPY"              ;  1 COPY
  3238 1494 01			        .BYTE   CMD_IDX.COPY           
  3239
  3240 1495 44 49 D2		        .CB     "DIR"               ;  2 DIR
  3241 1498 02			        .BYTE   CMD_IDX.DIR              
  3242
  3243 1499 44 45 CC		        .CB     "DEL"               ;  3 DEL
  3244 149C 03			        .BYTE   CMD_IDX.DEL              
  3245
  3246 149D 4C 4F 41 C4		        .CB     "LOAD"              ;  4 LOAD
  3247 14A1 04			        .BYTE   CMD_IDX.LOAD             
  3248
  3249 14A2 4C 4F 43 CB		        .CB     "LOCK"              ;  5 LOCK
  3250 14A6 05			        .BYTE   CMD_IDX.LOCK             
  3251
  3252 14A7 4C 4F 47 49 CE	        .CB     "LOGIN"             ;  6 LOGIN
  3253 14AC 06			        .BYTE   CMD_IDX.LOGIN              
  3254 				                                        
  3255 14AD 4D 4B 44 49 D2	        .CB     "MKDIR"             ;  7 MKDIR
  3256 14B2 07			        .BYTE   CMD_IDX.MKDIR           
  3257
  3258 14B3 4E 50 57 C4		        .CB     "NPWD"              ;  8 NPWD
  3259 14B7 08			        .BYTE   CMD_IDX.NPWD             
  3260
  3261 				.ifndef SYNCALD
  3262 14B8 4E 54 52 41 4E D3	        .CB     "NTRANS"            ;  9 NTRANS
  3263 14BE 09			        .BYTE   CMD_IDX.NTRANS            
  3264 				                                        
  3265 14BF 52 45 4E 41 4D C5	        .CB     "RENAME"            ; 10 RENAME
  3266 14C5 0A			        .BYTE   CMD_IDX.RENAME          
  3267 				                                        
  3268 14C6 52 4D 44 49 D2	        .CB     "RMDIR"             ; 11 RMDIR
  3269 14CB 0B			        .BYTE   CMD_IDX.RMDIR           
  3270 				                                        
  3271 14CC 53 55 42 4D 49 D4	        .CB     "SUBMIT"            ; 12 SUBMIT
  3272 14D2 0C			        .BYTE   CMD_IDX.SUBMIT             
  3273 				                                        
  3274 14D3 54 59 50 C5		        .CB     "TYPE"              ; 13 SUBMIT
  3275 14D7 0D			        .BYTE   CMD_IDX.TYPE              
  3276 				                                        
  3277 14D8 55 4E 4C 4F 43 CB	        .CB     "UNLOCK"            ; 14 UNLOCK
  3278 14DE 0E			        .BYTE   CMD_IDX.UNLOCK            
  3279 				                                        
  3280 14DF 43 41 D2		        .CB     "CAR"               ; 15 CAR
  3281 14E2 0F			        .BYTE   CMD_IDX.CAR             
  3282 				                                        
  3283 14E3 43 4C D3		        .CB     "CLS"               ; 16 CLS
  3284 14E6 10			        .BYTE   CMD_IDX.CLS           
  3285
  3286 14E7 43 4F 4C C4		        .CB     "COLD"              ; 17 COLD
  3287 14EB 11			        .BYTE   CMD_IDX.COLD              
  3288
  3289 				.endif
  3290 				.ifndef SYNCALC
  3291 14EC 48 45 4C D0		        .CB     "HELP"              ; 18 HELP
  3292 14F0 12			        .BYTE   CMD_IDX.HELP                
  3293 				.endif
  3294 				.ifndef SYNCALD
  3295 				                                        
  3296 14F1 4E 4F 42 41 53 49 +         .CB     "NOBASIC"           ; 19 NOBASIC
  3297 14F8 13			        .BYTE   CMD_IDX.NOBASIC           
  3298 				                                          
  3299 14F9 40 4E 4F 53 43 52 +         .CB     "@NOSCREEN"         ; 20 @NOSCREEN
  3300 1502 14			        .BYTE   CMD_IDX.NOSCREEN         
  3301 				                                        
  3302 1503 50 52 49 4E D4	        .CB     "PRINT"             ; 21 PRINT
  3303 1508 15			        .BYTE   CMD_IDX.PRINT           
  3304 				                                        
  3305 1509 52 45 45 4E 54 45 +         .CB     "REENTER"           ; 22 REENTER
  3306 1510 16			        .BYTE   CMD_IDX.REENTER         
  3307 				                                        
  3308 1511 52 45 CD		        .CB     "REM"               ; 23 REM
  3309 1514 17			        .BYTE   CMD_IDX.REM             
  3310 				                                        
  3311 1515 52 55 CE		        .CB     "RUN"               ; 24 RUN
  3312 1518 18			        .BYTE   CMD_IDX.RUN             
  3313 				                                        
  3314 1519 40 53 43 52 45 45 +         .CB     "@SCREEN"           ; 25 @SCREEN
  3315 1520 19			        .BYTE   CMD_IDX.SCREEN
  3316
  3317 1521 57 41 52 CD		        .CB     "WARM"              ; 26 WARM
  3318 1525 1A			        .BYTE   CMD_IDX.WARM
  3319
  3320 				; Aliases
  3321 1526 43 C4		        .CB     "CD"                ; CD = NCD
  3322 1528 00			        .BYTE   CMD_IDX.NCD           
  3323
  3324 1529 43 57 C4		        .CB     "CWD"               ; CWD = NCD
  3325 152C 00			        .BYTE   CMD_IDX.NCD           
  3326
  3327 152D 45 52 41 53 C5	        .CB     "ERASE"             ; ERASE = DEL
  3328 1532 03			        .BYTE   CMD_IDX.DEL           
  3329
  3330 1533 45 52 C1		        .CB     "ERA"               ; ERA = DEL
  3331 1536 03			        .BYTE   CMD_IDX.DEL           
  3332
  3333 1537 D8			        .CB     "X"                 ; X = LOAD
  3334 1538 04			        .BYTE   CMD_IDX.LOAD
  3335
  3336 1539 50 57 C4		        .CB     "PWD"               ; PWD = NPWD
  3337 153C 08			        .BYTE   CMD_IDX.NPWD             
  3338
  3339 153D 52 45 C5		        .CB     "REE"               ; R = REENTER
  3340 1540 16			        .BYTE   CMD_IDX.REENTER             
  3341
  3342 1541 52 45 CE		        .CB     "REN"               ; REN = RENAME
  3343 1544 0A			        .BYTE   CMD_IDX.RENAME
  3344
  3345 1545 C0			        .CB     "@"                 ; @ = SUBMIT
  3346 1546 0C			        .BYTE   CMD_IDX.SUBMIT
  3347 				.endif
  3348 				;SYNCALD
  3349
  3350 				        ; Drive Change intentionally omitted
  3351
  3352 = 00BA			COMMAND_SIZE = * - COMMAND - 1
  3353 1547 FF			        .BYTE   $FF
  3354
  3355 1548			CMD_TAB_L:
  3356 1548 40			        .BYTE   <(DO_GENERIC-1)     ;  0 NCD
  3357 1549 AD			        .BYTE   <(DO_COPY-1)        ;  1 COPY
  3358 154A B3			        .BYTE   <(DO_DIR-1)         ;  2 DIR
  3359 154B 40			        .BYTE   <(DO_GENERIC-1)     ;  3 DEL
  3360 154C 9D			        .BYTE   <(DO_LOAD-1)        ;  4 LOAD
  3361 154D 05			        .BYTE   <(DO_LOCK-1)        ;  5 LOCK
  3362 154E 0B			        .BYTE   <(DO_LOGIN-1)       ;  6 LOGIN
  3363 154F 40			        .BYTE   <(DO_GENERIC-1)     ;  7 MKDIR
  3364 1550 3C			        .BYTE   <(DO_NPWD-1)        ;  8 NPWD
  3365 				.ifndef SYNCALD
  3366 1551 7F			        .BYTE   <(DO_NTRANS-1)      ;  9 NTRANS
  3367 1552 40			        .BYTE   <(DO_GENERIC-1)     ; 10 RENAME
  3368 1553 40			        .BYTE   <(DO_GENERIC-1)     ; 11 RMDIR
  3369 1554 02			        .BYTE   <(DO_SUBMIT-1)      ; 12 SUBMIT
  3370 1555 66			        .BYTE   <(DO_TYPE-1)        ; 13 TYPE
  3371 1556 04			        .BYTE   <(DO_UNLOCK-1)      ; 14 UNLOCK
  3372 1557 0A			        .BYTE   <(DO_CAR-1)         ; 15 CAR
  3373 1558 33			        .BYTE   <(DO_CLS-1)         ; 16 CLS
  3374 1559 3C			        .BYTE   <(DO_COLD-1)        ; 17 COLD
  3375 				.endif
  3376 				.ifndef SYNCALC
  3377 155A 3F			        .BYTE   <(DO_HELP-1)        ; 18 HELP
  3378 				.endif
  3379 				.ifndef SYNCALD
  3380 155B ED			        .BYTE   <(DO_NOBASIC-1)     ; 19 NOBASIC
  3381 155C 2E			        .BYTE   <(DO_NOSCREEN-1)    ; 20 NOSCREEN
  3382 155D 3A			        .BYTE   <(DO_PRINT-1)       ; 21 PRINT
  3383 155E 48			        .BYTE   <(DO_REENTER-1)     ; 22 REENTER
  3384 155F 92			        .BYTE   <(DO_REM-1)         ; 23 REM
  3385 1560 93			        .BYTE   <(DO_RUN-1)         ; 24 RUN
  3386 1561 34			        .BYTE   <(DO_SCREEN-1)      ; 25 SCREEN
  3387 1562 E1			        .BYTE   <(DO_WARM-1)        ; 26 WARM
  3388 1563 FF			        .BYTE   <(DO_DRIVE_CHG-1)   ; 27
  3389 				.endif
  3390
  3391 1564			CMD_TAB_H:
  3392 1564 0C			        .BYTE   >(DO_GENERIC-1)     ;  0 NCD
  3393 1565 0C			        .BYTE   >(DO_COPY-1)        ;  1 COPY
  3394 1566 0C			        .BYTE   >(DO_DIR-1)         ;  2 DIR
  3395 1567 0C			        .BYTE   >(DO_GENERIC-1)     ;  3 DEL
  3396 1568 0D			        .BYTE   >(DO_LOAD-1)        ;  4 LOAD
  3397 1569 10			        .BYTE   >(DO_LOCK-1)        ;  5 LOCK
  3398 156A 10			        .BYTE   >(DO_LOGIN-1)       ;  6 LOGIN
  3399 156B 0C			        .BYTE   >(DO_GENERIC-1)     ;  7 MKDIR
  3400 156C 10			        .BYTE   >(DO_NPWD-1)        ;  8 NPWD
  3401 				.ifndef SYNCALD
  3402 156D 10			        .BYTE   >(DO_NTRANS-1)      ;  9 NTRANS
  3403 156E 0C			        .BYTE   >(DO_GENERIC-1)     ; 10 RENAME
  3404 156F 0C			        .BYTE   >(DO_GENERIC-1)     ; 11 RMDIR
  3405 1570 11			        .BYTE   >(DO_SUBMIT-1)      ; 12 SUBMIT
  3406 1571 11			        .BYTE   >(DO_TYPE-1)        ; 13 TYPE
  3407 1572 12			        .BYTE   >(DO_UNLOCK-1)      ; 14 UNLOCK
  3408 1573 12			        .BYTE   >(DO_CAR-1)         ; 15 CAR
  3409 1574 12			        .BYTE   >(DO_CLS-1)         ; 16 CLS
  3410 1575 12			        .BYTE   >(DO_COLD-1)        ; 17 COLD
  3411 				.endif
  3412 				.ifndef SYNCALC
  3413 1576 12			        .BYTE   >(DO_HELP-1)        ; 18 HELP
  3414 				.endif
  3415 				.ifndef SYNCALD
  3416 1577 12			        .BYTE   >(DO_NOBASIC-1)     ; 19 NOBASIC
  3417 1578 13			        .BYTE   >(DO_NOSCREEN-1)    ; 20 NOSCREEN
  3418 1579 13			        .BYTE   >(DO_PRINT-1)       ; 21 PRINT
  3419 157A 13			        .BYTE   >(DO_REENTER-1)     ; 22 REENTER
  3420 157B 13			        .BYTE   >(DO_REM-1)         ; 23 REM
  3421 157C 13			        .BYTE   >(DO_RUN-1)         ; 24 RUN
  3422 157D 13			        .BYTE   >(DO_SCREEN-1)      ; 25 SCREEN
  3423 157E 13			        .BYTE   >(DO_WARM-1)        ; 26 WARM
  3424 157F 0B			        .BYTE   >(DO_DRIVE_CHG-1)   ; 27
  3425 				.endif
  3426
  3427 				        ; DEVHDL TABLE FOR N:
  3428
  3429 1580 BD 07		CIOHND  .WORD   OPEN-1
  3430 1582 0B 08		        .WORD   CLOSE-1
  3431 1584 2C 08		        .WORD   GET-1
  3432 1586 8D 08		        .WORD   PUT-1
  3433 1588 ED 08		        .WORD   STATUS-1
  3434 158A 53 09		        .WORD   SPEC-1
  3435
  3436 				       ; BANNERS
  3437
  3438 				.ifdef SYNCALC
  3439 				BREADY  .BYTE   '#FUJI NOS-SC5a 0.3.2',EOL
  3440 				BERROR  .BYTE   '#FUJI ERR',EOL
  3441 				.else
  3442 158C 23 46 55 4A 49 4E + BREADY  .BYTE   '#FUJINET NOS v0.3.2-alpha',EOL
  3443 15A6 23 46 55 4A 49 4E + BERROR  .BYTE   '#FUJINET ERROR',EOL
  3444 				.endif
  3445
  3446 				        ; MESSAGES
  3447
  3448 15B5 4E 23 3F 9B		CDERR   .BYTE   'N#?',EOL
  3449
  3450 				        ; STRING CONSTANTS
  3451
  3452 15B9			MISSING_FILE_STR:
  3453 15B9 46 49 4C 45 3F 9B	        .BYTE   'FILE?',EOL
  3454
  3455 				        ; VARIABLES
  3456
  3457 15BF 01			DOSDR   .BYTE   $01         ; DOS DRIVE
  3458 15C0 01			CMD     .BYTE   $01
  3459 15C1 01			CMDPRV  .BYTE   $01
  3460 15C2 01			CURSCR  .BYTE   $01         ; echo batch cmds (1=enabled,0=disabled)
  3461
  3462 15C3 01			TRIP    .BYTE   $01         ; INTR FLAG
  3463 15C4 00 00 00 00		RLEN    :MAXDEV .BYTE $00   ; RCV LEN
  3464 15C8 00 00 00 00		ROFF    :MAXDEV .BYTE $00   ; RCV OFFSET
  3465 15CC 00 00 00 00		TOFF    :MAXDEV .BYTE $00   ; TRX OFFSET
  3466 15D0 01			INQDS   .BYTE   $01         ; DSTATS INQ
  3467
  3468 15D1 00 00 00 00		DVS2    :MAXDEV .BYTE $00   ; DVSTAT+2 SAVE
  3469 15D5 00 00 00 00		DVS3    :MAXDEV .BYTE $00   ; DVSTAT+3 SAVE
  3470
  3471 				       ; BUFFERS (PAGE ALIGNED)
  3472 15D9 00 00 00 00 00 00 +         .ALIGN  $100, $00
  3473 1600			BOOTEND:
  3474
  3475 1600 00 00 00 00 00 00 + RBUF    :$80 .BYTE $00      ; 128 bytes
  3476 1680 00 00 00 00 00 00 + TBUF    :$80 .BYTE $00      ; 128 bytes
  3477
  3478 				; Binary loader working variables
  3479 = 1600			BAL     = RBUF
  3480 = 1601			BAH     = RBUF+1    ;
  3481 = 1680			STL     = TBUF      ; Payload Start address
  3482 = 1681			STH     = TBUF+1
  3483 = 1682			ENL     = TBUF+2    ; Payload End address
  3484 = 1683			ENH     = TBUF+3
  3485 = 1684			BLL     = TBUF+4    ; Payload Buffer Length
  3486 = 1685			BLH     = TBUF+5
  3487 = 1686			HEADL   = TBUF+6    ; Bytes read from existing cache
  3488 = 1687			HEADH   = TBUF+7
  3489 = 1688			BODYL   = TBUF+8    ; Total bytes read in contiguous 512-byte blocks
  3490 = 1689			BODYH   = TBUF+9
  3491 = 168A			TAILL   = TBUF+10   ; Bytes read from last cache
  3492 = 168B			TAILH   = TBUF+11
  3493 = 168C			BODYSZL = TBUF+12   ; # Bytes to read at a time in Body
  3494 = 168D			BODYSZH = TBUF+13
  3495
  3496 = 1700			PGEND   = *
  3497
  3498 				; =================================================================
  3499 				; VTOC and Directory
  3500 				;
  3501
  3502 				; $10 is the added ATR-header
  3503 1700 00 00 00 00 00 00 + 	:($B390-*+HDR-$10) DTA $00
  3504 BA80			VTOCSTA
  3505 BA80 02 BD 02			DTA $02,$BD,$02
  3506 BA83			VTOCEND
  3507 				; Fill the remaining bytes of the VTOC sector
  3508 BA83 00 00 00 00 00 00 + 	:($80+VTOCSTA-VTOCEND) DTA $00
  3509
  3510 BB00			DIRSTA
  3511 BB00 42 00 00 00 00 2A + 	DTA $42,$00,$00,$00,$00,c"***********"
  3512 BB10 42 00 00 00 00 2A + 	DTA $42,$00,$00,$00,$00,c"* FujiNet *"
  3513 BB20 42 00 00 00 00 2A + 	DTA $42,$00,$00,$00,$00,c"* Network *"
  3514 BB30 42 00 00 00 00 2A + 	DTA $42,$00,$00,$00,$00,c"*   OS    *"
  3515 BB40 42 00 00 00 00 2A + 	DTA $42,$00,$00,$00,$00,c"*         *"
  3516 BB50 42 00 00 00 00 2A + 	DTA $42,$00,$00,$00,$00,c"* v0.3.2  *"
  3517 BB60 42 00 00 00 00 2A + 	DTA $42,$00,$00,$00,$00,c"*  alpha  *"
  3518 BB70 42 00 00 00 00 2A + 	DTA $42,$00,$00,$00,$00,c"***********"
  3519 BB80			DIREND
  3520 				; Fill the remaining sectors of the directory
  3521 BB80 00 00 00 00 00 00 + 	:($400+DIRSTA-DIREND) DTA $00
  3522 					
  3523 				; Sectors behind directory
  3524 BF00 00 00 00 00 00 00 + 	:($80*352) DTA $00
  3525
  3526 				       END
