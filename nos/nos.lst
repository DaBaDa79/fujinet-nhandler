mads 2.1.0
Source: nos.s
     1 				        ;; nos FujiNet Operating System
     2 				        ;; Compile with MADS
     3
     4 				        ;; Authors: Thomas Cherryhomes
     5 				        ;;   <thom.cherryhomes@gmail.com>
     6
     7 				        ;; Michael Sternberg
     8 				        ;;   <mhsternberg@gmail.com>
     9
    10
    11 				        ;; Optimizations being done by djaybee!
    12 				        ;; Thank you so much!
    13
    14
    15 = 000A			DOSVEC  =   $0A         ; DOSVEC
    16 = 000C			DOSINI  =   $0C         ; DOSINI
    17
    18 				        ;; CURRENT IOCB IN ZERO PAGE
    19 = 0020			ZIOCB   =   $20         ; ZP IOCB
    20 = 0020			ZICHID  =   ZIOCB       ; ID
    21 = 0021			ZICDNO  =   ZIOCB+1     ; UNIT #
    22 = 0022			ZICCOM  =   ZIOCB+2     ; COMMAND
    23 = 0023			ZICSTA  =   ZIOCB+3     ; STATUS
    24 = 0024			ZICBAL  =   ZIOCB+4     ; BUF ADR LOW
    25 = 0025			ZICBAH  =   ZIOCB+5     ; BUF ADR HIGH
    26 = 0026			ZICPTL  =   ZIOCB+6     ; PUT ADDR L
    27 = 0027			ZICPTH  =   ZIOCB+7     ; PUT ADDR H
    28 = 0028			ZICBLL  =   ZIOCB+8     ; BUF LEN LOW
    29 = 0029			ZICBLH  =   ZIOCB+9     ; BUF LEN HIGH
    30 = 002A			ZICAX1  =   ZIOCB+10    ; AUX 1
    31 = 002B			ZICAX2  =   ZIOCB+11    ; AUX 2
    32 = 002C			ZICAX3  =   ZIOCB+12    ; AUX 3
    33 = 002D			ZICAX4  =   ZIOCB+13    ; AUX 4
    34 = 002E			ZICAX5  =   ZIOCB+14    ; AUX 5
    35 = 002F			ZICAX6  =   ZIOCB+15    ; AUX 6
    36
    37 = 0052			LMARGN  =   $52         ; Left margin
    38 = 00D4			FR0     =   $D4         ; Floating Point register 0 (used during Hex->ASCII conversion)
    39 = 00F2			CIX     =   $F2         ; Inbuff cursor
    40 = 00F3			INBUFF  =   $F3         ; Ptr to input buffer ($0580)
    41 = 0040			MAX_APPKEY_LEN = $40    ; Used with appkey files
    42
    43 				;---------------------------------------
    44 				; INTERRUPT VECTORS
    45 				; AND OTHER PAGE 2 VARS
    46 				;---------------------------------------
    47
    48 = 0202			VPRCED  =   $0202       ; PROCEED VCTR
    49 = 02C6			COLOR2  =   $02C6       ; MODEF BKG C
    50 = 02E0			RUNAD   =   $02E0       ; RUN ADDRESS
    51 = 02E2			INITAD  =   $02E2       ; INIT ADDRESS
    52 = 02E7			MEMLO   =   $02E7       ; MEM LO
    53 = 02EA			DVSTAT  =   $02EA       ; 4 BYTE STATS
    54
    55 				;---------------------------------------
    56 				; PAGE 3
    57 				; DEVICE CONTROL BLOCK (DCB)
    58 				;---------------------------------------
    59
    60 = 0300			DCB     =   $0300       ; BASE
    61 = 0300			DDEVIC  =   DCB         ; DEVICE #
    62 = 0301			DUNIT   =   DCB+1       ; UNIT #
    63 = 0302			DCOMND  =   DCB+2       ; COMMAND
    64 = 0303			DSTATS  =   DCB+3       ; STATUS/DIR
    65 = 0304			DBUFL   =   DCB+4       ; BUF ADR L
    66 = 0305			DBUFH   =   DCB+5       ; BUF ADR H
    67 = 0306			DTIMLO  =   DCB+6       ; TIMEOUT (S)
    68 = 0307			DRSVD   =   DCB+7       ; NOT USED
    69 = 0308			DBYTL   =   DCB+8       ; BUF LEN L
    70 = 0309			DBYTH   =   DCB+9       ; BUF LEN H
    71 = 030A			DAUXL   =   DCB+10      ; AUX BYTE L
    72 = 030B			DAUXH   =   DCB+11      ; AUX BYTE H
    73
    74 = 031A			HATABS  =   $031A       ; HANDLER TBL
    75
    76 				;---------------------------------------
    77 				; IOCB'S * 8
    78 				;---------------------------------------
    79
    80 = 0340			IOCB    =   $0340       ; IOCB BASE
    81 = 0340			ICHID   =   IOCB        ; ID
    82 = 0341			ICDNO   =   IOCB+1      ; UNIT #
    83 = 0342			ICCOM   =   IOCB+2      ; COMMAND
    84 = 0343			ICSTA   =   IOCB+3      ; STATUS
    85 = 0344			ICBAL   =   IOCB+4      ; BUF ADR LOW
    86 = 0345			ICBAH   =   IOCB+5      ; BUF ADR HIGH
    87 = 0346			ICPTL   =   IOCB+6      ; PUT ADDR L
    88 = 0347			ICPTH   =   IOCB+7      ; PUT ADDR H
    89 = 0348			ICBLL   =   IOCB+8      ; BUF LEN LOW
    90 = 0349			ICBLH   =   IOCB+9      ; BUF LEN HIGH
    91 = 034A			ICAX1   =   IOCB+10     ; AUX 1
    92 = 034B			ICAX2   =   IOCB+11     ; AUX 2
    93 = 034C			ICAX3   =   IOCB+12     ; AUX 3
    94 = 034D			ICAX4   =   IOCB+13     ; AUX 4
    95 = 034E			ICAX5   =   IOCB+14     ; AUX 5
    96 = 034F			ICAX6   =   IOCB+15     ; AUX 6
    97
    98 = 0054			ROWCRS  =   $0054
    99 = 02BB			SCRFLG  =   $02BB       ; Scroll flag
   100 = 02FC			CH      =   $02FC       ; Hardware code for last key pressed
   101 = 02F2			CH1     =   $02F2       ; Prior keyboard character code
   102 = 0582			LNBUF   =   $0582       ; Line Buffer (128 bytes)
   103
   104 				;---------------------------------------
   105 				; HARDWARE REGISTERS
   106 				;---------------------------------------
   107
   108 = D301			PORTB   =   $D301       ; On XL/XE, used to enable/disable BASIC
   109 = D302			PACTL   =   $D302       ; PIA CTRL A
   110
   111 				;---------------------------------------
   112 				; MATH PACK VECTORS
   113 				;---------------------------------------
   114 = D8E6			FASC    =   $D8E6       ; Floating point to ASCII
   115 = D9AA			IFP     =   $D9AA       ; Integer to floating point
   116
   117 				;---------------------------------------
   118 				; OS ROM VECTORS
   119 				;---------------------------------------
   120
   121 = E456			CIOV    =   $E456       ; CIO ENTRY
   122 = E459			SIOV    =   $E459       ; SIO ENTRY
   123 = E474			WARMSV  =   $E474       ; Warmstart entry point
   124 = E477			COLDSV  =   $E477       ; Coldstart entry point
   125
   126 				;---------------------------------------
   127 				; CONSTANTS
   128 				;---------------------------------------
   129
   130 = 0005			GETREC  =   $05         ; CIO CMD TO GET RECORD
   131 = 0009			PUTREC  =   $09         ; CIO CMD TO PUT RECORD
   132 = 000B			PUTCHR  =   $0B         ; CIO CMD TO PUT CHAR
   133
   134 = 0071			DEVIDN  =   $71         ; SIO DEVID
   135 = 0040			DSREAD  =   $40         ; FUJI->ATARI
   136 = 0080			DSWRIT  =   $80         ; ATARI->FUJI
   137 = 0004			MAXDEV  =   4           ; # OF N: DEVS
   138 = 0088			EOF     =   $88         ; ERROR 136
   139
   140 = 009B			EOL     =   $9B         ; EOL CHAR
   141 = 000D			CR      =   $0D         ; Carrige Return
   142 = 000A			LF      =   $0A         ; Linefeed
   143
   144 = 001C			ESC_KEY =   $1C         ; Hardware code for ESC
   145 = 0021			SPC_KEY =   $21         ; Hardware code for SPACE
   146
   147 = 0004			OINPUT  =   $04         ; CIO/SIO direction
   148 = 0008			OOUTPUT =   $08         ; CIO/SIO direction
   149
   150 				; FujiNet SIO command bytes
   151 = 0001			CMD_DRIVE_CHG       = $01
   152 = 002C			CMD_CD              = $2C
   153 = 00A1			CMD_COPY            = $A1
   154 = 0002			CMD_DIR             = $02
   155 = 0021			CMD_DEL             = $21
   156 = 0028			CMD_LOAD            = $28
   157 = 0023			CMD_LOCK            = $23
   158 = 00FD			CMD_LOGIN           = $FD
   159 = 002A			CMD_MKDIR           = $2A
   160 = 0030			CMD_NPWD            = $30
   161 = 0054			CMD_NTRANS          = 'T'
   162 = 00FE			CMD_PASSWD          = $FE
   163 = 0020			CMD_RENAME          = $20
   164 = 002B			CMD_RMDIR           = $2B
   165 = 00F0			CMD_SUBMIT          = $F0
   166 = 00F0			CMD_TYPE            = $F0
   167 = 0024			CMD_UNLOCK          = $24
   168 = 00F0			CMD_CAR             = $F0
   169 = 00F0			CMD_CLS             = $F0
   170 = 00F0			CMD_COLD            = $F0
   171 = 00F0			CMD_HELP            = $F0
   172 = 00F0			CMD_NOBASIC         = $F0
   173 = 00F0			CMD_NOSCREEN        = $F0
   174 = 00F0			CMD_PRINT           = $F0
   175 = 00F0			CMD_REENTER         = $F0
   176 = 00F0			CMD_REM             = $F0
   177 = 00F0			CMD_RUN             = $F0
   178 = 00F0			CMD_SCREEN          = $F0
   179 = 00F0			CMD_WARM            = $F0
   180 = 00F0			CMD_XEP             = $F0
   181 = 00F0			CMD_AUTORUN         = $F0
   182
   183 				;;; Macros ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   184
   185 				        .MACRO DCBC
   186 				        .LOCAL
   187 				        LDY     #$0C
   188 				?DCBL   LDA     %%1,Y
   189 				        STA     DCB,Y
   190 				        DEY
   191 				        BPL     ?DCBL
   192 				        .ENDL
   193 				        .ENDM
   194
   195 				; ATR Header
   196 				;        ORG     $0700
   197 					    ORG	    $06f0
   198 				        OPT     h-
   199 06F0 96 02 80 16 80		    DTA	    $96,$02,$80,$16,$80
   200 06F5 00 00 00 00 00 00 + :11     DTA	    $00
   201
   202 				;;; Initialization ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   203
   204 				;        ORG     $0700
   205 				;        OPT     h-
   206
   207 0700 00			HDR:    .BYTE   $00                 ; BLFAG: Boot flag equals zero (unused)
   208 0701 22			        .BYTE   [BOOTEND-HDR]/128   ; BRCNT: Number of consecutive sectors to read
   209 0702 00 07		        .WORD   HDR                 ; BLDADR: Boot sector load address ($700).
   210 0704 C0 E4		        .WORD   $E4C0               ; BIWTARR: Init addr (addr of RTS in ROM)
   211
   212 				;HDR:    .BYTE   $00                 ; BLFAG: Boot flag equals zero (unused)
   213 				;        .BYTE   [PGEND-HDR]/128-2   ; BRCNT: Number of consecutive sectors to read
   214 				;        .WORD   $0700               ; BLDADR: Boot sector load address ($700).
   215 				;        .WORD   $E4C0               ; BIWTARR: Init addr (addr of RTS in ROM)
   216
   217 0706 4C 09 07			    JMP	    START
   218 				;	ORG	*+$64
   219
   220 0709 A5 0C		START:  LDA     DOSINI
   221 070B 8D 27 07		        STA     RESET+1
   222 070E A5 0D		        LDA     DOSINI+1
   223 0710 8D 28 07		        STA     RESET+2
   224
   225 0713 A9 26		        LDA     #<RESET
   226 0715 85 0C		        STA     DOSINI
   227 0717 A9 07		        LDA     #>RESET
   228 0719 85 0D		        STA     DOSINI+1
   229 071B A9 CE		        LDA     #<DOS       ; Point to DOS & CP below
   230 071D 85 0A		        STA     DOSVEC
   231 071F A9 0A		        LDA     #>DOS
   232 0721 85 0B		        STA     DOSVEC+1
   233
   234 0723 4C 39 07		        JMP     ALTMEML     ; Alter MEMLO
   235
   236 0726 20 FF FF		RESET:  JSR     $FFFF       ; Jump to extant DOSINI
   237
   238 0729 A9 4E		        LDA     #'N'
   239 072B 8D 00 18		        STA     RBUF
   240 072E 20 44 07		        JSR     IHTBS       ; Insert into HATABS
   241
   242 0731 A9 44		        LDA     #'D'
   243 0733 8D 00 18		        STA     RBUF
   244 0736 20 44 07		        JSR     IHTBS       ; Clone N: as D: for compatibility
   245
   246 				;---------------------------------------
   247 				;  Alter MEMLO
   248 				;---------------------------------------
   249 0739			ALTMEML:
   250 0739 A9 00		        LDA     #<PGEND
   251 073B 8D E7 02		        STA     MEMLO
   252 073E A9 19		        LDA     #>PGEND
   253 0740 8D E8 02		        STA     MEMLO+1
   254
   255 				        ;; Back to DOS
   256
   257 0743 60			        RTS
   258
   259 				;---------------------------------------
   260 				; Insert entry into HATABS
   261 				;---------------------------------------
   262
   263 0744			IHTBS:
   264 0744 A0 00		        LDY     #$00
   265 0746 B9 1A 03		IH1     LDA     HATABS,Y
   266 0749 F0 0C		        BEQ     HFND
   267 				        ;CMP     #'N'
   268 074B CD 00 18		        CMP     RBUF
   269 074E F0 07		        BEQ     HFND
   270 0750 C8			        INY
   271 0751 C8			        INY
   272 0752 C8			        INY
   273 0753 C0 21		        CPY     #11*3
   274 0755 90 EF		        BCC     IH1
   275
   276 				        ;; Found a slot
   277
   278 0757			HFND:
   279 				        ;LDA     #'N'
   280 				;--
   281 0757 AD 00 18		        LDA     RBUF
   282 075A AA			        TAX
   283 				;--
   284 075B 99 1A 03		        STA     HATABS,Y
   285 075E A9 FD		        LDA     #<CIOHND
   286 0760 99 1B 03		        STA     HATABS+1,Y
   287 0763 A9 16		        LDA     #>CIOHND
   288 0765 99 1C 03		        STA     HATABS+2,Y
   289
   290 0768 E0 44		        CPX     #'D'
   291 076A F0 01		        BEQ     HATABS_CONT
   292 076C 60			        RTS
   293
   294 076D			HATABS_CONT:
   295 				        ;; And we're done with HATABS
   296
   297 				        ;; Query FUJINET
   298
   299 076D 20 24 09		        JSR     STPOLL
   300
   301 				        ;; Output Ready/Error
   302
   303 0770			OBANR:
   304 0770 A2 00		        LDX     #$00        ; IOCB #0
   305 0772 A9 09		        LDA     #PUTREC
   306 0774 9D 42 03		        STA     ICCOM,X
   307 0777 A9 28		        LDA     #$28        ; 40 CHARS Max
   308 0779 9D 48 03		        STA     ICBLL,X
   309 077C 8A			        TXA
   310 077D 9D 49 03		        STA     ICBLH,X
   311 0780 AD 03 03		        LDA     DSTATS      ; Check DSTATS
   312 0783 10 06		        BPL     OBRDY       ; < 128 = Ready
   313
   314 				        ;; Status returned error.
   315
   316 0785			OBERR:
   317 0785 A9 23		        LDA     #<BERROR
   318 0787 A0 17		        LDY     #>BERROR
   319 0789 50 04		        BVC     OBCIO
   320
   321 				        ;; Status returned ready.
   322
   323 078B			OBRDY:
   324 078B A9 09		        LDA     #<BREADY
   325 078D A0 17		        LDY     #>BREADY
   326
   327 078F			OBCIO:
   328 078F 9D 44 03		        STA     ICBAL,X
   329 0792 98			        TYA
   330 0793 9D 45 03		        STA     ICBAH,X
   331
   332 0796 20 56 E4		        JSR     CIOV
   333
   334 				        ;; Vector in proceed interrupt
   335
   336 0799			SPRCED:
   337 0799 A9 5D		        LDA     #<PRCVEC
   338 079B 8D 02 02		        STA     VPRCED
   339 079E A9 0A		        LDA     #>PRCVEC
   340 07A0 8D 03 02		        STA     VPRCED+1
   341
   342 				        ;; And we are done, back to DOS.
   343 07A3 18			        CLC
   344 07A4 60			        RTS
   345
   346 				;;; End Initialization Code ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   347
   348 				; Copy command's template DCB struct to OS's DCB struct (12 bytes)
   349 07A5			DOSIOV:
   350 07A5 8D AE 07		        STA     DODCBL+1
   351 07A8 8C AF 07		        STY     DODCBL+2
   352 07AB A0 0C		        LDY     #$0C
   353 07AD B9 FF FF		DODCBL  LDA     $FFFF,Y
   354 07B0 99 00 03		        STA     DCB,Y
   355 07B3 88			        DEY
   356 07B4 10 F7		        BPL     DODCBL
   357
   358 07B6			SIOVDST:
   359 07B6 20 59 E4		        JSR     SIOV
   360 07B9 AC 03 03		        LDY     DSTATS
   361 07BC 98			        TYA
   362 07BD 60			        RTS
   363
   364
   365 				;---------------------------------------
   366 				; CIO OPEN
   367 				;---------------------------------------
   368
   369 07BE			OPEN:
   370 				        ;; Prepare DCB
   371
   372 07BE 20 59 0A		        JSR     GDIDX       ; Get Device ID in X (0-3)
   373 07C1 A5 21		        LDA     ZICDNO      ; IOCB UNIT # (1-4)
   374 07C3 8D 01 08		        STA     OPNDCB+1    ; Store in DUNIT
   375 07C6 A5 24		        LDA     ZICBAL      ; Get filename buffer
   376 07C8 8D 04 08		        STA     OPNDCB+4    ; stuff in DBUF
   377 07CB A5 25		        LDA     ZICBAH      ; ...
   378 07CD 8D 05 08		        STA     OPNDCB+5    ; ...
   379 07D0 A5 2A		        LDA     ZICAX1      ; Get desired AUX1/AUX2
   380 07D2 8D 0A 08		        STA     OPNDCB+10   ; Save them, and store in DAUX1/DAUX2
   381 07D5 A5 2B		        LDA     ZICAX2      ; ...
   382 07D7 8D 0B 08		        STA     OPNDCB+11   ; ...
   383
   384 				        ;;  Copy DCB template to DCB
   385
   386 07DA A9 00		        LDA     #<OPNDCB
   387 07DC A0 08		        LDY     #>OPNDCB
   388
   389 				        ;;  Send to #FujiNet
   390
   391 07DE 20 A5 07		        JSR     DOSIOV
   392
   393 				        ;; Return DSTATS, unless 144, then get extended error
   394
   395 07E1			OPCERR:
   396 07E1 C0 90		        CPY     #$90        ; ERR 144?
   397 07E3 D0 06		        BNE     OPDONE      ; NOPE. RETURN DSTATS
   398
   399 				        ;; 144 - get extended error
   400
   401 07E5 20 24 09		        JSR     STPOLL      ; POLL FOR STATUS
   402 07E8 AC ED 02		        LDY     DVSTAT+3
   403
   404 				       ; RESET BUFFER LENGTH + OFFSET
   405
   406 07EB			OPDONE:
   407 07EB A9 01		        LDA     #$01
   408 07ED 8D 41 17		        STA     TRIP
   409 07F0 20 59 0A		        JSR     GDIDX
   410 07F3 A9 00		        LDA     #$00
   411 07F5 9D 42 17		        STA     RLEN,X
   412 07F8 9D 4A 17		        STA     TOFF,X
   413 07FB 9D 46 17		        STA     ROFF,X
   414 07FE 98			        TYA
   415 07FF 60			        RTS                ; AY = ERROR
   416
   417 0800			OPNDCB:
   418 0800 71			        .BYTE   DEVIDN  ; DDEVIC
   419 0801 FF			        .BYTE   $FF     ; DUNIT
   420 0802 4F			        .BYTE   'O'     ; DCOMND
   421 0803 80			        .BYTE   $80     ; DSTATS
   422 0804 FF			        .BYTE   $FF     ; DBUFL
   423 0805 FF			        .BYTE   $FF     ; DBUFH
   424 0806 0F			        .BYTE   $0F     ; DTIMLO
   425 0807 00			        .BYTE   $00     ; DRESVD
   426 0808 00			        .BYTE   $00     ; DBYTL
   427 0809 01			        .BYTE   $01     ; DBYTH
   428 080A FF			        .BYTE   $FF     ; DAUX1
   429 080B FF			        .BYTE   $FF     ; DAUX2
   430
   431 				; End CIO OPEN
   432 				;---------------------------------------
   433
   434 				;---------------------------------------
   435 				; CIO CLOSE 
   436 				;---------------------------------------
   437
   438 080C			CLOSE:
   439 080C 20 50 0A		        JSR     DIPRCD      ; Disable Interrupts
   440 080F 20 59 0A		        JSR     GDIDX
   441 0812 20 AF 08		        JSR     PFLUSH      ; Do a Put Flush if needed.
   442
   443 0815 A5 21		        LDA     ZICDNO      ; IOCB Unit #
   444 0817 8D 22 08		        STA     CLODCB+1    ; to DCB...
   445
   446 081A A9 21		        LDA     #<CLODCB
   447 081C A0 08		        LDY     #>CLODCB
   448
   449 081E 4C A5 07		        JMP     DOSIOV
   450
   451 0821 71			CLODCB .BYTE    DEVIDN      ; DDEVIC
   452 0822 FF			       .BYTE    $FF         ; DUNIT
   453 0823 43			       .BYTE    'C'         ; DCOMND
   454 0824 00			       .BYTE    $00         ; DSTATS
   455 0825 00			       .BYTE    $00         ; DBUFL
   456 0826 00			       .BYTE    $00         ; DBUFH
   457 0827 0F			       .BYTE    $0F         ; DTIMLO
   458 0828 00			       .BYTE    $00         ; DRESVD
   459 0829 00			       .BYTE    $00         ; DBYTL
   460 082A 00			       .BYTE    $00         ; DBYTH
   461 082B 00			       .BYTE    $00         ; DAUX1
   462 082C 00			       .BYTE    $00         ; DAUX2
   463
   464 				; End CIO CLOSE
   465 				;---------------------------------------
   466
   467 				;---------------------------------------
   468 				; CIO GET
   469 				;---------------------------------------
   470
   471 082D 20 59 0A		GET:    JSR     GDIDX       ; IOCB UNIT #-1 into X
   472 0830 BD 42 17		        LDA     RLEN,X      ; Get # of RX chars waiting
   473 0833 D0 2B		        BNE     GETDISC     ; LEN > 0?
   474
   475 				        ;; If RX buffer is empty, get # of chars waiting...
   476
   477 0835 20 24 09		        JSR     STPOLL      ; Status Poll
   478 0838 20 59 0A		        JSR     GDIDX       ; IOCB UNIT -1 into X (because Poll trashes X)
   479 083B AD EA 02		        LDA     DVSTAT      ; # of bytes waiting (0-127)
   480 083E 9D 42 17		        STA     RLEN,X      ; Store in RX Len
   481 0841 F0 22		        BEQ     RETEOF
   482
   483 0843 A5 21		GETDO:  LDA     ZICDNO      ; Get IOCB UNIT #
   484 0845 8D 83 08		        STA     GETDCB+1    ; Store into DUNIT
   485 0848 AD EA 02		        LDA     DVSTAT      ; # of bytes waiting
   486 084B 8D 8A 08		        STA     GETDCB+8    ; Store into DBYT...
   487 084E 8D 8C 08		        STA     GETDCB+10   ; and DAUX1...
   488
   489 0851 A9 82		        LDA     #<GETDCB
   490 0853 A0 08		        LDY     #>GETDCB
   491
   492 0855 20 A5 07		        JSR     DOSIOV
   493
   494 				        ;; Clear the Receive buffer offset.
   495
   496 0858 20 59 0A		        JSR     GDIDX       ; IOCB UNIT #-1 into X
   497 085B A9 00		        LDA     #$00
   498 085D 9D 46 17		        STA     ROFF,X
   499
   500 0860			GETDISC:
   501 				        ;LDA     DVSTAT+2    ; Did we disconnect?
   502 0860 AD ED 02		        LDA     DVSTAT+3    ; Did we disconnect?
   503 0863 D0 04		        BNE     GETUPDP     ; nope, update the buffer cursor.
   504
   505 				        ;; We disconnected, emit an EOF.
   506
   507 0865			RETEOF:
   508 0865 A0 88		        LDY     #EOF
   509 0867 98			        TYA
   510 0868 60			        RTS                 ; buh-bye.
   511
   512 0869			GETUPDP:
   513 0869 DE 42 17		        DEC     RLEN,X      ; Decrement RX length.
   514 086C BC 46 17		        LDY     ROFF,X      ; Get RX offset cursor.
   515
   516 				        ;; Return Next char from appropriate RX buffer.
   517
   518 086F B9 00 18		        LDA     RBUF,Y
   519
   520 				        ;; Increment RX offset
   521
   522 0872 FE 46 17		GX:     INC     ROFF,X      ; Increment RX offset.
   523 0875 A8			        TAY                 ; stuff returned val into Y temporarily.
   524
   525 				        ;; If requested RX buffer is empty, reset TRIP.
   526
   527 0876 BD 42 17		        LDA     RLEN,X
   528 0879 D0 03		        BNE     GETDONE
   529 087B 8D 41 17		        STA     TRIP
   530
   531 				        ;; Return byte back to CIO.
   532
   533 087E			GETDONE:
   534 087E 98			        TYA                 ; Move returned val back.
   535 087F A0 01		        LDY     #$01        ; SUCCESS
   536
   537 0881 60			        RTS                 ; DONE...
   538
   539 0882			GETDCB:
   540 0882 71			       .BYTE    DEVIDN      ; DDEVIC
   541 0883 FF			       .BYTE    $FF         ; DUNIT
   542 0884 52			       .BYTE    'R'         ; DCOMND
   543 0885 40			       .BYTE    $40         ; DSTATS
   544 0886 00			       .BYTE    <RBUF       ; DBUFL
   545 0887 18			       .BYTE    >RBUF       ; DBUFH
   546 0888 0F			       .BYTE    $0F         ; DTIMLO
   547 0889 00			       .BYTE    $00         ; DRESVD
   548 088A FF			       .BYTE    $FF         ; DBYTL
   549 088B 00			       .BYTE    $00         ; DBYTH
   550 088C FF			       .BYTE    $FF         ; DAUX1
   551 088D 00			       .BYTE    $00         ; DAUX2
   552
   553 				; End CIO GET
   554 				;---------------------------------------
   555
   556 				;---------------------------------------
   557 				; CIO PUT
   558 				;---------------------------------------
   559
   560 088E			PUT:    ;; Add to TX buffer.
   561
   562 088E 20 59 0A		        JSR     GDIDX
   563 0891 BC 4A 17		        LDY     TOFF,X      ; GET TX cursor.
   564 0894 99 80 18		        STA     TBUF,Y      ; TX Buffer
   565
   566 0897 FE 4A 17		POFF:   INC     TOFF,X      ; Increment TX cursor
   567 089A A0 01		        LDY     #$01        ; SUCCESSFUL
   568
   569 				        ;; Do a PUT FLUSH if EOL or buffer full.
   570
   571 089C C9 9B		        CMP     #EOL        ; EOL?
   572 089E F0 0B		        BEQ     FLUSH       ; FLUSH BUFFER
   573 08A0 20 59 0A		        JSR     GDIDX       ; GET OFFSET
   574 08A3 BD 4A 17		        LDA     TOFF,X
   575 08A6 C9 7F		        CMP     #$7F        ; LEN = $FF?
   576 08A8 F0 01		        BEQ     FLUSH       ; FLUSH BUFFER
   577 08AA 60			        RTS
   578
   579 				       ; FLUSH BUFFER, IF ASKED.
   580
   581 08AB 20 AF 08		FLUSH:  JSR     PFLUSH      ; FLUSH BUFFER
   582 08AE 60			        RTS
   583
   584 08AF			PFLUSH:
   585
   586 				       ; CHECK CONNECTION, AND EOF
   587 				       ; IF DISCONNECTED.
   588
   589 08AF 20 24 09		        JSR     STPOLL      ; GET STATUS
   590 08B2 AD ED 02		        LDA     DVSTAT+3
   591 08B5 F0 AE		        BEQ     RETEOF
   592
   593 08B7 20 59 0A		PF1:    JSR     GDIDX       ; GET DEV X
   594 08BA BD 4A 17		        LDA     TOFF,X
   595 08BD D0 03		        BNE     PF2
   596 08BF 4C DF 08		        JMP     PDONE
   597
   598 				       ; FILL OUT DCB FOR PUT FLUSH
   599
   600 08C2 A5 21		PF2:    LDA     ZICDNO
   601 08C4 8D E3 08		        STA     PUTDCB+1
   602
   603 				       ; FINISH DCB AND DO SIOV
   604
   605 08C7 BD 4A 17		TBX:    LDA     TOFF,X
   606 08CA 8D EA 08		        STA     PUTDCB+8
   607 08CD 8D EC 08		        STA     PUTDCB+10
   608
   609 08D0 A9 E2		        LDA     #<PUTDCB
   610 08D2 A0 08		        LDY     #>PUTDCB
   611 08D4 20 A5 07		        JSR     DOSIOV
   612
   613 				        ; CLEAR THE OFFSET CURSOR
   614 				        ; AND LENGTH
   615
   616 08D7 20 59 0A		        JSR     GDIDX
   617 08DA A9 00		        LDA     #$00
   618 08DC 9D 4A 17		        STA     TOFF,X
   619
   620 08DF A0 01		PDONE:  LDY     #$01
   621 08E1 60			        RTS
   622
   623 08E2 71			PUTDCB .BYTE    DEVIDN      ; DDEVIC
   624 08E3 FF			       .BYTE    $FF         ; DUNIT
   625 08E4 57			       .BYTE    'W'         ; DCOMND
   626 08E5 80			       .BYTE    $80         ; DSTATS
   627 08E6 80			       .BYTE    $80         ; DBUFL
   628 08E7 18			       .BYTE    >TBUF       ; DBUFH
   629 08E8 0F			       .BYTE    $0F         ; DTIMLO
   630 08E9 00			       .BYTE    $00         ; DRESVD
   631 08EA FF			       .BYTE    $FF         ; DBYTL
   632 08EB 00			       .BYTE    $00         ; DBYTH
   633 08EC FF			       .BYTE    $FF         ; DAUX1
   634 08ED 00			       .BYTE    $00         ; DAUX2
   635
   636 				; End CIO PUT
   637 				;---------------------------------------
   638
   639 				;---------------------------------------
   640 				; CIO STATUS 
   641 				;---------------------------------------
   642
   643 08EE 20 47 0A		STATUS: JSR     ENPRCD      ; ENABLE PRCD
   644 08F1 20 59 0A		        JSR     GDIDX       ; GET DEVICE#
   645 08F4 BD 42 17		        LDA     RLEN,X      ; GET RLEN
   646 08F7 D0 05		        BNE     STSLEN      ; RLEN > 0?
   647 08F9 AD 41 17		        LDA     TRIP
   648 08FC D0 15		        BNE     STTRI1      ; TRIP = 1?
   649
   650 				        ; NO TRIP, RETURN SAVED LEN
   651
   652 08FE BD 42 17		STSLEN: LDA     RLEN,X      ; GET RLEN
   653 0901 8D EA 02		        STA     DVSTAT      ; RET IN DVSTAT
   654
   655 				        ; If you don't need to preserve Y then use it instead of A
   656 0904 A9 00		        LDA     #$00
   657 0906 8D EB 02		        STA     DVSTAT+1
   658
   659 				        ; and INY here
   660 0909 A9 01		        LDA     #$01
   661 090B 8D EC 02		        STA     DVSTAT+2
   662 090E 8D ED 02		        STA     DVSTAT+3
   663
   664 0911 D0 0B		        BNE     STDONE
   665
   666 				        ; DO POLL AND UPDATE RCV LEN
   667
   668 0913 20 24 09		STTRI1: JSR     STPOLL      ; POLL FOR ST
   669 0916 9D 42 17		        STA     RLEN,X
   670
   671 				        ; UPDATE TRIP FLAG
   672
   673 0919 D0 03		STTRIU: BNE     STDONE
   674 091B 8D 41 17		        STA     TRIP        ; RLEN = 0
   675
   676 				        ; RETURN CONNECTED? FLAG.
   677
   678 091E AD EC 02		STDONE: LDA     DVSTAT+2
   679 0921 A0 01		        LDY     #$01
   680 0923 60			        RTS
   681
   682 				       ; ASK FUJINET FOR STATUS
   683
   684 0924			STPOLL:
   685 0924 A5 21		        LDA     ZICDNO      ; IOCB #
   686 0926 8D 49 09		        STA     STADCB+1
   687
   688 0929 A9 48		        LDA     #<STADCB
   689 092B A0 09		        LDY     #>STADCB
   690
   691 092D 20 A5 07		        JSR     DOSIOV
   692
   693 				        ;; > 127 bytes? make it 127 bytes.
   694
   695 0930 AD EB 02		        LDA     DVSTAT+1
   696 0933 D0 07		        BNE     STADJ
   697 0935 AD EA 02		        LDA     DVSTAT
   698 0938 30 02		        BMI     STADJ
   699 093A 50 08		        BVC     STP2        ; <= 127 bytes...
   700
   701 093C A9 7F		STADJ   LDA     #$7F
   702 093E 8D EA 02		        STA     DVSTAT
   703 				        
   704 0941 8D EB 02		        STA     DVSTAT+1
   705
   706 				       ; A = CONNECTION STATUS
   707
   708 0944 AD EC 02		STP2:   LDA     DVSTAT+2
   709 0947 60			        RTS
   710
   711 0948 71			STADCB: .BYTE   DEVIDN      ; DDEVIC
   712 0949 FF			        .BYTE   $FF         ; DUNIT
   713 094A 53			        .BYTE   'S'         ; DCOMND
   714 094B 40			        .BYTE   $40         ; DSTATS
   715 094C EA			        .BYTE   <DVSTAT     ; DBUFL
   716 094D 02			        .BYTE   >DVSTAT     ; DBUFH
   717 094E 0F			        .BYTE   $0F         ; DTIMLO
   718 094F 00			        .BYTE   $00         ; DRESVD
   719 0950 04			        .BYTE   $04         ; DBYTL
   720 0951 00			        .BYTE   $00         ; DBYTH
   721 0952 00			        .BYTE   $00         ; DAUX1
   722 0953 00			        .BYTE   $00         ; DAUX2
   723
   724 				; End CIO STATUS
   725 				;---------------------------------------
   726
   727 				;---------------------------------------
   728 				; CIO SPECIAL
   729 				;---------------------------------------
   730
   731 0954			SPEC:   ; HANDLE LOCAL COMMANDS.
   732
   733 0954 A5 22		        LDA     ZICCOM
   734 0956 C9 0F		        CMP     #$0F        ; 15 = FLUSH
   735 0958 D0 06		        BNE     S1          ; NO.
   736 095A 20 AF 08		        JSR     PFLUSH      ; DO FLUSH
   737 095D A0 01		        LDY     #$01        ; SUCCESS
   738 095F 60			        RTS
   739
   740 0960 C9 28		S1:     CMP     #40         ; 40 = LOAD AND EXECUTE
   741 0962 F0 03		        BEQ     S2          ; YES.
   742 0964 4C 68 09		        JMP     S3          ; NO. SKIP OVER spec40
   743
   744 0967 60			S2:     RTS
   745 				       ; HANDLE SIO COMMANDS.
   746 				       ; GET DSTATS FOR COMMAND
   747 0968			S3:
   748 0968 A5 21		        LDA     ZICDNO
   749 096A 8D B0 09		        STA     SPEDCB+1
   750 096D A5 22		        LDA     ZICCOM
   751 096F 8D B9 09		        STA     SPEDCB+10
   752
   753 0972 A9 AF		        LDA     #<SPEDCB
   754 0974 A0 09		        LDY     #>SPEDCB
   755 0976 20 A5 07		        JSR     DOSIOV
   756
   757 0979 30 0A		        BMI     :DSERR
   758
   759 				       ; WE GOT A DSTATS INQUIRY
   760 				       ; IF $FF, THE COMMAND IS
   761 				       ; INVALID
   762
   763 097B AD 4E 17		DSOK:   LDA     INQDS
   764 097E C9 FF		        CMP     #$FF        ; INVALID?
   765 0980 D0 04		        BNE     DSGO        ; DO THE CMD
   766 0982 A0 92		        LDY     #$92        ; UNIMP CMD
   767 0984 98			        TYA
   768 0985			DSERR:
   769 0985 60			        RTS
   770
   771 				        ;; Do the special, since we want to pass in all the IOCB
   772 				        ;; Parameters to the DCB, This is being done long-hand.
   773
   774 0986 A5 22		DSGO:   LDA     ZICCOM
   775 0988 48			        PHA
   776 0989 A9 00		        LDA     #$00
   777 098B 48			        PHA
   778 098C AD 4E 17		        LDA     INQDS
   779 098F 48			        PHA
   780 0990 A9 01		        LDA     #$01
   781 0992 48			        PHA
   782 0993 A5 24		        LDA     ZICBAL
   783 0995 48			        PHA
   784 0996 A5 2A		        LDA     ZICAX1
   785 0998 48			        PHA
   786 0999 A5 25		        LDA     ZICBAH
   787 099B 48			        PHA
   788 099C A5 2B		        LDA     ZICAX2
   789 099E 48			        PHA
   790 099F A0 03		        LDY     #$03
   791 09A1			DSGOL:
   792 09A1 68			        PLA
   793 09A2 99 08 03		        STA     DBYTL,Y
   794 09A5 68			        PLA
   795 09A6 99 02 03		        STA     DCOMND,Y
   796 09A9 88			        DEY
   797 09AA 10 F5		        BPL     DSGOL
   798
   799 09AC 4C B6 07		        JMP     SIOVDST
   800
   801 				        ;; Return DSTATS in Y and A
   802
   803 09AF 71			SPEDCB  .BYTE   DEVIDN      ; DDEVIC
   804 09B0 FF			        .BYTE   $FF         ; DUNIT
   805 09B1 FF			        .BYTE   $FF         ; DCOMND ; inq
   806 09B2 40			        .BYTE   $40         ; DSTATS
   807 09B3 4E			        .BYTE   <INQDS      ; DBUFL
   808 09B4 17			        .BYTE   >INQDS      ; DBUFH
   809 09B5 0F			        .BYTE   $0F         ; DTIMLO
   810 09B6 00			        .BYTE   $00         ; DRESVD
   811 09B7 01			        .BYTE   $01         ; DBYTL
   812 09B8 00			        .BYTE   $00         ; DBYTH
   813 09B9 FF			        .BYTE   $FF         ; DAUX1
   814 09BA FF			        .BYTE   $FF         ; DAUX2
   815
   816 				; End CIO SPECIAL
   817 				;---------------------------------------
   818
   819 				;#######################################
   820 				;#                                     #
   821 				;#             CIO Functions           # 
   822 				;#                                     #
   823 				;#######################################
   824
   825
   826 				;---------------------------------------
   827 09BB			CIOCLOSE:
   828 				;---------------------------------------
   829 				    ; X must contain IOCB offset ($10,$20,..)
   830 09BB A9 0C		        LDA     #$0C            ; Close #1 first
   831 09BD 9D 42 03		        STA     ICCOM,X
   832 09C0 4C 56 E4		        JMP     CIOV
   833
   834 				;---------------------------------------
   835 09C3			CIOOPEN:
   836 				;---------------------------------------
   837 				    ; Input: 
   838 				    ; X = IOCB offset ($10,$20,..)
   839 				    ; Y = data direction (4=inp,8=out,12=i/o)
   840 				    ; INBUFF contains ICBAL/H
   841 09C3 A9 03		        LDA     #$03            ; 3 = CIO 'OPEN FILE'
   842 09C5 9D 42 03		        STA     ICCOM,X
   843 09C8 A5 F3		        LDA     INBUFF          ; Pointer to filename
   844 09CA 9D 44 03		        STA     ICBAL,X
   845 09CD A5 F4		        LDA     INBUFF+1        ; Pointer to filename
   846 09CF 9D 45 03		        STA     ICBAH,X
   847 09D2 98			        TYA
   848 09D3 9D 4A 03		        STA     ICAX1,X         ; Data direction
   849 09D6 A9 00		        LDA     #$00
   850 09D8 9D 4B 03		        STA     ICAX2,X         ; Unused
   851 09DB 20 56 E4		        JSR     CIOV            ; Call CIO
   852
   853 09DE			CIOOPEN_DONE:
   854 09DE 60			        RTS
   855
   856 				;---------------------------------------
   857 09DF			CIOSTATUS:
   858 				;---------------------------------------
   859 09DF A9 0D		        LDA     #$0D
   860 09E1 9D 42 03		        STA     ICCOM,X
   861 09E4 20 56 E4		        JSR     CIOV
   862 09E7 10 03		        BPL     CIOSTATUS_DONE
   863 09E9 20 96 0A		        JSR     PRINT_ERROR
   864
   865 09EC			CIOSTATUS_DONE:
   866 09EC 60			        RTS
   867 				        
   868
   869 				;---------------------------------------
   870 09ED			CIOGET:
   871 				;---------------------------------------
   872 				    ; Input: 
   873 				    ; X = IOCB offset ($10,$20,..)
   874 				    ; A = ICBLL
   875 				    ; Y = ICBLH
   876 				    ; INBUFF contains ICBAL/H
   877 09ED 48			        PHA                 ; Stash Buffer length Lo
   878 09EE A9 07		        LDA     #$07        ; GET BYTES command
   879 09F0 9D 42 03		        STA     ICCOM,X
   880 09F3 A5 F3		        LDA     INBUFF      ; Get buffer addr from pointer
   881 09F5 9D 44 03		        STA     ICBAL,X
   882 09F8 A5 F4		        LDA     INBUFF+1
   883 09FA 9D 45 03		        STA     ICBAH,X
   884 09FD 68			        PLA                 ; Retrieve Buffer length Lo
   885 09FE 9D 48 03		        STA     ICBLL,X
   886 0A01 98			        TYA                 ; Get Buffer length Hi
   887 0A02 9D 49 03		        STA     ICBLH,X
   888 0A05 20 56 E4		        JSR     CIOV        ; Bon voyage
   889 0A08 10 00		        BPL     CIOGET_DONE
   890 				;        JMP     PRINT_ERROR
   891
   892 0A0A			CIOGET_DONE:
   893 0A0A 60			        RTS
   894
   895 				;---------------------------------------
   896 0A0B			CIOPUT:
   897 				;---------------------------------------
   898 				    ; Input: 
   899 				    ; X = IOCB offset ($10,$20,..)
   900 				    ; A = ICBLL
   901 				    ; Y = ICBLH
   902 				    ; INBUFF contains ICBAL/H
   903 0A0B 48			        PHA                 ; Stash Buffer length Lo
   904 0A0C A9 0B		        LDA     #$0B        ; PUT BYTES command
   905 0A0E 9D 42 03		        STA     ICCOM,X
   906 0A11 A5 F3		        LDA     INBUFF      ; Get buffer addr from pointer
   907 0A13 9D 44 03		        STA     ICBAL,X
   908 0A16 A5 F4		        LDA     INBUFF+1
   909 0A18 9D 45 03		        STA     ICBAH,X
   910 0A1B 68			        PLA                 ; Retrieve Buffer length Lo
   911 0A1C 9D 48 03		        STA     ICBLL,X
   912 0A1F 98			        TYA                 ; Get Buffer length Hi
   913 0A20 9D 49 03		        STA     ICBLH,X
   914 0A23 20 56 E4		        JSR     CIOV        ; Bon voyage
   915 0A26 10 00		        BPL     CIOPUT_DONE
   916 				;        JMP     PRINT_ERROR
   917
   918 0A28			CIOPUT_DONE:
   919 0A28 60			        RTS
   920
   921 				;---------------------------------------
   922 0A29			CIOGETREC:
   923 				;---------------------------------------
   924 				    ; Input: 
   925 				    ; X = IOCB offset ($10,$20,..)
   926 				    ; A = ICBLL
   927 				    ; Y = ICBLH
   928 				    ; INBUFF contains ICBAL/H
   929 0A29 48			        PHA                 ; Stash Buffer length Lo
   930 0A2A A9 05		        LDA     #$05        ; GET RECORD command
   931 0A2C 9D 42 03		        STA     ICCOM,X
   932 0A2F A5 F3		        LDA     INBUFF      ; Get buffer addr from pointer
   933 0A31 9D 44 03		        STA     ICBAL,X
   934 0A34 A5 F4		        LDA     INBUFF+1
   935 0A36 9D 45 03		        STA     ICBAH,X
   936 0A39 68			        PLA                 ; Retrieve Buffer length Lo
   937 0A3A 9D 48 03		        STA     ICBLL,X
   938 0A3D 98			        TYA                 ; Get Buffer length Hi
   939 0A3E 9D 49 03		        STA     ICBLH,X
   940
   941 0A41 20 56 E4		        JSR     CIOV        ; Bon voyage
   942 0A44 10 00		        BPL     CIOGETREC_DONE
   943 				;        JMP     PRINT_ERROR
   944
   945 0A46			CIOGETREC_DONE:
   946 0A46 60			        RTS
   947
   948 				;#######################################
   949 				;#                                     #
   950 				;#          Utility Functions          #
   951 				;#                                     #
   952 				;#######################################
   953 				        ; ENABLE PROCEED INTERRUPT
   954
   955 0A47 AD 02 D3		ENPRCD: LDA     PACTL
   956 0A4A 09 01		        ORA     #$01        ; ENABLE BIT 0
   957 0A4C 8D 02 D3		        STA     PACTL
   958 0A4F 60			        RTS
   959
   960 				       ; DISABLE PROCEED INTERRUPT
   961
   962 0A50 AD 02 D3		DIPRCD: LDA     PACTL
   963 0A53 29 FE		        AND     #$FE        ; DISABLE BIT0
   964 0A55 8D 02 D3		        STA     PACTL
   965 0A58 60			        RTS
   966
   967 				       ; GET ZIOCB DEVNO - 1 INTO X
   968
   969 0A59 A6 21		GDIDX:  LDX     ZICDNO      ; IOCB UNIT #
   970 0A5B CA			        DEX                 ; - 1
   971 0A5C 60			        RTS
   972
   973 				;---------------------------------------
   974 				; Proceed Vector
   975 				;---------------------------------------
   976
   977 0A5D A9 01		PRCVEC: LDA     #$01
   978 0A5F 8D 41 17		        STA     TRIP
   979 0A62 68			        PLA
   980 0A63 40			        RTI
   981
   982 				; End Proceed Vector
   983 				;---------------------------------------
   984
   985 				;---------------------------------------
   986 				; Reset LNBUF
   987 				;---------------------------------------
   988 				; Normally this routine is at $DA51
   989 				; But some programs will bank-switch
   990 				; that portion of ROM to RAM
   991 				;---------------------------------------
   992
   993 0A64 A9 05		LDBUFA: LDA     #$05
   994 0A66 85 F4		        STA     INBUFF+1
   995 				;        LDA     #$80
   996 0A68 A9 82		        LDA     #$82
   997 0A6A 85 F3		        STA     INBUFF
   998 0A6C 60			        RTS
   999
  1000 				; End Reset LNBUF
  1001 				;---------------------------------------
  1002
  1003 				;---------------------------------------
  1004 				; Skip spaces
  1005 				;---------------------------------------
  1006 				; Normally this routine is at $DBA1
  1007 				; But some programs will bank-switch
  1008 				; that portion of ROM to RAM
  1009 				;---------------------------------------
  1010
  1011 0A6D A4 F2		SKPSPC: LDY     CIX
  1012 0A6F A9 20		        LDA     #$20
  1013 0A71 D1 F3		@:      CMP     (INBUFF),Y
  1014 0A73 D0 03		        BNE     @+
  1015 0A75 C8			        INY
  1016 0A76 D0 F9		        BNE     @-
  1017 0A78 84 F2		@:      STY     CIX
  1018 0A7A 60			        RTS
  1019
  1020 				; End SKPSPC
  1021 				;---------------------------------------
  1022
  1023 				;---------------------------------------
  1024 				; Print EOL-terminated string
  1025 				; A: String Buffer Lo
  1026 				; Y: String Buffer Hi
  1027 				;---------------------------------------
  1028 0A7B			PRINT_STRING:
  1029
  1030 0A7B A2 00		        LDX     #$00
  1031 				    ;---------------------------------------
  1032 				    ; String Buffer
  1033 				    ;---------------------------------------
  1034 0A7D 9D 44 03		        STA     ICBAL,X
  1035 0A80 98			        TYA
  1036 0A81 9D 45 03		        STA     ICBAH,X
  1037
  1038 				    ;---------------------------------------
  1039 				    ; String Length
  1040 				    ;---------------------------------------
  1041 0A84 A9 80		        LDA     #$80
  1042 0A86 9D 48 03		        STA     ICBLL,X
  1043 0A89 A9 00		        LDA     #$00
  1044 0A8B 9D 49 03		        STA     ICBLH,X
  1045
  1046 				    ;---------------------------------------
  1047 				    ; Call to CIO
  1048 				    ;---------------------------------------
  1049 0A8E A9 09		        LDA     #PUTREC
  1050 0A90 9D 42 03		        STA     ICCOM,X
  1051 0A93 4C 56 E4		        JMP     CIOV
  1052
  1053 				;---------------------------------------
  1054 				; Print integer error number from DOSIOV
  1055 				; Y: Return code from DOSIOV
  1056 				;---------------------------------------
  1057 0A96			PRINT_ERROR:
  1058 0A96 C0 01		        CPY     #$01        ; Exit if success (1)
  1059 0A98 F0 33		        BEQ     PRINT_ERROR_DONE
  1060
  1061 				    ;-----------------------------------
  1062 				    ; If error code = 144, then get
  1063 				    ; extended code from DVSTAT
  1064 				    ;-----------------------------------
  1065 0A9A C0 90		        CPY     #144
  1066 0A9C D0 0A		        BNE     PRINT_ERROR_NEXT
  1067
  1068 0A9E A9 48		        LDA     #<STADCB
  1069 0AA0 A0 09		        LDY     #>STADCB
  1070 0AA2 20 A5 07		        JSR     DOSIOV
  1071 0AA5 AC ED 02		        LDY     DVSTAT+3    ;
  1072
  1073 0AA8			PRINT_ERROR_NEXT:
  1074 				    ;-----------------------------------
  1075 				    ; Convert error code to ASCII
  1076 				    ;-----------------------------------
  1077 0AA8 84 D4		        STY     FR0
  1078 0AAA A9 00		        LDA     #$00
  1079 0AAC 85 D5		        STA     FR0+1
  1080 0AAE 20 AA D9		        JSR     IFP         ; Convert error from int to floating point
  1081 0AB1 20 E6 D8		        JSR     FASC        ; Convert floating point to ASCII
  1082
  1083 				    ;---------------------------------------
  1084 				    ; Find last char in ASCII error (noted by high bit)
  1085 				    ; Unset high bit & append EOL
  1086 				    ;---------------------------------------
  1087 0AB4 A0 FF		        LDY     #$FF        ; Init counter = 0
  1088
  1089 0AB6 C8			@       INY
  1090 0AB7 B1 F3		        LDA     (INBUFF),Y
  1091 0AB9 C9 80		        CMP     #$80
  1092 0ABB 90 F9		        BCC     @-
  1093
  1094 0ABD 29 7F		        AND     #$7F        ; Clear high bit
  1095 0ABF 91 F3		        STA     (INBUFF),Y
  1096 0AC1 C8			        INY
  1097 0AC2 A9 9B		        LDA     #EOL        ; Append EOL
  1098 0AC4 91 F3		        STA     (INBUFF),Y
  1099
  1100 0AC6 A5 F3		        LDA     INBUFF
  1101 0AC8 A4 F4		        LDY     INBUFF+1
  1102 0ACA 4C 7B 0A		        JMP     PRINT_STRING
  1103
  1104 0ACD			PRINT_ERROR_DONE:
  1105 0ACD 60			        RTS
  1106
  1107 				; End Utility Functions
  1108 				;---------------------------------------
  1109
  1110
  1111 				;#######################################
  1112 				;#                                     #
  1113 				;#       COMMAND PROCESSOR (CP)        #
  1114 				;#                                     #
  1115 				;#######################################
  1116
  1117 				;---------------------------------------
  1118 				; DOS Entry point
  1119 				;---------------------------------------
  1120 0ACE			DOS:
  1121 				        ; Autorun injection
  1122 0ACE A9 0F		        LDA     #CMD_IDX.AUTORUN    ; Check for AUTORUN
  1123 0AD0 CD 40 17		        CMP     AUTORUN_FLG         ; True only on 1st entry
  1124 0AD3 F0 06		        BEQ     CPLOOP              ; Skip to Command Processor
  1125 0AD5 8D 40 17		        STA     AUTORUN_FLG         ; Change flag
  1126 0AD8 20 CC 11		        JSR     SUBMIT_AUTORUN      ; Attempt to execute autorun file
  1127 				       
  1128 0ADB			CPLOOP:
  1129 0ADB 20 E1 0A		        JSR     CP          ; Command Processor
  1130 0ADE 4C DB 0A		        JMP     CPLOOP      ; Keep looping
  1131
  1132
  1133 				;---------------------------------------
  1134 				; Main loop
  1135 				;---------------------------------------
  1136
  1137 0AE1			CP:
  1138 0AE1 A9 FF		        LDA     #$FF        ; Clear command
  1139 0AE3 8D 3D 17		        STA     CMD
  1140
  1141 0AE6 20 F5 0A		        JSR     SHOWPROMPT
  1142 0AE9 20 1A 0B		        JSR     GETCMD
  1143 0AEC			AUTORUN_DO:
  1144 0AEC 20 89 0B		        JSR     PARSECMD
  1145 0AEF 30 03		        BMI     CP_DONE     ; Skip DOCMD if CMD == $FF
  1146 0AF1 20 FF 0B		        JSR     DOCMD
  1147 0AF4			CP_DONE:
  1148 0AF4 60			        RTS
  1149
  1150 				;---------------------------------------
  1151 				; Show Command Prompt (Nn:)
  1152 				; Leading EOF requires special CIOV call
  1153 				;---------------------------------------
  1154
  1155 				;---------------------------------------
  1156 0AF5			SHOWPROMPT:
  1157 				;---------------------------------------
  1158
  1159 0AF5 AD 3C 17		        LDA     DOSDR       ; Get the 1,2,... for N1,N2,...
  1160 0AF8 09 30		        ORA     #'0'        ; Convert, say, 1 to '1'
  1161 0AFA 8D CE 15		        STA     PRMPT+2     ; Store in after EOL and N
  1162
  1163 0AFD A2 00		        LDX     #$00
  1164 0AFF A9 0B		        LDA     #PUTCHR
  1165 0B01 9D 42 03		        STA     ICCOM,X
  1166
  1167 0B04 A9 CC		        LDA     #<PRMPT
  1168 0B06 9D 44 03		        STA     ICBAL,X
  1169 0B09 A9 15		        LDA     #>PRMPT
  1170
  1171 0B0B 9D 45 03		        STA     ICBAH,X
  1172 0B0E A9 04		        LDA     #4          ; Prompt length = 4
  1173 0B10 9D 48 03		        STA     ICBLL,X
  1174 0B13 8A			        TXA                 ; Still zero
  1175 0B14 9D 49 03		        STA     ICBLH,X
  1176
  1177 0B17 4C 56 E4		        JMP     CIOV
  1178
  1179 				;---------------------------------------
  1180 0B1A			GETCMD:
  1181 				;---------------------------------------
  1182 0B1A A2 00		        LDX     #$00
  1183 0B1C A9 05		        LDA     #GETREC
  1184 0B1E 9D 42 03		        STA     ICCOM,X
  1185 0B21 A9 82		        LDA     #<LNBUF
  1186 0B23 9D 44 03		        STA     ICBAL,X
  1187 0B26 A9 05		        LDA     #>LNBUF
  1188 0B28 9D 45 03		        STA     ICBAH,X
  1189 0B2B A9 7F		        LDA     #$7F
  1190 0B2D 9D 48 03		        STA     ICBLL,X
  1191 0B30 20 56 E4		        JSR     CIOV
  1192
  1193 0B33			GETCMDTEST:
  1194 0B33 A0 00		        LDY #$00
  1195 0B35 84 F2		        STY CIX
  1196 0B37 20 64 0A		        JSR LDBUFA      ; Reset LNBUF to $0580
  1197 0B3A 20 6D 0A		        JSR SKPSPC      ; Advance CIX to next space
  1198
  1199 				    ;---------------------------------------
  1200 				    ; CMDSEP is an sequence of bytes contains
  1201 				    ; indexes to chars following spaces
  1202 				    ; Iterate to clear CMDSEP bytes
  1203 				    ;---------------------------------------
  1204 0B3D 98			        TYA                 ; A = 0
  1205 0B3E A2 02		        LDX     #$02        ; for X = 2 to 0 step -1
  1206 0B40			GETLOOP:
  1207 0B40 9D 85 0B		        STA     CMDSEP,X
  1208 0B43 CA			        DEX
  1209 0B44 10 FA		        BPL     GETLOOP     ; next X
  1210
  1211 				    ; Initial Delimiter to space
  1212 0B46 A9 20		        LDA     #' '
  1213 0B48 8D 88 0B		        STA     DELIM
  1214
  1215 				    ;---------------------------------------
  1216 				    ; Loop until EOL is encountered
  1217 				    ;---------------------------------------
  1218 0B4B E8			        INX                 ; Reset X to 0
  1219 0B4C			GETCMD_LOOP:
  1220 0B4C B1 F3		        LDA     (INBUFF),Y
  1221 0B4E C9 9B		        CMP     #EOL        ; Found EOL?
  1222 0B50 F0 32		        BEQ     GETCMD_DONE ; yes. skip
  1223 0B52 CD 88 0B		        CMP     DELIM       ; Found space?
  1224 0B55 F0 03		        BEQ     GETCMD_REPL ; yes. Replace it
  1225 0B57 C8			        INY
  1226 0B58 D0 F2		        BNE     GETCMD_LOOP ; "always" non-zero
  1227
  1228 				    ;---------------------------------------
  1229 				    ; March through the cmd line and note
  1230 				    ; the positions of any args as delimited
  1231 				    ; by spaces or quotes. positions saved
  1232 				    ; in CMDSEP,X
  1233 				    ;---------------------------------------
  1234 0B5A			GETCMD_REPL:
  1235 0B5A A9 9B		        LDA     #EOL
  1236 0B5C 91 F3		        STA     (INBUFF),Y
  1237 0B5E C8			        INY
  1238 0B5F B1 F3		        LDA     (INBUFF),Y  ; Skip any run of spaces
  1239 0B61 C9 20		        CMP     #' '
  1240 0B63 F0 F5		        BEQ     GETCMD_REPL ; Keep skipping spaces
  1241
  1242 				    ; Here if any run of spaces has ended
  1243 				    ; Are we standing on a double-quote?
  1244 0B65 C9 22		        CMP     #'"'
  1245 0B67 D0 12		        BNE     GETCMD_WR_OFFSET  ; No. Skip ahead
  1246
  1247 				    ; Here if curr char is a double-quote
  1248 0B69 C8			        INY                 ; Advance the command line index
  1249 0B6A A9 22		        LDA     #'"'        ; Is the curr delim a double-quote?
  1250 0B6C CD 88 0B		        CMP     DELIM       ; If not, change delim to double-quote
  1251 0B6F D0 07		        BNE     GETCMD_DQ_DELIM
  1252
  1253 				    ; Here if curr delim is a double-quote
  1254 				    ; Switch delim to space
  1255 0B71 A9 20		        LDA     #' '
  1256 0B73 8D 88 0B		        STA     DELIM
  1257 0B76 D0 03		        BNE     GETCMD_WR_OFFSET
  1258
  1259 				    ; Here if curr delim is space
  1260 				    ; Switch delim to double-quote
  1261 0B78			GETCMD_DQ_DELIM:
  1262 0B78 8D 88 0B		        STA     DELIM
  1263
  1264 				    ; Note the position for the curr command-line arg
  1265 0B7B			GETCMD_WR_OFFSET:
  1266 0B7B 98			        TYA
  1267 0B7C 9D 85 0B		        STA     CMDSEP,X
  1268 0B7F E8			        INX
  1269 0B80 E0 03		        CPX     #$03
  1270 0B82 90 C8		        BCC     GETCMD_LOOP ; Continue searching
  1271
  1272 0B84			GETCMD_DONE:
  1273 0B84 60			        RTS
  1274
  1275 0B85 FF FF FF		CMDSEP: .BYTE $FF,$FF,$FF
  1276 0B88 20			DELIM:  .BYTE ' '
  1277
  1278 				;---------------------------------------
  1279 0B89			PARSECMD:
  1280 				;---------------------------------------
  1281 0B89 AD 82 05		        LDA     LNBUF
  1282 0B8C C9 9B		        CMP     #EOL        ; Quit immediately if no cmd
  1283 0B8E F0 09		        BEQ     PARSECMD_DONE
  1284
  1285 0B90 20 AE 0B		        JSR     PARSE_INTRINSIC_COMMAND
  1286 0B93 20 E8 0B		        JSR     PARSE_DRIVE_CHANGE
  1287 0B96 20 9A 0B		        JSR     PRINT_UNK_CMD
  1288 0B99			PARSECMD_DONE:
  1289 0B99 60			        RTS
  1290
  1291 0B9A			PRINT_UNK_CMD:
  1292 0B9A AD 3D 17		        LDA     CMD
  1293 0B9D C9 FF		        CMP     #$FF
  1294 0B9F D0 07		        BNE     PRINT_UNK_CMD_DONE
  1295 0BA1 A9 A9		        LDA     #<UNK_CMD_ERR
  1296 0BA3 A0 0B		        LDY     #>UNK_CMD_ERR
  1297 0BA5 20 7B 0A		        JSR     PRINT_STRING
  1298 0BA8			PRINT_UNK_CMD_DONE:
  1299 0BA8 60			        RTS
  1300
  1301 0BA9			UNK_CMD_ERR:
  1302 0BA9 43 4D 44 3F 9B	        .BYTE   'CMD?',EOL
  1303
  1304 				;---------------------------------------
  1305 0BAE			PARSE_INTRINSIC_COMMAND:
  1306 				;---------------------------------------
  1307 0BAE A2 00		        LDX     #$00        ; Initialize X for command code indexing
  1308 0BB0 A0 00		        LDY     #$00
  1309 0BB2 84 F2		        STY     CIX
  1310 0BB4 20 64 0A		        JSR     LDBUFA      ; Set INBUFF to $0580
  1311 0BB7 20 6D 0A		        JSR     SKPSPC      ; Skip whitespace
  1312
  1313 0BBA			PARSE_INTRINSIC_NEXT_CHAR:
  1314 0BBA B1 F3		        LDA     (INBUFF),Y
  1315 0BBC 29 7F		        AND     #$7F
  1316 0BBE 5D EE 15		        EOR     COMMAND,X   ; X initialized to 0 in caller
  1317 0BC1 C8			        INY
  1318 0BC2 0A			        ASL
  1319 0BC3 F0 0B		        BEQ     PARSE_INTRINSIC_CHAR_OK
  1320
  1321 				        ; Skip to next command
  1322
  1323 0BC5			PARSE_INTRINSIC_NEXT_COMMAND:
  1324 0BC5 BD EE 15		        LDA     COMMAND,X
  1325 0BC8 0A			        ASL
  1326 0BC9 E8			        INX
  1327 0BCA 90 F9		        BCC     PARSE_INTRINSIC_NEXT_COMMAND
  1328 0BCC A4 F2		        LDY     CIX
  1329 0BCE E0 D1		        CPX     #COMMAND_SIZE
  1330
  1331 0BD0			PARSE_INTRINSIC_CHAR_OK:
  1332 0BD0 E8			        INX
  1333 0BD1 90 E7		        BCC     PARSE_INTRINSIC_NEXT_CHAR
  1334 0BD3 84 F2		        STY     CIX
  1335 0BD5 B1 F3		        LDA     (INBUFF),Y
  1336 0BD7 30 05		        BMI     PARSE_INTRINSIC_RET
  1337
  1338 0BD9 20 6D 0A		        JSR     SKPSPC
  1339
  1340 0BDC			PARSE_INTRINSIC_RET_ERROR:
  1341 0BDC A2 D2		        LDX     #COMMAND_SIZE+1
  1342 0BDE			PARSE_INTRINSIC_RET:
  1343 0BDE BD EE 15		        LDA     COMMAND,X
  1344 0BE1 8D 3D 17		        STA     CMD
  1345 0BE4 8D 3E 17		        STA     CMDPRV
  1346 0BE7			PARSE_INTRINSIC_DONE:
  1347 0BE7 60			        RTS
  1348
  1349 				; End of PARSE_INTRINSIC_COMMAND
  1350 				;---------------------------------------
  1351
  1352 				;---------------------------------------
  1353 0BE8			PARSE_DRIVE_CHANGE:
  1354 				;---------------------------------------
  1355 0BE8 A2 03		        LDX     #$03        ; Check for EOL in pos 3
  1356 0BEA BD 82 05		        LDA     LNBUF,X
  1357 0BED C9 9B		        CMP     #EOL
  1358 0BEF D0 0D		        BNE     PARSE_DRIVE_CHANGE_DONE
  1359 0BF1 CA			        DEX                 ; go back one char
  1360 0BF2 BD 82 05		        LDA     LNBUF,X
  1361 0BF5 C9 3A		        CMP     #':'        ; Check for colon.
  1362 0BF7 D0 05		        BNE     PARSE_DRIVE_CHANGE_DONE
  1363 0BF9 A9 1D		        LDA     #CMD_IDX.DRIVE_CHG
  1364 0BFB 8D 3D 17		        STA     CMD
  1365 0BFE			PARSE_DRIVE_CHANGE_DONE:
  1366 0BFE 60			        RTS
  1367
  1368 				;---------------------------------------
  1369 0BFF			DOCMD:
  1370 				;---------------------------------------
  1371 0BFF AE 3D 17		        LDX     CMD
  1372 0C02 30 08		        BMI     DOCMD_DONE      ; Unassigned command = $FF
  1373 0C04 BD DF 16		        LDA     CMD_TAB_H,X     ; Get hi-byte of subroutine's addr
  1374 0C07 48			        PHA                     ; Push it to the stack
  1375 0C08 BD C1 16		        LDA     CMD_TAB_L,X     ; Get lo-byte of subroutine's addr
  1376 0C0B 48			        PHA                     ; Push it to the stack
  1377 0C0C			DOCMD_DONE:
  1378 0C0C 60			        RTS                     ; Use stack & RTS to jump to subroutine
  1379
  1380 				; End of DOCMD
  1381 				;---------------------------------------
  1382
  1383 				;---------------------------------------
  1384 0C0D			DO_DRIVE_CHG:
  1385 				;---------------------------------------
  1386 0C0D AD 82 05		        LDA     LNBUF
  1387 0C10 8D CD 15		        STA     PRMPT+1
  1388 0C13 AD 83 05		        LDA     LNBUF+1
  1389 0C16 C9 31		        CMP     #'1'        ; Skip if '0' or less
  1390 0C18 90 0A		        BCC     DO_DRIVE_CHG_ERROR
  1391 0C1A C9 39		        CMP     #'9'        ; Skip if '9' or more
  1392 0C1C B0 06		        BCS     DO_DRIVE_CHG_ERROR
  1393 0C1E 29 0F		        AND     #$0F        ; Convert, say, to 1-8
  1394 0C20 8D 3C 17		        STA     DOSDR
  1395 0C23 60			        RTS
  1396 0C24			DO_DRIVE_CHG_ERROR:
  1397 0C24 A9 32		        LDA     #<CDERR
  1398 0C26 A0 17		        LDY     #>CDERR
  1399 0C28 4C 7B 0A		        JMP     PRINT_STRING
  1400
  1401 				; End of DOCMD
  1402
  1403 				;---------------------------------------
  1404 				; Returns DOSDR in X
  1405 				; If arg1 contains Nn: then reg X = n
  1406 				; Otherwise X = DOSDR (from curr prompt)
  1407 				;---------------------------------------
  1408 0C2B			GET_DOSDR:
  1409 				;---------------------------------------
  1410
  1411 0C2B 20 64 0A		        JSR     LDBUFA      ; Reset INBUFF to LNBUF
  1412 0C2E AE 3C 17		        LDX     DOSDR       ; Set DUNIT(X) to curr drive
  1413
  1414 				    ;---------------------------------------
  1415 				    ; Consider arg1 = N2:TNFS://localhost/
  1416 				    ; Check arg1 for ":" in 3rd position
  1417 				    ; if found then use char in 2nd position ('2') as DOSDR
  1418 				    ; First, change INBUFF to point to beg. of 1st arg
  1419 				    ;---------------------------------------
  1420 0C31 AD 85 0B		        LDA     CMDSEP              ; arg offset
  1421 0C34 F0 17		        BEQ     GET_DOSDR_DONE      ; first, if arg1 not pop, leave X as-is & quit
  1422
  1423 0C36 18			        CLC                         ; Advance pointer to LNBUF
  1424 0C37 65 F3		        ADC     INBUFF
  1425 0C39 85 F3		        STA     INBUFF
  1426 0C3B 90 02		        BCC     GET_DOSDR_NEXT
  1427 0C3D E6 F4		        INC     INBUFF+1
  1428
  1429 0C3F			GET_DOSDR_NEXT:
  1430 0C3F A0 02		        LDY     #$02            ; Check for ':' in 3rd pos
  1431 0C41 B1 F3		        LDA     (INBUFF),Y
  1432 0C43 C9 3A		        CMP     #':'
  1433 0C45 D0 06		        BNE     GET_DOSDR_DONE  ; Not found, skip & use default
  1434 0C47 88			        DEY
  1435 0C48 B1 F3		        LDA     (INBUFF),Y
  1436 0C4A 29 0F		        AND     #$0F            ; Convert, say, '2' to 2
  1437 0C4C AA			        TAX                     ; Return DOSDR in X
  1438
  1439 0C4D			GET_DOSDR_DONE:
  1440 0C4D 60			        RTS
  1441
  1442 				;---------------------------------------
  1443 0C4E			DO_GENERIC:
  1444 				;---------------------------------------
  1445
  1446 				    ;---------------------------------------
  1447 				    ; SIO call for NCD,{MK,RM}DIR,DEL,RENAME
  1448 				    ;---------------------------------------
  1449
  1450 				    ;---------------------------------------
  1451 				    ; Get Fujinet SIO command (~ $21 for DEL)
  1452 				    ; X = table index from caller
  1453 				    ;---------------------------------------
  1454 0C4E BD D0 15		        LDA     CMD_DCOMND,X
  1455 0C51 8D B1 0C		        STA     GENDCB+2
  1456
  1457 				    ;---------------------------------------
  1458 				    ; Get DOSDR from either arg1 or curr drive
  1459 				    ;---------------------------------------
  1460 0C54 20 2B 0C		        JSR     GET_DOSDR    ; X will contain int of n in Nn:
  1461 0C57 8E B0 0C		        STX     GENDCB+1
  1462 0C5A 20 78 15		        JSR     PREPEND_DRIVE
  1463
  1464 				    ;---------------------------------------
  1465 				    ; If this is NCD ensure a '/' char is the last char
  1466 				    ;---------------------------------------
  1467 0C5D AD B1 0C		        LDA     GENDCB+2
  1468 0C60 C9 2C		        CMP     #CMD_CD         ; Is this an NCD command?
  1469 0C62 D0 08		        BNE     DO_GENERIC_NEXT ; No. skip
  1470
  1471 0C64 AD 85 0B		        LDA     CMDSEP
  1472 0C67 F0 2C		        BEQ     NCD_ERROR
  1473 0C69 20 A5 15		        JSR     APPEND_SLASH    ; Append '/' to path if missing
  1474
  1475 0C6C			DO_GENERIC_NEXT:
  1476 				    ;---------------------------------------
  1477 				    ; Populate the DCB
  1478 				    ;---------------------------------------
  1479 0C6C AD 3C 17		        LDA     DOSDR
  1480 0C6F 8D 49 09		        STA     STADCB+1        ; Yes. Status (not typo)
  1481 				;        STA     GENDCB+1   ; 20221105 - commented-out. checking for bug...
  1482 0C72 A5 F3		        LDA     INBUFF
  1483 0C74 8D B3 0C		        STA     GENDCB+4
  1484 0C77 A5 F4		        LDA     INBUFF+1
  1485 0C79 8D B4 0C		        STA     GENDCB+5
  1486
  1487 				    ;---------------------------------------
  1488 				    ; Send the command to FujiNet
  1489 				    ;---------------------------------------
  1490 0C7C A9 AF		        LDA     #<GENDCB
  1491 0C7E A0 0C		        LDY     #>GENDCB
  1492 0C80 20 A5 07		        JSR     DOSIOV
  1493 0C83 20 96 0A		        JSR     PRINT_ERROR
  1494
  1495 0C86			GEN_UNMOUNT:
  1496 				    ;---------------------------------------
  1497 				    ; if DEL or RENAME, then remount drive
  1498 				    ;---------------------------------------
  1499 0C86 AD 3E 17		        LDA     CMDPRV
  1500 0C89 C9 03		        CMP     #CMD_IDX.DEL
  1501 0C8B F0 04		        BEQ     GEN_REMOUNT
  1502 0C8D C9 0A		        CMP     #CMD_IDX.RENAME
  1503 0C8F D0 03		        BNE     GENDONE
  1504 0C91			GEN_REMOUNT:
  1505 0C91 4C 45 15		        JMP     REMOUNT_DRIVE
  1506
  1507 0C94			GENDONE:
  1508 0C94 60			        RTS
  1509
  1510 				;---------------------------------------
  1511 0C95			NCD_ERROR:
  1512 				;---------------------------------------
  1513 0C95 A9 A9		        LDA     #<NCD_ERROR_STR
  1514 0C97 A0 0C		        LDY     #>NCD_ERROR_STR
  1515 0C99 20 7B 0A		        JSR     PRINT_STRING
  1516 0C9C A0 01		        LDY     #$01        ; Return error
  1517 0C9E 60			        RTS
  1518 				    ;---------------------------------------
  1519 				    ; Close 
  1520 				    ;---------------------------------------
  1521 0C9F A2 10		        LDX     #$10            ; File #1
  1522 0CA1 A9 0C		        LDA     #$0C            ; Close #1 first
  1523 0CA3 9D 42 03		        STA     ICCOM,X
  1524 0CA6 20 56 E4		        JSR     CIOV
  1525
  1526 0CA9			NCD_ERROR_STR:
  1527 0CA9 50 41 54 48 3F 9B	        .BYTE   'PATH?',EOL
  1528
  1529 				;---------------------------------------
  1530 0CAF			GENDCB:
  1531 0CAF 71			        .BYTE      DEVIDN  ; DDEVIC
  1532 0CB0 FF			        .BYTE      $FF     ; DUNIT
  1533 0CB1 FF			        .BYTE      $FF     ; DCOMND
  1534 0CB2 80			        .BYTE      $80     ; DSTATS
  1535 0CB3 FF			        .BYTE      $FF     ; DBUFL
  1536 0CB4 FF			        .BYTE      $FF     ; DBUFH
  1537 0CB5 1F			        .BYTE      $1F     ; DTIMLO
  1538 0CB6 00			        .BYTE      $00     ; DRESVD
  1539 0CB7 00			        .BYTE      $00     ; DBYTL
  1540 0CB8 01			        .BYTE      $01     ; DBYTH
  1541 0CB9 00			        .BYTE      $00     ; DAUX1
  1542 0CBA 00			        .BYTE      $00     ; DAUX2
  1543
  1544 				; End of DO_GENERIC
  1545 				;---------------------------------------
  1546
  1547 				;;---------------------------------------
  1548 				;DO_COPY:
  1549 				;;---------------------------------------
  1550 				;
  1551 				;        LDA     #$20
  1552 				;        STA     COLOR2
  1553 				;
  1554 				;        LDA     #<CPYDCB
  1555 				;        LDY     #>CPYDCB
  1556 				;        JSR     DOSIOV
  1557 				;
  1558 				;        LDA     #$20
  1559 				;        STA     COLOR2
  1560 				;
  1561 				;        RTS
  1562 				;
  1563 				;CPYDCB:
  1564 				;        .BYTE      DEVIDN  ; DDEVIC
  1565 				;        .BYTE      $FF     ; DUNIT
  1566 				;        .BYTE      $D8     ; DCOMND
  1567 				;        .BYTE      $80     ; DSTATS
  1568 				;        .BYTE      <COPYSPEC  ; DBUFL
  1569 				;        .BYTE      >COPYSPEC ; DBUFH
  1570 				;        .BYTE      $FE     ; DTIMLO
  1571 				;        .BYTE      $00     ; DRESVD
  1572 				;        .BYTE      $00     ; DBYTL
  1573 				;        .BYTE      $01     ; DBYTH
  1574 				;        .BYTE      3       ; DAUX1
  1575 				;        .BYTE      2       ; DAUX2
  1576 				;
  1577 				;COPYSPEC:
  1578 				;        .BYTE 'iss.po|iss.po',$00
  1579
  1580 				;---------------------------------------
  1581 0CBB			DO_COPY:
  1582 				;---------------------------------------
  1583 0CBB A9 B0		        LDA     #$B0
  1584 0CBD 8D C6 02		        STA     COLOR2
  1585 0CC0 60			        RTS
  1586
  1587 				;        JSR     COPY_PARSE_FILES    ; locate comma, replace with EOL
  1588 				;        BMI     COPY_DONE
  1589 				;
  1590 				;        LDA     CMDSEP
  1591 				;        STA     CMDSEP+2
  1592 				;
  1593 				;        LDA     CMDSEP+1
  1594 				;        STA     CMDSEP
  1595 				;
  1596 				;        JSR     COPY_OPEN_DEST      ; use CIO to open file 2 for write
  1597 				;        BMI     COPY_DONE
  1598 				;
  1599 				;        LDA     CMDSEP+2
  1600 				;        STA     CMDSEP
  1601 				;        JSR     COPY_OPEN_SRC       ; use CIO to open file 1 for read
  1602 				;        BMI     COPY_DONE
  1603 				;
  1604 				;@:      JSR     COPY_GET_SRC
  1605 				;        JSR     COPY_PUT_DEST
  1606 				;        ;BNE     @-
  1607 				;
  1608 				;COPY_DONE:
  1609 				;    ; Close files
  1610 				;        LDX     #$10
  1611 				;        JSR     CIOCLOSE
  1612 				;        LDX     #$20
  1613 				;        JMP     CIOCLOSE
  1614 				;
  1615 				;;---------------------------------------
  1616 				;COPY_PARSE_FILES:
  1617 				;;---------------------------------------
  1618 				;    ; Find position of comma in line buffer
  1619 				;    ; Return X = position of comma
  1620 				;    ;---------------------------------------
  1621 				;        LDX     CMDSEP
  1622 				;COPY_PARSE_LOOP:
  1623 				;        LDA     LNBUF,X
  1624 				;        CMP     #','
  1625 				;        BEQ     COPY_PARSE_FILES_DONE
  1626 				;        CMP     #EOL
  1627 				;        BEQ     COPY_SHOW_USAGE
  1628 				;        INX
  1629 				;        BNE     COPY_PARSE_LOOP
  1630 				;COPY_PARSE_FILES_DONE:
  1631 				;    ;---------------------------------------
  1632 				;    ; Here if comma found.
  1633 				;    ; Inject EOL where the comma was found
  1634 				;    ;---------------------------------------
  1635 				;        LDA     #EOL
  1636 				;        STA     LNBUF,X
  1637 				;        INX                 ; Advance to start of 2nd arg
  1638 				;        STX     CMDSEP+1    ; Point to 2nd arg now
  1639 				;        RTS
  1640 				;    ;---------------------------------------
  1641 				;    ; Here if no comma found.
  1642 				;    ; Print usage
  1643 				;    ;---------------------------------------
  1644 				;COPY_SHOW_USAGE:
  1645 				;        LDA     #<COPY_SHOW_USAGE_STR
  1646 				;        LDY     #>COPY_SHOW_USAGE_STR
  1647 				;        JSR     PRINT_STRING
  1648 				;        LDY     #$FF
  1649 				;        RTS
  1650 				;
  1651 				;COPY_SHOW_USAGE_STR:
  1652 				;        .BYTE   'COPY SOURCE,DEST',EOL
  1653 				;
  1654 				;; End of COPY_COMMA_POS:
  1655 				;;---------------------------------------
  1656 				;
  1657 				;;---------------------------------------
  1658 				;COPY_OPEN_SRC:
  1659 				;;---------------------------------------
  1660 				;        JSR     GET_DOSDR       ; Get DUNIT
  1661 				;        JSR     PREPEND_DRIVE
  1662 				;
  1663 				;        LDX     #$10            ; File #1
  1664 				;        JSR     CIOCLOSE        ; Assert file #1 is closed
  1665 				;        LDY     #$04            ; Open for input
  1666 				;        JSR     CIOOPEN         ; Open filename @ (INBUFF)
  1667 				;        BPL     COPY_OPEN_SRC_DONE
  1668 				;
  1669 				;        LDA     #<COPY_OPEN_SRC_ERR_STR
  1670 				;        LDY     #>COPY_OPEN_SRC_ERR_STR
  1671 				;        JMP     PRINT_STRING
  1672 				;
  1673 				;COPY_OPEN_SRC_DONE:
  1674 				;        RTS
  1675 				;        
  1676 				;COPY_OPEN_SRC_ERR_STR:
  1677 				;        .BYTE   'UNABLE TO OPEN SOURCE',EOL
  1678 				;
  1679 				;;End of COPY_OPEN_SRC
  1680 				;;---------------------------------------
  1681 				;
  1682 				;;---------------------------------------
  1683 				;COPY_OPEN_DEST:
  1684 				;;---------------------------------------
  1685 				;    ; Advance offset to arg2
  1686 				;        
  1687 				;@:      JSR     GET_DOSDR       ; Get DUNIT
  1688 				;        JSR     PREPEND_DRIVE
  1689 				;
  1690 				;        LDX     #$20            ; Assert file #2 is closed
  1691 				;        JSR     CIOCLOSE
  1692 				;
  1693 				;        LDY     #$08            ; Open for write
  1694 				;        JSR     CIOOPEN
  1695 				;        BPL     COPY_OPEN_DEST_DONE  ; If success, skip ahead
  1696 				;
  1697 				;        LDA     #<COPY_OPEN_DEST_ERR_STR
  1698 				;        LDY     #>COPY_OPEN_DEST_ERR_STR
  1699 				;        JMP     PRINT_STRING
  1700 				;
  1701 				;COPY_OPEN_DEST_DONE:
  1702 				;        RTS
  1703 				;        
  1704 				;COPY_OPEN_DEST_ERR_STR:
  1705 				;        .BYTE   'UNABLE TO OPEN DEST',EOL
  1706 				;
  1707 				;;End of COPY_OPEN_SRC
  1708 				;;---------------------------------------
  1709 				;
  1710 				;;---------------------------------------
  1711 				;COPY_GET_SRC:
  1712 				;;---------------------------------------
  1713 				;        ;LDX     #$10
  1714 				;        ;JSR     CIOSTATUS
  1715 				;
  1716 				;        LDX     #$10
  1717 				;        LDA     #<TBUF
  1718 				;        STA     INBUFF      ; Buffer addr Lo
  1719 				;        LDA     #>TBUF
  1720 				;        STA     INBUFF+1    ; Buffer addr Hi
  1721 				;        LDA     #$80        ; Buffer size Lo
  1722 				;        LDY     #$00        ; Buffer size Hi
  1723 				;        JSR     CIOGET
  1724 				;        BPL     COPY_GET_SRC_DONE
  1725 				;        CPY     #EOF
  1726 				;        BEQ     COPY_GET_SRC_DONE
  1727 				; 
  1728 				;        LDA     #<COPY_GET_SRC_STR
  1729 				;        LDY     #>COPY_GET_SRC_STR
  1730 				;        JMP     PRINT_STRING
  1731 				;
  1732 				;COPY_GET_SRC_DONE:
  1733 				;        RTS
  1734 				;
  1735 				;COPY_GET_SRC_STR:
  1736 				;        .BYTE   'ERROR READING FROM SOURCE',EOL
  1737 				;
  1738 				;;---------------------------------------
  1739 				;COPY_PUT_DEST:
  1740 				;;---------------------------------------
  1741 				;        ;LDX     #$20
  1742 				;        ;JSR     CIOSTATUS
  1743 				;
  1744 				;        LDX     #$20
  1745 				;        LDA     #<TBUF
  1746 				;        STA     INBUFF      ; Buffer addr Lo
  1747 				;        LDA     #>TBUF
  1748 				;        STA     INBUFF+1    ; Buffer addr Hi
  1749 				;        LDA     #$06        ; Buffer size Lo
  1750 				;        LDY     #$00        ; Buffer size Hi
  1751 				;        JSR     CIOPUT
  1752 				;        BPL     COPY_PUT_DEST_DONE
  1753 				;        CPY     #EOF
  1754 				;        BEQ     COPY_PUT_DEST_DONE
  1755 				; 
  1756 				;        LDA     #<COPY_PUT_DEST_STR
  1757 				;        LDY     #>COPY_PUT_DEST_STR
  1758 				;        JMP     PRINT_STRING
  1759 				;
  1760 				;COPY_PUT_DEST_DONE:
  1761 				;        RTS
  1762 				;
  1763 				;COPY_PUT_DEST_STR:
  1764 				;        .BYTE   'ERROR WRITING TO DEST',EOL
  1765 				;
  1766
  1767 				;---------------------------------------
  1768 0CC1			DO_DIR:
  1769 				;---------------------------------------
  1770 0CC1 20 21 0D		        JSR     DIR_INIT    ; set dunits
  1771 0CC4 20 31 0D		        JSR     DIR_OPEN    ; open with dir request
  1772 0CC7 C0 01		        CPY     #$01        ; success (1) ?
  1773 0CC9 F0 03		        BEQ     DIR_LOOP    ; if success, jump ahead
  1774 0CCB 4C 96 0A		        JMP     PRINT_ERROR ; exit
  1775
  1776 0CCE			DIR_LOOP:
  1777
  1778 				    ;---------------------------------------
  1779 				    ; Send Status request to SIO
  1780 				    ;---------------------------------------
  1781 0CCE A9 48		        LDA     #<STADCB
  1782 0CD0 A0 09		        LDY     #>STADCB
  1783 0CD2 20 A5 07		        JSR     DOSIOV
  1784
  1785 				    ;---------------------------------------
  1786 				    ; Status returns DVSTAT
  1787 				    ;---------------------------------------
  1788 0CD5 A2 00		        LDX     #$00
  1789 0CD7 EC EB 02		        CPX     DVSTAT+1    ; if byte count < 255 (that is, hi=0)
  1790 0CDA F0 09		        BEQ     DIR_LT_255  ; then skip
  1791
  1792 				    ;---------------------------------------
  1793 				    ; Branch 1: Read 255 bytes (max)
  1794 				    ;---------------------------------------
  1795 0CDC CA			        DEX                 ; X now 255 (Read FF Bytes)
  1796 0CDD 8E 1D 0D		        STX     DIRRDCB+8   ; DBYTL
  1797 0CE0 8E 1F 0D		        STX     DIRRDCB+10  ; DAUX1
  1798 0CE3 30 0B		        BMI     DIR_NEXT1   ; "always" true. skip down SIO call
  1799
  1800 				    ;---------------------------------------
  1801 				    ; Branch 2: Read < 255 bytes
  1802 				    ;---------------------------------------
  1803 0CE5			DIR_LT_255:
  1804 0CE5 AD EA 02		        LDA     DVSTAT      ; Get count of bytes remaining
  1805 0CE8 F0 6C		        BEQ     DIR_ERROR   ; If here then DVSTAT = $0000 (error)
  1806 0CEA 8D 1D 0D		        STA     DIRRDCB+8   ; DBYTL
  1807 0CED 8D 1F 0D		        STA     DIRRDCB+10  ; DAUX1
  1808
  1809 				    ;-------------------------
  1810 				    ; Send Read request to SIO
  1811 				    ;-------------------------
  1812 0CF0			DIR_NEXT1:
  1813 0CF0 A9 15		        LDA     #<DIRRDCB
  1814 0CF2 A0 0D		        LDY     #>DIRRDCB
  1815 0CF4 20 A5 07		        JSR     DOSIOV      ; Fetch directory listing
  1816 0CF7 20 86 0D		        JSR     DIR_PRINT   ; xfer payload to screen
  1817
  1818 				    ;---------------------------------------
  1819 				    ; Pause output if SPACE key code found
  1820 				    ;---------------------------------------
  1821 0CFA			DIR_WAIT:
  1822 0CFA AD FC 02		        LDA     CH
  1823 0CFD C9 21		        CMP     #SPC_KEY
  1824 0CFF F0 F9		        BEQ     DIR_WAIT
  1825
  1826 				    ;---------------------------------------
  1827 				    ; Exit loop if ESC key code found
  1828 				    ;---------------------------------------
  1829 0D01 AD FC 02		        LDA     CH
  1830 0D04 C9 1C		        CMP     #ESC_KEY    ; hardware code for ESC key
  1831 0D06 F0 05		        BEQ     DIR_NEXT
  1832
  1833 				    ;---------------------------------------
  1834 				    ; Loop if more data to read
  1835 				    ;---------------------------------------
  1836 0D08 AD EB 02		        LDA     DVSTAT+1    ; Was there more to read (that is, was hi>0)?
  1837 0D0B D0 C1		        BNE     DIR_LOOP    ; If yes, then do it again
  1838
  1839 0D0D			DIR_NEXT:
  1840 0D0D A9 FF		        LDA     #$FF        ; Clear key
  1841 0D0F 8D FC 02		        STA     CH
  1842 0D12 4C A4 0D		        JMP     DIR_CLOSE
  1843
  1844 0D15			DIRRDCB:
  1845 0D15 71			        .BYTE   DEVIDN      ; DDEVIC
  1846 0D16 FF			        .BYTE   $FF         ; DUNIT
  1847 0D17 52			        .BYTE   'R'         ; DCOMND
  1848 0D18 40			        .BYTE   $40         ; DSTATS
  1849 0D19 00			        .BYTE   <RBUF       ; DBUFL
  1850 0D1A 18			        .BYTE   >RBUF       ; DBUFH
  1851 0D1B 1F			        .BYTE   $1F         ; DTIMLO
  1852 0D1C 00			        .BYTE   $00         ; DRESVD
  1853 0D1D 00			        .BYTE   $00         ; DBYTL
  1854 0D1E 00			        .BYTE   $00         ; DBYTH
  1855 0D1F 00			        .BYTE   $00         ; DAUX1
  1856 0D20 00			        .BYTE   $00         ; DAUX2
  1857
  1858 				;---------------------------------------
  1859 				; Set DUNITs in all DCBs used by DIR
  1860 				;---------------------------------------
  1861 0D21			DIR_INIT:
  1862 				;---------------------------------------
  1863 0D21 20 2B 0C		        JSR     GET_DOSDR   ; On return, X <- n in Nn:
  1864 0D24 8E 7B 0D		        STX     DIRODCB+1   ; DUNIT for Open
  1865 0D27 8E 49 09		        STX     STADCB+1    ; DUNIT for Status
  1866 0D2A 8E 16 0D		        STX     DIRRDCB+1   ; DUNIT for Read
  1867 0D2D 8E 22 08		        STX     CLODCB+1    ; DUNIT for Close
  1868 0D30 60			        RTS
  1869
  1870 				;---------------------------------------
  1871 0D31			DIR_OPEN:
  1872 				;---------------------------------------
  1873 0D31 20 78 15		        JSR     PREPEND_DRIVE
  1874
  1875 				    ;-----------------------------------
  1876 				    ; Default to arg1
  1877 				    ;-----------------------------------
  1878 0D34 A6 F3		        LDX     INBUFF
  1879 0D36 A4 F4		        LDY     INBUFF+1
  1880
  1881 				    ;-----------------------------------
  1882 				    ; But use Nn:*.* if no arg1
  1883 				    ;-----------------------------------
  1884 0D38 AD 85 0B		        LDA     CMDSEP          ; 0 means no arg1
  1885 0D3B D0 0C		        BNE     DIR_OPEN_NEXT   ; If arg1 present then skip
  1886
  1887 				    ;-----------------------------------
  1888 				    ; Here if no arg1
  1889 				    ;-----------------------------------
  1890 0D3D A2 73		        LDX     #<DIR_OPEN_STR
  1891 0D3F A0 0D		        LDY     #>DIR_OPEN_STR
  1892
  1893 0D41 AD 3C 17		        LDA     DOSDR
  1894 0D44 09 30		        ORA     #'0'            ; Convert, say, 1 to '1'
  1895 0D46 8D 74 0D		        STA     DIR_OPEN_STR+1  ; Inject DOSDR into string
  1896
  1897 0D49			DIR_OPEN_NEXT:
  1898 0D49 8E 7E 0D		        STX     DIRODCB+4       ; DBUFL
  1899 0D4C 8C 7F 0D		        STY     DIRODCB+5       ; DBUFH
  1900
  1901 0D4F A9 7A		        LDA     #<DIRODCB
  1902 0D51 A0 0D		        LDY     #>DIRODCB
  1903 0D53 4C A5 07		        JMP     DOSIOV
  1904
  1905 				;---------------------------------------
  1906 0D56			DIR_ERROR:
  1907 				;---------------------------------------
  1908 0D56 A9 60		        LDA     #<DIR_ERROR_STR
  1909 0D58 A0 0D		        LDY     #>DIR_ERROR_STR
  1910 0D5A 20 7B 0A		        JSR     PRINT_STRING
  1911 0D5D A0 01		        LDY     #$01            ; Return error
  1912 0D5F 60			        RTS
  1913
  1914 0D60			DIR_ERROR_STR:
  1915 0D60 55 4E 41 42 4C 45 +         .BYTE   'UNABLE TO READ DIR',EOL
  1916
  1917 0D73			DIR_OPEN_STR:
  1918 0D73 4E 20 3A 2A 2E 2A +         .BYTE   'N :*.*',EOL
  1919
  1920 0D7A			DIRODCB:
  1921 0D7A 71			        .BYTE   DEVIDN          ; DDEVIC
  1922 0D7B FF			        .BYTE   $FF             ; DUNIT
  1923 0D7C 4F			        .BYTE   'O'             ; DCOMND
  1924 0D7D 80			        .BYTE   $80             ; DSTATS
  1925 0D7E FF			        .BYTE   $FF             ; DBUFL
  1926 0D7F FF			        .BYTE   $FF             ; DBUFH
  1927 0D80 1F			        .BYTE   $1F             ; DTIMLO
  1928 0D81 00			        .BYTE   $00             ; DRESVD
  1929 0D82 00			        .BYTE   $00             ; DBYTL
  1930 0D83 01			        .BYTE   $01             ; DBYTH
  1931 0D84 06			        .BYTE   $06             ; DAUX1
  1932 0D85 80			        .BYTE   $80             ; DAUX2 (Long Dir)
  1933
  1934 				; End of DIR_OPEN
  1935 				;---------------------------------------
  1936
  1937 				;---------------------------------------
  1938 0D86			DIR_PRINT:
  1939 				;---------------------------------------
  1940 				        ; Print results using CIO
  1941 0D86 A2 00		        LDX     #$00
  1942 0D88 A9 0B		        LDA     #PUTCHR
  1943 0D8A 9D 42 03		        STA     ICCOM,X
  1944
  1945 				        ; Fill out buffer loc
  1946 0D8D A9 00		        LDA     #<RBUF
  1947 0D8F 9D 44 03		        STA     ICBAL,X
  1948 0D92 A9 18		        LDA     #>RBUF
  1949 0D94 9D 45 03		        STA     ICBAH,X
  1950
  1951 				        ; Fill out size loc
  1952 0D97 AD 1D 0D		        LDA     DIRRDCB+8
  1953 0D9A 9D 48 03		        STA     ICBLL,X
  1954 0D9D 8A			        TXA
  1955 0D9E 9D 49 03		        STA     ICBLH,X
  1956 0DA1 4C 56 E4		        JMP     CIOV
  1957
  1958 				;---------------------------------------
  1959 0DA4			DIR_CLOSE:
  1960 				;---------------------------------------
  1961 				        ; Close
  1962 0DA4 A9 21		        LDA     #<CLODCB
  1963 0DA6 A0 08		        LDY     #>CLODCB
  1964 0DA8 4C A5 07		        JMP     DOSIOV
  1965
  1966 				;---------------------------------------
  1967 0DAB			DO_LOAD:
  1968 				;---------------------------------------
  1969 				    ; Binary Loader based on work by Richard J. Kalagher 07-AUG-1983
  1970
  1971 				    ; Open file
  1972 0DAB AD 85 0B		        LDA     CMDSEP          ; Quit if no arg1
  1973 0DAE D0 03		        BNE     LOAD_NEXT1
  1974 0DB0 4C 3F 10		        JMP     LOAD_ERROR
  1975
  1976 0DB3			LOAD_NEXT1:
  1977 				    ; Point INBUFF to start of filename
  1978 0DB3 18			        CLC
  1979 0DB4 65 F3		        ADC     INBUFF          ; [A] contains offset to arg1
  1980 0DB6 85 F3		        STA     INBUFF
  1981 0DB8 90 02		        BCC     LOAD_NEXT2
  1982 0DBA E6 F4		        INC     INBUFF+1
  1983
  1984 0DBC			LOAD_NEXT2:
  1985 0DBC 20 4F 0E		        JSR     LOAD_NTRANS     ; Disable any EOL transation
  1986 0DBF 20 0B 0E		        JSR     LOAD_SETUP      ; Set up run and init to RTS
  1987 0DC2 A9 04		        LDA     #OINPUT         ; A arg needed in LOAD_OPEN
  1988 0DC4 20 21 0E		        JSR     LOAD_OPEN       ; Open the file
  1989 0DC7 C0 01		        CPY     #$01            ; Quit if unable to open
  1990 0DC9 D0 3F		        BNE     R
  1991
  1992 0DCB A9 FF		        LDA     #$FF
  1993 0DCD 8D 90 18		        STA     BIN_1ST
  1994 0DD0 20 5D 0E		        JSR     LOAD_READ2
  1995 0DD3 20 7E 0E		        JSR     LOAD_CHKFF
  1996 0DD6 C0 01		        CPY     #$01
  1997 0DD8 D0 30		        BNE     R
  1998
  1999 0DDA EE 90 18		        INC     BIN_1ST
  2000 				    ; Process each payload
  2001 0DDD 20 5D 0E		GETFIL: JSR     LOAD_READ2      ; Get two bytes (binary header)
  2002 0DE0 30 28		        BMI     R               ; Exit if EOF hit
  2003 0DE2 20 16 0E		        JSR     LOAD_INIT       ; Set init default
  2004 0DE5 A2 01		        LDX     #$01
  2005 0DE7 20 7E 0E		        JSR     LOAD_CHKFF      ; Check if header (and start addr, too)
  2006 0DEA 20 B5 0E		        JSR     LOAD_STRAD      ; Put start address in
  2007 0DED 20 5D 0E		        JSR     LOAD_READ2      ; Get to more butes (end addr)
  2008 0DF0 20 C2 0E		        JSR     LOAD_ENDAD      ; Put end address in
  2009 0DF3 20 DB 0E		        JSR     LOAD_BUFLEN     ; Calculate buffer length
  2010 0DF6 20 00 0F		        JSR     LOAD_GETDAT     ; Get the data record
  2011 0DF9 10 03		        BPL     @+              ; Was EOF detected?
  2012 0DFB 20 07 0E		        JSR     JSTART          ; Yes. Go to RUNAD
  2013 0DFE 20 04 0E		@:      JSR     JINIT           ; Attempt initialization
  2014 0E01 4C DD 0D		        JMP     GETFIL          ; Process next payload
  2015
  2016 0E04 6C E2 02		JINIT:  JMP     (INITAD)        ; Will either RTS or perform INIT
  2017 0E07 6C E0 02		JSTART: JMP     (RUNAD)         ; Godspeed.
  2018 0E0A 60			R:      RTS                     ; Stunt-double for (INITAD),(RUNAD)
  2019
  2020 				;---------------------------------------
  2021 0E0B			LOAD_SETUP:
  2022 				;---------------------------------------
  2023 0E0B A9 0A		        LDA     #<R
  2024 0E0D 8D E0 02		        STA     RUNAD
  2025 0E10 A9 0E		        LDA     #>R
  2026 0E12 8D E1 02		        STA     RUNAD+1
  2027 0E15 60			        RTS
  2028
  2029 				;---------------------------------------
  2030 0E16			LOAD_INIT:
  2031 				;---------------------------------------
  2032 0E16 A9 0A		        LDA     #<R
  2033 0E18 8D E2 02		        STA     INITAD
  2034 0E1B A9 0E		        LDA     #>R
  2035 0E1D 8D E3 02		        STA     INITAD+1
  2036 0E20 60			        RTS
  2037
  2038 				;---------------------------------------
  2039 0E21			LOAD_OPEN:
  2040 				;---------------------------------------
  2041 0E21 48			        PHA                     ; A = data direction (4=in, 8=out)
  2042 0E22 20 2B 0C		        JSR     GET_DOSDR       ; Get DUNIT
  2043 0E25 8E 01 08		        STX     OPNDCB+1        ; Set DUNIT
  2044 0E28 8E 83 08		        STX     GETDCB+1        ; Set DUNIT FOR READ
  2045 0E2B 20 78 15		        JSR     PREPEND_DRIVE
  2046
  2047 0E2E A5 F3		        LDA     INBUFF          ; Register location of filename
  2048 0E30 8D 04 08		        STA     OPNDCB+4
  2049 0E33 A5 F4		        LDA     INBUFF+1
  2050 0E35 8D 05 08		        STA     OPNDCB+5
  2051
  2052 0E38 68			        PLA                     ; A = data direction (4=in, 8=out)
  2053 0E39 8D 0A 08		        STA     OPNDCB+10
  2054 0E3C A9 00		        LDA     #$00            ; AUX2: No translation
  2055 0E3E 8D 0B 08		        STA     OPNDCB+11
  2056
  2057 0E41 A9 00		        LDA     #<OPNDCB
  2058 0E43 A0 08		        LDY     #>OPNDCB
  2059
  2060 0E45 20 A5 07		        JSR     DOSIOV
  2061 0E48 48			        PHA
  2062 0E49 20 96 0A		        JSR     PRINT_ERROR
  2063 0E4C 68			        PLA
  2064 0E4D A8			        TAY
  2065
  2066 0E4E 60			        RTS
  2067
  2068 				;---------------------------------------
  2069 0E4F			LOAD_NTRANS:
  2070 				;---------------------------------------
  2071 				    ; Disable any EOL transation otherwise
  2072 				    ; binary data will be corrupted during load
  2073 				    ;---------------------------------------
  2074 0E4F 20 2B 0C		        JSR     GET_DOSDR       ; Get DUNIT
  2075 0E52 8E 38 11		        STX     NTRDCB+1        ; Set DUNIT
  2076 0E55 A9 00		        LDA     #$00
  2077 0E57 8D 42 11		        STA     NTRDCB+11       ; Translation mode (0 = NONE)
  2078 0E5A 4C 04 11		        JMP     NTRANS_CALL     ; Reuse code in DO_NTRANS
  2079
  2080 				;---------------------------------------
  2081 0E5D			LOAD_READ2:
  2082 				;---------------------------------------
  2083 				    ; Load 2 bytes into Buffer (BAL/H).
  2084 				    ;---------------------------------------
  2085 				    ; This is accomplished by abusing the LOAD_GETDAT
  2086 				    ; routine by stuffing the buffer addr (BAL/H)
  2087 				    ; into the payload Start/End addrs. We're doing
  2088 				    ; this in case a payload  header straddles a
  2089 				    ; cache boundary. LOAD_GETDAT has the logic for
  2090 				    ; dealing with that.
  2091 				    ;---------------------------------------
  2092 0E5D A9 00		        LDA     #<BAL
  2093 0E5F 8D 80 18		        STA     STL             ; Payload start address
  2094 0E62 A9 18		        LDA     #>BAL
  2095 0E64 8D 81 18		        STA     STH
  2096
  2097 0E67 A9 01		        LDA     #<BAH
  2098 0E69 8D 82 18		        STA     ENL             ; Payload end address
  2099 0E6C A9 18		        LDA     #>BAH
  2100 0E6E 8D 83 18		        STA     ENH
  2101
  2102 0E71 A2 02		        LDX     #$02
  2103 0E73 8E 84 18		        STX     BLL             ; Payload size (2)
  2104 0E76 A9 00		        LDA     #$00
  2105 0E78 8D 85 18		        STA     BLH
  2106
  2107 0E7B 4C 00 0F		        JMP     LOAD_GETDAT     ; Read 2 bytes
  2108
  2109 				;---------------------------------------
  2110 0E7E			LOAD_CHKFF:
  2111 				;---------------------------------------
  2112 				    ; On 1st pass, check for binary signature (FF FF)
  2113 				    ; On 2..n passes, Skip FF FF (if found) 
  2114 				    ; and read next 2 bytes
  2115 				    ;---------------------------------------
  2116 				        
  2117 0E7E A9 FF		        LDA     #$FF
  2118 0E80 CD 00 18		        CMP     BAL         ; Is 1st byte FF?
  2119 0E83 D0 0D		        BNE     NOTFF       ; If no, skip down.
  2120 0E85 CD 01 18		        CMP     BAH         ; Is 2nd byte FF?
  2121 0E88 D0 08		        BNE     NOTFF       ; If no, skip down.
  2122
  2123 				    ;---------------------------------------
  2124 				    ; Here if FF FF tags found. 
  2125 				    ; On 1st pass, we're done.
  2126 				    ; On 2..n passes, read next 2 bytes and leave.
  2127 				    ;---------------------------------------
  2128 0E8A CD 90 18		        CMP     BIN_1ST     ; Is this 1st pass?
  2129 0E8D F0 13		        BEQ     NOTFF_DONE  ; If yes, then we're done here.
  2130 0E8F 4C 5D 0E		        JMP     LOAD_READ2  ; 
  2131
  2132 				    ;---------------------------------------
  2133 				    ; Here if FF FF tags NOT found. 
  2134 				    ; On 1st pass, print error.
  2135 				    ; On 2..n passes, the 2 bytes = payload start addr.
  2136 				    ;---------------------------------------
  2137 0E92 A0 01		NOTFF:  LDY     #$01        ; Preload success return code
  2138 0E94 CD 90 18		        CMP     BIN_1ST     ; A still has FF. BIN_1ST = FF on first pass
  2139 0E97 D0 09		        BNE     NOTFF_DONE  ; Not 1st pass, exit with success.
  2140
  2141 0E99			NOTFF_ERR:
  2142 0E99 A9 A3		        LDA     #<LOAD_ERROR_STR2
  2143 0E9B A0 0E		        LDY     #>LOAD_ERROR_STR2
  2144 0E9D 20 7B 0A		        JSR     PRINT_STRING
  2145
  2146 0EA0 A0 FF		        LDY     #$FF        ; Return failure
  2147 0EA2			NOTFF_DONE:
  2148 0EA2 60			        RTS
  2149
  2150 0EA3			LOAD_ERROR_STR2:
  2151 0EA3 4E 4F 54 20 41 20 +         .BYTE   'NOT A BINARY FILE',EOL
  2152
  2153 				;---------------------------------------
  2154 0EB5			LOAD_STRAD:
  2155 				;---------------------------------------
  2156 				    ; Save payload start address into STL2/STLH2.
  2157 				    ; Otherwise it will get clobbered
  2158 				    ; when reading payload end address.
  2159 0EB5 AD 00 18		        LDA     RBUF
  2160 0EB8 8D 8E 18		        STA     STL2
  2161 0EBB AD 01 18		        LDA     RBUF+1
  2162 0EBE 8D 8F 18		        STA     STH2
  2163 0EC1 60			        RTS
  2164
  2165 				;---------------------------------------
  2166 0EC2			LOAD_ENDAD:
  2167 				;---------------------------------------
  2168 				    ; Save payload end address
  2169 0EC2 AD 8E 18		        LDA     STL2
  2170 0EC5 8D 80 18		        STA     STL
  2171 0EC8 AD 8F 18		        LDA     STH2
  2172 0ECB 8D 81 18		        STA     STH
  2173 				    
  2174 0ECE AD 00 18		        LDA     RBUF
  2175 0ED1 8D 82 18		        STA     ENL
  2176 0ED4 AD 01 18		        LDA     RBUF+1
  2177 0ED7 8D 83 18		        STA     ENH
  2178 0EDA 60			        RTS
  2179
  2180 				;---------------------------------------
  2181 0EDB			LOAD_BUFLEN:
  2182 				;---------------------------------------
  2183 				    ; Calculate buffer length (end-start+1)
  2184
  2185 				    ; Calc buffer size Lo
  2186 0EDB AD 82 18		        LDA     ENL
  2187 0EDE 38			        SEC
  2188 0EDF ED 80 18		        SBC     STL
  2189 0EE2 8D 84 18		        STA     BLL     ; Buffer Length Lo
  2190
  2191 				    ; Calc buffer size Hi
  2192 0EE5 AD 83 18		        LDA     ENH     ; Calc buffer size Hi
  2193 0EE8 ED 81 18		        SBC     STH
  2194 0EEB 8D 85 18		        STA     BLH     ; Buffer Length Hi
  2195
  2196 				    ; Add 1
  2197 0EEE 18			        CLC
  2198 0EEF AD 84 18		        LDA     BLL
  2199 0EF2 69 01		        ADC     #$01
  2200 0EF4 8D 84 18		        STA     BLL
  2201
  2202 0EF7 AD 85 18		        LDA     BLH
  2203 0EFA 69 00		        ADC     #$00    ; Take care of any carry
  2204 0EFC 8D 85 18		        STA     BLH
  2205
  2206 0EFF 60			        RTS
  2207
  2208 				;---------------------------------------
  2209 0F00			LOAD_GETDAT:
  2210 				;---------------------------------------
  2211 				    ; Definitions:
  2212 				    ; HEAD = requested bytes that will be found in current cache (< 512 bytes)
  2213 				    ; BODY = contiguous 512 byte sections. BODY = n * 512 bytes)
  2214 				    ; TAIL = any bytes remaining after BODY (< 512 bytes)
  2215
  2216 0F00 20 2B 0C		        JSR     GET_DOSDR
  2217 0F03 8E 27 10		        STX     BINDCB+1
  2218
  2219 0F06 20 02 10		        JSR     GETDAT_CHECK_EOF    ; Check EOF before proceeding
  2220 0F09 10 01		        BPL     GETDAT_NEXT1        ; If true, then EOF found. Exit
  2221 0F0B 60			        RTS
  2222
  2223 				    ; Check if bytes requested BL < DVSTAT (bytes waiting in cache)
  2224 0F0C			GETDAT_NEXT1:
  2225 0F0C AD EA 02		        LDA     DVSTAT
  2226 0F0F CD 84 18		        CMP     BLL
  2227 0F12 AD EB 02		        LDA     DVSTAT+1
  2228 0F15 ED 85 18		        SBC     BLH
  2229 0F18 B0 4C		        BCS     GETDAT_OPT2     ; BL <= BW (bytes waiting)
  2230
  2231 0F1A			GETDAT_OPT1:
  2232 				    ;--------------------------------
  2233 				    ; Here if bytes requested > bytes 
  2234 				    ; remaining in cache
  2235 				    ;------------------------P--------
  2236
  2237 				    ;-------------------------------
  2238 				    ; Head = BW (bytes waiting)
  2239 				    ;-------------------------------
  2240 0F1A AD EA 02		        LDA     DVSTAT
  2241 0F1D 8D 86 18		        STA     HEADL
  2242 0F20 AD EB 02		        LDA     DVSTAT+1
  2243 0F23 8D 87 18		        STA     HEADH
  2244
  2245 				    ;-------------------------------
  2246 				    ; Tail = (BL - HEAD) mod 512
  2247 				    ;-------------------------------
  2248 0F26 38			        SEC
  2249 0F27 AD 84 18		        LDA     BLL
  2250 0F2A ED 86 18		        SBC     HEADL
  2251 0F2D 29 FF		        AND     #$FF
  2252 0F2F 8D 8A 18		        STA     TAILL
  2253 0F32 AD 85 18		        LDA     BLH
  2254 0F35 ED 87 18		        SBC     HEADH
  2255 0F38 29 01		        AND     #$01
  2256 0F3A 8D 8B 18		        STA     TAILH
  2257
  2258 				    ;-----------------------------------
  2259 				    ; Body = BL - HEAD - TAIL
  2260 				    ;-----------------------------------
  2261 				        ; 1. Body = BL - HEAD
  2262 				        ;-------------------------------
  2263 0F3D 38			        SEC
  2264 0F3E AD 84 18		        LDA     BLL
  2265 0F41 ED 86 18		        SBC     HEADL
  2266 0F44 8D 88 18		        STA     BODYL
  2267 0F47 AD 85 18		        LDA     BLH
  2268 0F4A ED 87 18		        SBC     HEADH
  2269 0F4D 8D 89 18		        STA     BODYH
  2270
  2271 				        ;-------------------------------
  2272 				        ; 2. Body = Body - HEAD
  2273 				        ;-------------------------------
  2274 0F50 38			        SEC
  2275 0F51 AD 88 18		        LDA     BODYL
  2276 0F54 ED 8A 18		        SBC     TAILL
  2277 0F57 8D 88 18		        STA     BODYL
  2278 0F5A AD 89 18		        LDA     BODYH
  2279 0F5D ED 8B 18		        SBC     TAILH
  2280 0F60 8D 89 18		        STA     BODYH
  2281
  2282 0F63 4C 80 0F		        JMP     GETDAT_READ
  2283
  2284 0F66			GETDAT_OPT2:
  2285 				    ;--------------------------------
  2286 				    ; Here if bytes requested <= bytes 
  2287 				    ; remaining in cache
  2288 				    ;--------------------------------
  2289 				    ; Head = BL, TAIL = BODY = 0
  2290 				    ;--------------------------------
  2291 0F66 AD 84 18		        LDA     BLL
  2292 0F69 8D 86 18		        STA     HEADL
  2293 0F6C AD 85 18		        LDA     BLH
  2294 0F6F 8D 87 18		        STA     HEADH
  2295 0F72 A9 00		        LDA     #$00
  2296 0F74 8D 8A 18		        STA     TAILL
  2297 0F77 8D 8B 18		        STA     TAILH
  2298 0F7A 8D 88 18		        STA     BODYL
  2299 0F7D 8D 89 18		        STA     BODYH
  2300
  2301 				;---------------------------------------
  2302 0F80			GETDAT_READ:
  2303 				;---------------------------------------
  2304 				    ;---------------------------------------
  2305 				    ; Read HEAD bytes
  2306 				    ;---------------------------------------
  2307 0F80 AD 86 18		        LDA     HEADL
  2308 0F83 8D 84 18		        STA     BLL
  2309 0F86 AD 87 18		        LDA     HEADH
  2310 0F89 8D 85 18		        STA     BLH
  2311 0F8C 20 BD 0F		        JSR     GETDAT_DOSIOV
  2312 0F8F 10 01		        BPL     GETDAT_BODY ; Skip ahead if no problems
  2313 0F91 60			        RTS                 ; Bail if error
  2314
  2315 				    ;---------------------------------------
  2316 				    ; Read BODY bytes
  2317 				    ;---------------------------------------
  2318 0F92			GETDAT_BODY:
  2319 0F92 AE 89 18		        LDX     BODYH
  2320 0F95			GETDAT_BODY_LOOP:
  2321 0F95 F0 1A		        BEQ     GETDAT_TAIL ; Skip if less than a page to read
  2322
  2323 0F97 A9 00		        LDA     #$00
  2324 0F99 8D 84 18		        STA     BLL         ; Buffer length
  2325 0F9C A9 02		        LDA     #$02        ; 512 bytes at a time
  2326 0F9E 8D 85 18		        STA     BLH
  2327
  2328 0FA1 8A			        TXA                 ; Stash our loop index (X)
  2329 0FA2 48			        PHA                 ; onto the stack
  2330 0FA3 20 BD 0F		        JSR     GETDAT_DOSIOV   
  2331 0FA6 10 03		        BPL     @+          ; Skip ahead if no problems
  2332 0FA8 68			        PLA                 ; Here if problem. Clean up stack
  2333 0FA9 98			        TYA                 ; Reset N status flag before returning
  2334 0FAA 60			        RTS                 ; Bail if error
  2335
  2336 0FAB 68			@:      PLA                 ; Retrieve our loop index
  2337 0FAC AA			        TAX                 ; and xfer it back into X
  2338 0FAD CA			        DEX                 ; -2 (we pull 0200 bytes at a time)
  2339 0FAE CA			        DEX                 ; 
  2340 0FAF D0 E4		        BNE     GETDAT_BODY_LOOP
  2341
  2342 0FB1			GETDAT_TAIL:
  2343 				    ;---------------------------------------
  2344 				    ; Read TAIL bytes
  2345 				    ;---------------------------------------
  2346 0FB1 AD 8A 18		        LDA     TAILL
  2347 0FB4 8D 84 18		        STA     BLL
  2348 0FB7 AD 8B 18		        LDA     TAILH
  2349 0FBA 8D 85 18		        STA     BLH
  2350
  2351 				;---------------------------------------
  2352 0FBD			GETDAT_DOSIOV:
  2353 				;---------------------------------------
  2354 				    ; Bail if BL = 0
  2355 0FBD AD 84 18		        LDA     BLL
  2356 0FC0 D0 05		        BNE     @+
  2357 0FC2 AD 85 18		        LDA     BLH
  2358 0FC5 F0 5C		        BEQ     CHECK_EOF_DONE
  2359
  2360 0FC7			@:
  2361 				    ; SIO READ
  2362 0FC7 AD 80 18		        LDA     STL
  2363 0FCA 8D 2A 10		        STA     BINDCB+4    ; Start Address Lo
  2364 0FCD AD 81 18		        LDA     STH
  2365 0FD0 8D 2B 10		        STA     BINDCB+5    ; Start Address Hi
  2366 0FD3 AD 84 18		        LDA     BLL
  2367 0FD6 8D 2E 10		        STA     BINDCB+8    ; Buffer Size Lo
  2368 0FD9 8D 30 10		        STA     BINDCB+10
  2369 0FDC AD 85 18		        LDA     BLH
  2370 0FDF 8D 2F 10		        STA     BINDCB+9    ; Buffer Size Hi
  2371 0FE2 8D 31 10		        STA     BINDCB+11
  2372
  2373 				    ;---------------------------------------
  2374 				    ; Send Read request to SIO
  2375 				    ;---------------------------------------
  2376 0FE5 A9 26		        LDA     #<BINDCB
  2377 0FE7 A0 10		        LDY     #>BINDCB
  2378 0FE9 20 A5 07		        JSR     DOSIOV
  2379 0FEC 20 96 0A		        JSR     PRINT_ERROR
  2380
  2381 				    ;---------------------------------------
  2382 				    ; Advance start address by buffer length
  2383 				    ;---------------------------------------
  2384 0FEF 18			        CLC
  2385 0FF0 AD 80 18		        LDA     STL
  2386 0FF3 6D 84 18		        ADC     BLL
  2387 0FF6 8D 80 18		        STA     STL
  2388
  2389 0FF9 AD 81 18		        LDA     STH
  2390 0FFC 6D 85 18		        ADC     BLH
  2391 0FFF 8D 81 18		        STA     STH
  2392
  2393 1002			GETDAT_CHECK_EOF:
  2394 				    ; Get status (updates DVSTAT, DSTATS)
  2395 1002 AD 27 10		        LDA     BINDCB+1
  2396 1005 8D 49 09		        STA     STADCB+1
  2397 1008 A9 48		        LDA     #<STADCB
  2398 100A A0 09		        LDY     #>STADCB
  2399 100C 20 A5 07		        JSR     DOSIOV
  2400
  2401 				    ; Return -1 if DVSTAT == $0000 and DVSTAT+3 == EOF
  2402 100F AD EA 02		        LDA     DVSTAT
  2403 1012 D0 0F		        BNE     CHECK_EOF_DONE
  2404
  2405 1014 AD EB 02		        LDA     DVSTAT+1
  2406 1017 D0 0A		        BNE     CHECK_EOF_DONE
  2407
  2408 1019 A9 88		        LDA     #EOF
  2409 101B CD ED 02		        CMP     DVSTAT+3        ; Is it EOF
  2410 101E D0 03		        BNE     CHECK_EOF_DONE  ; No? Go to success
  2411 1020 A0 FF		        LDY     #$FF            ; Yes? Return -1
  2412 1022 60			        RTS
  2413
  2414 1023			CHECK_EOF_DONE:
  2415 1023 A0 01		        LDY     #$01            ; Return success
  2416 1025 60			        RTS
  2417
  2418 1026			BINDCB:
  2419 1026 71			       .BYTE    DEVIDN      ; DDEVIC
  2420 1027 FF			       .BYTE    $FF         ; DUNIT
  2421 1028 52			       .BYTE    'R'         ; DCOMND
  2422 1029 40			       .BYTE    $40         ; DSTATS
  2423 102A FF			       .BYTE    $FF         ; DBUFL
  2424 102B FF			       .BYTE    $FF         ; DBUFH
  2425 102C 0F			       .BYTE    $0F         ; DTIMLO
  2426 102D 00			       .BYTE    $00         ; DRESVD
  2427 102E FF			       .BYTE    $FF         ; DBYTL
  2428 102F FF			       .BYTE    $FF         ; DBYTH
  2429 1030 FF			       .BYTE    $FF         ; DAUX1
  2430 1031 FF			       .BYTE    $FF         ; DAUX2
  2431
  2432
  2433 				;---------------------------------------
  2434 1032			LOAD_CLOSE:
  2435 				;---------------------------------------
  2436 1032 AD 27 10		        LDA     BINDCB+1
  2437 1035 8D 22 08		        STA     CLODCB+1
  2438 1038 A9 21		        LDA     #<CLODCB
  2439 103A A0 08		        LDY     #>CLODCB
  2440 103C 4C A5 07		        JMP     DOSIOV
  2441
  2442 				;---------------------------------------
  2443 103F			LOAD_ERROR:
  2444 				;---------------------------------------
  2445 103F A9 36		        LDA     #<MISSING_FILE_STR
  2446 1041 A0 17		        LDY     #>MISSING_FILE_STR
  2447 1043 4C 7B 0A		        JMP     PRINT_STRING
  2448
  2449 				;---------------------------------------
  2450 1046			DO_LOCK:
  2451 				;---------------------------------------
  2452 1046 A9 60		        LDA     #$60
  2453 1048 8D C6 02		        STA     COLOR2
  2454 104B 60			        RTS
  2455
  2456 				;---------------------------------------
  2457 104C			DO_LOGIN:
  2458 				;---------------------------------------
  2459 104C A9 A0		        LDA     #$A0
  2460 104E 8D C6 02		        STA     COLOR2
  2461 1051 60			        RTS
  2462
  2463 1052			LOGIN_ERROR:
  2464 1052 A9 59		        LDA     #<LOGIN_ERROR_STR
  2465 1054 A0 10		        LDY     #>LOGIN_ERROR_STR
  2466 1056 4C 7B 0A		        JMP     PRINT_STRING
  2467
  2468 1059			LOGIN_ERROR_STR:
  2469 1059 4C 4F 47 49 4E 20 +         .BYTE   'LOGIN [N[n]:] <USERNAME> <PASSWORD>',EOL
  2470
  2471 				;---------------------------------------
  2472 107D			DO_NPWD:
  2473 				;---------------------------------------
  2474 107D A9 9B		        LDA     #EOL        ; Truncate buffer
  2475 107F 8D 00 18		        STA     RBUF
  2476
  2477 1082 20 2B 0C		        JSR     GET_DOSDR   ; X will contain n in Nn:
  2478 1085 8E B5 10		        STX     PWDDCB+1
  2479
  2480 1088 A9 B4		        LDA     #<PWDDCB
  2481 108A A0 10		        LDY     #>PWDDCB
  2482 108C 20 A5 07		        JSR     DOSIOV
  2483 108F 20 96 0A		        JSR     PRINT_ERROR
  2484
  2485 				    ;---------------------------------------
  2486 				    ; If we entered DO_NPWD from REMOUNT_DRIVE
  2487 				    ; then scipt printing output
  2488 				    ;---------------------------------------
  2489 1092 AD 3E 17		        LDA     CMDPRV
  2490 1095 C9 03		        CMP     #CMD_IDX.DEL
  2491 1097 F0 1A		        BEQ     NPWD_DONE
  2492 1099 C9 0A		        CMP     #CMD_IDX.RENAME
  2493 109B F0 16		        BEQ     NPWD_DONE
  2494
  2495 109D			NPWD_LOOP:
  2496 109D A9 00		        LDA     #<RBUF
  2497 109F A0 18		        LDY     #>RBUF
  2498 10A1 20 7B 0A		        JSR     PRINT_STRING
  2499
  2500 10A4 A9 48		        LDA     #<STADCB
  2501 10A6 A0 09		        LDY     #>STADCB
  2502 10A8 20 A5 07		        JSR     DOSIOV
  2503 10AB 20 96 0A		        JSR     PRINT_ERROR
  2504
  2505 				    ;---------------------------------------
  2506 				    ; Loop if more data to read
  2507 				    ;---------------------------------------
  2508 10AE AD EB 02		        LDA     DVSTAT+1    ; Was there more to read (that is, was hi>0)?
  2509 10B1 D0 EA		        BNE     NPWD_LOOP   ; If yes, then do it again
  2510
  2511 10B3			NPWD_DONE:
  2512 10B3 60			        RTS
  2513
  2514 10B4			PWDDCB:
  2515 10B4 71			        .BYTE   DEVIDN      ; DDEVIC
  2516 10B5 FF			        .BYTE   $FF         ; DUNIT
  2517 10B6 30			        .BYTE   $30         ; DCOMND
  2518 10B7 40			        .BYTE   $40         ; DSTATS
  2519 10B8 00			        .BYTE   <RBUF       ; DBUFL
  2520 10B9 18			        .BYTE   >RBUF       ; DBUFH
  2521 10BA 1F			        .BYTE   $1F         ; DTIMLO
  2522 10BB 00			        .BYTE   $00         ; DRESVD
  2523 10BC 00			        .BYTE   $00         ; DBYTL
  2524 10BD 01			        .BYTE   $01         ; DBYTH
  2525 10BE 00			        .BYTE   $00         ; DAUX1
  2526 10BF 00			        .BYTE   $00         ; DAUX2
  2527
  2528 				; End of DO_NPWD
  2529 				;---------------------------------------
  2530
  2531 				;---------------------------------------
  2532 10C0			DO_NTRANS:
  2533 				;---------------------------------------
  2534 10C0 AE 85 0B		        LDX     CMDSEP          ; Check if there's any args
  2535 10C3 F0 49		        BEQ     NTRANS_ERROR    ; No. Show usage and quit
  2536
  2537 10C5 AD 3C 17		        LDA     DOSDR           ; Go with current drive for now
  2538 10C8 8D 38 11		        STA     NTRDCB+1        ; it'll be overwritten later if req'd
  2539
  2540 				    ;---------------------------------------
  2541 				    ; Check for argc = 2
  2542 				    ;---------------------------------------
  2543 10CB AC 85 0B		        LDY     CMDSEP          ; Stash offset to arg1 in Y
  2544 10CE AE 86 0B		        LDX     CMDSEP+1        ; Is there an arg2?
  2545 10D1 F0 21		        BEQ     PARSE_MODE      ; No. parse arg1 as mode (0-3)
  2546
  2547 				    ;---------------------------------------
  2548 				    ; Here if argc = 2 (arg1 = Nn: arg2 = mode)
  2549 				    ;---------------------------------------
  2550 10D3 AE 85 0B		        LDX     CMDSEP          ; Get offset to arg1 (Nn:)
  2551 10D6 BD 82 05		        LDA     LNBUF,X         ; Is arg1's (N[n]:) 1st char = 'N'?
  2552 10D9 C9 4E		        CMP     #'N'            ;
  2553 10DB D0 31		        BNE     NTRANS_ERROR    ; No? Then quit
  2554 10DD BD 83 05		        LDA     LNBUF+1,X
  2555 10E0 C9 3A		        CMP     #':'            ; Is arg1's (N[n]:) 2nd char = ':'?
  2556 10E2 F0 10		        BEQ     PARSE_MODE      ; Yes, stick with default drive
  2557
  2558 				    ;---------------------------------------
  2559 				    ; Parse drive number
  2560 				    ;---------------------------------------
  2561 10E4 C9 31		        CMP     #'1'            ; Quit if n in Nn not 1..4
  2562 10E6 90 26		        BCC     NTRANS_ERROR    ; Quit if < '1'
  2563 10E8 C9 39		        CMP     #'9'
  2564 10EA B0 22		        BCS     NTRANS_ERROR    ; Quit if >= '9'
  2565 10EC 49 30		        EOR     #%00110000
  2566 10EE 8D 38 11		        STA     NTRDCB+1
  2567 10F1 AC 86 0B		        LDY     CMDSEP+1
  2568
  2569 				    ;---------------------------------------
  2570 				    ; Confirm valid parameter
  2571 				    ;---------------------------------------
  2572 10F4			PARSE_MODE:
  2573 10F4 B9 82 05		        LDA     LNBUF,Y         ; Quit if mode not 0..3
  2574 10F7 C9 30		        CMP     #'0'
  2575 10F9 90 13		        BCC     NTRANS_ERROR
  2576 10FB C9 34		        CMP     #'4'
  2577 10FD B0 0F		        BCS     NTRANS_ERROR
  2578 10FF 49 30		        EOR     #%00110000      ; Here if valid parameter
  2579 1101 8D 42 11		        STA     NTRDCB+11       ; Assign parameter to DCB
  2580
  2581 				    ;---------------------------------------
  2582 				    ; Call SIO
  2583 				    ;---------------------------------------
  2584 1104			NTRANS_CALL:
  2585 1104 A9 37		        LDA     #<NTRDCB
  2586 1106 A0 11		        LDY     #>NTRDCB
  2587 1108 20 A5 07		        JSR     DOSIOV
  2588 110B 4C 96 0A		        JMP     PRINT_ERROR
  2589
  2590 110E			NTRANS_ERROR:
  2591 110E A9 15		        LDA     #<NTRANS_ERROR_STR
  2592 1110 A0 11		        LDY     #>NTRANS_ERROR_STR
  2593 1112 4C 7B 0A		        JMP     PRINT_STRING
  2594
  2595 1115			NTRANS_ERROR_STR:
  2596 1115 4D 4F 44 45 3F 20 +         .BYTE   'MODE? 0=NONE, 1=CR, 2=LF, 3=CR/LF',EOL
  2597
  2598 1137			NTRDCB:
  2599 1137 71			        .BYTE   DEVIDN  ; DDEVIC
  2600 1138 FF			        .BYTE   $FF     ; DUNIT
  2601 1139 54			        .BYTE   'T'     ; DCOMND
  2602 113A 00			        .BYTE   $00     ; DSTATS
  2603 113B 00			        .BYTE   $00     ; DBUFL
  2604 113C 00			        .BYTE   $00     ; DBUFH
  2605 113D 1F			        .BYTE   $1F     ; DTIMLO
  2606 113E 00			        .BYTE   $00     ; DRESVD
  2607 113F 00			        .BYTE   $00     ; DBYTL
  2608 1140 00			        .BYTE   $00     ; DBYTH
  2609 1141 00			        .BYTE   $00     ; DAUX1
  2610 1142 00			        .BYTE   $00     ; DAUX2
  2611
  2612 				; End of DO_NTRANS
  2613 				;---------------------------------------
  2614
  2615 				;---------------------------------------
  2616 1143			DO_AUTORUN:
  2617 				;---------------------------------------
  2618 				    ; Change URL stored in AUTORUN app key
  2619 				    ;-----------------------------------
  2620 1143 AD 85 0B		        LDA     CMDSEP          ; Check if there's any arg
  2621 1146 D0 07		        BNE     AUTORUN_NEXT1   ; If arg found, skip ahead
  2622
  2623 				    ; Here if no command line arg found
  2624 				    ; Print error message and exit
  2625 1148 A9 90		        LDA     #<AUTORUN_ERROR_STR
  2626 114A A0 11		        LDY     #>AUTORUN_ERROR_STR
  2627 114C 4C 7B 0A		        JMP     PRINT_STRING
  2628
  2629 114F			AUTORUN_NEXT1:
  2630 				    ; Point to start of arg on command line
  2631 114F 18			        CLC
  2632 1150 65 F3		        ADC     INBUFF          ; INBUFF += CMDSEP
  2633 1152 85 F3		        STA     INBUFF
  2634 1154 8D C4 11		        STA     APPKEYWRITEDCB+4
  2635
  2636 				    ; If "AUTORUN ?" Then abuse AUTORUN_SUBMIT to print appkey
  2637 1157 A0 00		        LDY     #$00
  2638 1159 A9 3F		        LDA     #'?'
  2639 115B 8D 91 18		        STA     AUTORUN_QUERY_FLG
  2640 115E D1 F3		        CMP     (INBUFF),Y
  2641 1160 F0 6A		        BEQ     SUBMIT_AUTORUN
  2642
  2643 				    ; Open app key
  2644 1162 A9 01		        LDA     #$01            ; Open for write (1)
  2645 1164 8D 91 18		        STA     AUTORUN_QUERY_FLG
  2646 1167 8D 9A 11		        STA     AUTORUN_APPKEY+4
  2647 116A A9 A8		        LDA     #<APPKEYOPENDCB
  2648 116C A0 11		        LDY     #>APPKEYOPENDCB
  2649 116E 20 A5 07		        JSR     DOSIOV
  2650
  2651 				    ; Find length of URL (arg1)
  2652 1171 A0 FF		        LDY     #$FF            ; Init strlen
  2653 1173			AUTORUN_LOOP1
  2654 1173 C8			        INY                     ; Incr strlen
  2655 1174 B1 F3		        LDA     (INBUFF),Y
  2656 1176 C9 9B		        CMP     #EOL            ; At end of string?
  2657 1178 D0 F9		        BNE     AUTORUN_LOOP1   ; No. Keep counting
  2658
  2659 117A A9 0A		        LDA     #LF             ; Convert EOL to LF
  2660 117C 91 F3		        STA     (INBUFF),Y
  2661 117E C8			        INY                     ; One more for strlen
  2662
  2663 117F			AUTORUN_NEXT2: 
  2664 				    ; Write app key
  2665 117F 8C CA 11		        STY     APPKEYWRITEDCB+10   ; Y = strlen
  2666 1182 A9 C0		        LDA     #<APPKEYWRITEDCB
  2667 1184 A0 11		        LDY     #>APPKEYWRITEDCB
  2668 1186 20 A5 07		        JSR     DOSIOV
  2669
  2670 				    ; Close app key
  2671 1189 A9 9C		        LDA     #<APPKEYCLOSEDCB
  2672 118B A0 11		        LDY     #>APPKEYCLOSEDCB
  2673 118D 4C A5 07		        JMP     DOSIOV
  2674
  2675 1190			AUTORUN_ERROR_STR:
  2676 1190 50 41 54 48 3F 9B	        .BYTE   'PATH?',EOL
  2677
  2678 1196			AUTORUN_APPKEY:
  2679 1196 79 DB		        .WORD   $DB79           ; creator ID
  2680 1198 00			        .BYTE   $00             ; app ID
  2681 1199 00			        .BYTE   $00             ; key ID
  2682 119A 00			        .BYTE   $00             ; read or write mode
  2683 119B 00			        .BYTE   $00             ; unused
  2684
  2685 119C			APPKEYCLOSEDCB:
  2686 119C 70			        .BYTE   $70             ; DDEVIC
  2687 119D 01			        .BYTE   $01             ; DUNIT
  2688 119E DB			        .BYTE   $DB             ; DCOMND
  2689 119F 00			        .BYTE   $00             ; DSTATS
  2690 11A0 00			        .BYTE   $00             ; DBUFL
  2691 11A1 00			        .BYTE   $00             ; DBUFH
  2692 11A2 0F			        .BYTE   $0F             ; DTIMLO
  2693 11A3 00			        .BYTE   $00             ; DRESVD
  2694 11A4 00			        .BYTE   $00             ; DBYTL
  2695 11A5 00			        .BYTE   $00             ; DBYTH
  2696 11A6 00			        .BYTE   $00             ; DAUX1
  2697 11A7 00			        .BYTE   $00             ; DAUX2
  2698
  2699 11A8			APPKEYOPENDCB:
  2700 11A8 70			        .BYTE   $70             ; DDEVIC
  2701 11A9 01			        .BYTE   $01             ; DUNIT
  2702 11AA DC			        .BYTE   $DC             ; DCOMND
  2703 11AB 80			        .BYTE   $80             ; DSTATS
  2704 11AC 96			        .BYTE   <AUTORUN_APPKEY ; DBUFL
  2705 11AD 11			        .BYTE   >AUTORUN_APPKEY ; DBUFH
  2706 11AE 0F			        .BYTE   $0F             ; DTIMLO
  2707 11AF 00			        .BYTE   $00             ; DRESVD
  2708 11B0 06			        .BYTE   $06             ; DBYTL
  2709 11B1 00			        .BYTE   $00             ; DBYTH
  2710 11B2 00			        .BYTE   $00             ; DAUX1
  2711 11B3 00			        .BYTE   $00             ; DAUX2
  2712
  2713 11B4			APPKEYREADDCB:
  2714 11B4 70			        .BYTE   $70             ; DDEVIC
  2715 11B5 01			        .BYTE   $01             ; DUNIT
  2716 11B6 DD			        .BYTE   $DD             ; DCOMND
  2717 11B7 40			        .BYTE   $40             ; DSTATS
  2718 11B8 82			        .BYTE   <LNBUF          ; DBUFL
  2719 11B9 05			        .BYTE   >LNBUF          ; DBUFH
  2720 11BA 01			        .BYTE   $01             ; DTIMLO - minimize timeout
  2721 11BB 00			        .BYTE   $00             ; DRESVD
  2722 11BC 40			        .BYTE   MAX_APPKEY_LEN  ; DBYTL
  2723 11BD 00			        .BYTE   $00             ; DBYTH
  2724 11BE 00			        .BYTE   $00             ; DAUX1
  2725 11BF 00			        .BYTE   $00             ; DAUX2
  2726
  2727 11C0			APPKEYWRITEDCB:
  2728 11C0 70			        .BYTE   $70             ; DDEVIC
  2729 11C1 01			        .BYTE   $01             ; DUNIT
  2730 11C2 DE			        .BYTE   $DE             ; DCOMND
  2731 11C3 80			        .BYTE   $80             ; DSTATS
  2732 11C4 FF			        .BYTE   $FF             ; DBUFL
  2733 11C5 05			        .BYTE   $05             ; DBUFH (expect page 5)
  2734 11C6 0F			        .BYTE   $0F             ; DTIMLO
  2735 11C7 00			        .BYTE   $00             ; DRESVD
  2736 11C8 40			        .BYTE   MAX_APPKEY_LEN  ; DBYTL
  2737 11C9 00			        .BYTE   $00             ; DBYTH
  2738 11CA FF			        .BYTE   $FF             ; DAUX1 (# actual bytes)
  2739 11CB 00			        .BYTE   $00             ; DAUX2
  2740
  2741 				;---------------------------------------
  2742 11CC			SUBMIT_AUTORUN:
  2743 				;---------------------------------------
  2744 				    ; At initial DOS boot, read URL for 
  2745 				    ; app key file from SD card's
  2746 				    ; FujiNet folder.
  2747 				    ;
  2748 				    ; filename: db790000.key
  2749 				    ; contents: url to a batch file
  2750 				    ;---------------------------------------
  2751 11CC 20 64 0A		        JSR     LDBUFA
  2752
  2753 				    ; Open app key
  2754 11CF A9 00		        LDA     #$00            ; Open for read
  2755 11D1 8D 9A 11		        STA     AUTORUN_APPKEY+4
  2756 11D4 A9 A8		        LDA     #<APPKEYOPENDCB
  2757 11D6 A0 11		        LDY     #>APPKEYOPENDCB
  2758 11D8 20 A5 07		        JSR     DOSIOV
  2759
  2760 11DB C0 01		        CPY     #$01            ; Was open successful?
  2761 11DD F0 01		        BEQ     AUTOSUB_NEXT    ; Yes. Continue.
  2762 11DF 60			        RTS                     ; No. Exit
  2763
  2764 11E0			AUTOSUB_NEXT:
  2765 				    ; Read app key
  2766 11E0 A9 B4		        LDA     #<APPKEYREADDCB
  2767 11E2 A0 11		        LDY     #>APPKEYREADDCB
  2768 11E4 20 A5 07		        JSR     DOSIOV
  2769
  2770 				    ; Close app key
  2771 11E7 A9 9C		        LDA     #<APPKEYCLOSEDCB
  2772 11E9 A0 11		        LDY     #>APPKEYCLOSEDCB
  2773 11EB 20 A5 07		        JSR     DOSIOV
  2774
  2775 				    ; Does the returned URL contain something?
  2776 11EE AE 82 05		        LDX     LNBUF           ; X contains strlen of AUTORUN path
  2777 11F1 D0 01		        BNE     AUTORUN_CALL_SUBMIT
  2778
  2779 				;        LDX     LNBUF
  2780 				;        BEQ     AUTOSUB_DONE
  2781 				;
  2782 				        
  2783
  2784 11F3			AUTOSUB_DONE:
  2785 11F3 60			        RTS
  2786
  2787 11F4			AUTORUN_CALL_SUBMIT:
  2788 				    ; Replace end-of-line in buffer with null terminator
  2789 11F4 CA			        DEX                     ; Move index back 1 position
  2790 11F5 A9 00		        LDA     #$00            ;
  2791 11F7 9D 84 05		        STA     LNBUF+2,X       ; Write null-terminator 
  2792 11FA A9 02		        LDA     #$02            ; Change arg1 location...
  2793 11FC 8D 85 0B		        STA     CMDSEP          ;  to point to filename
  2794 				;        BNE     SUBMIT_NEXT1    ; Fall through
  2795
  2796 11FF AD 91 18		        LDA     AUTORUN_QUERY_FLG
  2797 1202 C9 3F		        CMP     #'?'
  2798 1204 D0 18		        BNE     SUBMIT_NEXT1
  2799
  2800 1206 A9 9B		        LDA     #EOL            ; Shove EOL to terminate string
  2801 1208 9D 84 05		        STA     LNBUF+2,X
  2802 120B A9 84		        LDA     #<(LNBUF+2)
  2803 120D A0 05		        LDY     #>(LNBUF+2)
  2804 120F 4C 7B 0A		        JMP     PRINT_STRING    ; Print AUTORUN path and exit
  2805
  2806 				;---------------------------------------
  2807 1212			DO_SUBMIT:
  2808 				;---------------------------------------
  2809 1212 AD 85 0B		        LDA     CMDSEP
  2810 1215 D0 07		        BNE     SUBMIT_NEXT1
  2811
  2812 				    ; Filename required
  2813 1217 A9 36		        LDA     #<MISSING_FILE_STR
  2814 1219 A0 17		        LDY     #>MISSING_FILE_STR
  2815 121B 4C 7B 0A		        JMP     PRINT_STRING
  2816
  2817 121E			SUBMIT_NEXT1:
  2818
  2819 				    ; Default to NOSCREEN
  2820 121E A9 00		        LDA     #$00
  2821 1220 8D 3F 17		        STA     ECHO_FLG
  2822
  2823 				    ; Prep file path
  2824 1223 20 2B 0C		        JSR     GET_DOSDR       ; Get DUNIT
  2825 1226 20 78 15		        JSR     PREPEND_DRIVE
  2826
  2827 				    ; Assert FILE #1 is closed
  2828 1229 A2 10		        LDX     #$10
  2829 122B 20 BB 09		        JSR     CIOCLOSE
  2830 				        
  2831 				    ; OPEN #1, 4, 0, file path
  2832 122E A2 10		        LDX     #$10            ; File #1
  2833 1230 A0 04		        LDY     #$04            ; Open for input
  2834 1232 20 C3 09		        JSR     CIOOPEN         ; Open filename @ (INBUFF)
  2835 1235 10 03		        BPL     SUBMIT_NEXT2
  2836 1237 4C 96 0A		        JMP     PRINT_ERROR
  2837
  2838 				    ; Read batch file character by character
  2839 				    ; This allows it be end-of-line agnostic
  2840 				    ; Branch forward when an end-of-line is interpretted.
  2841
  2842 123A			SUBMIT_NEXT2:
  2843 123A 20 64 0A		        JSR     LDBUFA      ; Reset INBUFF to $0580
  2844 123D C6 F3		        DEC     INBUFF      ; Init 1 byte before buffer
  2845 123F A9 FF		        LDA     #$FF        ; Clear command
  2846 1241 8D 3D 17		        STA     CMD
  2847
  2848 1244			SUBMIT_GETCH:
  2849 1244 E6 F3		        INC     INBUFF          ; Advance pointer
  2850 1246 D0 02		        BNE     SUBMIT_NEXT3
  2851 1248 E6 F4		        INC     INBUFF+1
  2852
  2853 124A			SUBMIT_NEXT3:
  2854 124A A2 10		        LDX     #$10            ; OPEN #1
  2855 124C A9 01		        LDA     #$01            ; Get 1 byte
  2856 124E A0 00		        LDY     #$00            ; ditto
  2857
  2858 1250 20 ED 09		        JSR     CIOGET          ; Get byte from file
  2859 1253 A0 00		        LDY     #$00            ;
  2860 1255 B1 F3		        LDA     (INBUFF),Y      ; byte will be here
  2861 				        
  2862 1257 C9 0D		        CMP     #CR             ; Just skip if Windows CR
  2863 1259 F0 E9		        BEQ     SUBMIT_GETCH
  2864
  2865 125B C9 0A		        CMP     #LF             ; Convert LF to EOL
  2866 125D D0 04		        BNE     SUBMIT_EOL
  2867 125F A9 9B		        LDA     #EOL
  2868 1261 91 F3		        STA     (INBUFF),Y
  2869
  2870 1263			SUBMIT_EOL:
  2871 1263 C9 9B		        CMP     #EOL            ; At end of command line?
  2872 1265 D0 DD		        BNE     SUBMIT_GETCH    ; No. Get next byte.
  2873
  2874 				    ; Here if we've reached the end of a command line.
  2875 				    ; At end of file?
  2876 1267 A2 10		        LDX     #$10            ; Channel #1
  2877 1269 BD 43 03		        LDA     ICSTA,X         ; Inspect return code
  2878 126C C9 88		        CMP     #EOF
  2879 126E F0 22		        BEQ     SUBMIT_DONE     ; No error, try parsing cmd
  2880
  2881 1270 AD 3F 17		        LDA     ECHO_FLG        ; Skip echo if SCREEN is disabled
  2882 1273 F0 11		        BEQ     SUBMIT_NEXT4
  2883 1275 AD 82 05		        LDA     LNBUF
  2884 1278 C9 40		        CMP     #'@'            ; Skip lines beginning with @
  2885 127A F0 0A		        BEQ     SUBMIT_NEXT4
  2886
  2887 				    ; Echo commands
  2888 127C 20 64 0A		        JSR     LDBUFA
  2889 127F A5 F3		        LDA     INBUFF
  2890 1281 A4 F4		        LDY     INBUFF+1
  2891 1283 20 7B 0A		        JSR     PRINT_STRING
  2892
  2893 1286			SUBMIT_NEXT4:
  2894 1286 20 33 0B		        JSR     GETCMDTEST
  2895 1289 20 89 0B		        JSR     PARSECMD
  2896 128C 20 FF 0B		        JSR     DOCMD
  2897 128F 38			        SEC
  2898 1290 B0 A8		        BCS     SUBMIT_NEXT2
  2899
  2900 1292			SUBMIT_DONE
  2901 1292 A2 10		        LDX     #$10
  2902 1294 4C BB 09		        JMP     CIOCLOSE
  2903
  2904 				; End of DO_SUBMIT
  2905 				;---------------------------------------
  2906
  2907 				;---------------------------------------
  2908 1297			DO_TYPE:
  2909 				;---------------------------------------
  2910 1297 AD 85 0B		        LDA     CMDSEP
  2911 129A D0 07		        BNE     TYPE_SKIP
  2912
  2913 129C			TYPE_USAGE:
  2914 129C A9 36		        LDA     #<MISSING_FILE_STR
  2915 129E A0 17		        LDY     #>MISSING_FILE_STR
  2916 12A0 4C 7B 0A		        JMP     PRINT_STRING
  2917
  2918 12A3			TYPE_SKIP:
  2919 12A3 20 2B 0C		        JSR     GET_DOSDR       ; Get DUNIT
  2920 12A6 20 78 15		        JSR     PREPEND_DRIVE
  2921
  2922 				    ; Assert input file closed
  2923 12A9 A2 10		        LDX     #$10            ; File #1
  2924 12AB 20 BB 09		        JSR     CIOCLOSE        ; Assert file #1 is closed
  2925
  2926 				    ; Open input file
  2927 12AE A2 10		        LDX     #$10            ; File #1
  2928 12B0 A0 04		        LDY     #$04            ; Open for input
  2929 12B2 20 C3 09		        JSR     CIOOPEN         ; Open filename @ (INBUFF)
  2930 12B5 10 08		        BPL     TYPE_NEXT
  2931
  2932 				    ; If open failed, Print error
  2933 12B7 A2 10		        LDX     #$10            ; File #1
  2934 12B9 BC 43 03		        LDY     ICSTA,X
  2935 12BC 4C 96 0A		        JMP     PRINT_ERROR
  2936
  2937 12BF			TYPE_NEXT:
  2938
  2939 				    ; Initialize pagination
  2940 12BF 20 64 13		        JSR     DO_CLS
  2941 12C2 A9 15		        LDA     #21
  2942 12C4 8D BB 02		        STA     SCRFLG
  2943
  2944 12C7			TYPE_LOOP:
  2945 				    ; Bail if ESC key is pressed
  2946 12C7 AD FC 02		        LDA     CH
  2947 12CA C9 1C		        CMP     #ESC_KEY
  2948 12CC F0 49		        BEQ     TYPE_DONE
  2949
  2950 				    ; Check if page is full
  2951 12CE AD BB 02		        LDA     SCRFLG
  2952 12D1 C9 16		        CMP     #22             ; if SCRFLG < 21
  2953 12D3 90 14		        BCC     TYPE_READ       ; then skip to read
  2954
  2955 				    ; Here if page is full
  2956 				    ; Wait for keypress
  2957 12D5 A9 FF		        LDA     #$FF            ; Clear keypress
  2958 12D7 8D FC 02		        STA     CH
  2959
  2960 12DA			TYPE_WAIT:
  2961 12DA AE FC 02		        LDX     CH              ; Will be $FF if no keypress
  2962 12DD E8			        INX                     ; $FF --> $00
  2963 12DE F0 FA		        BEQ     TYPE_WAIT       ; Keep waiting if $00
  2964
  2965 12E0 E0 1C		        CPX     #ESC_KEY        ; Leave if ESC key pressed
  2966 12E2 F0 33		        BEQ     TYPE_DONE
  2967
  2968 				    ; Reset pagination
  2969 12E4 A9 00		        LDA     #$00
  2970 12E6 8D BB 02		        STA     SCRFLG
  2971
  2972 12E9			TYPE_READ:
  2973 				    ; Read from file
  2974 12E9 A2 10		        LDX     #$10
  2975 12EB A9 01		        LDA     #$01
  2976 12ED A0 00		        LDY     #$00
  2977 12EF 20 ED 09		        JSR     CIOGET
  2978
  2979 				    ; Quit if EOF
  2980 12F2 A2 10		        LDX     #$10
  2981 12F4 BD 43 03		        LDA     ICSTA,X
  2982 12F7 C9 88		        CMP     #EOF
  2983 12F9 F0 1C		        BEQ     TYPE_DONE
  2984
  2985 				    ; Convert CRLF or LF --> EOL
  2986 12FB A0 00		        LDY     #$00
  2987 12FD B1 F3		        LDA     (INBUFF),Y
  2988 12FF C9 0D		        CMP     #CR     ; Skip CR
  2989 1301 F0 11		        BEQ     TYPE_NEXT3
  2990 1303 C9 0A		        CMP     #LF     ; Convert LF --> EOL
  2991 1305 D0 04		        BNE     TYPE_NEXT2
  2992 1307 A9 9B		        LDA     #EOL
  2993 1309 91 F3		        STA     (INBUFF),Y
  2994
  2995 130B			TYPE_NEXT2:
  2996 				    ; Write to screen
  2997 130B A2 00		        LDX     #$00
  2998 130D A9 01		        LDA     #$01
  2999 130F A0 00		        LDY     #$00
  3000 1311 20 0B 0A		        JSR     CIOPUT
  3001
  3002 1314			TYPE_NEXT3:
  3003 				    ; Do next
  3004 1314 4C C7 12		        JMP     TYPE_LOOP
  3005 				        
  3006 1317			TYPE_DONE:
  3007 1317 A9 FF		        LDA     #$FF
  3008 1319 8D FC 02		        STA     CH
  3009 131C A2 10		        LDX     #$10            ; Close File #1
  3010 131E 4C BB 09		        JMP     CIOCLOSE        ; 
  3011
  3012 1321			TYPE_OPEN_ERR_STR:
  3013 1321 55 4E 41 42 4C 45 +         .BYTE   'UNABLE TO OPEN FILE',EOL
  3014
  3015 				;---------------------------------------
  3016 1335			DO_UNLOCK:
  3017 				;---------------------------------------
  3018 1335 A9 90		        LDA     #$90
  3019 1337 8D C6 02		        STA     COLOR2
  3020 133A 60			        RTS
  3021
  3022 				;---------------------------------------
  3023 133B			DO_CAR:
  3024 				;---------------------------------------
  3025
  3026 				    ;---------------------------------------
  3027 				    ; Is cart address space RAM or ROM?
  3028 				    ;---------------------------------------
  3029 133B AD 00 A0		        LDA     $A000
  3030 133E EE 00 A0		        INC     $A000
  3031 1341 CD 00 A0		        CMP     $A000
  3032 1344 F0 0A		        BEQ     DO_CAR_NEXT
  3033
  3034 				    ;---------------------------------------
  3035 				    ; RAM found
  3036 				    ;---------------------------------------
  3037 1346 8D 00 A0		        STA     $A000
  3038 1349 A9 57		        LDA     #<DO_CAR_ERR
  3039 134B A0 13		        LDY     #>DO_CAR_ERR
  3040 134D 4C 7B 0A		        JMP     PRINT_STRING
  3041
  3042 1350			DO_CAR_NEXT:
  3043 1350 A9 FF		        LDA     #$FF
  3044 1352 85 08		        STA     $08         ; Warmstart
  3045 1354 6C FA BF		        JMP     ($BFFA)
  3046
  3047 1357			DO_CAR_ERR:
  3048 1357 4E 4F 20 43 41 52 +         .BYTE   'NO CARTRIDGE',EOL
  3049
  3050 				;---------------------------------------
  3051 1364			DO_CLS:
  3052 				;---------------------------------------
  3053 1364 A9 6B		        LDA     #<CLS_STR
  3054 1366 A0 13		        LDY     #>CLS_STR
  3055 1368 4C 7B 0A		        JMP     PRINT_STRING
  3056
  3057 136B			CLS_STR:
  3058 136B 7D 9B		        .BYTE   125,EOL
  3059
  3060 				;---------------------------------------
  3061 136D			DO_COLD:
  3062 				;---------------------------------------
  3063 136D 4C 77 E4		        JMP     COLDSV
  3064
  3065 				;---------------------------------------
  3066 1370			DO_HELP:
  3067 				;---------------------------------------
  3068 				    ; Append either "HELP" or arg1 to URL
  3069 1370 A2 00		        LDX     #$00        ; index to start of article buf
  3070 1372 AC 85 0B		        LDY     CMDSEP      ; index to cmd line arg
  3071 				        
  3072 1375			HELP_LOOP1:
  3073 1375 B1 F3		        LDA     (INBUFF),Y
  3074 1377 C9 9B		        CMP     #EOL
  3075 1379 F0 11		        BEQ     HELP_NEXT1  ; Exit loop at end of arg
  3076 137B E0 16		        CPX     #22
  3077 137D 10 2B		        BPL     HELP_DONE   ; Exit if arg is too long
  3078 137F 9D 06 14		        STA     HELP_ARTICLE,X
  3079 1382 E8			        INX
  3080 1383 C8			        INY
  3081 1384 D0 EF		        BNE     HELP_LOOP1  ; Always true
  3082
  3083 				    ; Append .DOC extension to article name
  3084 1386			HELP_EXT:
  3085 1386 2E 44 4F 43 9B 00	        .BYTE   '.DOC',EOL,$00
  3086
  3087 138C			HELP_NEXT1:
  3088 138C A0 00		        LDY     #$00
  3089
  3090 138E			HELP_LOOP2:
  3091 138E B9 86 13		        LDA     HELP_EXT,Y
  3092 1391 9D 06 14		        STA     HELP_ARTICLE,X  ; Store null term too
  3093 1394 F0 04		        BEQ     HELP_NEXT2      ; Skip ahead if terminator
  3094 1396 E8			        INX
  3095 1397 C8			        INY
  3096 1398 D0 F4		        BNE     HELP_LOOP2  ; Always true
  3097
  3098 139A			HELP_NEXT2:
  3099 				    ; Copy URL to LNBUF
  3100 139A A2 00		        LDX     #$00    ; Index to start of HELP_URL
  3101 139C A0 05		        LDY     #$05    ; Index to start at arg1 for "TYPE "
  3102 				    
  3103 139E			HELP_LOOP3:
  3104 139E BD B2 13		        LDA     HELP_URL,X  ; Get source byte
  3105 13A1 99 82 05		        STA     LNBUF,Y     ; Write to target location
  3106 13A4 F0 04		        BEQ     HELP_DONE   ; Exit loop on null terminator
  3107 13A6 E8			        INX                 ; Advance indices
  3108 13A7 C8			        INY
  3109 13A8 D0 F4		        BNE     HELP_LOOP3  ; Always true
  3110 				        
  3111 13AA			HELP_DONE:        
  3112 13AA A9 05		        LDA     #$05        ; Trick TYPE to look for URL in arg1
  3113 13AC 8D 85 0B		        STA     CMDSEP
  3114 13AF 4C 97 12		        JMP     DO_TYPE
  3115
  3116 13B2			HELP_URL:
  3117 13B2 4E 38 3A 48 54 54 +         .BYTE   'N8:HTTPS://raw.githubusercontent.com/michaelsternberg/fujinet-nhandler/nos/nos/HELP/'
  3118
  3119 1406			HELP_ARTICLE:
  3120 1406 00 00 00 00 00 00 +     :24 .BYTE   $00
  3121
  3122 				;---------------------------------------
  3123 141E			DO_NOBASIC:
  3124 				;---------------------------------------
  3125 				    ; Quit if 400/800
  3126 141E AD F7 FF		        LDA     $FFF7
  3127 1421 C9 FF		        CMP     #$FF        ; ????
  3128 1423 F0 21		        BEQ     NOBASIC_ERROR
  3129 1425 C9 DD		        CMP     #$DD        ; OSA NTSC
  3130 1427 F0 1D		        BEQ     NOBASIC_ERROR
  3131 1429 C9 F3		        CMP     #$F3        ; OSB NTSC
  3132 142B F0 19		        BEQ     NOBASIC_ERROR
  3133 142D C9 D6		        CMP     #$D6        ; OSA PAL
  3134 142F F0 15		        BEQ     NOBASIC_ERROR
  3135 1431 C9 22		        CMP     #$22        ; OSB PAL
  3136 1433 F0 11		        BEQ     NOBASIC_ERROR
  3137 1435 C9 0A		        CMP     #$0A        ; OSA 1200XL
  3138 1437 F0 0D		        BEQ     NOBASIC_ERROR
  3139 1439 C9 0B		        CMP     #$0B        ; OSB 1200XL
  3140 143B F0 09		        BEQ     NOBASIC_ERROR
  3141 				        
  3142 				    ; Disable BASIC
  3143 143D AD 01 D3		        LDA     PORTB
  3144 1440 09 02		        ORA     #%00000010  ; if Bit 1 = 1 then BASIC is disabled
  3145 1442 8D 01 D3		        STA     PORTB
  3146 1445 60			        RTS
  3147
  3148 				;---------------------------------------
  3149 1446			NOBASIC_ERROR:
  3150 				;---------------------------------------
  3151 1446 A9 4D		        LDA     #<NOBASIC_ERROR_STR
  3152 1448 A0 14		        LDY     #>NOBASIC_ERROR_STR
  3153 144A 4C 7B 0A		        JMP     PRINT_STRING
  3154
  3155 144D			NOBASIC_ERROR_STR:
  3156 144D 4E 4F 20 42 55 49 +         .BYTE   'NO BUILT-IN BASIC',EOL
  3157
  3158 				;---------------------------------------
  3159 145F			DO_NOSCREEN:
  3160 				;---------------------------------------
  3161 145F A9 00		        LDA     #$00
  3162 1461 8D 3F 17		        STA     ECHO_FLG    ; Disable echo in batch processing
  3163 1464 60			        RTS
  3164
  3165 				;---------------------------------------
  3166 1465			DO_SCREEN:
  3167 				;---------------------------------------
  3168 1465 A9 01		        LDA     #$01
  3169 1467 8D 3F 17		        STA     ECHO_FLG    ; Enable echo in batch processing
  3170 146A 60			        RTS
  3171
  3172 				;---------------------------------------
  3173 146B			DO_PRINT:
  3174 				;---------------------------------------
  3175 146B AD 85 0B		        LDA     CMDSEP
  3176 146E F0 08		        BEQ     PRINT_DONE
  3177
  3178 1470 18			        CLC
  3179 1471 65 F3		        ADC     INBUFF
  3180 1473 A4 F4		        LDY     INBUFF+1
  3181 1475 4C 7B 0A		        JMP     PRINT_STRING
  3182
  3183 1478			PRINT_DONE:
  3184 1478 60			        RTS
  3185
  3186 				;---------------------------------------
  3187 1479			DO_REENTER:
  3188 				;---------------------------------------
  3189 				    ; Jump to the address stored in RUNAD or INITAD
  3190 				    ; Do the one that isn't pointing to R (RUNAD first)
  3191
  3192 				    ; Skip it all if both contain $0000
  3193 1479 AD E2 02		        LDA     INITAD
  3194 147C D0 16		        BNE     DO_REENTER_CONT
  3195 147E AD E3 02		        LDA     INITAD+1
  3196 1481 D0 11		        BNE     DO_REENTER_CONT
  3197 1483 AD E0 02		        LDA     RUNAD
  3198 1486 D0 0C		        BNE     DO_REENTER_CONT
  3199 1488 AD E1 02		        LDA     RUNAD+1
  3200 148B D0 07		        BNE     DO_REENTER_CONT
  3201
  3202 148D A9 A8		        LDA     #<DO_REENTER_ERR
  3203 148F A0 14		        LDY     #>DO_REENTER_ERR
  3204 1491 4C 7B 0A		        JMP     PRINT_STRING
  3205
  3206 1494			DO_REENTER_CONT:
  3207 1494 AD E0 02		        LDA     RUNAD
  3208 1497 C9 0E		        CMP     #>R
  3209 1499 D0 07		        BNE     DO_REENTER_RUNAD
  3210 149B AD E1 02		        LDA     RUNAD+1
  3211 149E C9 0E		        CMP     #>R
  3212 14A0 F0 03		        BEQ     DO_REENTER_INITAD
  3213
  3214 14A2			DO_REENTER_RUNAD:
  3215 14A2 6C E0 02		        JMP     (RUNAD)     ; Godspeed
  3216
  3217 14A5			DO_REENTER_INITAD:
  3218 14A5 6C E2 02		        JMP     (INITAD)    ; Godspeed
  3219
  3220 14A8			DO_REENTER_ERR:
  3221 14A8 4E 4F 20 41 44 44 +         .BYTE   'NO ADDR IN INITAD OR RUNAD',EOL
  3222
  3223 				;---------------------------------------
  3224 14C3			DO_REM:
  3225 				;---------------------------------------
  3226 14C3 60			        RTS
  3227
  3228 				;---------------------------------------
  3229 14C4			DO_RUN:
  3230 				;---------------------------------------
  3231 14C4 AD 85 0B		        LDA     CMDSEP      ; Get position for address arg
  3232 14C7 A8			        TAY                 ; Offset to arg used later
  3233 14C8 18			        CLC
  3234 14C9 69 04		        ADC     #$04
  3235 14CB 8D 00 18		        STA     RBUF
  3236
  3237 				    ;---------------------------------------
  3238 				    ; ASCII hex char to integer conversion
  3239 				    ; algorithm borrowed from Apple II Monitor
  3240 				    ;---------------------------------------
  3241 14CE A9 00		        LDA     #$00
  3242 14D0 85 F3		        STA     INBUFF      ; L
  3243 14D2 85 F4		        STA     INBUFF+1    ; H
  3244 14D4			NEXTHEX:
  3245 14D4 B9 82 05		        LDA     LNBUF,Y     ; Get character for hex test.
  3246 14D7 49 30		        EOR     #%00110000  ; Maps digits to $0-$9
  3247 14D9 C9 0A		        CMP     #$0A        ; Digit?
  3248 14DB 90 06		        BCC     DIG         ; Yes.
  3249 14DD 69 88		        ADC     #$88        ; Map letter "A"-"F" to $FA-FF.
  3250 14DF C9 FA		        CMP     #$FA        ; Hex letter?
  3251 14E1 90 17		        BCC     NOTHEX      ; No, character not hex.
  3252
  3253 14E3 0A			DIG:    ASL
  3254 14E4 0A			        ASL
  3255 14E5 0A			        ASL
  3256 14E6 0A			        ASL
  3257 14E7 A2 04		        LDX     #$04        ; Shift count.
  3258
  3259 14E9			HEXSHIFT:
  3260 14E9 0A			        ASL
  3261 14EA 26 F3		        ROL     INBUFF      ; Rotate into LSD.
  3262 14EC 26 F4		        ROL     INBUFF+1    ; Rotate into MSD's.
  3263 14EE CA			        DEX                 ; Done 4 shifts?
  3264 14EF D0 F8		        BNE     HEXSHIFT    ; No, loop.
  3265 14F1 C8			        INY                 ; Advance text index
  3266 14F2 CC 00 18		        CPY     RBUF        ; Processed 4 characters?
  3267 14F5 D0 DD		        BNE     NEXTHEX     ; No, get next character.
  3268
  3269 14F7 6C F3 00		        JMP     (INBUFF)    ; Goto requested address. Godspeed.
  3270
  3271 14FA			NOTHEX:
  3272 14FA A9 01		        LDA     #<RUN_ERROR_STR
  3273 14FC A0 15		        LDY     #>RUN_ERROR_STR
  3274 14FE 4C 7B 0A		        JMP     PRINT_STRING
  3275
  3276 1501			RUN_ERROR_STR:
  3277 1501 41 44 44 52 3F 20 +         .BYTE   'ADDR? 0000..FFFF',EOL
  3278
  3279 				;---------------------------------------
  3280 1512			DO_WARM:
  3281 				;---------------------------------------
  3282 1512 4C 74 E4		        JMP     WARMSV
  3283
  3284 				;---------------------------------------
  3285 1515			DO_XEP:
  3286 				;---------------------------------------
  3287 1515 A0 19		        LDY     #$19        ; CMD = $19 (enter 40 col)
  3288 1517 AE 85 0B		        LDX     CMDSEP
  3289 151A BD 82 05		        LDA     LNBUF,X
  3290 151D C9 34		        CMP     #'4'
  3291 151F F0 01		        BEQ     @+
  3292 1521 88			        DEY                 ; CMD = $18 (enter 80 col)
  3293 1522			@:      
  3294 1522 A2 00		        LDX     #$00
  3295 1524 98			        TYA
  3296 1525 9D 42 03		        STA     ICCOM,X
  3297 1528 A9 42		        LDA     #<EDEV
  3298 152A 9D 44 03		        STA     ICBAL,X
  3299 152D A9 15		        LDA     #>EDEV
  3300 152F 9D 45 03		        STA     ICBAH,X
  3301 1532 A9 2C		        LDA     #$2C
  3302 1534 9D 4A 03		        STA     ICAX1,X
  3303 1537 A9 00		        LDA     #$00
  3304 1539 9D 4B 03		        STA     ICAX2,X
  3305 153C 20 56 E4		        JSR     CIOV
  3306 153F 4C 64 13		        JMP     DO_CLS
  3307
  3308 1542 25 1A 9B		EDEV:   .BYTE   "E:",EOL
  3309 				        
  3310 				;---------------------------------------
  3311 1545			REMOUNT_DRIVE:
  3312 				;---------------------------------------
  3313
  3314 				    ;---------------------------------------
  3315 				    ; Workaround for timeout issue regarding idempotent commands that
  3316 				    ; unmount the server.  So far, these are DEL and RENAME. This
  3317 				    ; routine, remounts the TNFS URL by calling NPWD and attempts
  3318 				    ; a MKDIR on the returned mount point. Hopefully this is an
  3319 				    ; non-consequential operation since the directory already exists.
  3320 				    ;---------------------------------------
  3321
  3322 1545 20 7D 10		        JSR     DO_NPWD         ; Curr dir for drive now in RBUF
  3323
  3324 1548 AD 00 18		        LDA     RBUF            ; Quit if not TNFS. Only TNFS is affected.
  3325 154B C9 54		        CMP     #'T'            ; TODO More letters needed if...
  3326 154D D0 28		        BNE     REMOUNT_DONE    ; ...another Txxx protocol exists
  3327
  3328 154F A9 4E		        LDA     #'N'
  3329 1551 8D 00 18		        STA     RBUF+0
  3330 1554 AD 3C 17		        LDA     DOSDR           ; Get drive number
  3331 1557 09 30		        ORA     #'0'            ; Convert, say, 1 to '1'
  3332 1559 8D 01 18		        STA     RBUF+1
  3333 155C A9 3A		        LDA     #':'
  3334 155E 8D 02 18		        STA     RBUF+2
  3335
  3336 1561 A9 2A		        LDA     #CMD_MKDIR
  3337 1563 8D B1 0C		        STA     GENDCB+2
  3338 1566 A9 00		        LDA     #<RBUF          ; TODO Is this needed
  3339 1568 8D B3 0C		        STA     GENDCB+4        ; TODO or is it hardcoded in DO_GENERIC?
  3340 156B A9 18		        LDA     #>RBUF
  3341 156D 8D B4 0C		        STA     GENDCB+5
  3342
  3343 1570 A9 AF		        LDA     #<GENDCB
  3344 1572 A0 0C		        LDY     #>GENDCB
  3345 1574 4C A5 07		        JMP     DOSIOV
  3346
  3347 1577			REMOUNT_DONE:
  3348 1577 60			        RTS
  3349
  3350 				;---------------------------------------
  3351 1578			PREPEND_DRIVE:
  3352 				;---------------------------------------
  3353 				        ; Inject "Nn:" in front of a plain filename
  3354 				        ; before passing it to the FujiNet
  3355 1578 A0 00		        LDY     #$00
  3356 157A A9 4E		        LDA     #'N'
  3357 157C D1 F3		        CMP     (INBUFF),Y  ; Does arg1 already begin with N?
  3358
  3359 157E A0 02		        LDY     #$02
  3360 1580 A9 3A		        LDA     #':'
  3361 1582 D1 F3		        CMP     (INBUFF),Y
  3362 1584 F0 1C		        BEQ     PREPEND_DRIVE_DONE
  3363 1586 88			        DEY
  3364 1587 D1 F3		        CMP     (INBUFF),Y
  3365 1589 F0 17		        BEQ     PREPEND_DRIVE_DONE
  3366
  3367 				        ; Move input buffer pointer back 3 bytes
  3368 158B 38			        SEC
  3369 158C A5 F3		        LDA     INBUFF
  3370 158E E9 03		        SBC     #$03
  3371 1590 85 F3		        STA     INBUFF
  3372 1592 A5 F4		        LDA     INBUFF+1
  3373 1594 E9 00		        SBC     #$00
  3374 1596 85 F4		        STA     INBUFF+1
  3375
  3376 				        ; Inject PRMPT to front of arg1
  3377 1598 A0 03		        LDY     #$03
  3378 159A			PREPEND_DRIVE_LOOP:
  3379 159A B9 CC 15		        LDA     PRMPT,Y
  3380 159D 88			        DEY
  3381 159E 91 F3		        STA     (INBUFF),Y
  3382 15A0 D0 F8		        BNE     PREPEND_DRIVE_LOOP
  3383
  3384 15A2			PREPEND_DRIVE_DONE:
  3385 15A2 A0 01		        LDY     #$01
  3386 15A4 60			        RTS             ; Y = $00 here
  3387
  3388 				;---------------------------------------
  3389 15A5			APPEND_SLASH:
  3390 				;---------------------------------------
  3391 				    ;---------------------------------------
  3392 				    ; Skip if relative path (..)
  3393 				    ;---------------------------------------
  3394 15A5 A0 00		        LDY     #$00
  3395 15A7 A9 2E		        LDA     #'.'
  3396 15A9 D1 F3		        CMP     (INBUFF),Y
  3397 15AB F0 1E		        BEQ     APPEND_SLASH_DONE
  3398
  3399 15AD A0 FF		        LDY     #$FF        ; Iterate thru arg2 until EOF
  3400 15AF			APPEND_SLASH_LOOP:
  3401 15AF C8			        INY                 ; Zero on 1st pass
  3402 15B0 B1 F3		        LDA     (INBUFF),Y
  3403 15B2 C9 9B		        CMP     #EOL
  3404 15B4 D0 F9		        BNE     APPEND_SLASH_LOOP
  3405
  3406 15B6 88			        DEY                 ; Move pointer back one character
  3407 15B7 B1 F3		        LDA     (INBUFF),Y
  3408 15B9 C9 2F		        CMP     #'/'        ; If already slash then skip rest
  3409 15BB F0 0E		        BEQ     APPEND_SLASH_DONE
  3410 15BD C9 3A		        CMP     #':'        ; If a drive, skip
  3411 15BF F0 0A		        BEQ     APPEND_SLASH_DONE
  3412
  3413 15C1 C8			        INY                 ; Else inject '/' + EOL
  3414 15C2 A9 2F		        LDA     #'/'
  3415 15C4 91 F3		        STA     (INBUFF),Y
  3416 15C6 C8			        INY
  3417 15C7 A9 9B		        LDA     #EOL
  3418 15C9 91 F3		        STA     (INBUFF),Y
  3419
  3420 15CB			APPEND_SLASH_DONE:
  3421 15CB 60			        RTS
  3422
  3423 15CC			PRMPT:
  3424 15CC 9B 4E 20 3A		        .BYTE   EOL,'N :'
  3425
  3426 				;;; End CP ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  3427 				;;; Variables
  3428
  3429 15D0			        .ENUM   CMD_IDX
  3430 				        ;---------------
  3431 = 0000			                NCD                 ;  0
  3432 = 0001			                COPY                ;  1
  3433 = 0002			                DIR                 ;  2
  3434 = 0003			                DEL                 ;  3
  3435 = 0004			                LOAD                ;  4
  3436 = 0005			                LOCK                ;  5
  3437 = 0006			                LOGIN               ;  6
  3438 = 0007			                MKDIR               ;  7
  3439 = 0008			                NPWD                ;  8
  3440 = 0009			                NTRANS              ;  9
  3441 = 000A			                RENAME              ; 10
  3442 = 000B			                RMDIR               ; 11
  3443 = 000C			                SUBMIT              ; 12
  3444 = 000D			                TYPE                ; 13
  3445 = 000E			                UNLOCK              ; 14
  3446 = 000F			                AUTORUN             ; 15
  3447 = 0010			                CAR                 ; 16
  3448 = 0011			                CLS                 ; 17
  3449 = 0012			                COLD                ; 18
  3450 = 0013			                HELP                ; 19
  3451 = 0014			                NOBASIC             ; 20
  3452 = 0015			                NOSCREEN            ; 21
  3453 = 0016			                PRINT               ; 22
  3454 = 0017			                REENTER             ; 23
  3455 = 0018			                REM                 ; 24
  3456 = 0019			                RUN                 ; 25
  3457 = 001A			                SCREEN              ; 26
  3458 = 001B			                WARM                ; 27
  3459 = 001C			                XEP                 ; 28
  3460 = 001D			                DRIVE_CHG           ; 
  3461 				        .ENDE
  3462
  3463 15D0			CMD_DCOMND:
  3464 15D0 2C			        .BYTE   CMD_CD              ;  0 NCD
  3465 15D1 A1			        .BYTE   CMD_COPY            ;  1 COPY
  3466 15D2 02			        .BYTE   CMD_DIR             ;  2 DIR
  3467 15D3 21			        .BYTE   CMD_DEL             ;  3 DEL
  3468 15D4 28			        .BYTE   CMD_LOAD            ;  4 LOAD
  3469 15D5 FD			        .BYTE   CMD_LOGIN           ;  5 LOAD
  3470 15D6 23			        .BYTE   CMD_LOCK            ;  6 LOCK
  3471 15D7 2A			        .BYTE   CMD_MKDIR           ;  7 MKDIR
  3472 15D8 30			        .BYTE   CMD_NPWD            ;  8 NPWD
  3473 15D9 54			        .BYTE   CMD_NTRANS          ;  9 NTRANS
  3474 15DA 20			        .BYTE   CMD_RENAME          ; 10 RENAME
  3475 15DB 2B			        .BYTE   CMD_RMDIR           ; 11 RMDIR
  3476 15DC F0			        .BYTE   CMD_SUBMIT          ; 12 SUBMIT
  3477 15DD F0			        .BYTE   CMD_TYPE            ; 13 TYPE
  3478 15DE 24			        .BYTE   CMD_UNLOCK          ; 14 UNLOCK
  3479 15DF F0			        .BYTE   CMD_AUTORUN         ; 15 AUTORUN
  3480 15E0 F0			        .BYTE   CMD_CAR             ; 16 CAR
  3481 15E1 F0			        .BYTE   CMD_CLS             ; 17 CLS
  3482 15E2 F0			        .BYTE   CMD_COLD            ; 18 COLD
  3483 15E3 F0			        .BYTE   CMD_HELP            ; 19 HELP
  3484 15E4 F0			        .BYTE   CMD_NOBASIC         ; 20 NOBASIC
  3485 15E5 F0			        .BYTE   CMD_NOSCREEN        ; 21 NOSCREEN
  3486 15E6 F0			        .BYTE   CMD_PRINT           ; 22 PRINT
  3487 15E7 F0			        .BYTE   CMD_REENTER         ; 23 REENTER
  3488 15E8 F0			        .BYTE   CMD_REM             ; 24 REM
  3489 15E9 F0			        .BYTE   CMD_RUN             ; 25 RUN
  3490 15EA F0			        .BYTE   CMD_SCREEN          ; 26 SCREEN
  3491 15EB F0			        .BYTE   CMD_WARM            ; 27 WARM
  3492 15EC F0			        .BYTE   CMD_XEP             ; 28 XEP
  3493 15ED 01			        .BYTE   CMD_DRIVE_CHG       ; 29
  3494
  3495 15EE			COMMAND:
  3496 15EE 4E 43 C4		        .CB     "NCD"               ;  0 NCD
  3497 15F1 00			        .BYTE   CMD_IDX.NCD            
  3498
  3499 15F2 43 4F 50 D9		        .CB     "COPY"              ;  1 COPY
  3500 15F6 01			        .BYTE   CMD_IDX.COPY           
  3501
  3502 15F7 44 49 D2		        .CB     "DIR"               ;  2 DIR
  3503 15FA 02			        .BYTE   CMD_IDX.DIR              
  3504
  3505 15FB 44 45 CC		        .CB     "DEL"               ;  3 DEL
  3506 15FE 03			        .BYTE   CMD_IDX.DEL              
  3507
  3508 15FF 4C 4F 41 C4		        .CB     "LOAD"              ;  4 LOAD
  3509 1603 04			        .BYTE   CMD_IDX.LOAD             
  3510
  3511 1604 4C 4F 43 CB		        .CB     "LOCK"              ;  5 LOCK
  3512 1608 05			        .BYTE   CMD_IDX.LOCK             
  3513
  3514 1609 4C 4F 47 49 CE	        .CB     "LOGIN"             ;  6 LOGIN
  3515 160E 06			        .BYTE   CMD_IDX.LOGIN              
  3516 				                                        
  3517 160F 4D 4B 44 49 D2	        .CB     "MKDIR"             ;  7 MKDIR
  3518 1614 07			        .BYTE   CMD_IDX.MKDIR           
  3519
  3520 1615 4E 50 57 C4		        .CB     "NPWD"              ;  8 NPWD
  3521 1619 08			        .BYTE   CMD_IDX.NPWD             
  3522
  3523 161A 4E 54 52 41 4E D3	        .CB     "NTRANS"            ;  9 NTRANS
  3524 1620 09			        .BYTE   CMD_IDX.NTRANS            
  3525 				                                        
  3526 1621 52 45 4E 41 4D C5	        .CB     "RENAME"            ; 10 RENAME
  3527 1627 0A			        .BYTE   CMD_IDX.RENAME          
  3528 				                                        
  3529 1628 52 4D 44 49 D2	        .CB     "RMDIR"             ; 11 RMDIR
  3530 162D 0B			        .BYTE   CMD_IDX.RMDIR           
  3531 				                                        
  3532 162E 53 55 42 4D 49 D4	        .CB     "SUBMIT"            ; 12 SUBMIT
  3533 1634 0C			        .BYTE   CMD_IDX.SUBMIT             
  3534 				                                        
  3535 1635 54 59 50 C5		        .CB     "TYPE"              ; 13 SUBMIT
  3536 1639 0D			        .BYTE   CMD_IDX.TYPE              
  3537 				                                        
  3538 163A 55 4E 4C 4F 43 CB	        .CB     "UNLOCK"            ; 14 UNLOCK
  3539 1640 0E			        .BYTE   CMD_IDX.UNLOCK            
  3540 				                                        
  3541 1641 41 55 54 4F 52 55 +         .CB     "AUTORUN"           ; 28 AUTORUN
  3542 1648 0F			        .BYTE   CMD_IDX.AUTORUN
  3543
  3544 1649 43 41 D2		        .CB     "CAR"               ; 15 CAR
  3545 164C 10			        .BYTE   CMD_IDX.CAR             
  3546 				                                        
  3547 164D 43 4C D3		        .CB     "CLS"               ; 16 CLS
  3548 1650 11			        .BYTE   CMD_IDX.CLS           
  3549
  3550 1651 43 4F 4C C4		        .CB     "COLD"              ; 17 COLD
  3551 1655 12			        .BYTE   CMD_IDX.COLD              
  3552
  3553 1656 48 45 4C D0		        .CB     "HELP"              ; 18 HELP
  3554 165A 13			        .BYTE   CMD_IDX.HELP               
  3555 				                                       
  3556 165B 4E 4F 42 41 53 49 +         .CB     "NOBASIC"           ; 19 NOBASIC
  3557 1662 14			        .BYTE   CMD_IDX.NOBASIC           
  3558 				                                          
  3559 1663 40 4E 4F 53 43 52 +         .CB     "@NOSCREEN"         ; 20 @NOSCREEN
  3560 166C 15			        .BYTE   CMD_IDX.NOSCREEN         
  3561 				                                        
  3562 166D 50 52 49 4E D4	        .CB     "PRINT"             ; 21 PRINT
  3563 1672 16			        .BYTE   CMD_IDX.PRINT           
  3564 				                                        
  3565 1673 52 45 45 4E 54 45 +         .CB     "REENTER"           ; 22 REENTER
  3566 167A 17			        .BYTE   CMD_IDX.REENTER         
  3567 				                                        
  3568 167B 52 45 CD		        .CB     "REM"               ; 23 REM
  3569 167E 18			        .BYTE   CMD_IDX.REM             
  3570 				                                        
  3571 167F 52 55 CE		        .CB     "RUN"               ; 24 RUN
  3572 1682 19			        .BYTE   CMD_IDX.RUN             
  3573 				                                        
  3574 1683 40 53 43 52 45 45 +         .CB     "@SCREEN"           ; 25 @SCREEN
  3575 168A 1A			        .BYTE   CMD_IDX.SCREEN          
  3576 				                                        
  3577 168B 57 41 52 CD		        .CB     "WARM"              ; 26 WARM
  3578 168F 1B			        .BYTE   CMD_IDX.WARM            
  3579 				                                        
  3580 1690 58 45 D0		        .CB     "XEP"               ; 27 XEP
  3581 1693 1C			        .BYTE   CMD_IDX.XEP            
  3582 				                                        
  3583 				; Aliases
  3584 1694 43 C4		        .CB     "CD"                ; CD = NCD
  3585 1696 00			        .BYTE   CMD_IDX.NCD           
  3586
  3587 1697 43 57 C4		        .CB     "CWD"               ; CWD = NCD
  3588 169A 00			        .BYTE   CMD_IDX.NCD           
  3589
  3590 169B 45 52 41 53 C5	        .CB     "ERASE"             ; ERASE = DEL
  3591 16A0 03			        .BYTE   CMD_IDX.DEL           
  3592
  3593 16A1 45 52 C1		        .CB     "ERA"               ; ERA = DEL
  3594 16A4 03			        .BYTE   CMD_IDX.DEL           
  3595
  3596 16A5 D8			        .CB     "X"                 ; X = LOAD
  3597 16A6 04			        .BYTE   CMD_IDX.LOAD
  3598
  3599 16A7 50 57 C4		        .CB     "PWD"               ; PWD = NPWD
  3600 16AA 08			        .BYTE   CMD_IDX.NPWD             
  3601
  3602 16AB 52 45 C5		        .CB     "REE"               ; R = REENTER
  3603 16AE 17			        .BYTE   CMD_IDX.REENTER             
  3604
  3605 16AF 52 45 CE		        .CB     "REN"               ; REN = RENAME
  3606 16B2 0A			        .BYTE   CMD_IDX.RENAME
  3607
  3608 16B3 53 4F 55 52 43 C5	        .CB     "SOURCE"            ; SOURCE = SUBMIT
  3609 16B9 0C			        .BYTE   CMD_IDX.SUBMIT
  3610
  3611 16BA C0			        .CB     "@"                 ; @ = SUBMIT
  3612 16BB 0C			        .BYTE   CMD_IDX.SUBMIT
  3613
  3614 16BC A3			        .CB     "#"                 ; # = REM
  3615 16BD 18			        .BYTE   CMD_IDX.REM
  3616
  3617 16BE A7			        .CB     "'"                 ; ' = REM
  3618 16BF 18			        .BYTE   CMD_IDX.REM
  3619
  3620 				        ; Drive Change intentionally omitted
  3621
  3622 = 00D1			COMMAND_SIZE = * - COMMAND - 1
  3623 16C0 FF			        .BYTE   $FF
  3624
  3625 16C1			CMD_TAB_L:
  3626 16C1 4D			        .BYTE   <(DO_GENERIC-1)     ;  0 NCD
  3627 16C2 BA			        .BYTE   <(DO_COPY-1)        ;  1 COPY
  3628 16C3 C0			        .BYTE   <(DO_DIR-1)         ;  2 DIR
  3629 16C4 4D			        .BYTE   <(DO_GENERIC-1)     ;  3 DEL
  3630 16C5 AA			        .BYTE   <(DO_LOAD-1)        ;  4 LOAD
  3631 16C6 45			        .BYTE   <(DO_LOCK-1)        ;  5 LOCK
  3632 16C7 4B			        .BYTE   <(DO_LOGIN-1)       ;  6 LOGIN
  3633 16C8 4D			        .BYTE   <(DO_GENERIC-1)     ;  7 MKDIR
  3634 16C9 7C			        .BYTE   <(DO_NPWD-1)        ;  8 NPWD
  3635 16CA BF			        .BYTE   <(DO_NTRANS-1)      ;  9 NTRANS
  3636 16CB 4D			        .BYTE   <(DO_GENERIC-1)     ; 10 RENAME
  3637 16CC 4D			        .BYTE   <(DO_GENERIC-1)     ; 11 RMDIR
  3638 16CD 11			        .BYTE   <(DO_SUBMIT-1)      ; 12 SUBMIT
  3639 16CE 96			        .BYTE   <(DO_TYPE-1)        ; 13 TYPE
  3640 16CF 34			        .BYTE   <(DO_UNLOCK-1)      ; 14 UNLOCK
  3641 16D0 42			        .BYTE   <(DO_AUTORUN-1)     ; 15 AUTORUN
  3642 16D1 3A			        .BYTE   <(DO_CAR-1)         ; 16 CAR
  3643 16D2 63			        .BYTE   <(DO_CLS-1)         ; 17 CLS
  3644 16D3 6C			        .BYTE   <(DO_COLD-1)        ; 18 COLD
  3645 16D4 6F			        .BYTE   <(DO_HELP-1)        ; 19 HELP
  3646 16D5 1D			        .BYTE   <(DO_NOBASIC-1)     ; 20 NOBASIC
  3647 16D6 5E			        .BYTE   <(DO_NOSCREEN-1)    ; 21 NOSCREEN
  3648 16D7 6A			        .BYTE   <(DO_PRINT-1)       ; 22 PRINT
  3649 16D8 78			        .BYTE   <(DO_REENTER-1)     ; 23 REENTER
  3650 16D9 C2			        .BYTE   <(DO_REM-1)         ; 24 REM
  3651 16DA C3			        .BYTE   <(DO_RUN-1)         ; 25 RUN
  3652 16DB 64			        .BYTE   <(DO_SCREEN-1)      ; 26 SCREEN
  3653 16DC 11			        .BYTE   <(DO_WARM-1)        ; 27 WARM
  3654 16DD 14			        .BYTE   <(DO_XEP-1)         ; 28 WARM
  3655 16DE 0C			        .BYTE   <(DO_DRIVE_CHG-1)   ; 29
  3656
  3657 16DF			CMD_TAB_H:
  3658 16DF 0C			        .BYTE   >(DO_GENERIC-1)     ;  0 NCD
  3659 16E0 0C			        .BYTE   >(DO_COPY-1)        ;  1 COPY
  3660 16E1 0C			        .BYTE   >(DO_DIR-1)         ;  2 DIR
  3661 16E2 0C			        .BYTE   >(DO_GENERIC-1)     ;  3 DEL
  3662 16E3 0D			        .BYTE   >(DO_LOAD-1)        ;  4 LOAD
  3663 16E4 10			        .BYTE   >(DO_LOCK-1)        ;  5 LOCK
  3664 16E5 10			        .BYTE   >(DO_LOGIN-1)       ;  6 LOGIN
  3665 16E6 0C			        .BYTE   >(DO_GENERIC-1)     ;  7 MKDIR
  3666 16E7 10			        .BYTE   >(DO_NPWD-1)        ;  8 NPWD
  3667 16E8 10			        .BYTE   >(DO_NTRANS-1)      ;  9 NTRANS
  3668 16E9 0C			        .BYTE   >(DO_GENERIC-1)     ; 10 RENAME
  3669 16EA 0C			        .BYTE   >(DO_GENERIC-1)     ; 11 RMDIR
  3670 16EB 12			        .BYTE   >(DO_SUBMIT-1)      ; 12 SUBMIT
  3671 16EC 12			        .BYTE   >(DO_TYPE-1)        ; 13 TYPE
  3672 16ED 13			        .BYTE   >(DO_UNLOCK-1)      ; 14 UNLOCK
  3673 16EE 11			        .BYTE   >(DO_AUTORUN-1)     ; 15 AUTORUN
  3674 16EF 13			        .BYTE   >(DO_CAR-1)         ; 16 CAR
  3675 16F0 13			        .BYTE   >(DO_CLS-1)         ; 17 CLS
  3676 16F1 13			        .BYTE   >(DO_COLD-1)        ; 18 COLD
  3677 16F2 13			        .BYTE   >(DO_HELP-1)        ; 19 HELP
  3678 16F3 14			        .BYTE   >(DO_NOBASIC-1)     ; 20 NOBASIC
  3679 16F4 14			        .BYTE   >(DO_NOSCREEN-1)    ; 21 NOSCREEN
  3680 16F5 14			        .BYTE   >(DO_PRINT-1)       ; 22 PRINT
  3681 16F6 14			        .BYTE   >(DO_REENTER-1)     ; 23 REENTER
  3682 16F7 14			        .BYTE   >(DO_REM-1)         ; 24 REM
  3683 16F8 14			        .BYTE   >(DO_RUN-1)         ; 25 RUN
  3684 16F9 14			        .BYTE   >(DO_SCREEN-1)      ; 26 SCREEN
  3685 16FA 15			        .BYTE   >(DO_WARM-1)        ; 27 WARM
  3686 16FB 15			        .BYTE   >(DO_XEP-1)         ; 28 WARM
  3687 16FC 0C			        .BYTE   >(DO_DRIVE_CHG-1)   ; 29
  3688
  3689 				        ; DEVHDL TABLE FOR N:
  3690
  3691 16FD BD 07		CIOHND  .WORD   OPEN-1
  3692 16FF 0B 08		        .WORD   CLOSE-1
  3693 1701 2C 08		        .WORD   GET-1
  3694 1703 8D 08		        .WORD   PUT-1
  3695 1705 ED 08		        .WORD   STATUS-1
  3696 1707 53 09		        .WORD   SPEC-1
  3697
  3698 				       ; BANNERS
  3699
  3700 1709 23 46 55 4A 49 4E + BREADY  .BYTE   '#FUJINET NOS v0.4.1-alpha',EOL
  3701 1723 23 46 55 4A 49 4E + BERROR  .BYTE   '#FUJINET ERROR',EOL
  3702
  3703 				        ; MESSAGES
  3704
  3705 1732 4E 23 3F 9B		CDERR   .BYTE   'N#?',EOL
  3706
  3707 				        ; STRING CONSTANTS
  3708
  3709 1736			MISSING_FILE_STR:
  3710 1736 46 49 4C 45 3F 9B	        .BYTE   'FILE?',EOL
  3711
  3712 				        ; VARIABLES
  3713
  3714 173C 01			DOSDR       .BYTE   $01     ; DOS DRIVE
  3715 173D 01			CMD         .BYTE   $01
  3716 173E 01			CMDPRV      .BYTE   $01
  3717 173F 01			ECHO_FLG    .BYTE   $01     ; Echo batch cmds (1=enabled,0=disabled)
  3718 1740 00			AUTORUN_FLG .BYTE   $00     ; Checked at DOS entry. Runs only on first pass
  3719
  3720 1741 01			TRIP    .BYTE   $01         ; INTR FLAG
  3721 1742 00 00 00 00		RLEN    :MAXDEV .BYTE $00   ; RCV LEN
  3722 1746 00 00 00 00		ROFF    :MAXDEV .BYTE $00   ; RCV OFFSET
  3723 174A 00 00 00 00		TOFF    :MAXDEV .BYTE $00   ; TRX OFFSET
  3724 174E 01			INQDS   .BYTE   $01         ; DSTATS INQ
  3725
  3726 174F 00 00 00 00		DVS2    :MAXDEV .BYTE $00   ; DVSTAT+2 SAVE
  3727 1753 00 00 00 00		DVS3    :MAXDEV .BYTE $00   ; DVSTAT+3 SAVE
  3728
  3729 				       ; BUFFERS (PAGE ALIGNED)
  3730 1757 00 00 00 00 00 00 +         .ALIGN  $100, $00
  3731 1800			BOOTEND:
  3732
  3733 1800 00 00 00 00 00 00 + RBUF:   :$80 .BYTE $00      ; 128 bytes
  3734 1880 00 00 00 00 00 00 + TBUF:   :$80 .BYTE $00      ; 128 bytes
  3735
  3736 				; Binary loader working variables
  3737 = 1800			BAL     = RBUF
  3738 = 1801			BAH     = RBUF+1    ;
  3739 = 1880			STL     = TBUF      ; Payload Start address
  3740 = 1881			STH     = TBUF+1
  3741 = 1882			ENL     = TBUF+2    ; Payload End address
  3742 = 1883			ENH     = TBUF+3
  3743 = 1884			BLL     = TBUF+4    ; Payload Buffer Length
  3744 = 1885			BLH     = TBUF+5
  3745 = 1886			HEADL   = TBUF+6    ; Bytes read from existing cache
  3746 = 1887			HEADH   = TBUF+7
  3747 = 1888			BODYL   = TBUF+8    ; Total bytes read in contiguous 512-byte blocks
  3748 = 1889			BODYH   = TBUF+9
  3749 = 188A			TAILL   = TBUF+10   ; Bytes read from last cache
  3750 = 188B			TAILH   = TBUF+11
  3751 = 188C			BODYSZL = TBUF+12   ; # Bytes to read at a time in Body
  3752 = 188D			BODYSZH = TBUF+13
  3753 = 188E			STL2    = TBUF+14   ; Payload Start address (working var)
  3754 = 188F			STH2    = TBUF+15
  3755 = 1890			BIN_1ST = TBUF+16   ; Flag for binary loader signature (FF -> 1st pass)
  3756 = 1891			AUTORUN_QUERY_FLG = TBUF+17   ; Flag for printing contents of autorun appkey
  3757
  3758 = 1900			PGEND   = *
  3759
  3760 				; =================================================================
  3761 				; VTOC and Directory
  3762 				;
  3763
  3764 				; $10 is the added ATR-header
  3765 1900 00 00 00 00 00 00 + :($B390-*+HDR-$10) DTA $00
  3766 BA80			VTOCSTA:
  3767 BA80 02 BD 02		    DTA $02,$BD,$02
  3768 BA83			VTOCEND:
  3769
  3770 				; Fill the remaining bytes of the VTOC sector
  3771 BA83 00 00 00 00 00 00 +     :($80+VTOCSTA-VTOCEND) DTA $00
  3772
  3773 BB00			DIRSTA:
  3774 BB00 60 C3 02 04 00 30 +     DTA $60,$C3,$02,$04,$00,C"0**********"
  3775 BB10 60 C3 02 04 00 31 +     DTA $60,$C3,$02,$04,$00,C"1 FujiNet  "
  3776 BB20 60 C3 02 04 00 32 +     DTA $60,$C3,$02,$04,$00,C"2 Network  "
  3777 BB30 60 C3 02 04 00 33 +     DTA $60,$C3,$02,$04,$00,C"3   OS     "
  3778 BB40 60 C3 02 04 00 34 +     DTA $60,$C3,$02,$04,$00,C"4          "
  3779 BB50 60 C3 02 04 00 35 +     DTA $60,$C3,$02,$04,$00,C"5 v0.4.1   "
  3780 BB60 60 C3 02 04 00 36 +     DTA $60,$C3,$02,$04,$00,C"6  alpha   "
  3781 BB70 60 C3 02 04 00 37 +     DTA $60,$C3,$02,$04,$00,C"7**********"
  3782 BB80 C0			    DTA $C0
  3783 BB81			DIREND:
  3784
  3785 				; Fill the remaining sectors of the directory
  3786 BB81 00 00 00 00 00 00 +     :($400+DIRSTA-DIREND) DTA $00
  3787
  3788 				; Sectors behind directory
  3789 BF00 00 00 00 00 00 00 +     :($80*352) DTA $00
  3790
  3791 				       END
