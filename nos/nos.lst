mads 2.1.5
Source: nos.s
     1 				        
     2 				        ;; Compile with MADS
     3
     4 				        ;; Authors: Thomas Cherryhomes
     5 				        ;;   <thom.cherryhomes@gmail.com>
     6
     7 				        ;; Michael Sternberg
     8 				        ;;   <mhsternberg@gmail.com>
     9
    10
    11 				        ;; Optimizations being done by djaybee!
    12 				        ;; Thank you so much!
    13
    14
    15 = 000A			DOSVEC  =   $0A         ; DOSVEC
    16 = 000C			DOSINI  =   $0C         ; DOSINI
    17
    18 				        ;; CURRENT IOCB IN ZERO PAGE
    19 = 0020			ZIOCB   =   $20         ; ZP IOCB
    20 = 0020			ZICHID  =   ZIOCB       ; ID
    21 = 0021			ZICDNO  =   ZIOCB+1     ; UNIT #
    22 = 0022			ZICCOM  =   ZIOCB+2     ; COMMAND
    23 = 0023			ZICSTA  =   ZIOCB+3     ; STATUS
    24 = 0024			ZICBAL  =   ZIOCB+4     ; BUF ADR LOW
    25 = 0025			ZICBAH  =   ZIOCB+5     ; BUF ADR HIGH
    26 = 0026			ZICPTL  =   ZIOCB+6     ; PUT ADDR L
    27 = 0027			ZICPTH  =   ZIOCB+7     ; PUT ADDR H
    28 = 0028			ZICBLL  =   ZIOCB+8     ; BUF LEN LOW
    29 = 0029			ZICBLH  =   ZIOCB+9     ; BUF LEN HIGH
    30 = 002A			ZICAX1  =   ZIOCB+10    ; AUX 1
    31 = 002B			ZICAX2  =   ZIOCB+11    ; AUX 2
    32 = 002C			ZICAX3  =   ZIOCB+12    ; AUX 3
    33 = 002D			ZICAX4  =   ZIOCB+13    ; AUX 4
    34 = 002E			ZICAX5  =   ZIOCB+14    ; AUX 5
    35 = 002F			ZICAX6  =   ZIOCB+15    ; AUX 6
    36
    37 = 0052			LMARGN  =   $52         ; Left margin
    38 = 00D4			FR0     =   $D4         ; Floating Point register 0 (used during Hex->ASCII conversion)
    39 = 00F2			CIX     =   $F2         ; Inbuff cursor
    40 = 00F3			INBUFF  =   $F3         ; Ptr to input buffer ($0580)
    41 = 0040			MAX_APPKEY_LEN = $40    ; Used with appkey files
    42
    43 				;---------------------------------------
    44 				; INTERRUPT VECTORS
    45 				; AND OTHER PAGE 2 VARS
    46 				;---------------------------------------
    47
    48 = 0202			VPRCED  =   $0202       ; PROCEED VCTR
    49 = 02C4			COLOR0  =   $02C4       ; 
    50 = 02C5			COLOR1  =   $02C5       ; 
    51 = 02C6			COLOR2  =   $02C6       ; MODEF BKG C
    52 = 02C7			COLOR3  =   $02C7       ; 
    53 = 02C8			COLOR4  =   $02C8       ; 
    54 = 02E0			RUNAD   =   $02E0       ; RUN ADDRESS
    55 = 02E2			INITAD  =   $02E2       ; INIT ADDRESS
    56 = 02E7			MEMLO   =   $02E7       ; MEM LO
    57 = 02EA			DVSTAT  =   $02EA       ; 4 BYTE STATS
    58
    59 				;---------------------------------------
    60 				; PAGE 3
    61 				; DEVICE CONTROL BLOCK (DCB)
    62 				;---------------------------------------
    63
    64 = 0300			DCB     =   $0300       ; BASE
    65 = 0300			DDEVIC  =   DCB         ; DEVICE #
    66 = 0301			DUNIT   =   DCB+1       ; UNIT #
    67 = 0302			DCOMND  =   DCB+2       ; COMMAND
    68 = 0303			DSTATS  =   DCB+3       ; STATUS/DIR
    69 = 0304			DBUFL   =   DCB+4       ; BUF ADR L
    70 = 0305			DBUFH   =   DCB+5       ; BUF ADR H
    71 = 0306			DTIMLO  =   DCB+6       ; TIMEOUT (S)
    72 = 0307			DRSVD   =   DCB+7       ; NOT USED
    73 = 0308			DBYTL   =   DCB+8       ; BUF LEN L
    74 = 0309			DBYTH   =   DCB+9       ; BUF LEN H
    75 = 030A			DAUXL   =   DCB+10      ; AUX BYTE L
    76 = 030B			DAUXH   =   DCB+11      ; AUX BYTE H
    77
    78 = 031A			HATABS  =   $031A       ; HANDLER TBL
    79
    80 				;---------------------------------------
    81 				; IOCB'S * 8
    82 				;---------------------------------------
    83
    84 = 0340			IOCB    =   $0340       ; IOCB BASE
    85 = 0340			ICHID   =   IOCB        ; ID
    86 = 0341			ICDNO   =   IOCB+1      ; UNIT #
    87 = 0342			ICCOM   =   IOCB+2      ; COMMAND
    88 = 0343			ICSTA   =   IOCB+3      ; STATUS
    89 = 0344			ICBAL   =   IOCB+4      ; BUF ADR LOW
    90 = 0345			ICBAH   =   IOCB+5      ; BUF ADR HIGH
    91 = 0346			ICPTL   =   IOCB+6      ; PUT ADDR L
    92 = 0347			ICPTH   =   IOCB+7      ; PUT ADDR H
    93 = 0348			ICBLL   =   IOCB+8      ; BUF LEN LOW
    94 = 0349			ICBLH   =   IOCB+9      ; BUF LEN HIGH
    95 = 034A			ICAX1   =   IOCB+10     ; AUX 1
    96 = 034B			ICAX2   =   IOCB+11     ; AUX 2
    97 = 034C			ICAX3   =   IOCB+12     ; AUX 3
    98 = 034D			ICAX4   =   IOCB+13     ; AUX 4
    99 = 034E			ICAX5   =   IOCB+14     ; AUX 5
   100 = 034F			ICAX6   =   IOCB+15     ; AUX 6
   101
   102 = 0054			ROWCRS  =   $0054
   103 = 006A			RAMTOP  =   $006A
   104 = 02BB			SCRFLG  =   $02BB       ; Scroll flag
   105 = 02FC			CH      =   $02FC       ; Hardware code for last key pressed
   106 = 02F2			CH1     =   $02F2       ; Prior keyboard character code
   107 = 03F8			BASICF  =   $03F8
   108 = 0582			LNBUF   =   $0582       ; Line Buffer (128 bytes)
   109 				;LNBUF   =   $1880       ; Line Buffer (128 bytes)
   110
   111 				;---------------------------------------
   112 				; HARDWARE REGISTERS
   113 				;---------------------------------------
   114
   115 = D01F			CONSOL  =   $D01F       ; Console switches
   116 = D301			PORTB   =   $D301       ; On XL/XE, used to enable/disable BASIC
   117 = D302			PACTL   =   $D302       ; PIA CTRL A
   118
   119 				;---------------------------------------
   120 				; MATH PACK VECTORS
   121 				;---------------------------------------
   122 = D8E6			FASC    =   $D8E6       ; Floating point to ASCII
   123 = D9AA			IFP     =   $D9AA       ; Integer to floating point
   124
   125 				;---------------------------------------
   126 				; OS ROM VECTORS
   127 				;---------------------------------------
   128
   129 = E456			CIOV    =   $E456       ; CIO ENTRY
   130 = E459			SIOV    =   $E459       ; SIO ENTRY
   131 = E474			WARMSV  =   $E474       ; Warmstart entry point
   132 = E477			COLDSV  =   $E477       ; Coldstart entry point
   133
   134 				;---------------------------------------
   135 				; CONSTANTS
   136 				;---------------------------------------
   137
   138 = 0005			GETREC  =   $05         ; CIO CMD TO GET RECORD
   139 = 0009			PUTREC  =   $09         ; CIO CMD TO PUT RECORD
   140 = 000B			PUTCHR  =   $0B         ; CIO CMD TO PUT CHAR
   141
   142 = 0071			DEVIDN  =   $71         ; SIO DEVID
   143 = 0040			DSREAD  =   $40         ; FUJI->ATARI
   144 = 0080			DSWRIT  =   $80         ; ATARI->FUJI
   145 = 0004			MAXDEV  =   4           ; # OF N: DEVS
   146 = 0088			EOF     =   $88         ; ERROR 136
   147
   148 = 009B			EOL     =   $9B         ; EOL CHAR
   149 = 000D			CR      =   $0D         ; Carrige Return
   150 = 000A			LF      =   $0A         ; Linefeed
   151
   152 = 0003			OPTION  =   $03
   153 = 001C			ESC_KEY =   $1C         ; Hardware code for ESC
   154 = 0021			SPC_KEY =   $21         ; Hardware code for SPACE
   155
   156 = 0004			OINPUT  =   $04         ; CIO/SIO direction
   157 = 0008			OOUTPUT =   $08         ; CIO/SIO direction
   158 = 00F0			BOGUS   =   $F0         ; Bogus FujiNet SIO command byte
   159
   160 				;ROM_BORDER = $92        ; Border color when program in ROM
   161 = 0006			ROM_BORDER = $06        ; Border color when program in ROM
   162
   163 				; FujiNet SIO command bytes.
   164 = 0001			CMD_DRIVE_CHG       = $01
   165 = 002C			CMD_CD              = $2C
   166 				;CMD_COPY            = $A1
   167 = 0002			CMD_DIR             = $02
   168 = 0021			CMD_DEL             = $21
   169 = 0028			CMD_LOAD            = $28
   170 = 0023			CMD_LOCK            = $23
   171 = 00F0			CMD_LPR             = BOGUS
   172 = 002A			CMD_MKDIR           = $2A
   173 = 0030			CMD_NPWD            = $30
   174 = 0054			CMD_NTRANS          = 'T'
   175 = 00FE			CMD_PASS            = $FE
   176 = 0020			CMD_RENAME          = $20
   177 = 002B			CMD_RMDIR           = $2B
   178 = 00F0			CMD_SAVE            = BOGUS
   179 = 00F0			CMD_SUBMIT          = BOGUS
   180 = 00F0			CMD_TYPE            = BOGUS
   181 = 00FD			CMD_USER            = $FD
   182 = 0024			CMD_UNLOCK          = $24
   183 = 00F0			CMD_CAR             = BOGUS
   184 = 00F0			CMD_CLS             = BOGUS
   185 = 00F0			CMD_COLD            = BOGUS
   186 = 00F0			CMD_HELP            = BOGUS
   187 = 00F0			CMD_BASIC           = BOGUS
   188 = 00F0			CMD_NOSCREEN        = BOGUS
   189 = 00F0			CMD_PRINT           = BOGUS
   190 = 00F0			CMD_REENTER         = BOGUS
   191 = 00F0			CMD_REM             = BOGUS
   192 = 00F0			CMD_RUN             = BOGUS
   193 = 00F0			CMD_SCREEN          = BOGUS
   194 = 00F0			CMD_WARM            = BOGUS
   195 = 00F0			CMD_XEP             = BOGUS
   196 = 00F0			CMD_AUTORUN         = BOGUS
   197
   198 				;;; Macros ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   199
   200 				        .MACRO DCBC
   201 				        .LOCAL
   202 				        LDY     #$0C
   203 				?DCBL   LDA     %%1,Y
   204 				        STA     DCB,Y
   205 				        DEY
   206 				        BPL     ?DCBL
   207 				        .ENDL
   208 				        .ENDM
   209
   210 				; ATR Header
   211 					    ORG	    $06f0
   212 				        OPT     h-
   213 06F0 96 02 80 16 80		    DTA	    $96,$02,$80,$16,$80
   214 06F5 00 00 00 00 00 00 + :11     DTA	    $00
   215
   216 				;;; Initialization ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   217
   218 0700 00			HDR:    .BYTE   $00                 ; BLFAG: Boot flag equals zero (unused)
   219 0701 24			        .BYTE   [BOOTEND-HDR]/128   ; BRCNT: Number of consecutive sectors to read
   220 0702 00 07		        .WORD   HDR                 ; BLDADR: Boot sector load address ($700).
   221 0704 C0 E4		        .WORD   $E4C0               ; BIWTARR: Init addr (addr of RTS in ROM)
   222
   223 0706 4C 09 07			    JMP	    START
   224
   225 0709 A5 0C		START:  LDA     DOSINI
   226 070B 8D 27 07		        STA     RESET+1
   227 070E A5 0D		        LDA     DOSINI+1
   228 0710 8D 28 07		        STA     RESET+2
   229
   230 0713 A9 26		        LDA     #<RESET
   231 0715 85 0C		        STA     DOSINI
   232 0717 A9 07		        LDA     #>RESET
   233 0719 85 0D		        STA     DOSINI+1
   234 071B A9 9D		        LDA     #<DOS       ; Point to DOS & CP below
   235 071D 85 0A		        STA     DOSVEC
   236 071F A9 0B		        LDA     #>DOS
   237 0721 85 0B		        STA     DOSVEC+1
   238
   239 0723 4C 39 07		        JMP     ALTMEML     ; Alter MEMLO
   240
   241 0726 20 FF FF		RESET:  JSR     $FFFF       ; Jump to extant DOSINI
   242
   243 0729 A9 4E		        LDA     #'N'
   244 072B 8D 00 19		        STA     RBUF
   245 072E 20 44 07		        JSR     IHTBS       ; Insert into HATABS
   246
   247 0731 A9 44		        LDA     #'D'
   248 0733 8D 00 19		        STA     RBUF
   249 0736 20 44 07		        JSR     IHTBS       ; Clone N: as D: for compatibility
   250
   251 				;---------------------------------------
   252 				;  Alter MEMLO
   253 				;---------------------------------------
   254 0739			ALTMEML:
   255 0739 A9 00		        LDA     #<PGEND
   256 073B 8D E7 02		        STA     MEMLO
   257 073E A9 1A		        LDA     #>PGEND
   258 0740 8D E8 02		        STA     MEMLO+1
   259
   260 				        ;; Back to DOS
   261
   262 0743 60			        RTS
   263
   264 				;---------------------------------------
   265 				; Insert entry into HATABS
   266 				;---------------------------------------
   267
   268 0744			IHTBS:
   269 0744 A0 00		        LDY     #$00
   270 0746 B9 1A 03		IH1     LDA     HATABS,Y
   271 0749 F0 0C		        BEQ     HFND
   272 074B CD 00 19		        CMP     RBUF        ; RBUF contains 'N' or 'D'
   273 074E F0 07		        BEQ     HFND
   274 0750 C8			        INY
   275 0751 C8			        INY
   276 0752 C8			        INY
   277 0753 C0 21		        CPY     #11*3
   278 0755 90 EF		        BCC     IH1
   279
   280 				        ;; Found a slot
   281
   282 0757			HFND:
   283 0757 AD 00 19		        LDA     RBUF        ; RBUF contains 'N' or 'D'
   284 075A AA			        TAX
   285 075B 99 1A 03		        STA     HATABS,Y
   286 075E A9 46		        LDA     #<CIOHND
   287 0760 99 1B 03		        STA     HATABS+1,Y
   288 0763 A9 18		        LDA     #>CIOHND
   289 0765 99 1C 03		        STA     HATABS+2,Y
   290
   291 0768 E0 44		        CPX     #'D'
   292 076A F0 01		        BEQ     HATABS_CONT
   293 076C 60			        RTS
   294
   295 076D			HATABS_CONT:
   296 				        ;; And we're done with HATABS
   297
   298 				        ;; Query FUJINET
   299
   300 076D 20 24 09		        JSR     STPOLL
   301
   302 				        ;; Output Ready/Error
   303
   304 0770			OBANR:
   305 0770 A2 00		        LDX     #$00        ; IOCB #0
   306 0772 A9 09		        LDA     #PUTREC
   307 0774 9D 42 03		        STA     ICCOM,X
   308 0777 A9 28		        LDA     #$28        ; 40 CHARS Max
   309 0779 9D 48 03		        STA     ICBLL,X
   310 077C 8A			        TXA
   311 077D 9D 49 03		        STA     ICBLH,X
   312 0780 AD 03 03		        LDA     DSTATS      ; Check DSTATS
   313 0783 10 06		        BPL     OBRDY       ; < 128 = Ready
   314
   315 				        ;; Status returned error.
   316
   317 0785			OBERR:
   318 0785 A9 6C		        LDA     #<BERROR
   319 0787 A0 18		        LDY     #>BERROR
   320 0789 50 04		        BVC     OBCIO
   321
   322 				        ;; Status returned ready.
   323
   324 078B			OBRDY:
   325 078B A9 52		        LDA     #<BREADY
   326 078D A0 18		        LDY     #>BREADY
   327
   328 078F			OBCIO:
   329 078F 9D 44 03		        STA     ICBAL,X
   330 0792 98			        TYA
   331 0793 9D 45 03		        STA     ICBAH,X
   332
   333 0796 20 56 E4		        JSR     CIOV
   334
   335 				        ;; Vector in proceed interrupt
   336
   337 0799			SPRCED:
   338 0799 A9 6B		        LDA     #<PRCVEC
   339 079B 8D 02 02		        STA     VPRCED
   340 079E A9 0A		        LDA     #>PRCVEC
   341 07A0 8D 03 02		        STA     VPRCED+1
   342
   343 				        ;; And we are done, back to DOS.
   344 07A3 18			        CLC
   345 07A4 60			        RTS
   346
   347 				;;; End Initialization Code ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   348
   349 				; Copy command's template DCB struct to OS's DCB struct (12 bytes)
   350 07A5			DOSIOV:
   351 07A5 8D AE 07		        STA     DODCBL+1
   352 07A8 8C AF 07		        STY     DODCBL+2
   353 07AB A0 0C		        LDY     #$0C
   354 07AD B9 FF FF		DODCBL  LDA     $FFFF,Y
   355 07B0 99 00 03		        STA     DCB,Y
   356 07B3 88			        DEY
   357 07B4 10 F7		        BPL     DODCBL
   358
   359 07B6			SIOVDST:
   360 07B6 20 59 E4		        JSR     SIOV
   361 07B9 AC 03 03		        LDY     DSTATS
   362 07BC 98			        TYA
   363 07BD 60			        RTS
   364
   365
   366 				;---------------------------------------
   367 				; CIO OPEN
   368 				;---------------------------------------
   369
   370 07BE			OPEN:
   371 				        ;; Prepare DCB
   372
   373 07BE 20 5C 0A		        JSR     GDIDX       ; Get Device ID in X (0-3)
   374 07C1 A5 21		        LDA     ZICDNO      ; IOCB UNIT # (1-4)
   375 07C3 8D 01 08		        STA     OPNDCB+1    ; Store in DUNIT
   376 07C6 A5 24		        LDA     ZICBAL      ; Get filename buffer
   377 07C8 8D 04 08		        STA     OPNDCB+4    ; stuff in DBUF
   378 07CB A5 25		        LDA     ZICBAH      ; ...
   379 07CD 8D 05 08		        STA     OPNDCB+5    ; ...
   380 07D0 A5 2A		        LDA     ZICAX1      ; Get desired AUX1/AUX2
   381 07D2 8D 0A 08		        STA     OPNDCB+10   ; Save them, and store in DAUX1/DAUX2
   382 07D5 A5 2B		        LDA     ZICAX2      ; ...
   383 07D7 8D 0B 08		        STA     OPNDCB+11   ; ...
   384
   385 				        ;;  Copy DCB template to DCB
   386
   387 07DA A9 00		        LDA     #<OPNDCB
   388 07DC A0 08		        LDY     #>OPNDCB
   389
   390 				        ;;  Send to #FujiNet
   391
   392 07DE 20 A5 07		        JSR     DOSIOV
   393
   394 				        ;; Return DSTATS, unless 144, then get extended error
   395
   396 07E1			OPCERR:
   397 07E1 C0 90		        CPY     #$90        ; ERR 144?
   398 07E3 D0 06		        BNE     OPDONE      ; NOPE. RETURN DSTATS
   399
   400 				        ;; 144 - get extended error
   401
   402 07E5 20 24 09		        JSR     STPOLL      ; POLL FOR STATUS
   403 07E8 AC ED 02		        LDY     DVSTAT+3
   404
   405 				       ; RESET BUFFER LENGTH + OFFSET
   406
   407 07EB			OPDONE:
   408 07EB A9 01		        LDA     #$01
   409 07ED 8D 8A 18		        STA     TRIP
   410 07F0 20 5C 0A		        JSR     GDIDX
   411 07F3 A9 00		        LDA     #$00
   412 07F5 9D 8B 18		        STA     RLEN,X
   413 07F8 9D 93 18		        STA     TOFF,X
   414 07FB 9D 8F 18		        STA     ROFF,X
   415 07FE 98			        TYA
   416 07FF 60			        RTS                ; AY = ERROR
   417
   418 0800			OPNDCB:
   419 0800 71			        .BYTE   DEVIDN  ; DDEVIC
   420 0801 FF			        .BYTE   $FF     ; DUNIT
   421 0802 4F			        .BYTE   'O'     ; DCOMND
   422 0803 80			        .BYTE   $80     ; DSTATS
   423 0804 FF			        .BYTE   $FF     ; DBUFL
   424 0805 FF			        .BYTE   $FF     ; DBUFH
   425 0806 0F			        .BYTE   $0F     ; DTIMLO
   426 0807 00			        .BYTE   $00     ; DRESVD
   427 0808 00			        .BYTE   $00     ; DBYTL
   428 0809 01			        .BYTE   $01     ; DBYTH
   429 080A FF			        .BYTE   $FF     ; DAUX1
   430 080B FF			        .BYTE   $FF     ; DAUX2
   431
   432 				; End CIO OPEN
   433 				;---------------------------------------
   434
   435 				;---------------------------------------
   436 				; CIO CLOSE 
   437 				;---------------------------------------
   438
   439 080C			CLOSE:
   440 080C 20 53 0A		        JSR     DIPRCD      ; Disable Interrupts
   441 080F 20 5C 0A		        JSR     GDIDX
   442 0812 20 AF 08		        JSR     PFLUSH      ; Do a Put Flush if needed.
   443
   444 0815 A5 21		        LDA     ZICDNO      ; IOCB Unit #
   445 0817 8D 22 08		        STA     CLODCB+1    ; to DCB...
   446
   447 081A A9 21		        LDA     #<CLODCB
   448 081C A0 08		        LDY     #>CLODCB
   449
   450 081E 4C A5 07		        JMP     DOSIOV
   451
   452 0821 71			CLODCB .BYTE    DEVIDN      ; DDEVIC
   453 0822 FF			       .BYTE    $FF         ; DUNIT
   454 0823 43			       .BYTE    'C'         ; DCOMND
   455 0824 00			       .BYTE    $00         ; DSTATS
   456 0825 00			       .BYTE    $00         ; DBUFL
   457 0826 00			       .BYTE    $00         ; DBUFH
   458 0827 0F			       .BYTE    $0F         ; DTIMLO
   459 0828 00			       .BYTE    $00         ; DRESVD
   460 0829 00			       .BYTE    $00         ; DBYTL
   461 082A 00			       .BYTE    $00         ; DBYTH
   462 082B 00			       .BYTE    $00         ; DAUX1
   463 082C 00			       .BYTE    $00         ; DAUX2
   464
   465 				; End CIO CLOSE
   466 				;---------------------------------------
   467
   468 				;---------------------------------------
   469 				; CIO GET
   470 				;---------------------------------------
   471
   472 082D 20 5C 0A		GET:    JSR     GDIDX       ; IOCB UNIT #-1 into X
   473 0830 BD 8B 18		        LDA     RLEN,X      ; Get # of RX chars waiting
   474 0833 D0 2B		        BNE     GETDISC     ; LEN > 0?
   475
   476 				        ;; If RX buffer is empty, get # of chars waiting...
   477
   478 0835 20 24 09		        JSR     STPOLL      ; Status Poll
   479 0838 20 5C 0A		        JSR     GDIDX       ; IOCB UNIT -1 into X (because Poll trashes X)
   480 083B AD EA 02		        LDA     DVSTAT      ; # of bytes waiting (0-127)
   481 083E 9D 8B 18		        STA     RLEN,X      ; Store in RX Len
   482 0841 F0 22		        BEQ     RETEOF
   483
   484 0843 A5 21		GETDO:  LDA     ZICDNO      ; Get IOCB UNIT #
   485 0845 8D 83 08		        STA     GETDCB+1    ; Store into DUNIT
   486 0848 AD EA 02		        LDA     DVSTAT      ; # of bytes waiting
   487 084B 8D 8A 08		        STA     GETDCB+8    ; Store into DBYT...
   488 084E 8D 8C 08		        STA     GETDCB+10   ; and DAUX1...
   489
   490 0851 A9 82		        LDA     #<GETDCB
   491 0853 A0 08		        LDY     #>GETDCB
   492
   493 0855 20 A5 07		        JSR     DOSIOV
   494
   495 				        ;; Clear the Receive buffer offset.
   496
   497 0858 20 5C 0A		        JSR     GDIDX       ; IOCB UNIT #-1 into X
   498 085B A9 00		        LDA     #$00
   499 085D 9D 8F 18		        STA     ROFF,X
   500
   501 0860			GETDISC:
   502 				        ;LDA     DVSTAT+2    ; Did we disconnect?
   503 0860 AD ED 02		        LDA     DVSTAT+3    ; Did we disconnect?
   504 0863 D0 04		        BNE     GETUPDP     ; nope, update the buffer cursor.
   505
   506 				        ;; We disconnected, emit an EOF.
   507
   508 0865			RETEOF:
   509 0865 A0 88		        LDY     #EOF
   510 0867 98			        TYA
   511 0868 60			        RTS                 ; buh-bye.
   512
   513 0869			GETUPDP:
   514 0869 DE 8B 18		        DEC     RLEN,X      ; Decrement RX length.
   515 086C BC 8F 18		        LDY     ROFF,X      ; Get RX offset cursor.
   516
   517 				        ;; Return Next char from appropriate RX buffer.
   518
   519 086F B9 00 19		        LDA     RBUF,Y
   520
   521 				        ;; Increment RX offset
   522
   523 0872 FE 8F 18		GX:     INC     ROFF,X      ; Increment RX offset.
   524 0875 A8			        TAY                 ; stuff returned val into Y temporarily.
   525
   526 				        ;; If requested RX buffer is empty, reset TRIP.
   527
   528 0876 BD 8B 18		        LDA     RLEN,X
   529 0879 D0 03		        BNE     GETDONE
   530 087B 8D 8A 18		        STA     TRIP
   531
   532 				        ;; Return byte back to CIO.
   533
   534 087E			GETDONE:
   535 087E 98			        TYA                 ; Move returned val back.
   536 087F A0 01		        LDY     #$01        ; SUCCESS
   537
   538 0881 60			        RTS                 ; DONE...
   539
   540 0882			GETDCB:
   541 0882 71			       .BYTE    DEVIDN      ; DDEVIC
   542 0883 FF			       .BYTE    $FF         ; DUNIT
   543 0884 52			       .BYTE    'R'         ; DCOMND
   544 0885 40			       .BYTE    $40         ; DSTATS
   545 0886 00			       .BYTE    <RBUF       ; DBUFL
   546 0887 19			       .BYTE    >RBUF       ; DBUFH
   547 0888 0F			       .BYTE    $0F         ; DTIMLO
   548 0889 00			       .BYTE    $00         ; DRESVD
   549 088A FF			       .BYTE    $FF         ; DBYTL
   550 088B 00			       .BYTE    $00         ; DBYTH
   551 088C FF			       .BYTE    $FF         ; DAUX1
   552 088D 00			       .BYTE    $00         ; DAUX2
   553
   554 				; End CIO GET
   555 				;---------------------------------------
   556
   557 				;---------------------------------------
   558 				; CIO PUT
   559 				;---------------------------------------
   560
   561 088E			PUT:    ;; Add to TX buffer.
   562
   563 088E 20 5C 0A		        JSR     GDIDX
   564 0891 BC 93 18		        LDY     TOFF,X      ; GET TX cursor.
   565 0894 99 80 19		        STA     TBUF,Y      ; TX Buffer
   566
   567 0897 FE 93 18		POFF:   INC     TOFF,X      ; Increment TX cursor
   568 089A A0 01		        LDY     #$01        ; SUCCESSFUL
   569
   570 				        ;; Do a PUT FLUSH if EOL or buffer full.
   571
   572 089C C9 9B		        CMP     #EOL        ; EOL?
   573 089E F0 0B		        BEQ     FLUSH       ; FLUSH BUFFER
   574 08A0 20 5C 0A		        JSR     GDIDX       ; GET OFFSET
   575 08A3 BD 93 18		        LDA     TOFF,X
   576 08A6 C9 7F		        CMP     #$7F        ; LEN = $FF?
   577 08A8 F0 01		        BEQ     FLUSH       ; FLUSH BUFFER
   578 08AA 60			        RTS
   579
   580 				       ; FLUSH BUFFER, IF ASKED.
   581
   582 08AB 20 AF 08		FLUSH:  JSR     PFLUSH      ; FLUSH BUFFER
   583 08AE 60			        RTS
   584
   585 08AF			PFLUSH:
   586
   587 				       ; CHECK CONNECTION, AND EOF
   588 				       ; IF DISCONNECTED.
   589
   590 08AF 20 24 09		        JSR     STPOLL      ; GET STATUS
   591 08B2 AD ED 02		        LDA     DVSTAT+3
   592 08B5 F0 AE		        BEQ     RETEOF
   593
   594 08B7 20 5C 0A		PF1:    JSR     GDIDX       ; GET DEV X
   595 08BA BD 93 18		        LDA     TOFF,X
   596 08BD D0 03		        BNE     PF2
   597 08BF 4C DF 08		        JMP     PDONE
   598
   599 				       ; FILL OUT DCB FOR PUT FLUSH
   600
   601 08C2 A5 21		PF2:    LDA     ZICDNO
   602 08C4 8D E3 08		        STA     PUTDCB+1
   603
   604 				       ; FINISH DCB AND DO SIOV
   605
   606 08C7 BD 93 18		TBX:    LDA     TOFF,X
   607 08CA 8D EA 08		        STA     PUTDCB+8
   608 08CD 8D EC 08		        STA     PUTDCB+10
   609
   610 08D0 A9 E2		        LDA     #<PUTDCB
   611 08D2 A0 08		        LDY     #>PUTDCB
   612 08D4 20 A5 07		        JSR     DOSIOV
   613
   614 				        ; CLEAR THE OFFSET CURSOR
   615 				        ; AND LENGTH
   616
   617 08D7 20 5C 0A		        JSR     GDIDX
   618 08DA A9 00		        LDA     #$00
   619 08DC 9D 93 18		        STA     TOFF,X
   620
   621 08DF A0 01		PDONE:  LDY     #$01
   622 08E1 60			        RTS
   623
   624 08E2 71			PUTDCB .BYTE    DEVIDN      ; DDEVIC
   625 08E3 FF			       .BYTE    $FF         ; DUNIT
   626 08E4 57			       .BYTE    'W'         ; DCOMND
   627 08E5 80			       .BYTE    $80         ; DSTATS
   628 08E6 80			       .BYTE    $80         ; DBUFL
   629 08E7 19			       .BYTE    >TBUF       ; DBUFH
   630 08E8 0F			       .BYTE    $0F         ; DTIMLO
   631 08E9 00			       .BYTE    $00         ; DRESVD
   632 08EA FF			       .BYTE    $FF         ; DBYTL
   633 08EB 00			       .BYTE    $00         ; DBYTH
   634 08EC FF			       .BYTE    $FF         ; DAUX1
   635 08ED 00			       .BYTE    $00         ; DAUX2
   636
   637 				; End CIO PUT
   638 				;---------------------------------------
   639
   640 				;---------------------------------------
   641 				; CIO STATUS 
   642 				;---------------------------------------
   643
   644 08EE 20 4A 0A		STATUS: JSR     ENPRCD      ; ENABLE PRCD
   645 08F1 20 5C 0A		        JSR     GDIDX       ; GET DEVICE#
   646 08F4 BD 8B 18		        LDA     RLEN,X      ; GET RLEN
   647 08F7 D0 05		        BNE     STSLEN      ; RLEN > 0?
   648 08F9 AD 8A 18		        LDA     TRIP
   649 08FC D0 15		        BNE     STTRI1      ; TRIP = 1?
   650
   651 				        ; NO TRIP, RETURN SAVED LEN
   652
   653 08FE BD 8B 18		STSLEN: LDA     RLEN,X      ; GET RLEN
   654 0901 8D EA 02		        STA     DVSTAT      ; RET IN DVSTAT
   655
   656 				        ; If you don't need to preserve Y then use it instead of A
   657 0904 A9 00		        LDA     #$00
   658 0906 8D EB 02		        STA     DVSTAT+1
   659
   660 				        ; and INY here
   661 0909 A9 01		        LDA     #$01
   662 090B 8D EC 02		        STA     DVSTAT+2
   663 090E 8D ED 02		        STA     DVSTAT+3
   664
   665 0911 D0 0B		        BNE     STDONE
   666
   667 				        ; DO POLL AND UPDATE RCV LEN
   668
   669 0913 20 24 09		STTRI1: JSR     STPOLL      ; POLL FOR ST
   670 0916 9D 8B 18		        STA     RLEN,X
   671
   672 				        ; UPDATE TRIP FLAG
   673
   674 0919 D0 03		STTRIU: BNE     STDONE
   675 091B 8D 8A 18		        STA     TRIP        ; RLEN = 0
   676
   677 				        ; RETURN CONNECTED? FLAG.
   678
   679 091E AD EC 02		STDONE: LDA     DVSTAT+2
   680 0921 A0 01		        LDY     #$01
   681 0923 60			        RTS
   682
   683 				       ; ASK FUJINET FOR STATUS
   684
   685 0924			STPOLL:
   686 0924 A5 21		        LDA     ZICDNO      ; IOCB #
   687 0926 8D 49 09		        STA     STADCB+1
   688
   689 0929 A9 48		        LDA     #<STADCB
   690 092B A0 09		        LDY     #>STADCB
   691
   692 092D 20 A5 07		        JSR     DOSIOV
   693
   694 				        ;; > 127 bytes? make it 127 bytes.
   695
   696 0930 AD EB 02		        LDA     DVSTAT+1
   697 0933 D0 07		        BNE     STADJ
   698 0935 AD EA 02		        LDA     DVSTAT
   699 0938 30 02		        BMI     STADJ
   700 093A 50 08		        BVC     STP2        ; <= 127 bytes...
   701
   702 093C A9 7F		STADJ   LDA     #$7F
   703 093E 8D EA 02		        STA     DVSTAT
   704 				        
   705 0941 8D EB 02		        STA     DVSTAT+1
   706
   707 				       ; A = CONNECTION STATUS
   708
   709 0944 AD EC 02		STP2:   LDA     DVSTAT+2
   710 0947 60			        RTS
   711
   712 0948 71			STADCB: .BYTE   DEVIDN      ; DDEVIC
   713 0949 FF			        .BYTE   $FF         ; DUNIT
   714 094A 53			        .BYTE   'S'         ; DCOMND
   715 094B 40			        .BYTE   $40         ; DSTATS
   716 094C EA			        .BYTE   <DVSTAT     ; DBUFL
   717 094D 02			        .BYTE   >DVSTAT     ; DBUFH
   718 094E 0F			        .BYTE   $0F         ; DTIMLO
   719 094F 00			        .BYTE   $00         ; DRESVD
   720 0950 04			        .BYTE   $04         ; DBYTL
   721 0951 00			        .BYTE   $00         ; DBYTH
   722 0952 00			        .BYTE   $00         ; DAUX1
   723 0953 00			        .BYTE   $00         ; DAUX2
   724
   725 				; End CIO STATUS
   726 				;---------------------------------------
   727
   728 				;---------------------------------------
   729 				; CIO SPECIAL
   730 				;---------------------------------------
   731
   732 0954			SPEC:   ; HANDLE LOCAL COMMANDS.
   733
   734 0954 A5 22		        LDA     ZICCOM
   735 0956 C9 0F		        CMP     #$0F        ; 15 = FLUSH
   736 0958 D0 06		        BNE     S1          ; NO.
   737 095A 20 AF 08		        JSR     PFLUSH      ; DO FLUSH
   738 095D A0 01		        LDY     #$01        ; SUCCESS
   739 095F 60			        RTS
   740
   741 0960 C9 28		S1:     CMP     #40         ; 40 = LOAD AND EXECUTE
   742 0962 F0 03		        BEQ     S2          ; YES.
   743 0964 4C 68 09		        JMP     S3          ; NO. SKIP OVER spec40
   744
   745 0967 60			S2:     RTS
   746 				       ; HANDLE SIO COMMANDS.
   747 				       ; GET DSTATS FOR COMMAND
   748 0968			S3:
   749 0968 A5 21		        LDA     ZICDNO
   750 096A 8D B0 09		        STA     SPEDCB+1
   751 096D A5 22		        LDA     ZICCOM
   752 096F 8D B9 09		        STA     SPEDCB+10
   753
   754 0972 A9 AF		        LDA     #<SPEDCB
   755 0974 A0 09		        LDY     #>SPEDCB
   756 0976 20 A5 07		        JSR     DOSIOV
   757
   758 0979 30 0A		        BMI     :DSERR
   759
   760 				       ; WE GOT A DSTATS INQUIRY
   761 				       ; IF $FF, THE COMMAND IS
   762 				       ; INVALID
   763
   764 097B AD 97 18		DSOK:   LDA     INQDS
   765 097E C9 FF		        CMP     #$FF        ; INVALID?
   766 0980 D0 04		        BNE     DSGO        ; DO THE CMD
   767 0982 A0 92		        LDY     #$92        ; UNIMP CMD
   768 0984 98			        TYA
   769 0985			DSERR:
   770 0985 60			        RTS
   771
   772 				        ;; Do the special, since we want to pass in all the IOCB
   773 				        ;; Parameters to the DCB, This is being done long-hand.
   774
   775 0986 A5 22		DSGO:   LDA     ZICCOM
   776 0988 48			        PHA
   777 0989 A9 00		        LDA     #$00
   778 098B 48			        PHA
   779 098C AD 97 18		        LDA     INQDS
   780 098F 48			        PHA
   781 0990 A9 01		        LDA     #$01
   782 0992 48			        PHA
   783 0993 A5 24		        LDA     ZICBAL
   784 0995 48			        PHA
   785 0996 A5 2A		        LDA     ZICAX1
   786 0998 48			        PHA
   787 0999 A5 25		        LDA     ZICBAH
   788 099B 48			        PHA
   789 099C A5 2B		        LDA     ZICAX2
   790 099E 48			        PHA
   791 099F A0 03		        LDY     #$03
   792 09A1			DSGOL:
   793 09A1 68			        PLA
   794 09A2 99 08 03		        STA     DBYTL,Y
   795 09A5 68			        PLA
   796 09A6 99 02 03		        STA     DCOMND,Y
   797 09A9 88			        DEY
   798 09AA 10 F5		        BPL     DSGOL
   799
   800 09AC 4C B6 07		        JMP     SIOVDST
   801
   802 				        ;; Return DSTATS in Y and A
   803
   804 09AF 71			SPEDCB  .BYTE   DEVIDN      ; DDEVIC
   805 09B0 FF			        .BYTE   $FF         ; DUNIT
   806 09B1 FF			        .BYTE   $FF         ; DCOMND ; inq
   807 09B2 40			        .BYTE   $40         ; DSTATS
   808 09B3 97			        .BYTE   <INQDS      ; DBUFL
   809 09B4 18			        .BYTE   >INQDS      ; DBUFH
   810 09B5 0F			        .BYTE   $0F         ; DTIMLO
   811 09B6 00			        .BYTE   $00         ; DRESVD
   812 09B7 01			        .BYTE   $01         ; DBYTL
   813 09B8 00			        .BYTE   $00         ; DBYTH
   814 09B9 FF			        .BYTE   $FF         ; DAUX1
   815 09BA FF			        .BYTE   $FF         ; DAUX2
   816
   817 				; End CIO SPECIAL
   818 				;---------------------------------------
   819
   820 				;#######################################
   821 				;#                                     #
   822 				;#             CIO Functions           # 
   823 				;#                                     #
   824 				;#######################################
   825
   826
   827 				;---------------------------------------
   828 09BB			CIOCLOSE:
   829 				;---------------------------------------
   830 				    ; X must contain IOCB offset ($10,$20,..)
   831 09BB A9 0C		        LDA     #$0C            ; Close #1 first
   832 09BD 9D 42 03		        STA     ICCOM,X
   833 09C0 4C 56 E4		        JMP     CIOV
   834
   835 				;---------------------------------------
   836 09C3			CIOOPEN:
   837 				;---------------------------------------
   838 				    ; Input: 
   839 				    ; X = IOCB offset ($10,$20,..)
   840 				    ; Y = data direction (4=inp,8=out,12=i/o)
   841 				    ; INBUFF contains ICBAL/H
   842 09C3 A9 03		        LDA     #$03            ; 3 = CIO 'OPEN FILE'
   843 09C5 9D 42 03		        STA     ICCOM,X
   844 09C8 A5 F3		        LDA     INBUFF          ; Pointer to filename
   845 09CA 9D 44 03		        STA     ICBAL,X
   846 09CD A5 F4		        LDA     INBUFF+1        ; Pointer to filename
   847 09CF 9D 45 03		        STA     ICBAH,X
   848 09D2 98			        TYA
   849 09D3 9D 4A 03		        STA     ICAX1,X         ; Data direction
   850 09D6 A9 00		        LDA     #$00
   851 09D8 9D 4B 03		        STA     ICAX2,X         ; Unused
   852 09DB 20 56 E4		        JSR     CIOV            ; Call CIO
   853 09DE 20 A4 0A		        JSR     PRINT_ERROR
   854
   855 09E1			CIOOPEN_DONE:
   856 09E1 60			        RTS
   857
   858 				;---------------------------------------
   859 09E2			CIOSTATUS:
   860 				;---------------------------------------
   861 09E2 A9 0D		        LDA     #$0D
   862 09E4 9D 42 03		        STA     ICCOM,X
   863 09E7 20 56 E4		        JSR     CIOV
   864 09EA 10 03		        BPL     CIOSTATUS_DONE
   865 09EC 20 A4 0A		        JSR     PRINT_ERROR
   866
   867 09EF			CIOSTATUS_DONE:
   868 09EF 60			        RTS
   869 				        
   870
   871 				;---------------------------------------
   872 09F0			CIOGET:
   873 				;---------------------------------------
   874 				    ; Input: 
   875 				    ; X = IOCB offset ($10,$20,..)
   876 				    ; A = ICBLL
   877 				    ; Y = ICBLH
   878 				    ; INBUFF contains ICBAL/H
   879 09F0 48			        PHA                 ; Stash Buffer length Lo
   880 09F1 A9 07		        LDA     #$07        ; GET BYTES command
   881 09F3 9D 42 03		        STA     ICCOM,X
   882 09F6 A5 F3		        LDA     INBUFF      ; Get buffer addr from pointer
   883 09F8 9D 44 03		        STA     ICBAL,X
   884 09FB A5 F4		        LDA     INBUFF+1
   885 09FD 9D 45 03		        STA     ICBAH,X
   886 0A00 68			        PLA                 ; Retrieve Buffer length Lo
   887 0A01 9D 48 03		        STA     ICBLL,X
   888 0A04 98			        TYA                 ; Get Buffer length Hi
   889 0A05 9D 49 03		        STA     ICBLH,X
   890 0A08 20 56 E4		        JSR     CIOV        ; Bon voyage
   891 0A0B 10 00		        BPL     CIOGET_DONE
   892 				;        JMP     PRINT_ERROR
   893
   894 0A0D			CIOGET_DONE:
   895 0A0D 60			        RTS
   896
   897 				;---------------------------------------
   898 0A0E			CIOPUT:
   899 				;---------------------------------------
   900 				    ; Input: 
   901 				    ; X = IOCB offset ($10,$20,..)
   902 				    ; A = ICBLL
   903 				    ; Y = ICBLH
   904 				    ; INBUFF contains ICBAL/H
   905 0A0E 48			        PHA                 ; Stash Buffer length Lo
   906 0A0F A9 0B		        LDA     #$0B        ; PUT BYTES command
   907 0A11 9D 42 03		        STA     ICCOM,X
   908 0A14 A5 F3		        LDA     INBUFF      ; Get buffer addr from pointer
   909 0A16 9D 44 03		        STA     ICBAL,X
   910 0A19 A5 F4		        LDA     INBUFF+1
   911 0A1B 9D 45 03		        STA     ICBAH,X
   912 0A1E 68			        PLA                 ; Retrieve Buffer length Lo
   913 0A1F 9D 48 03		        STA     ICBLL,X
   914 0A22 98			        TYA                 ; Get Buffer length Hi
   915 0A23 9D 49 03		        STA     ICBLH,X
   916 0A26 20 56 E4		        JSR     CIOV        ; Bon voyage
   917 0A29 10 00		        BPL     CIOPUT_DONE
   918 				;        JMP     PRINT_ERROR
   919
   920 0A2B			CIOPUT_DONE:
   921 0A2B 60			        RTS
   922
   923 				;---------------------------------------
   924 0A2C			CIOGETREC:
   925 				;---------------------------------------
   926 				    ; Input: 
   927 				    ; X = IOCB offset ($10,$20,..)
   928 				    ; A = ICBLL
   929 				    ; Y = ICBLH
   930 				    ; INBUFF contains ICBAL/H
   931 0A2C 48			        PHA                 ; Stash Buffer length Lo
   932 0A2D A9 05		        LDA     #$05        ; GET RECORD command
   933 0A2F 9D 42 03		        STA     ICCOM,X
   934 0A32 A5 F3		        LDA     INBUFF      ; Get buffer addr from pointer
   935 0A34 9D 44 03		        STA     ICBAL,X
   936 0A37 A5 F4		        LDA     INBUFF+1
   937 0A39 9D 45 03		        STA     ICBAH,X
   938 0A3C 68			        PLA                 ; Retrieve Buffer length Lo
   939 0A3D 9D 48 03		        STA     ICBLL,X
   940 0A40 98			        TYA                 ; Get Buffer length Hi
   941 0A41 9D 49 03		        STA     ICBLH,X
   942
   943 0A44 20 56 E4		        JSR     CIOV        ; Bon voyage
   944 0A47 10 00		        BPL     CIOGETREC_DONE
   945 				;        JMP     PRINT_ERROR
   946
   947 0A49			CIOGETREC_DONE:
   948 0A49 60			        RTS
   949
   950 				;#######################################
   951 				;#                                     #
   952 				;#          Utility Functions          #
   953 				;#                                     #
   954 				;#######################################
   955 				    ; ENABLE PROCEED INTERRUPT
   956
   957 0A4A AD 02 D3		ENPRCD: LDA     PACTL
   958 0A4D 09 01		        ORA     #$01        ; ENABLE BIT 0
   959 0A4F 8D 02 D3		        STA     PACTL
   960 0A52 60			        RTS
   961
   962 				   ; DISABLE PROCEED INTERRUPT
   963
   964 0A53 AD 02 D3		DIPRCD: LDA     PACTL
   965 0A56 29 FE		        AND     #$FE        ; DISABLE BIT0
   966 0A58 8D 02 D3		        STA     PACTL
   967 0A5B 60			        RTS
   968
   969 				   ; GET ZIOCB DEVNO - 1 INTO X
   970
   971 0A5C A6 21		GDIDX:  LDX     ZICDNO      ; IOCB UNIT #
   972 0A5E CA			        DEX                 ; - 1
   973 0A5F 60			        RTS
   974
   975 				    ; Convert char in A from upper-case to lower-case
   976 0A60			TOUPPER:
   977 0A60 C9 61		        CMP     #'a'        ; SKip if < 'a'
   978 0A62 90 06		        BCC     @+
   979 0A64 C9 7B		        CMP     #'z'+1      ; Skip if > 'z'
   980 0A66 B0 02		        BCS     @+
   981 0A68 29 5F		        AND     #$5F        ; Disable high-bit and convert to lower
   982 0A6A 60			 @:     RTS
   983
   984 				;---------------------------------------
   985 				; Proceed Vector
   986 				;---------------------------------------
   987
   988 0A6B A9 01		PRCVEC: LDA     #$01
   989 0A6D 8D 8A 18		        STA     TRIP
   990 0A70 68			        PLA
   991 0A71 40			        RTI
   992
   993 				; End Proceed Vector
   994 				;---------------------------------------
   995
   996 				;---------------------------------------
   997 				; Reset LNBUF
   998 				;---------------------------------------
   999 				; Normally this routine is at $DA51
  1000 				; But some programs will bank-switch
  1001 				; that portion of ROM to RAM
  1002 				;---------------------------------------
  1003
  1004 0A72 A9 05		LDBUFA: LDA     #$05
  1005 0A74 85 F4		        STA     INBUFF+1
  1006 0A76 A9 82		        LDA     #$82        ; Normally $80. 2 for headroom
  1007 0A78 85 F3		        STA     INBUFF
  1008 0A7A 60			        RTS
  1009
  1010 				; End Reset LNBUF
  1011 				;---------------------------------------
  1012
  1013 				;---------------------------------------
  1014 				; Skip spaces
  1015 				;---------------------------------------
  1016 				; Normally this routine is at $DBA1
  1017 				; But some programs will bank-switch
  1018 				; that portion of ROM to RAM
  1019 				;---------------------------------------
  1020
  1021 0A7B A4 F2		SKPSPC: LDY     CIX
  1022 0A7D A9 20		        LDA     #$20
  1023 0A7F D1 F3		@:      CMP     (INBUFF),Y
  1024 0A81 D0 03		        BNE     @+
  1025 0A83 C8			        INY
  1026 0A84 D0 F9		        BNE     @-
  1027 0A86 84 F2		@:      STY     CIX
  1028 0A88 60			        RTS
  1029
  1030 				; End SKPSPC
  1031 				;---------------------------------------
  1032
  1033 				;---------------------------------------
  1034 				; Print EOL-terminated string
  1035 				; A: String Buffer Lo
  1036 				; Y: String Buffer Hi
  1037 				;---------------------------------------
  1038 0A89			PRINT_STRING:
  1039
  1040 0A89 A2 00		        LDX     #$00
  1041 				    ;---------------------------------------
  1042 				    ; String Buffer
  1043 				    ;---------------------------------------
  1044 0A8B 9D 44 03		        STA     ICBAL,X
  1045 0A8E 98			        TYA
  1046 0A8F 9D 45 03		        STA     ICBAH,X
  1047
  1048 				    ;---------------------------------------
  1049 				    ; String Length
  1050 				    ;---------------------------------------
  1051 0A92 A9 80		        LDA     #$80
  1052 0A94 9D 48 03		        STA     ICBLL,X
  1053 0A97 A9 00		        LDA     #$00
  1054 0A99 9D 49 03		        STA     ICBLH,X
  1055
  1056 				    ;---------------------------------------
  1057 				    ; Call to CIO
  1058 				    ;---------------------------------------
  1059 0A9C A9 09		        LDA     #PUTREC
  1060 0A9E 9D 42 03		        STA     ICCOM,X
  1061 0AA1 4C 56 E4		        JMP     CIOV
  1062
  1063 				;---------------------------------------
  1064 				; Print integer error number from DOSIOV
  1065 				; Y: Return code from DOSIOV
  1066 				;---------------------------------------
  1067 0AA4			PRINT_ERROR:
  1068 0AA4 C0 01		        CPY     #$01        ; Exit if success (1)
  1069 0AA6 F0 4E		        BEQ     PRINT_ERROR_DONE
  1070
  1071 				    ;-----------------------------------
  1072 				    ; If error code = 144, then get
  1073 				    ; extended code from DVSTAT
  1074 				    ;-----------------------------------
  1075 0AA8 C0 90		        CPY     #144
  1076 0AAA D0 0A		        BNE     PRINT_ERROR_NEXT
  1077
  1078 0AAC A9 48		        LDA     #<STADCB
  1079 0AAE A0 09		        LDY     #>STADCB
  1080 0AB0 20 A5 07		        JSR     DOSIOV
  1081 0AB3 AC ED 02		        LDY     DVSTAT+3    ;
  1082
  1083 0AB6			PRINT_ERROR_NEXT:
  1084 				    ;-----------------------------------
  1085 				    ; Convert error code to ASCII
  1086 				    ;-----------------------------------
  1087
  1088 				    ; Call subroutines in ROM to convert error into to ascii
  1089 0AB6 84 D4		        STY     FR0
  1090 0AB8 A9 00		        LDA     #$00
  1091 0ABA 85 D5		        STA     FR0+1
  1092 0ABC 20 AA D9		        JSR     IFP         ; Convert error from int to floating point
  1093 0ABF 20 E6 D8		        JSR     FASC        ; Convert floating point to ASCII
  1094
  1095 				    ;---------------------------------------
  1096 				    ; Find last char in ASCII error (noted by high bit)
  1097 				    ; Unset high bit & append EOL
  1098 				    ;---------------------------------------
  1099 0AC2 A0 FF		        LDY     #$FF        ; Init counter = 0
  1100 0AC4 A2 0E		        LDX     #14
  1101 0AC6 C8			@       INY
  1102 0AC7 E8			        INX
  1103 0AC8 B1 F3		        LDA     (INBUFF),Y
  1104 0ACA 9D F7 0A		    STA     PRINT_ERROR_HELP,X
  1105 0ACD C9 80		        CMP     #$80
  1106 0ACF 90 F5		        BCC     @-
  1107
  1108 0AD1 29 7F		        AND     #$7F        ; Clear high bit
  1109 0AD3 91 F3		        STA     (INBUFF),Y
  1110 0AD5 9D F7 0A		   STA     PRINT_ERROR_HELP,X
  1111 0AD8 C8			        INY
  1112 0AD9 A9 9B		        LDA     #EOL        ; Append EOL
  1113 0ADB 91 F3		        STA     (INBUFF),Y
  1114
  1115 0ADD A5 F3		        LDA     INBUFF
  1116 0ADF A4 F4		        LDY     INBUFF+1
  1117 				;        JMP     PRINT_STRING
  1118
  1119 0AE1 A9 05		        LDA     #$05        ; Point to 
  1120 0AE3 8D 70 0C		        STA     CMDSEP
  1121 0AE6 A9 F7		        LDA     #<PRINT_ERROR_HELP
  1122 0AE8 85 F3		        STA     INBUFF
  1123 0AEA A9 0A		        LDA     #>PRINT_ERROR_HELP
  1124 0AEC 85 F4		        STA     INBUFF+1
  1125 0AEE A9 FF		        LDA     #$FF
  1126 0AF0 8D A0 18		        STA     PRINT_ERR_FLG  ; Set flag that arrived from PRINT_ERROR. This will skip the CLS
  1127 0AF3 4C 7A 14		        JMP     DO_HELP
  1128
  1129 0AF6			PRINT_ERROR_DONE:
  1130 0AF6 60			        RTS
  1131
  1132 0AF7			PRINT_ERROR_HELP:
  1133 0AF7 48 45 4C 50 20 52 +         .BYTE   'HELP REF/ERROR/XXX',EOL
  1134
  1135 				; End PRINTSCR
  1136 				;---------------------------------------
  1137
  1138 0B0A			ASCII2ADDR:
  1139 				    ;---------------------------------------
  1140 				    ; Convert 4-char ASCII string found in LNBUF
  1141 				    ; to bytes found at INBUFF. 
  1142 				    ; Ex: "0F1A" --> $1A, $0F
  1143 				    ;
  1144 				    ; Input:
  1145 				    ; LNBUF contains 4-char ASCII string
  1146 				    ; Y contains offset from LNBUF to start 
  1147 				    ; of ASCII string
  1148 				    ;
  1149 				    ; Output:
  1150 				    ; INBUFF contains 2 bytes
  1151 				    ;---------------------------------------
  1152 				    
  1153 				    ;---------------------------------------
  1154 				    ; ASCII hex char to integer conversion
  1155 				    ; algorithm borrowed from Apple II Monitor
  1156 				    ;---------------------------------------
  1157 0B0A A9 00		        LDA     #$00
  1158 0B0C 85 F3		        STA     INBUFF      ; L
  1159 0B0E 85 F4		        STA     INBUFF+1    ; H
  1160 0B10			NEXTHEX:
  1161 0B10 B9 82 05		        LDA     LNBUF,Y     ; Get character for hex test.
  1162 0B13 49 30		        EOR     #%00110000  ; Maps digits to $0-$9
  1163 0B15 C9 0A		        CMP     #$0A        ; Digit?
  1164 0B17 90 06		        BCC     DIG         ; Yes.
  1165 0B19 69 88		        ADC     #$88        ; Map letter "A"-"F" to $FA-FF.
  1166 0B1B C9 FA		        CMP     #$FA        ; Hex letter?
  1167 0B1D 90 16		        BCC     NOTHEX      ; No, character not hex.
  1168
  1169 0B1F 0A			DIG:    ASL
  1170 0B20 0A			        ASL
  1171 0B21 0A			        ASL
  1172 0B22 0A			        ASL
  1173 0B23 A2 04		        LDX     #$04        ; Shift count.
  1174
  1175 0B25			HEXSHIFT:
  1176 0B25 0A			        ASL
  1177 0B26 26 F3		        ROL     INBUFF      ; Rotate into LSD.
  1178 0B28 26 F4		        ROL     INBUFF+1    ; Rotate into MSD's.
  1179 0B2A CA			        DEX                 ; Done 4 shifts?
  1180 0B2B D0 F8		        BNE     HEXSHIFT    ; No, loop.
  1181 0B2D C8			        INY                 ; Advance text index
  1182 0B2E CC 00 19		        CPY     RBUF        ; Processed 4 characters?
  1183 0B31 D0 DD		        BNE     NEXTHEX     ; No, get next character.
  1184
  1185 0B33 18			        CLC                 ;
  1186 0B34 60			        RTS                 ; INBUFF contains bytes
  1187
  1188 0B35			NOTHEX:
  1189 0B35 A9 3E		        LDA     #<RUN_ERROR_STR
  1190 0B37 A0 0B		        LDY     #>RUN_ERROR_STR
  1191 0B39 20 89 0A		        JSR     PRINT_STRING
  1192 0B3C 38			        SEC
  1193 0B3D 60			        RTS
  1194
  1195 0B3E			RUN_ERROR_STR:
  1196 0B3E 41 44 44 52 3F 20 +         .BYTE   'ADDR? 0000..FFFF',EOL
  1197
  1198 				;---------------------------------------
  1199 0B4F			CHECK_INTERNAL_BASIC:
  1200 				;---------------------------------------
  1201 				    ; Check for internal BASIC found in XL/XEs
  1202 				    ; On return:
  1203 				    ;   CARRY is clear if not found
  1204 				    ;   CARRY is set if found
  1205 				    ;-----------------------------------
  1206 0B4F 18			        CLC 
  1207 0B50 AD F7 FF		        LDA     $FFF7
  1208 0B53 C9 FF		        CMP     #$FF        ; ????
  1209 0B55 F0 19		        BEQ     NOBASIC_ERROR
  1210 0B57 C9 DD		        CMP     #$DD        ; OSA NTSC
  1211 0B59 F0 15		        BEQ     NOBASIC_ERROR
  1212 0B5B C9 F3		        CMP     #$F3        ; OSB NTSC
  1213 0B5D F0 11		        BEQ     NOBASIC_ERROR
  1214 0B5F C9 D6		        CMP     #$D6        ; OSA PAL
  1215 0B61 F0 0D		        BEQ     NOBASIC_ERROR
  1216 0B63 C9 22		        CMP     #$22        ; OSB PAL
  1217 0B65 F0 09		        BEQ     NOBASIC_ERROR
  1218 0B67 C9 0A		        CMP     #$0A        ; OSA 1200XL
  1219 0B69 F0 05		        BEQ     NOBASIC_ERROR
  1220 0B6B C9 0B		        CMP     #$0B        ; OSB 1200XL
  1221 0B6D F0 01		        BEQ     NOBASIC_ERROR
  1222 0B6F 60			        RTS
  1223
  1224 				;---------------------------------------
  1225 0B70			NOBASIC_ERROR:
  1226 				;---------------------------------------
  1227 0B70 A9 79		        LDA     #<NOBASIC_ERROR_STR
  1228 0B72 A0 0B		        LDY     #>NOBASIC_ERROR_STR
  1229 0B74 20 89 0A		        JSR     PRINT_STRING
  1230 0B77 38			        SEC
  1231 0B78 60			        RTS
  1232
  1233 0B79			NOBASIC_ERROR_STR:
  1234 0B79 4E 4F 20 42 55 49 +         .BYTE   'NO BUILT-IN BASIC',EOL
  1235
  1236 				;---------------------------------------
  1237 0B8B			CHECK_IF_ROM:
  1238 				;---------------------------------------
  1239 				    ; Checks if cart space is ROM or RAM
  1240 				    ;-----------------------------------
  1241 				    ; On return 
  1242 				    ; If A000 = ROM then Y = 1
  1243 				    ; If A000 = RAM then Y = 0
  1244 				    ;-----------------------------------
  1245 0B8B A0 01		        LDY     #$01        ; Assume ROM -> Y=1
  1246 0B8D AD 00 A0		        LDA     $A000       ; Try altering A000
  1247 0B90 EE 00 A0		        INC     $A000       ; 
  1248 0B93 CD 00 A0		        CMP     $A000       ; If A <> A000 then RAM
  1249 0B96 F0 04		        BEQ     @+          ; If A = A000 then ROM (Y=FF)
  1250 0B98 88			        DEY                 ; RAM -> Y=0
  1251 0B99 8D 00 A0		        STA     $A000       ; Restore altered RAM
  1252 0B9C 60			@:      RTS
  1253
  1254 				;#######################################
  1255 				;#                                     #
  1256 				;#       COMMAND PROCESSOR (CP)        #
  1257 				;#                                     #
  1258 				;#######################################
  1259
  1260 				;---------------------------------------
  1261 				; DOS Entry point (DOSVEC points here)
  1262 				;---------------------------------------
  1263 0B9D			DOS:
  1264 				        ; Change border if BASIC (or something else) in ROM
  1265 0B9D AD C8 02		        LDA     COLOR4
  1266 0BA0 8D A1 18		        STA     COLOR4_ORIG          ; Preserve border
  1267 0BA3 20 8B 0B		        JSR     CHECK_IF_ROM
  1268 0BA6 98			        TYA                         ; Y = 1 if ROM
  1269 0BA7 F0 05		        BEQ     @+                  ; Skip ahead if A000 is RAM
  1270 0BA9 A9 06		        LDA     #ROM_BORDER         ; Change border
  1271 0BAB 8D C8 02		        STA     COLOR4
  1272
  1273 				        ; Bypass Autorun if OPTION switch held
  1274 0BAE AD 1F D0		@:      LDA     CONSOL
  1275 0BB1 C9 03		        CMP     #OPTION
  1276 0BB3 F0 0D		        BEQ     CPLOOP
  1277
  1278 				        ; Autorun injection
  1279 0BB5 A9 11		        LDA     #CMD_IDX.AUTORUN    ; Check for AUTORUN
  1280 0BB7 CD 89 18		        CMP     AUTORUN_FLG         ; True only on 1st entry
  1281 0BBA F0 06		        BEQ     CPLOOP              ; Skip to Command Processor
  1282 0BBC 8D 89 18		        STA     AUTORUN_FLG         ; Change flag
  1283 0BBF 20 D3 12		        JSR     SUBMIT_AUTORUN      ; Attempt to execute autorun file
  1284
  1285 				       
  1286 0BC2			CPLOOP:
  1287 0BC2 20 C8 0B		        JSR     CP          ; Command Processor
  1288 0BC5 4C C2 0B		        JMP     CPLOOP      ; Keep looping
  1289
  1290 				;---------------------------------------
  1291 				; Main loop
  1292 				;---------------------------------------
  1293 0BC8			CP:
  1294 0BC8 A2 FF		        LDX     #$FF        ; Clear command
  1295 0BCA 8E 86 18		        STX     CMD
  1296 				    ; NOTE Testing for PRINT_ERROR
  1297 0BCD E8			    INX
  1298 0BCE 8E A0 18		    STX     PRINT_ERR_FLG
  1299 				        
  1300
  1301 0BD1 20 E0 0B		        JSR     SHOWPROMPT
  1302 0BD4 20 05 0C		        JSR     GETCMD
  1303 0BD7			AUTORUN_DO:
  1304 0BD7 20 76 0C		        JSR     PARSECMD
  1305 0BDA 30 03		        BMI     CP_DONE     ; Skip DOCMD if CMD == $FF
  1306 0BDC 20 29 0D		        JSR     DOCMD
  1307 0BDF			CP_DONE:
  1308 0BDF 60			        RTS
  1309
  1310 				;---------------------------------------
  1311 				; Show Command Prompt (Nn:)
  1312 				; Leading EOF requires special CIOV call
  1313 				;---------------------------------------
  1314
  1315 				;---------------------------------------
  1316 0BE0			SHOWPROMPT:
  1317 				;---------------------------------------
  1318
  1319 0BE0 AD 85 18		        LDA     DOSDR       ; Get the 1,2,... for N1,N2,...
  1320 0BE3 09 30		        ORA     #'0'        ; Convert, say, 1 to '1'
  1321 0BE5 8D 07 17		        STA     PRMPT+2     ; Store in after EOL and N
  1322
  1323 0BE8 A2 00		        LDX     #$00
  1324 0BEA A9 0B		        LDA     #PUTCHR
  1325 0BEC 9D 42 03		        STA     ICCOM,X
  1326
  1327 0BEF A9 05		        LDA     #<PRMPT
  1328 0BF1 9D 44 03		        STA     ICBAL,X
  1329 0BF4 A9 17		        LDA     #>PRMPT
  1330
  1331 0BF6 9D 45 03		        STA     ICBAH,X
  1332 0BF9 A9 04		        LDA     #4          ; Prompt length = 4
  1333 0BFB 9D 48 03		        STA     ICBLL,X
  1334 0BFE 8A			        TXA                 ; Still zero
  1335 0BFF 9D 49 03		        STA     ICBLH,X
  1336
  1337 0C02 4C 56 E4		        JMP     CIOV
  1338
  1339 				;---------------------------------------
  1340 0C05			GETCMD:
  1341 				;---------------------------------------
  1342 0C05 A2 00		        LDX     #$00
  1343 0C07 A9 05		        LDA     #GETREC
  1344 0C09 9D 42 03		        STA     ICCOM,X
  1345 0C0C A9 82		        LDA     #<LNBUF
  1346 0C0E 9D 44 03		        STA     ICBAL,X
  1347 0C11 A9 05		        LDA     #>LNBUF
  1348 0C13 9D 45 03		        STA     ICBAH,X
  1349 0C16 A9 7F		        LDA     #$7F
  1350 0C18 9D 48 03		        STA     ICBLL,X
  1351 0C1B 20 56 E4		        JSR     CIOV
  1352
  1353 0C1E			GETCMDTEST:
  1354 0C1E A0 00		        LDY     #$00
  1355 0C20 84 F2		        STY     CIX
  1356 0C22 20 72 0A		        JSR     LDBUFA      ; Reset LNBUF to $0580
  1357 0C25 20 7B 0A		        JSR     SKPSPC      ; Advance CIX to next space
  1358
  1359 				    ;---------------------------------------
  1360 				    ; CMDSEP is an sequence of bytes contains
  1361 				    ; indexes to chars following spaces
  1362 				    ; Iterate to clear CMDSEP bytes
  1363 				    ;---------------------------------------
  1364 0C28 98			        TYA                 ; A = 0
  1365 0C29 A2 02		        LDX     #$02        ; for X = 2 to 0 step -1
  1366 0C2B			GETLOOP:
  1367 0C2B 9D 70 0C		        STA     CMDSEP,X
  1368 0C2E CA			        DEX
  1369 0C2F 10 FA		        BPL     GETLOOP     ; next X
  1370
  1371 				    ; Initialize Delimiter to space
  1372 0C31 A9 20		        LDA     #' '
  1373 0C33 8D 75 0C		        STA     DELIM
  1374
  1375 				    ;---------------------------------------
  1376 				    ; Loop until EOL is encountered
  1377 				    ;---------------------------------------
  1378 0C36 E8			        INX                 ; Reset X to 0
  1379 0C37			GETCMD_LOOP:
  1380 0C37 B1 F3		        LDA     (INBUFF),Y
  1381 0C39 C9 9B		        CMP     #EOL        ; Found EOL?
  1382 0C3B F0 32		        BEQ     GETCMD_DONE ; yes. skip
  1383 0C3D CD 75 0C		        CMP     DELIM       ; Found space?
  1384 0C40 F0 03		        BEQ     GETCMD_REPL ; yes. Replace it
  1385 0C42 C8			        INY
  1386 0C43 D0 F2		        BNE     GETCMD_LOOP ; "always" non-zero
  1387
  1388 				    ;---------------------------------------
  1389 				    ; March through the cmd line and note
  1390 				    ; the positions of any args as delimited
  1391 				    ; by spaces or quotes. positions saved
  1392 				    ; in CMDSEP,X
  1393 				    ;---------------------------------------
  1394 0C45			GETCMD_REPL:
  1395 0C45 A9 9B		        LDA     #EOL
  1396 0C47 91 F3		        STA     (INBUFF),Y
  1397 0C49 C8			        INY
  1398 0C4A B1 F3		        LDA     (INBUFF),Y  ; Skip any run of spaces
  1399 0C4C C9 20		        CMP     #' '
  1400 0C4E F0 F5		        BEQ     GETCMD_REPL ; Keep skipping spaces
  1401
  1402 				    ; Here if any run of spaces has ended
  1403 				    ; Are we standing on a double-quote?
  1404 0C50 C9 22		        CMP     #'"'
  1405 0C52 D0 12		        BNE     GETCMD_WR_OFFSET  ; No. Skip ahead
  1406
  1407 				    ; Here if curr char is a double-quote
  1408 0C54 C8			        INY                 ; Advance the command line index
  1409 0C55 A9 22		        LDA     #'"'        ; Is the curr delim a double-quote?
  1410 0C57 CD 75 0C		        CMP     DELIM       ; If not, change delim to double-quote
  1411 0C5A D0 07		        BNE     GETCMD_DQ_DELIM
  1412
  1413 				    ; Here if curr delim is a double-quote
  1414 				    ; Switch delim to space
  1415 0C5C A9 20		        LDA     #' '
  1416 0C5E 8D 75 0C		        STA     DELIM
  1417 0C61 D0 03		        BNE     GETCMD_WR_OFFSET
  1418
  1419 				    ; Here if curr delim is space
  1420 				    ; Switch delim to double-quote
  1421 0C63			GETCMD_DQ_DELIM:
  1422 0C63 8D 75 0C		        STA     DELIM
  1423
  1424 				    ; Note the position for the curr command-line arg
  1425 0C66			GETCMD_WR_OFFSET:
  1426 0C66 98			        TYA
  1427 0C67 9D 70 0C		        STA     CMDSEP,X
  1428 0C6A E8			        INX
  1429 0C6B E0 03		        CPX     #$03
  1430 0C6D 90 C8		        BCC     GETCMD_LOOP ; Continue searching
  1431
  1432 0C6F			GETCMD_DONE:
  1433 0C6F 60			        RTS
  1434
  1435 0C70 FF FF FF FF FF	CMDSEP: .BYTE $FF,$FF,$FF,$FF,$FF
  1436 0C75 20			DELIM:  .BYTE ' '
  1437
  1438 				;---------------------------------------
  1439 0C76			PARSECMD:
  1440 				;---------------------------------------
  1441 				        ;LDA     LNBUF
  1442 0C76 A0 00		        LDY     #$00
  1443 0C78 B1 F3		        LDA     (INBUFF),Y
  1444 0C7A C9 9B		        CMP     #EOL        ; Quit immediately if no cmd
  1445 0C7C F0 0C		        BEQ     PARSECMD_DONE
  1446
  1447 0C7E 20 9F 0C		        JSR     PARSE_INTRINSIC_COMMAND
  1448 0C81 20 D9 0C		        JSR     PARSE_DRIVE_CHANGE
  1449 0C84 20 F0 0C		        JSR     PARSE_EXTRINSIC_COMMAND
  1450 0C87 20 8B 0C		        JSR     PRINT_UNK_CMD
  1451 0C8A			PARSECMD_DONE:
  1452 0C8A 60			        RTS
  1453
  1454 0C8B			PRINT_UNK_CMD:
  1455 0C8B AD 86 18		        LDA     CMD
  1456 0C8E C9 FF		        CMP     #$FF
  1457 0C90 D0 07		        BNE     PRINT_UNK_CMD_DONE
  1458 0C92 A9 9A		        LDA     #<UNK_CMD_ERR
  1459 0C94 A0 0C		        LDY     #>UNK_CMD_ERR
  1460 0C96 20 89 0A		        JSR     PRINT_STRING
  1461 0C99			PRINT_UNK_CMD_DONE:
  1462 0C99 60			        RTS
  1463
  1464 0C9A			UNK_CMD_ERR:
  1465 0C9A 43 4D 44 3F 9B	        .BYTE   'CMD?',EOL
  1466
  1467 				;---------------------------------------
  1468 0C9F			PARSE_INTRINSIC_COMMAND:
  1469 				;---------------------------------------
  1470 0C9F A2 00		        LDX     #$00        ; Initialize X for command code indexing
  1471 0CA1 A0 00		        LDY     #$00
  1472 0CA3 84 F2		        STY     CIX
  1473 0CA5 20 72 0A		        JSR     LDBUFA      ; Set INBUFF to $0580, er make that TBUF
  1474
  1475 0CA8 20 7B 0A		@:      JSR     SKPSPC      ; Skip whitespace
  1476
  1477 0CAB			PARSE_INTRINSIC_NEXT_CHAR:
  1478 0CAB B1 F3		        LDA     (INBUFF),Y
  1479 0CAD 29 5F		        AND     #$5F        ; Disable high-bit and convert to upper
  1480 0CAF 5D 29 17		        EOR     COMMAND,X   ; X initialized to 0 in caller
  1481 0CB2 C8			        INY
  1482 0CB3 0A			        ASL
  1483 0CB4 F0 0B		        BEQ     PARSE_INTRINSIC_CHAR_OK
  1484
  1485 				        ; Skip to next command
  1486
  1487 0CB6			PARSE_INTRINSIC_NEXT_COMMAND:
  1488 0CB6 BD 29 17		        LDA     COMMAND,X
  1489 0CB9 0A			        ASL
  1490 0CBA E8			        INX
  1491 0CBB 90 F9		        BCC     PARSE_INTRINSIC_NEXT_COMMAND
  1492 0CBD A4 F2		        LDY     CIX
  1493 0CBF E0 DB		        CPX     #COMMAND_SIZE
  1494
  1495 0CC1			PARSE_INTRINSIC_CHAR_OK:
  1496 0CC1 E8			        INX
  1497 0CC2 90 E7		        BCC     PARSE_INTRINSIC_NEXT_CHAR
  1498 0CC4 84 F2		        STY     CIX
  1499 0CC6 B1 F3		        LDA     (INBUFF),Y
  1500 0CC8 30 05		        BMI     PARSE_INTRINSIC_RET
  1501
  1502 0CCA 20 7B 0A		        JSR     SKPSPC
  1503
  1504 0CCD			PARSE_INTRINSIC_RET_ERROR:
  1505 0CCD A2 DC		        LDX     #COMMAND_SIZE+1
  1506 0CCF			PARSE_INTRINSIC_RET:
  1507 0CCF BD 29 17		        LDA     COMMAND,X
  1508 0CD2 8D 86 18		        STA     CMD
  1509 0CD5 8D 87 18		        STA     CMDPRV
  1510 0CD8			PARSE_INTRINSIC_DONE:
  1511 0CD8 60			        RTS
  1512
  1513 				; End of PARSE_INTRINSIC_COMMAND
  1514 				;---------------------------------------
  1515
  1516 				;---------------------------------------
  1517 0CD9			PARSE_DRIVE_CHANGE:
  1518 				;---------------------------------------
  1519 0CD9 A2 03		        LDX     #$03        ; Check for EOL in pos 3
  1520 0CDB BD 82 05		        LDA     LNBUF,X
  1521 0CDE C9 9B		        CMP     #EOL
  1522 0CE0 D0 0D		        BNE     PARSE_DRIVE_CHANGE_DONE
  1523 0CE2 CA			        DEX                 ; go back one char
  1524 0CE3 BD 82 05		        LDA     LNBUF,X
  1525 0CE6 C9 3A		        CMP     #':'        ; Check for colon.
  1526 0CE8 D0 05		        BNE     PARSE_DRIVE_CHANGE_DONE
  1527 0CEA A9 1F		        LDA     #CMD_IDX.DRIVE_CHG
  1528 0CEC 8D 86 18		        STA     CMD
  1529 0CEF			PARSE_DRIVE_CHANGE_DONE:
  1530 0CEF 60			        RTS
  1531
  1532 				;---------------------------------------
  1533 0CF0			PARSE_EXTRINSIC_COMMAND:
  1534 				;---------------------------------------
  1535 				    ; Quit if CMD has been found earlier
  1536 0CF0 AE 86 18		        LDX     CMD         ; Undefined CMD = $FF
  1537 0CF3 E8			        INX                 ; now 0 if undefined
  1538 0CF4 D0 F9		        BNE     PARSE_DRIVE_CHANGE_DONE ; Exit if defined CMD
  1539
  1540 				    ; Here if  CMD is undefined.
  1541 				    ; From here we'll assume it's a filename for a executable
  1542 				    ; and attempt to LOAD it. But first append a ".COM"
  1543 				    ; and shift the filename to the right
  1544
  1545 				    ; Find offset to EOL
  1546 0CF6 A0 FF		        LDY     #$FF
  1547 0CF8 C8			@       INY
  1548 0CF9 B1 F3		        LDA     (INBUFF),Y
  1549 0CFB C9 9B		        CMP     #EOL
  1550 0CFD D0 F9		        BNE     @-
  1551
  1552 				    ; Y contains offset to last char & stash it
  1553 0CFF 98			        TYA
  1554 0D00 48			        PHA
  1555
  1556 				    ; Advance Y to allow the 5 chars of '.COM',EOL
  1557 0D01 18			        CLC
  1558 0D02 69 05		        ADC     #$05
  1559 0D04 A8			        TAY
  1560
  1561 				    ; Append .COM, EOL
  1562 0D05 A2 04		        LDX     #$04
  1563 0D07 BD 24 0D		@:      LDA     CMDEXT,X
  1564 0D0A 91 F3		        STA     (INBUFF),Y
  1565 0D0C 88			        DEY
  1566 0D0D CA			        DEX                     ; 
  1567 0D0E 10 F7		        BPL     @-
  1568
  1569 				    ; Shift executable name to the right to allow room for PREPEND_DRIVE
  1570 				    ; Stack contains offset to last char
  1571 				    ; Y is still counting down from where '.COM' was appended.
  1572 0D10 68			        PLA                 ; Get offset to last char of executable
  1573 0D11 AA			        TAX                 ; It'll be used for indexing
  1574 0D12 CA			        DEX                 ; Skip original EOF
  1575 0D13			SHIFT_LOOP:
  1576 0D13 BD 82 05		        LDA     LNBUF,X     ; Get source ch
  1577 0D16 91 F3		@:      STA     (INBUFF),Y  ; Copy ch to new location
  1578 0D18 88			        DEY                 ; Point to next dest ch
  1579 0D19 CA			        DEX                 ; Point to next source ch
  1580 0D1A 10 F7		        BPL     SHIFT_LOOP  ; Until X = 0
  1581
  1582 				    ; Let DO_LOAD attempt to execute the file
  1583 0D1C A9 01		        LDA     #$01        ; Point to start of filename
  1584 0D1E 8D 70 0C		        STA     CMDSEP      ; so DO_LOAD will treat it like
  1585 0D21 4C DD 0E		        JMP     DO_LOAD     ; 'LOAD filename'
  1586
  1587 0D24			CMDEXT:
  1588 0D24 2E 43 4F 4D 9B	        .BYTE   '.COM',EOL
  1589
  1590 				; End of PARSE_EXTRINSIC_COMMAND
  1591 				;---------------------------------------
  1592
  1593 				;---------------------------------------
  1594 0D29			DOCMD:
  1595 				;---------------------------------------
  1596 0D29 AE 86 18		        LDX     CMD
  1597 0D2C 30 08		        BMI     DOCMD_DONE  ; Unassigned command = $FF
  1598 0D2E BD 26 18		        LDA     CMD_TAB_H,X ; Get hi-byte of subroutine's addr
  1599 0D31 48			        PHA                 ; Push it to the stack
  1600 0D32 BD 06 18		        LDA     CMD_TAB_L,X ; Get lo-byte of subroutine's addr
  1601 0D35 48			        PHA                 ; Push it to the stack
  1602 0D36			DOCMD_DONE:
  1603 0D36 60			        RTS                 ; Use stack & RTS to jump to subroutine
  1604
  1605 				; End of DOCMD
  1606 				;---------------------------------------
  1607
  1608 				;---------------------------------------
  1609 0D37			DO_DRIVE_CHG:
  1610 				;---------------------------------------
  1611 0D37 AD 82 05		        LDA     LNBUF
  1612 0D3A 29 DF		        AND     #%11011111  ; Convert lower to upper
  1613 0D3C C9 4E		        CMP     #'N'
  1614 0D3E D0 14		        BNE     DO_DRIVE_CHG_ERROR
  1615 0D40 8D 06 17		        STA     PRMPT+1
  1616 0D43 AD 83 05		        LDA     LNBUF+1
  1617 0D46 C9 31		        CMP     #'1'        ; Skip if < '1'
  1618 0D48 90 0A		        BCC     DO_DRIVE_CHG_ERROR
  1619 0D4A C9 39		        CMP     #'9'        ; Skip if >= '9'
  1620 0D4C B0 06		        BCS     DO_DRIVE_CHG_ERROR
  1621 0D4E 29 0F		        AND     #$0F        ; Convert, say, to 1-8
  1622 0D50 8D 85 18		        STA     DOSDR
  1623 0D53 60			        RTS
  1624 0D54			DO_DRIVE_CHG_ERROR:
  1625 0D54 A9 7B		        LDA     #<CDERR
  1626 0D56 A0 18		        LDY     #>CDERR
  1627 0D58 4C 89 0A		        JMP     PRINT_STRING
  1628
  1629 				; End of DOCMD
  1630
  1631 				;---------------------------------------
  1632 				; Returns DOSDR in X
  1633 				; If arg1 contains Nn: then reg X = n
  1634 				; Otherwise X = DOSDR (from curr prompt)
  1635 				;---------------------------------------
  1636 0D5B			GET_DOSDR:
  1637 				;---------------------------------------
  1638
  1639 0D5B 20 72 0A		        JSR     LDBUFA      ; Reset INBUFF to LNBUF
  1640 0D5E AE 85 18		        LDX     DOSDR       ; Set DUNIT(X) to curr drive
  1641
  1642 				    ;---------------------------------------
  1643 				    ; Consider arg1 = N2:TNFS://localhost/
  1644 				    ; Check arg1 for ":" in 3rd position
  1645 				    ; if found then use char in 2nd position ('2') as DOSDR
  1646 				    ; First, change INBUFF to point to beg. of 1st arg
  1647 				    ;---------------------------------------
  1648 0D61 AD 70 0C		        LDA     CMDSEP              ; arg offset
  1649 0D64 F0 17		        BEQ     GET_DOSDR_DONE      ; first, if arg1 not pop, leave X as-is & quit
  1650
  1651 0D66 18			        CLC                         ; Advance pointer to LNBUF
  1652 0D67 65 F3		        ADC     INBUFF
  1653 0D69 85 F3		        STA     INBUFF
  1654 0D6B 90 02		        BCC     GET_DOSDR_NEXT
  1655 0D6D E6 F4		        INC     INBUFF+1
  1656
  1657 0D6F			GET_DOSDR_NEXT:
  1658 0D6F A0 02		        LDY     #$02            ; Check for ':' in 3rd pos
  1659 0D71 B1 F3		        LDA     (INBUFF),Y
  1660 0D73 C9 3A		        CMP     #':'
  1661 0D75 D0 06		        BNE     GET_DOSDR_DONE  ; Not found, skip & use default
  1662 0D77 88			        DEY
  1663 0D78 B1 F3		        LDA     (INBUFF),Y
  1664 0D7A 29 0F		        AND     #$0F            ; Convert, say, '2' to 2
  1665 0D7C AA			        TAX                     ; Return DOSDR in X
  1666
  1667 0D7D			GET_DOSDR_DONE:
  1668 0D7D 60			        RTS
  1669
  1670 				;---------------------------------------
  1671 0D7E			DO_GENERIC:
  1672 				;---------------------------------------
  1673
  1674 				    ;---------------------------------------
  1675 				    ; SIO call for NCD,{MK,RM}DIR,DEL,RENAME
  1676 				    ;---------------------------------------
  1677
  1678 				    ;---------------------------------------
  1679 				    ; Get Fujinet SIO command (~ $21 for DEL)
  1680 				    ; X = table index from caller
  1681 				    ;---------------------------------------
  1682 0D7E BD 09 17		        LDA     CMD_DCOMND,X
  1683 0D81 8D E9 0D		        STA     GENDCB+2
  1684
  1685 0D84 C9 FD		        CMP     #CMD_USER       ; Skip prepending devspec for SSH
  1686 0D86 F0 1C		        BEQ     DO_GENERIC_NEXT
  1687 0D88 C9 FE		        CMP     #CMD_PASS
  1688 0D8A F0 18		        BEQ     DO_GENERIC_NEXT
  1689
  1690 				    ;---------------------------------------
  1691 				    ; Get DOSDR from either arg1 or curr drive
  1692 				    ;---------------------------------------
  1693 0D8C 20 5B 0D		        JSR     GET_DOSDR    ; X will contain int of n in Nn:
  1694 0D8F 8E E8 0D		        STX     GENDCB+1
  1695 0D92 20 B1 16		        JSR     PREPEND_DRIVE
  1696
  1697 				    ;---------------------------------------
  1698 				    ; If this is NCD ensure a '/' char is the last char
  1699 				    ;---------------------------------------
  1700 0D95 AD E9 0D		        LDA     GENDCB+2
  1701 0D98 C9 2C		        CMP     #CMD_CD         ; Is this an NCD command?
  1702 0D9A D0 08		        BNE     DO_GENERIC_NEXT ; No. skip
  1703
  1704 0D9C AD 70 0C		        LDA     CMDSEP
  1705 0D9F F0 2C		        BEQ     NCD_ERROR
  1706 0DA1 20 DE 16		        JSR     APPEND_SLASH    ; Append '/' to path if missing
  1707
  1708 0DA4			DO_GENERIC_NEXT:
  1709 				    ;---------------------------------------
  1710 				    ; Populate the DCB
  1711 				    ;---------------------------------------
  1712 0DA4 AD 85 18		        LDA     DOSDR
  1713 0DA7 8D 49 09		        STA     STADCB+1        ; Yes. Status (not typo)
  1714 				;        STA     GENDCB+1   ; 20221105 - commented-out. checking for bug...
  1715 0DAA A5 F3		        LDA     INBUFF
  1716 0DAC 8D EB 0D		        STA     GENDCB+4
  1717 0DAF A5 F4		        LDA     INBUFF+1
  1718 0DB1 8D EC 0D		        STA     GENDCB+5
  1719
  1720 				    ;---------------------------------------
  1721 				    ; Send the command to FujiNet
  1722 				    ;---------------------------------------
  1723 0DB4 A9 E7		        LDA     #<GENDCB
  1724 0DB6 A0 0D		        LDY     #>GENDCB
  1725 0DB8 20 A5 07		        JSR     DOSIOV
  1726 0DBB 20 A4 0A		        JSR     PRINT_ERROR
  1727
  1728 0DBE			GEN_UNMOUNT:
  1729 				    ;---------------------------------------
  1730 				    ; if DEL or RENAME, then remount drive
  1731 				    ;---------------------------------------
  1732 0DBE AD 87 18		        LDA     CMDPRV
  1733 0DC1 C9 02		        CMP     #CMD_IDX.DEL
  1734 0DC3 F0 04		        BEQ     GEN_REMOUNT
  1735 0DC5 C9 0A		        CMP     #CMD_IDX.RENAME
  1736 0DC7 D0 03		        BNE     GENDONE
  1737 0DC9			GEN_REMOUNT:
  1738 0DC9 4C 7E 16		        JMP     REMOUNT_DRIVE
  1739
  1740 0DCC			GENDONE:
  1741 0DCC 60			        RTS
  1742
  1743 				;---------------------------------------
  1744 0DCD			NCD_ERROR:
  1745 				;---------------------------------------
  1746 0DCD A9 E1		        LDA     #<NCD_ERROR_STR
  1747 0DCF A0 0D		        LDY     #>NCD_ERROR_STR
  1748 0DD1 20 89 0A		        JSR     PRINT_STRING
  1749 0DD4 A0 01		        LDY     #$01        ; Return error
  1750 0DD6 60			        RTS
  1751 				    ;---------------------------------------
  1752 				    ; Close 
  1753 				    ;---------------------------------------
  1754 0DD7 A2 10		        LDX     #$10        ; File #1
  1755 0DD9 A9 0C		        LDA     #$0C        ; Close #1 first
  1756 0DDB 9D 42 03		        STA     ICCOM,X
  1757 0DDE 20 56 E4		        JSR     CIOV
  1758
  1759 0DE1			NCD_ERROR_STR:
  1760 0DE1 50 41 54 48 3F 9B	        .BYTE   'PATH?',EOL
  1761
  1762 				;---------------------------------------
  1763 0DE7			GENDCB:
  1764 0DE7 71			        .BYTE   DEVIDN      ; DDEVIC
  1765 0DE8 FF			        .BYTE   $FF         ; DUNIT
  1766 0DE9 FF			        .BYTE   $FF         ; DCOMND
  1767 0DEA 80			        .BYTE   $80         ; DSTATS
  1768 0DEB FF			        .BYTE   $FF         ; DBUFL
  1769 0DEC FF			        .BYTE   $FF         ; DBUFH
  1770 0DED 1F			        .BYTE   $1F         ; DTIMLO
  1771 0DEE 00			        .BYTE   $00         ; DRESVD
  1772 0DEF 00			        .BYTE   $00         ; DBYTL
  1773 0DF0 01			        .BYTE   $01         ; DBYTH
  1774 0DF1 00			        .BYTE   $00         ; DAUX1
  1775 0DF2 00			        .BYTE   $00         ; DAUX2
  1776
  1777 				; End of DO_GENERIC
  1778 				;---------------------------------------
  1779
  1780 				;;---------------------------------------
  1781 				;DO_COPY:
  1782 				;;---------------------------------------
  1783 				;
  1784 				;        LDA     #$20
  1785 				;        STA     COLOR2
  1786 				;
  1787 				;        LDA     #<CPYDCB
  1788 				;        LDY     #>CPYDCB
  1789 				;        JSR     DOSIOV
  1790 				;
  1791 				;        LDA     #$20
  1792 				;        STA     COLOR2
  1793 				;
  1794 				;        RTS
  1795 				;
  1796 				;CPYDCB:
  1797 				;        .BYTE      DEVIDN  ; DDEVIC
  1798 				;        .BYTE      $FF     ; DUNIT
  1799 				;        .BYTE      $D8     ; DCOMND
  1800 				;        .BYTE      $80     ; DSTATS
  1801 				;        .BYTE      <COPYSPEC  ; DBUFL
  1802 				;        .BYTE      >COPYSPEC ; DBUFH
  1803 				;        .BYTE      $FE     ; DTIMLO
  1804 				;        .BYTE      $00     ; DRESVD
  1805 				;        .BYTE      $00     ; DBYTL
  1806 				;        .BYTE      $01     ; DBYTH
  1807 				;        .BYTE      3       ; DAUX1
  1808 				;        .BYTE      2       ; DAUX2
  1809 				;
  1810 				;COPYSPEC:
  1811 				;        .BYTE 'iss.po|iss.po',$00
  1812
  1813 				;;---------------------------------------
  1814 				;DO_COPY:
  1815 				;;---------------------------------------
  1816 				;        LDA     #$B0
  1817 				;        STA     COLOR2
  1818 				;        RTS
  1819
  1820 				;        JSR     COPY_PARSE_FILES    ; locate comma, replace with EOL
  1821 				;        BMI     COPY_DONE
  1822 				;
  1823 				;        LDA     CMDSEP
  1824 				;        STA     CMDSEP+2
  1825 				;
  1826 				;        LDA     CMDSEP+1
  1827 				;        STA     CMDSEP
  1828 				;
  1829 				;        JSR     COPY_OPEN_DEST      ; use CIO to open file 2 for write
  1830 				;        BMI     COPY_DONE
  1831 				;
  1832 				;        LDA     CMDSEP+2
  1833 				;        STA     CMDSEP
  1834 				;        JSR     COPY_OPEN_SRC       ; use CIO to open file 1 for read
  1835 				;        BMI     COPY_DONE
  1836 				;
  1837 				;@:      JSR     COPY_GET_SRC
  1838 				;        JSR     COPY_PUT_DEST
  1839 				;        ;BNE     @-
  1840 				;
  1841 				;COPY_DONE:
  1842 				;    ; Close files
  1843 				;        LDX     #$10
  1844 				;        JSR     CIOCLOSE
  1845 				;        LDX     #$20
  1846 				;        JMP     CIOCLOSE
  1847 				;
  1848 				;;---------------------------------------
  1849 				;COPY_PARSE_FILES:
  1850 				;;---------------------------------------
  1851 				;    ; Find position of comma in line buffer
  1852 				;    ; Return X = position of comma
  1853 				;    ;---------------------------------------
  1854 				;        LDX     CMDSEP
  1855 				;COPY_PARSE_LOOP:
  1856 				;        LDA     LNBUF,X
  1857 				;        CMP     #','
  1858 				;        BEQ     COPY_PARSE_FILES_DONE
  1859 				;        CMP     #EOL
  1860 				;        BEQ     COPY_SHOW_USAGE
  1861 				;        INX
  1862 				;        BNE     COPY_PARSE_LOOP
  1863 				;COPY_PARSE_FILES_DONE:
  1864 				;    ;---------------------------------------
  1865 				;    ; Here if comma found.
  1866 				;    ; Inject EOL where the comma was found
  1867 				;    ;---------------------------------------
  1868 				;        LDA     #EOL
  1869 				;        STA     LNBUF,X
  1870 				;        INX                 ; Advance to start of 2nd arg
  1871 				;        STX     CMDSEP+1    ; Point to 2nd arg now
  1872 				;        RTS
  1873 				;    ;---------------------------------------
  1874 				;    ; Here if no comma found.
  1875 				;    ; Print usage
  1876 				;    ;---------------------------------------
  1877 				;COPY_SHOW_USAGE:
  1878 				;        LDA     #<COPY_SHOW_USAGE_STR
  1879 				;        LDY     #>COPY_SHOW_USAGE_STR
  1880 				;        JSR     PRINT_STRING
  1881 				;        LDY     #$FF
  1882 				;        RTS
  1883 				;
  1884 				;COPY_SHOW_USAGE_STR:
  1885 				;        .BYTE   'COPY SOURCE,DEST',EOL
  1886 				;
  1887 				;; End of COPY_COMMA_POS:
  1888 				;;---------------------------------------
  1889 				;
  1890 				;;---------------------------------------
  1891 				;COPY_OPEN_SRC:
  1892 				;;---------------------------------------
  1893 				;        JSR     GET_DOSDR       ; Get DUNIT
  1894 				;        JSR     PREPEND_DRIVE
  1895 				;
  1896 				;        LDX     #$10            ; File #1
  1897 				;        JSR     CIOCLOSE        ; Assert file #1 is closed
  1898 				;        LDY     #$04            ; Open for input
  1899 				;        JSR     CIOOPEN         ; Open filename @ (INBUFF)
  1900 				;        BPL     COPY_OPEN_SRC_DONE
  1901 				;
  1902 				;        LDA     #<COPY_OPEN_SRC_ERR_STR
  1903 				;        LDY     #>COPY_OPEN_SRC_ERR_STR
  1904 				;        JMP     PRINT_STRING
  1905 				;
  1906 				;COPY_OPEN_SRC_DONE:
  1907 				;        RTS
  1908 				;        
  1909 				;COPY_OPEN_SRC_ERR_STR:
  1910 				;        .BYTE   'UNABLE TO OPEN SOURCE',EOL
  1911 				;
  1912 				;;End of COPY_OPEN_SRC
  1913 				;;---------------------------------------
  1914 				;
  1915 				;;---------------------------------------
  1916 				;COPY_OPEN_DEST:
  1917 				;;---------------------------------------
  1918 				;    ; Advance offset to arg2
  1919 				;        
  1920 				;@:      JSR     GET_DOSDR       ; Get DUNIT
  1921 				;        JSR     PREPEND_DRIVE
  1922 				;
  1923 				;        LDX     #$20            ; Assert file #2 is closed
  1924 				;        JSR     CIOCLOSE
  1925 				;
  1926 				;        LDY     #$08            ; Open for write
  1927 				;        JSR     CIOOPEN
  1928 				;        BPL     COPY_OPEN_DEST_DONE  ; If success, skip ahead
  1929 				;
  1930 				;        LDA     #<COPY_OPEN_DEST_ERR_STR
  1931 				;        LDY     #>COPY_OPEN_DEST_ERR_STR
  1932 				;        JMP     PRINT_STRING
  1933 				;
  1934 				;COPY_OPEN_DEST_DONE:
  1935 				;        RTS
  1936 				;        
  1937 				;COPY_OPEN_DEST_ERR_STR:
  1938 				;        .BYTE   'UNABLE TO OPEN DEST',EOL
  1939 				;
  1940 				;;End of COPY_OPEN_SRC
  1941 				;;---------------------------------------
  1942 				;
  1943 				;;---------------------------------------
  1944 				;COPY_GET_SRC:
  1945 				;;---------------------------------------
  1946 				;        ;LDX     #$10
  1947 				;        ;JSR     CIOSTATUS
  1948 				;
  1949 				;        LDX     #$10
  1950 				;        LDA     #<TBUF
  1951 				;        STA     INBUFF      ; Buffer addr Lo
  1952 				;        LDA     #>TBUF
  1953 				;        STA     INBUFF+1    ; Buffer addr Hi
  1954 				;        LDA     #$80        ; Buffer size Lo
  1955 				;        LDY     #$00        ; Buffer size Hi
  1956 				;        JSR     CIOGET
  1957 				;        BPL     COPY_GET_SRC_DONE
  1958 				;        CPY     #EOF
  1959 				;        BEQ     COPY_GET_SRC_DONE
  1960 				; 
  1961 				;        LDA     #<COPY_GET_SRC_STR
  1962 				;        LDY     #>COPY_GET_SRC_STR
  1963 				;        JMP     PRINT_STRING
  1964 				;
  1965 				;COPY_GET_SRC_DONE:
  1966 				;        RTS
  1967 				;
  1968 				;COPY_GET_SRC_STR:
  1969 				;        .BYTE   'ERROR READING FROM SOURCE',EOL
  1970 				;
  1971 				;;---------------------------------------
  1972 				;COPY_PUT_DEST:
  1973 				;;---------------------------------------
  1974 				;        ;LDX     #$20
  1975 				;        ;JSR     CIOSTATUS
  1976 				;
  1977 				;        LDX     #$20
  1978 				;        LDA     #<TBUF
  1979 				;        STA     INBUFF      ; Buffer addr Lo
  1980 				;        LDA     #>TBUF
  1981 				;        STA     INBUFF+1    ; Buffer addr Hi
  1982 				;        LDA     #$06        ; Buffer size Lo
  1983 				;        LDY     #$00        ; Buffer size Hi
  1984 				;        JSR     CIOPUT
  1985 				;        BPL     COPY_PUT_DEST_DONE
  1986 				;        CPY     #EOF
  1987 				;        BEQ     COPY_PUT_DEST_DONE
  1988 				; 
  1989 				;        LDA     #<COPY_PUT_DEST_STR
  1990 				;        LDY     #>COPY_PUT_DEST_STR
  1991 				;        JMP     PRINT_STRING
  1992 				;
  1993 				;COPY_PUT_DEST_DONE:
  1994 				;        RTS
  1995 				;
  1996 				;COPY_PUT_DEST_STR:
  1997 				;        .BYTE   'ERROR WRITING TO DEST',EOL
  1998 				;
  1999
  2000 				;---------------------------------------
  2001 0DF3			DO_DIR:
  2002 				;---------------------------------------
  2003 0DF3 20 53 0E		        JSR     DIR_INIT    ; set dunits
  2004 0DF6 20 63 0E		        JSR     DIR_OPEN    ; open with dir request
  2005 0DF9 C0 01		        CPY     #$01        ; success (1) ?
  2006 0DFB F0 03		        BEQ     DIR_LOOP    ; if success, jump ahead
  2007 0DFD 4C A4 0A		        JMP     PRINT_ERROR ; exit
  2008
  2009 0E00			DIR_LOOP:
  2010
  2011 				    ;---------------------------------------
  2012 				    ; Send Status request to SIO
  2013 				    ;---------------------------------------
  2014 0E00 A9 48		        LDA     #<STADCB
  2015 0E02 A0 09		        LDY     #>STADCB
  2016 0E04 20 A5 07		        JSR     DOSIOV
  2017
  2018 				    ;---------------------------------------
  2019 				    ; Status returns DVSTAT
  2020 				    ;---------------------------------------
  2021 0E07 A2 00		        LDX     #$00
  2022 0E09 EC EB 02		        CPX     DVSTAT+1    ; if byte count < 255 (that is, hi=0)
  2023 0E0C F0 09		        BEQ     DIR_LT_255  ; then skip
  2024
  2025 				    ;---------------------------------------
  2026 				    ; Branch 1: Read 255 bytes (max)
  2027 				    ;---------------------------------------
  2028 0E0E CA			        DEX                 ; X now 255 (Read FF Bytes)
  2029 0E0F 8E 4F 0E		        STX     DIRRDCB+8   ; DBYTL
  2030 0E12 8E 51 0E		        STX     DIRRDCB+10  ; DAUX1
  2031 0E15 30 0B		        BMI     DIR_NEXT1   ; "always" true. skip down SIO call
  2032
  2033 				    ;---------------------------------------
  2034 				    ; Branch 2: Read < 255 bytes
  2035 				    ;---------------------------------------
  2036 0E17			DIR_LT_255:
  2037 0E17 AD EA 02		        LDA     DVSTAT      ; Get count of bytes remaining
  2038 0E1A F0 6C		        BEQ     DIR_ERROR   ; If here then DVSTAT = $0000 (error)
  2039 0E1C 8D 4F 0E		        STA     DIRRDCB+8   ; DBYTL
  2040 0E1F 8D 51 0E		        STA     DIRRDCB+10  ; DAUX1
  2041
  2042 				    ;-------------------------
  2043 				    ; Send Read request to SIO
  2044 				    ;-------------------------
  2045 0E22			DIR_NEXT1:
  2046 0E22 A9 47		        LDA     #<DIRRDCB
  2047 0E24 A0 0E		        LDY     #>DIRRDCB
  2048 0E26 20 A5 07		        JSR     DOSIOV      ; Fetch directory listing
  2049 0E29 20 B8 0E		        JSR     DIR_PRINT   ; xfer payload to screen
  2050
  2051 				    ;---------------------------------------
  2052 				    ; Pause output if SPACE key code found
  2053 				    ;---------------------------------------
  2054 0E2C			DIR_WAIT:
  2055 0E2C AD FC 02		        LDA     CH
  2056 0E2F C9 21		        CMP     #SPC_KEY
  2057 0E31 F0 F9		        BEQ     DIR_WAIT
  2058
  2059 				    ;---------------------------------------
  2060 				    ; Exit loop if ESC key code found
  2061 				    ;---------------------------------------
  2062 0E33 AD FC 02		        LDA     CH
  2063 0E36 C9 1C		        CMP     #ESC_KEY    ; hardware code for ESC key
  2064 0E38 F0 05		        BEQ     DIR_NEXT
  2065
  2066 				    ;---------------------------------------
  2067 				    ; Loop if more data to read
  2068 				    ;---------------------------------------
  2069 0E3A AD EB 02		        LDA     DVSTAT+1    ; Was there more to read (that is, was hi>0)?
  2070 0E3D D0 C1		        BNE     DIR_LOOP    ; If yes, then do it again
  2071
  2072 0E3F			DIR_NEXT:
  2073 0E3F A9 FF		        LDA     #$FF        ; Clear key
  2074 0E41 8D FC 02		        STA     CH
  2075 0E44 4C D6 0E		        JMP     DIR_CLOSE
  2076
  2077 0E47			DIRRDCB:
  2078 0E47 71			        .BYTE   DEVIDN      ; DDEVIC
  2079 0E48 FF			        .BYTE   $FF         ; DUNIT
  2080 0E49 52			        .BYTE   'R'         ; DCOMND
  2081 0E4A 40			        .BYTE   $40         ; DSTATS
  2082 0E4B 00			        .BYTE   <RBUF       ; DBUFL
  2083 0E4C 19			        .BYTE   >RBUF       ; DBUFH
  2084 0E4D 1F			        .BYTE   $1F         ; DTIMLO
  2085 0E4E 00			        .BYTE   $00         ; DRESVD
  2086 0E4F 00			        .BYTE   $00         ; DBYTL
  2087 0E50 00			        .BYTE   $00         ; DBYTH
  2088 0E51 00			        .BYTE   $00         ; DAUX1
  2089 0E52 00			        .BYTE   $00         ; DAUX2
  2090
  2091 				;---------------------------------------
  2092 				; Set DUNITs in all DCBs used by DIR
  2093 				;---------------------------------------
  2094 0E53			DIR_INIT:
  2095 				;---------------------------------------
  2096 0E53 20 5B 0D		        JSR     GET_DOSDR   ; On return, X <- n in Nn:
  2097 0E56 8E AD 0E		        STX     DIRODCB+1   ; DUNIT for Open
  2098 0E59 8E 49 09		        STX     STADCB+1    ; DUNIT for Status
  2099 0E5C 8E 48 0E		        STX     DIRRDCB+1   ; DUNIT for Read
  2100 0E5F 8E 22 08		        STX     CLODCB+1    ; DUNIT for Close
  2101 0E62 60			        RTS
  2102
  2103 				;---------------------------------------
  2104 0E63			DIR_OPEN:
  2105 				;---------------------------------------
  2106 0E63 20 B1 16		        JSR     PREPEND_DRIVE
  2107
  2108 				    ;-----------------------------------
  2109 				    ; Default to arg1
  2110 				    ;-----------------------------------
  2111 0E66 A6 F3		        LDX     INBUFF
  2112 0E68 A4 F4		        LDY     INBUFF+1
  2113
  2114 				    ;-----------------------------------
  2115 				    ; But use Nn:*.* if no arg1
  2116 				    ;-----------------------------------
  2117 0E6A AD 70 0C		        LDA     CMDSEP          ; 0 means no arg1
  2118 0E6D D0 0C		        BNE     DIR_OPEN_NEXT   ; If arg1 present then skip
  2119
  2120 				    ;-----------------------------------
  2121 				    ; Here if no arg1
  2122 				    ;-----------------------------------
  2123 0E6F A2 A5		        LDX     #<DIR_OPEN_STR
  2124 0E71 A0 0E		        LDY     #>DIR_OPEN_STR
  2125
  2126 0E73 AD 85 18		        LDA     DOSDR
  2127 0E76 09 30		        ORA     #'0'            ; Convert, say, 1 to '1'
  2128 0E78 8D A6 0E		        STA     DIR_OPEN_STR+1  ; Inject DOSDR into string
  2129
  2130 0E7B			DIR_OPEN_NEXT:
  2131 0E7B 8E B0 0E		        STX     DIRODCB+4       ; DBUFL
  2132 0E7E 8C B1 0E		        STY     DIRODCB+5       ; DBUFH
  2133
  2134 0E81 A9 AC		        LDA     #<DIRODCB
  2135 0E83 A0 0E		        LDY     #>DIRODCB
  2136 0E85 4C A5 07		        JMP     DOSIOV
  2137
  2138 				;---------------------------------------
  2139 0E88			DIR_ERROR:
  2140 				;---------------------------------------
  2141 0E88 A9 92		        LDA     #<DIR_ERROR_STR
  2142 0E8A A0 0E		        LDY     #>DIR_ERROR_STR
  2143 0E8C 20 89 0A		        JSR     PRINT_STRING
  2144 0E8F A0 01		        LDY     #$01            ; Return error
  2145 0E91 60			        RTS
  2146
  2147 0E92			DIR_ERROR_STR:
  2148 0E92 55 4E 41 42 4C 45 +         .BYTE   'UNABLE TO READ DIR',EOL
  2149
  2150 0EA5			DIR_OPEN_STR:
  2151 0EA5 4E 20 3A 2A 2E 2A +         .BYTE   'N :*.*',EOL
  2152
  2153 0EAC			DIRODCB:
  2154 0EAC 71			        .BYTE   DEVIDN          ; DDEVIC
  2155 0EAD FF			        .BYTE   $FF             ; DUNIT
  2156 0EAE 4F			        .BYTE   'O'             ; DCOMND
  2157 0EAF 80			        .BYTE   $80             ; DSTATS
  2158 0EB0 FF			        .BYTE   $FF             ; DBUFL
  2159 0EB1 FF			        .BYTE   $FF             ; DBUFH
  2160 0EB2 1F			        .BYTE   $1F             ; DTIMLO
  2161 0EB3 00			        .BYTE   $00             ; DRESVD
  2162 0EB4 00			        .BYTE   $00             ; DBYTL
  2163 0EB5 01			        .BYTE   $01             ; DBYTH
  2164 0EB6 06			        .BYTE   $06             ; DAUX1
  2165 0EB7 80			        .BYTE   $80             ; DAUX2 (Long Dir)
  2166
  2167 				; End of DIR_OPEN
  2168 				;---------------------------------------
  2169
  2170 				;---------------------------------------
  2171 0EB8			DIR_PRINT:
  2172 				;---------------------------------------
  2173 				        ; Print results using CIO
  2174 0EB8 A2 00		        LDX     #$00
  2175 0EBA A9 0B		        LDA     #PUTCHR
  2176 0EBC 9D 42 03		        STA     ICCOM,X
  2177
  2178 				        ; Fill out buffer loc
  2179 0EBF A9 00		        LDA     #<RBUF
  2180 0EC1 9D 44 03		        STA     ICBAL,X
  2181 0EC4 A9 19		        LDA     #>RBUF
  2182 0EC6 9D 45 03		        STA     ICBAH,X
  2183
  2184 				        ; Fill out size loc
  2185 0EC9 AD 4F 0E		        LDA     DIRRDCB+8
  2186 0ECC 9D 48 03		        STA     ICBLL,X
  2187 0ECF 8A			        TXA
  2188 0ED0 9D 49 03		        STA     ICBLH,X
  2189 0ED3 4C 56 E4		        JMP     CIOV
  2190
  2191 				;---------------------------------------
  2192 0ED6			DIR_CLOSE:
  2193 				;---------------------------------------
  2194 				        ; Close
  2195 0ED6 A9 21		        LDA     #<CLODCB
  2196 0ED8 A0 08		        LDY     #>CLODCB
  2197 0EDA 4C A5 07		        JMP     DOSIOV
  2198
  2199 				;---------------------------------------
  2200 0EDD			DO_LOAD:
  2201 				;---------------------------------------
  2202 				    ; Binary Loader based on work by Richard J. Kalagher 07-AUG-1983
  2203
  2204 				    ; Open file
  2205 0EDD AD 70 0C		        LDA     CMDSEP          ; Quit if no arg1
  2206 0EE0 D0 03		        BNE     LOAD_NEXT1
  2207 0EE2 4C 71 11		        JMP     LOAD_ERROR
  2208
  2209 0EE5			LOAD_NEXT1:
  2210 				    ; Point INBUFF to start of filename
  2211 0EE5 18			        CLC
  2212 0EE6 65 F3		        ADC     INBUFF          ; [A] contains offset to arg1
  2213 0EE8 85 F3		        STA     INBUFF
  2214 0EEA 90 02		        BCC     LOAD_NEXT2
  2215 0EEC E6 F4		        INC     INBUFF+1
  2216
  2217 0EEE			LOAD_NEXT2:
  2218 0EEE 20 81 0F		        JSR     LOAD_NTRANS     ; Disable any EOL translation
  2219 0EF1 20 3D 0F		        JSR     LOAD_SETUP      ; Set up run and init to RTS
  2220 0EF4 A9 04		        LDA     #OINPUT         ; A arg needed in LOAD_OPEN
  2221 0EF6 20 53 0F		        JSR     LOAD_OPEN       ; Open the file
  2222 0EF9 C0 01		        CPY     #$01            ; Quit if unable to open
  2223 0EFB D0 3F		        BNE     R
  2224
  2225 0EFD A9 FF		        LDA     #$FF
  2226 0EFF 8D 90 19		        STA     BIN_1ST
  2227 0F02 20 8F 0F		        JSR     LOAD_READ2
  2228 0F05 20 B0 0F		        JSR     LOAD_CHKFF
  2229 0F08 C0 01		        CPY     #$01
  2230 0F0A D0 30		        BNE     R
  2231
  2232 0F0C EE 90 19		        INC     BIN_1ST
  2233 				    ; Process each payload
  2234 0F0F 20 8F 0F		GETFIL: JSR     LOAD_READ2      ; Get two bytes (binary header)
  2235 0F12 30 28		        BMI     R               ; Exit if EOF hit
  2236 0F14 20 48 0F		        JSR     LOAD_INIT       ; Set init default
  2237 0F17 A2 01		        LDX     #$01
  2238 0F19 20 B0 0F		        JSR     LOAD_CHKFF      ; Check if header (and start addr, too)
  2239 0F1C 20 E7 0F		        JSR     LOAD_STRAD      ; Put start address in
  2240 0F1F 20 8F 0F		        JSR     LOAD_READ2      ; Get to more butes (end addr)
  2241 0F22 20 F4 0F		        JSR     LOAD_ENDAD      ; Put end address in
  2242 0F25 20 0D 10		        JSR     LOAD_BUFLEN     ; Calculate buffer length
  2243 0F28 20 32 10		        JSR     LOAD_GETDAT     ; Get the data record
  2244 0F2B 10 03		        BPL     @+              ; Was EOF detected?
  2245 0F2D 20 39 0F		        JSR     JSTART          ; Yes. Go to RUNAD
  2246 0F30 20 36 0F		@:      JSR     JINIT           ; Attempt initialization
  2247 0F33 4C 0F 0F		        JMP     GETFIL          ; Process next payload
  2248
  2249 0F36 6C E2 02		JINIT:  JMP     (INITAD)        ; Will either RTS or perform INIT
  2250 0F39 6C E0 02		JSTART: JMP     (RUNAD)         ; Godspeed.
  2251 0F3C 60			R:      RTS                     ; Stunt-double for (INITAD),(RUNAD)
  2252
  2253 				;---------------------------------------
  2254 0F3D			LOAD_SETUP:
  2255 				;---------------------------------------
  2256 0F3D A9 3C		        LDA     #<R
  2257 0F3F 8D E0 02		        STA     RUNAD
  2258 0F42 A9 0F		        LDA     #>R
  2259 0F44 8D E1 02		        STA     RUNAD+1
  2260 0F47 60			        RTS
  2261
  2262 				;---------------------------------------
  2263 0F48			LOAD_INIT:
  2264 				;---------------------------------------
  2265 0F48 A9 3C		        LDA     #<R
  2266 0F4A 8D E2 02		        STA     INITAD
  2267 0F4D A9 0F		        LDA     #>R
  2268 0F4F 8D E3 02		        STA     INITAD+1
  2269 0F52 60			        RTS
  2270
  2271 				;---------------------------------------
  2272 0F53			LOAD_OPEN:
  2273 				;---------------------------------------
  2274 0F53 48			        PHA                     ; Save data direction passed in A
  2275 0F54 20 5B 0D		        JSR     GET_DOSDR       ; Get DUNIT
  2276 0F57 8E 01 08		        STX     OPNDCB+1        ; Set DUNIT
  2277 0F5A 8E 83 08		        STX     GETDCB+1        ; Set DUNIT FOR READ
  2278 0F5D 20 B1 16		        JSR     PREPEND_DRIVE
  2279
  2280 0F60 A5 F3		        LDA     INBUFF          ; Register location of filename
  2281 0F62 8D 04 08		        STA     OPNDCB+4
  2282 0F65 A5 F4		        LDA     INBUFF+1
  2283 0F67 8D 05 08		        STA     OPNDCB+5
  2284
  2285 0F6A 68			        PLA                     ; A = data direction (4=in, 8=out)
  2286 0F6B 8D 0A 08		        STA     OPNDCB+10
  2287 0F6E A9 00		        LDA     #$00            ; AUX2: No translation
  2288 0F70 8D 0B 08		        STA     OPNDCB+11
  2289
  2290 0F73 A9 00		        LDA     #<OPNDCB
  2291 0F75 A0 08		        LDY     #>OPNDCB
  2292 0F77 20 A5 07		        JSR     DOSIOV
  2293
  2294 0F7A 48			        PHA
  2295 0F7B 20 A4 0A		        JSR     PRINT_ERROR
  2296 0F7E 68			        PLA
  2297 0F7F A8			        TAY
  2298
  2299 0F80 60			        RTS
  2300
  2301 				;---------------------------------------
  2302 0F81			LOAD_NTRANS:
  2303 				;---------------------------------------
  2304 				    ; Disable any EOL transation otherwise
  2305 				    ; binary data will be corrupted during load
  2306 				    ;---------------------------------------
  2307 0F81 20 5B 0D		        JSR     GET_DOSDR       ; Get DUNIT
  2308 0F84 8E 3F 12		        STX     NTRDCB+1        ; Set DUNIT
  2309 0F87 A9 00		        LDA     #$00
  2310 0F89 8D 49 12		        STA     NTRDCB+11       ; Translation mode (0 = NONE)
  2311 0F8C 4C 0B 12		        JMP     NTRANS_CALL     ; Reuse code in DO_NTRANS
  2312
  2313 				;---------------------------------------
  2314 0F8F			LOAD_READ2:
  2315 				;---------------------------------------
  2316 				    ; Load 2 bytes into Buffer (BAL/H).
  2317 				    ;---------------------------------------
  2318 				    ; This is accomplished by abusing the LOAD_GETDAT
  2319 				    ; routine by stuffing the buffer addr (BAL/H)
  2320 				    ; into the payload Start/End addrs. We're doing
  2321 				    ; this in case a payload  header straddles a
  2322 				    ; cache boundary. LOAD_GETDAT has the logic for
  2323 				    ; dealing with that.
  2324 				    ;---------------------------------------
  2325 0F8F A9 00		        LDA     #<BAL
  2326 0F91 8D 80 19		        STA     STL         ; Payload start address
  2327 0F94 A9 19		        LDA     #>BAL
  2328 0F96 8D 81 19		        STA     STH
  2329
  2330 0F99 A9 01		        LDA     #<BAH
  2331 0F9B 8D 82 19		        STA     ENL         ; Payload end address
  2332 0F9E A9 19		        LDA     #>BAH
  2333 0FA0 8D 83 19		        STA     ENH
  2334
  2335 0FA3 A2 02		        LDX     #$02
  2336 0FA5 8E 84 19		        STX     BLL         ; Payload size (2)
  2337 0FA8 A9 00		        LDA     #$00
  2338 0FAA 8D 85 19		        STA     BLH
  2339
  2340 0FAD 4C 32 10		        JMP     LOAD_GETDAT ; Read 2 bytes
  2341
  2342 				;---------------------------------------
  2343 0FB0			LOAD_CHKFF:
  2344 				;---------------------------------------
  2345 				    ; On 1st pass, check for binary signature (FF FF)
  2346 				    ; On 2..n passes, Skip FF FF (if found) 
  2347 				    ; and read next 2 bytes
  2348 				    ;---------------------------------------
  2349 				        
  2350 0FB0 A9 FF		        LDA     #$FF
  2351 0FB2 CD 00 19		        CMP     BAL         ; Is 1st byte FF?
  2352 0FB5 D0 0D		        BNE     NOTFF       ; If no, skip down.
  2353 0FB7 CD 01 19		        CMP     BAH         ; Is 2nd byte FF?
  2354 0FBA D0 08		        BNE     NOTFF       ; If no, skip down.
  2355
  2356 				    ;---------------------------------------
  2357 				    ; Here if FF FF tags found. 
  2358 				    ; On 1st pass, we're done.
  2359 				    ; On 2..n passes, read next 2 bytes and leave.
  2360 				    ;---------------------------------------
  2361 0FBC CD 90 19		        CMP     BIN_1ST     ; Is this 1st pass?
  2362 0FBF F0 13		        BEQ     NOTFF_DONE  ; If yes, then we're done here.
  2363 0FC1 4C 8F 0F		        JMP     LOAD_READ2  ; 
  2364
  2365 				    ;---------------------------------------
  2366 				    ; Here if FF FF tags NOT found. 
  2367 				    ; On 1st pass, print error.
  2368 				    ; On 2..n passes, the 2 bytes = payload start addr.
  2369 				    ;---------------------------------------
  2370 0FC4 A0 01		NOTFF:  LDY     #$01        ; Preload success return code
  2371 0FC6 CD 90 19		        CMP     BIN_1ST     ; A still has FF. BIN_1ST = FF on first pass
  2372 0FC9 D0 09		        BNE     NOTFF_DONE  ; Not 1st pass, exit with success.
  2373
  2374 0FCB			NOTFF_ERR:
  2375 0FCB A9 D5		        LDA     #<LOAD_ERROR_STR2
  2376 0FCD A0 0F		        LDY     #>LOAD_ERROR_STR2
  2377 0FCF 20 89 0A		        JSR     PRINT_STRING
  2378
  2379 0FD2 A0 FF		        LDY     #$FF        ; Return failure
  2380 0FD4			NOTFF_DONE:
  2381 0FD4 60			        RTS
  2382
  2383 0FD5			LOAD_ERROR_STR2:
  2384 0FD5 4E 4F 54 20 41 20 +         .BYTE   'NOT A BINARY FILE',EOL
  2385
  2386 				;---------------------------------------
  2387 0FE7			LOAD_STRAD:
  2388 				;---------------------------------------
  2389 				    ; Save payload start address into STL2/STLH2.
  2390 				    ; Otherwise it will get clobbered
  2391 				    ; when reading payload end address.
  2392 0FE7 AD 00 19		        LDA     RBUF
  2393 0FEA 8D 8E 19		        STA     STL2
  2394 0FED AD 01 19		        LDA     RBUF+1
  2395 0FF0 8D 8F 19		        STA     STH2
  2396 0FF3 60			        RTS
  2397
  2398 				;---------------------------------------
  2399 0FF4			LOAD_ENDAD:
  2400 				;---------------------------------------
  2401 				    ; Save payload end address
  2402 0FF4 AD 8E 19		        LDA     STL2
  2403 0FF7 8D 80 19		        STA     STL
  2404 0FFA AD 8F 19		        LDA     STH2
  2405 0FFD 8D 81 19		        STA     STH
  2406 				    
  2407 1000 AD 00 19		        LDA     RBUF
  2408 1003 8D 82 19		        STA     ENL
  2409 1006 AD 01 19		        LDA     RBUF+1
  2410 1009 8D 83 19		        STA     ENH
  2411 100C 60			        RTS
  2412
  2413 				;---------------------------------------
  2414 100D			LOAD_BUFLEN:
  2415 				;---------------------------------------
  2416 				    ; Calculate buffer length (end-start+1)
  2417
  2418 				    ; Calc buffer size Lo
  2419 100D AD 82 19		        LDA     ENL
  2420 1010 38			        SEC
  2421 1011 ED 80 19		        SBC     STL
  2422 1014 8D 84 19		        STA     BLL     ; Buffer Length Lo
  2423
  2424 				    ; Calc buffer size Hi
  2425 1017 AD 83 19		        LDA     ENH     ; Calc buffer size Hi
  2426 101A ED 81 19		        SBC     STH
  2427 101D 8D 85 19		        STA     BLH     ; Buffer Length Hi
  2428
  2429 				    ; Add 1
  2430 1020 18			        CLC
  2431 1021 AD 84 19		        LDA     BLL
  2432 1024 69 01		        ADC     #$01
  2433 1026 8D 84 19		        STA     BLL
  2434
  2435 1029 AD 85 19		        LDA     BLH
  2436 102C 69 00		        ADC     #$00    ; Take care of any carry
  2437 102E 8D 85 19		        STA     BLH
  2438
  2439 1031 60			        RTS
  2440
  2441 				;;---------------------------------------
  2442 				;LOAD_GETDAT:
  2443 				;;---------------------------------------
  2444 				;
  2445 				;    ;---------------------------------------
  2446 				;    ; Fill out the DCB
  2447 				;    ;---------------------------------------
  2448 				;        JSR     GET_DOSDR
  2449 				;        STX     BINDCB+1        ; DUNIT
  2450 				;
  2451 				;        LDA     STL
  2452 				;        STA     BINDCB+4        ; DBUFL 
  2453 				;        LDA     STH
  2454 				;        STA     BINDCB+5        ; DBUFH
  2455 				;        LDA     BLL
  2456 				;        STA     BINDCB+8        ; DBYTL
  2457 				;        STA     BINDCB+10
  2458 				;        LDA     BLH
  2459 				;        STA     BINDCB+9        ; DBYTH
  2460 				;        STA     BINDCB+11
  2461 				;
  2462 				;    ;---------------------------------------
  2463 				;    ; Send Read request to SIO
  2464 				;    ;---------------------------------------
  2465 				;        LDA     #<BINDCB
  2466 				;        LDY     #>BINDCB
  2467 				;        JSR     DOSIOV
  2468 				;        JSR     PRINT_ERROR     ; Show any errors
  2469 				;
  2470 				;    ;---------------------------------------
  2471 				;    ; Get status (updates DVSTAT, DSTATS)
  2472 				;    ;---------------------------------------
  2473 				;        LDA     BINDCB+1
  2474 				;        STA     STADCB+1
  2475 				;        LDA     #<STADCB
  2476 				;        LDY     #>STADCB
  2477 				;        JSR     DOSIOV
  2478 				;
  2479 				;    ; Check if EOF (current requested chunk completed?)
  2480 				;        LDA     #EOF
  2481 				;        CMP     DVSTAT+3
  2482 				;        BEQ     LOAD_GETDAT_DONE
  2483 				;        JMP     PRINT_ERROR
  2484 				;
  2485 				;LOAD_GETDAT_DONE:
  2486 				;    ; Check if 0 bytes remaining
  2487 				;        LDA     DVSTAT
  2488 				;        BNE     LOAD_GETDAT_DONE2
  2489 				;        LDA     DVSTAT+1
  2490 				;        BNE     LOAD_GETDAT_DONE2
  2491 				;        LDY     #$FF
  2492 				;        RTS
  2493 				;
  2494 				;LOAD_GETDAT_DONE2:
  2495 				;        LDY     #$01            ; Return success
  2496 				;        RTS
  2497 				;        
  2498 				;BINDCB:
  2499 				;       .BYTE    DEVIDN      ; DDEVIC
  2500 				;       .BYTE    $FF         ; DUNIT
  2501 				;       .BYTE    'R'         ; DCOMND
  2502 				;       .BYTE    $40         ; DSTATS
  2503 				;       .BYTE    $FF         ; DBUFL
  2504 				;       .BYTE    $FF         ; DBUFH
  2505 				;       .BYTE    $0F         ; DTIMLO
  2506 				;       .BYTE    $00         ; DRESVD
  2507 				;       .BYTE    $FF         ; DBYTL
  2508 				;       .BYTE    $FF         ; DBYTH
  2509 				;       .BYTE    $FF         ; DAUX1
  2510 				;       .BYTE    $FF         ; DAUX2
  2511
  2512 				;---------------------------------------
  2513 1032			LOAD_GETDAT:
  2514 				;---------------------------------------
  2515 				    ; Definitions:
  2516 				    ; HEAD = requested bytes that will be found in current cache (< 512 bytes)
  2517 				    ; BODY = contiguous 512 byte sections. BODY = n * 512 bytes)
  2518 				    ; TAIL = any bytes remaining after BODY (< 512 bytes)
  2519
  2520 1032 20 5B 0D		        JSR     GET_DOSDR
  2521 1035 8E 59 11		        STX     BINDCB+1
  2522
  2523 1038 20 34 11		        JSR     GETDAT_CHECK_EOF    ; Check EOF before proceeding
  2524 103B 10 01		        BPL     GETDAT_NEXT1        ; If true, then EOF found. Exit
  2525 103D 60			        RTS
  2526
  2527 				    ; Check if bytes requested BL < DVSTAT (bytes waiting in cache)
  2528 103E			GETDAT_NEXT1:
  2529 103E AD EA 02		        LDA     DVSTAT
  2530 1041 CD 84 19		        CMP     BLL
  2531 1044 AD EB 02		        LDA     DVSTAT+1
  2532 1047 ED 85 19		        SBC     BLH
  2533 104A B0 4C		        BCS     GETDAT_OPT2     ; BL <= BW (bytes waiting)
  2534
  2535 104C			GETDAT_OPT1:
  2536 				    ;--------------------------------
  2537 				    ; Here if bytes requested > bytes 
  2538 				    ; remaining in cache
  2539 				    ;--------------------------------
  2540
  2541 				    ;-------------------------------
  2542 				    ; Head = BW (bytes waiting)
  2543 				    ;-------------------------------
  2544 104C AD EA 02		        LDA     DVSTAT
  2545 104F 8D 86 19		        STA     HEADL
  2546 1052 AD EB 02		        LDA     DVSTAT+1
  2547 1055 8D 87 19		        STA     HEADH
  2548
  2549 				    ;-------------------------------
  2550 				    ; Tail = (BL - HEAD) mod 512
  2551 				    ;-------------------------------
  2552 1058 38			        SEC
  2553 1059 AD 84 19		        LDA     BLL
  2554 105C ED 86 19		        SBC     HEADL
  2555 105F 29 FF		        AND     #$FF
  2556 1061 8D 8A 19		        STA     TAILL
  2557 1064 AD 85 19		        LDA     BLH
  2558 1067 ED 87 19		        SBC     HEADH
  2559 106A 29 01		        AND     #$01
  2560 106C 8D 8B 19		        STA     TAILH
  2561
  2562 				    ;-----------------------------------
  2563 				    ; Body = BL - HEAD - TAIL
  2564 				    ;-----------------------------------
  2565 				        ; 1. Body = BL - HEAD
  2566 				        ;-------------------------------
  2567 106F 38			        SEC
  2568 1070 AD 84 19		        LDA     BLL
  2569 1073 ED 86 19		        SBC     HEADL
  2570 1076 8D 88 19		        STA     BODYL
  2571 1079 AD 85 19		        LDA     BLH
  2572 107C ED 87 19		        SBC     HEADH
  2573 107F 8D 89 19		        STA     BODYH
  2574
  2575 				        ;-------------------------------
  2576 				        ; 2. Body = Body - HEAD
  2577 				        ;-------------------------------
  2578 1082 38			        SEC
  2579 1083 AD 88 19		        LDA     BODYL
  2580 1086 ED 8A 19		        SBC     TAILL
  2581 1089 8D 88 19		        STA     BODYL
  2582 108C AD 89 19		        LDA     BODYH
  2583 108F ED 8B 19		        SBC     TAILH
  2584 1092 8D 89 19		        STA     BODYH
  2585
  2586 1095 4C B2 10		        JMP     GETDAT_READ
  2587
  2588 1098			GETDAT_OPT2:
  2589 				    ;--------------------------------
  2590 				    ; Here if bytes requested <= bytes 
  2591 				    ; remaining in cache
  2592 				    ;--------------------------------
  2593 				    ; Head = BL, TAIL = BODY = 0
  2594 				    ;--------------------------------
  2595 1098 AD 84 19		        LDA     BLL
  2596 109B 8D 86 19		        STA     HEADL
  2597 109E AD 85 19		        LDA     BLH
  2598 10A1 8D 87 19		        STA     HEADH
  2599 10A4 A9 00		        LDA     #$00
  2600 10A6 8D 8A 19		        STA     TAILL
  2601 10A9 8D 8B 19		        STA     TAILH
  2602 10AC 8D 88 19		        STA     BODYL
  2603 10AF 8D 89 19		        STA     BODYH
  2604
  2605 				;---------------------------------------
  2606 10B2			GETDAT_READ:
  2607 				;---------------------------------------
  2608 				    ;---------------------------------------
  2609 				    ; Read HEAD bytes
  2610 				    ;---------------------------------------
  2611 10B2 AD 86 19		        LDA     HEADL
  2612 10B5 8D 84 19		        STA     BLL
  2613 10B8 AD 87 19		        LDA     HEADH
  2614 10BB 8D 85 19		        STA     BLH
  2615 10BE 20 EF 10		        JSR     GETDAT_DOSIOV
  2616 10C1 10 01		        BPL     GETDAT_BODY ; Skip ahead if no problems
  2617 10C3 60			        RTS                 ; Bail if error
  2618
  2619 				    ;---------------------------------------
  2620 				    ; Read BODY bytes
  2621 				    ;---------------------------------------
  2622 10C4			GETDAT_BODY:
  2623 10C4 AE 89 19		        LDX     BODYH
  2624 10C7			GETDAT_BODY_LOOP:
  2625 10C7 F0 1A		        BEQ     GETDAT_TAIL ; Skip if less than a page to read
  2626
  2627 10C9 A9 00		        LDA     #$00
  2628 10CB 8D 84 19		        STA     BLL         ; Buffer length
  2629 10CE A9 02		        LDA     #$02        ; 512 bytes at a time
  2630 10D0 8D 85 19		        STA     BLH
  2631
  2632 10D3 8A			        TXA                 ; Stash our loop index (X)
  2633 10D4 48			        PHA                 ; onto the stack
  2634 10D5 20 EF 10		        JSR     GETDAT_DOSIOV   
  2635 10D8 10 03		        BPL     @+          ; Skip ahead if no problems
  2636 10DA 68			        PLA                 ; Here if problem. Clean up stack
  2637 10DB 98			        TYA                 ; Reset N status flag before returning
  2638 10DC 60			        RTS                 ; Bail if error
  2639
  2640 10DD 68			@:      PLA                 ; Retrieve our loop index
  2641 10DE AA			        TAX                 ; and xfer it back into X
  2642 10DF CA			        DEX                 ; -2 (we pull 0200 bytes at a time)
  2643 10E0 CA			        DEX                 ; 
  2644 10E1 D0 E4		        BNE     GETDAT_BODY_LOOP
  2645
  2646 10E3			GETDAT_TAIL:
  2647 				    ;---------------------------------------
  2648 				    ; Read TAIL bytes
  2649 				    ;---------------------------------------
  2650 10E3 AD 8A 19		        LDA     TAILL
  2651 10E6 8D 84 19		        STA     BLL
  2652 10E9 AD 8B 19		        LDA     TAILH
  2653 10EC 8D 85 19		        STA     BLH
  2654
  2655 				;---------------------------------------
  2656 10EF			GETDAT_DOSIOV:
  2657 				;---------------------------------------
  2658 				    ; Bail if BL = 0
  2659 10EF AD 84 19		        LDA     BLL
  2660 10F2 D0 05		        BNE     @+
  2661 10F4 AD 85 19		        LDA     BLH
  2662 10F7 F0 5C		        BEQ     CHECK_EOF_DONE
  2663
  2664 				@:
  2665 				    ; SIO READ
  2666 10F9 AD 80 19		        LDA     STL
  2667 10FC 8D 5C 11		        STA     BINDCB+4    ; Start Address Lo
  2668 10FF AD 81 19		        LDA     STH
  2669 1102 8D 5D 11		        STA     BINDCB+5    ; Start Address Hi
  2670 1105 AD 84 19		        LDA     BLL
  2671 1108 8D 60 11		        STA     BINDCB+8    ; Buffer Size Lo
  2672 110B 8D 62 11		        STA     BINDCB+10
  2673 110E AD 85 19		        LDA     BLH
  2674 1111 8D 61 11		        STA     BINDCB+9    ; Buffer Size Hi
  2675 1114 8D 63 11		        STA     BINDCB+11
  2676
  2677 				    ;---------------------------------------
  2678 				    ; Send Read request to SIO
  2679 				    ;---------------------------------------
  2680 1117 A9 58		        LDA     #<BINDCB
  2681 1119 A0 11		        LDY     #>BINDCB
  2682 111B 20 A5 07		        JSR     DOSIOV
  2683 111E 20 A4 0A		        JSR     PRINT_ERROR
  2684
  2685 				    ;---------------------------------------
  2686 				    ; Advance start address by buffer length
  2687 				    ;---------------------------------------
  2688 1121 18			        CLC
  2689 1122 AD 80 19		        LDA     STL
  2690 1125 6D 84 19		        ADC     BLL
  2691 1128 8D 80 19		        STA     STL
  2692
  2693 112B AD 81 19		        LDA     STH
  2694 112E 6D 85 19		        ADC     BLH
  2695 1131 8D 81 19		        STA     STH
  2696
  2697 1134			GETDAT_CHECK_EOF:
  2698 				    ; Get status (updates DVSTAT, DSTATS)
  2699 1134 AD 59 11		        LDA     BINDCB+1
  2700 1137 8D 49 09		        STA     STADCB+1
  2701 113A A9 48		        LDA     #<STADCB
  2702 113C A0 09		        LDY     #>STADCB
  2703 113E 20 A5 07		        JSR     DOSIOV
  2704
  2705 				    ; Return -1 if DVSTAT == $0000 and DVSTAT+3 == EOF
  2706 1141 AD EA 02		        LDA     DVSTAT
  2707 1144 D0 0F		        BNE     CHECK_EOF_DONE
  2708
  2709 1146 AD EB 02		        LDA     DVSTAT+1
  2710 1149 D0 0A		        BNE     CHECK_EOF_DONE
  2711
  2712 114B A9 88		        LDA     #EOF
  2713 114D CD ED 02		        CMP     DVSTAT+3        ; Is it EOF
  2714 1150 D0 03		        BNE     CHECK_EOF_DONE  ; No? Go to success
  2715 1152 A0 FF		        LDY     #$FF            ; Yes? Return -1
  2716 1154 60			        RTS
  2717
  2718 1155			CHECK_EOF_DONE:
  2719 1155 A0 01		        LDY     #$01        ; Return success
  2720 1157 60			        RTS
  2721
  2722 1158			BINDCB:
  2723 1158 71			       .BYTE    DEVIDN      ; DDEVIC
  2724 1159 FF			       .BYTE    $FF         ; DUNIT
  2725 115A 52			       .BYTE    'R'         ; DCOMND
  2726 115B 40			       .BYTE    $40         ; DSTATS
  2727 115C FF			       .BYTE    $FF         ; DBUFL
  2728 115D FF			       .BYTE    $FF         ; DBUFH
  2729 115E 0F			       .BYTE    $0F         ; DTIMLO
  2730 115F 00			       .BYTE    $00         ; DRESVD
  2731 1160 FF			       .BYTE    $FF         ; DBYTL
  2732 1161 FF			       .BYTE    $FF         ; DBYTH
  2733 1162 FF			       .BYTE    $FF         ; DAUX1
  2734 1163 FF			       .BYTE    $FF         ; DAUX2
  2735
  2736
  2737 				;---------------------------------------
  2738 1164			LOAD_CLOSE:
  2739 				;---------------------------------------
  2740 1164 AD 59 11		        LDA     BINDCB+1
  2741 1167 8D 22 08		        STA     CLODCB+1
  2742 116A A9 21		        LDA     #<CLODCB
  2743 116C A0 08		        LDY     #>CLODCB
  2744 116E 4C A5 07		        JMP     DOSIOV
  2745
  2746 				;---------------------------------------
  2747 1171			LOAD_ERROR:
  2748 				;---------------------------------------
  2749 1171 A9 7F		        LDA     #<MISSING_FILE_STR
  2750 1173 A0 18		        LDY     #>MISSING_FILE_STR
  2751 1175 4C 89 0A		        JMP     PRINT_STRING
  2752
  2753 				;---------------------------------------
  2754 1178			DO_LOCK:
  2755 				;---------------------------------------
  2756 1178 A9 60		        LDA     #$60
  2757 117A 8D C6 02		        STA     COLOR2
  2758 117D 60			        RTS
  2759
  2760
  2761 				;---------------------------------------
  2762 117E			DO_LPR:
  2763 				;---------------------------------------
  2764 117E A9 B0		        LDA     #$B0
  2765 1180 8D C6 02		        STA     COLOR2
  2766 1183 60			        RTS
  2767
  2768 				;---------------------------------------
  2769 1184			DO_NPWD:
  2770 				;---------------------------------------
  2771 1184 A9 9B		        LDA     #EOL        ; Truncate buffer
  2772 1186 8D 00 19		        STA     RBUF
  2773
  2774 1189 20 5B 0D		        JSR     GET_DOSDR   ; X will contain n in Nn:
  2775 118C 8E BC 11		        STX     PWDDCB+1
  2776
  2777 118F A9 BB		        LDA     #<PWDDCB
  2778 1191 A0 11		        LDY     #>PWDDCB
  2779 1193 20 A5 07		        JSR     DOSIOV
  2780 1196 20 A4 0A		        JSR     PRINT_ERROR
  2781
  2782 				    ;---------------------------------------
  2783 				    ; If we entered DO_NPWD from REMOUNT_DRIVE
  2784 				    ; then skip printing output
  2785 				    ;---------------------------------------
  2786 1199 AD 87 18		        LDA     CMDPRV
  2787 119C C9 02		        CMP     #CMD_IDX.DEL
  2788 119E F0 1A		        BEQ     NPWD_DONE
  2789 11A0 C9 0A		        CMP     #CMD_IDX.RENAME
  2790 11A2 F0 16		        BEQ     NPWD_DONE
  2791
  2792 11A4			NPWD_LOOP:
  2793 11A4 A9 00		        LDA     #<RBUF
  2794 11A6 A0 19		        LDY     #>RBUF
  2795 11A8 20 89 0A		        JSR     PRINT_STRING
  2796
  2797 11AB A9 48		        LDA     #<STADCB
  2798 11AD A0 09		        LDY     #>STADCB
  2799 11AF 20 A5 07		        JSR     DOSIOV
  2800 11B2 20 A4 0A		        JSR     PRINT_ERROR
  2801
  2802 				    ;---------------------------------------
  2803 				    ; Loop if more data to read
  2804 				    ;---------------------------------------
  2805 11B5 AD EB 02		        LDA     DVSTAT+1    ; Was there more to read (that is, was hi>0)?
  2806 11B8 D0 EA		        BNE     NPWD_LOOP   ; If yes, then do it again
  2807
  2808 11BA			NPWD_DONE:
  2809 11BA 60			        RTS
  2810
  2811 11BB			PWDDCB:
  2812 11BB 71			        .BYTE   DEVIDN      ; DDEVIC
  2813 11BC FF			        .BYTE   $FF         ; DUNIT
  2814 11BD 30			        .BYTE   $30         ; DCOMND
  2815 11BE 40			        .BYTE   $40         ; DSTATS
  2816 11BF 00			        .BYTE   <RBUF       ; DBUFL
  2817 11C0 19			        .BYTE   >RBUF       ; DBUFH
  2818 11C1 1F			        .BYTE   $1F         ; DTIMLO
  2819 11C2 00			        .BYTE   $00         ; DRESVD
  2820 11C3 00			        .BYTE   $00         ; DBYTL
  2821 11C4 01			        .BYTE   $01         ; DBYTH
  2822 11C5 00			        .BYTE   $00         ; DAUX1
  2823 11C6 00			        .BYTE   $00         ; DAUX2
  2824
  2825 				; End of DO_NPWD
  2826 				;---------------------------------------
  2827
  2828 				;---------------------------------------
  2829 11C7			DO_NTRANS:
  2830 				;---------------------------------------
  2831 11C7 AE 70 0C		        LDX     CMDSEP          ; Check if there's any args
  2832 11CA F0 49		        BEQ     NTRANS_ERROR    ; No. Show usage and quit
  2833
  2834 11CC AD 85 18		        LDA     DOSDR           ; Go with current drive for now
  2835 11CF 8D 3F 12		        STA     NTRDCB+1        ; it'll be overwritten later if req'd
  2836
  2837 				    ;---------------------------------------
  2838 				    ; Check for argc = 2
  2839 				    ;---------------------------------------
  2840 11D2 AC 70 0C		        LDY     CMDSEP          ; Stash offset to arg1 in Y
  2841 11D5 AE 71 0C		        LDX     CMDSEP+1        ; Is there an arg2?
  2842 11D8 F0 21		        BEQ     PARSE_MODE      ; No. parse arg1 as mode (0-3)
  2843
  2844 				    ;---------------------------------------
  2845 				    ; Here if argc = 2 (arg1 = Nn: arg2 = mode)
  2846 				    ;---------------------------------------
  2847 11DA AE 70 0C		        LDX     CMDSEP          ; Get offset to arg1 (Nn:)
  2848 11DD BD 82 05		        LDA     LNBUF,X         ; Is arg1's (N[n]:) 1st char = 'N'?
  2849 11E0 C9 4E		        CMP     #'N'            ;
  2850 11E2 D0 31		        BNE     NTRANS_ERROR    ; No? Then quit
  2851 11E4 BD 83 05		        LDA     LNBUF+1,X
  2852 11E7 C9 3A		        CMP     #':'            ; Is arg1's (N[n]:) 2nd char = ':'?
  2853 11E9 F0 10		        BEQ     PARSE_MODE      ; Yes, stick with default drive
  2854
  2855 				    ;---------------------------------------
  2856 				    ; Parse drive number
  2857 				    ;---------------------------------------
  2858 11EB C9 31		        CMP     #'1'            ; Quit if n in Nn not 1..4
  2859 11ED 90 26		        BCC     NTRANS_ERROR    ; Quit if < '1'
  2860 11EF C9 39		        CMP     #'9'
  2861 11F1 B0 22		        BCS     NTRANS_ERROR    ; Quit if >= '9'
  2862 11F3 49 30		        EOR     #%00110000
  2863 11F5 8D 3F 12		        STA     NTRDCB+1
  2864 11F8 AC 71 0C		        LDY     CMDSEP+1
  2865
  2866 				    ;---------------------------------------
  2867 				    ; Confirm valid parameter
  2868 				    ;---------------------------------------
  2869 11FB			PARSE_MODE:
  2870 11FB B9 82 05		        LDA     LNBUF,Y         ; Quit if mode not 0..3
  2871 11FE C9 30		        CMP     #'0'
  2872 1200 90 13		        BCC     NTRANS_ERROR
  2873 1202 C9 34		        CMP     #'4'
  2874 1204 B0 0F		        BCS     NTRANS_ERROR
  2875 1206 49 30		        EOR     #%00110000      ; Here if valid parameter
  2876 1208 8D 49 12		        STA     NTRDCB+11       ; Assign parameter to DCB
  2877
  2878 				    ;---------------------------------------
  2879 				    ; Call SIO
  2880 				    ;---------------------------------------
  2881 120B			NTRANS_CALL:
  2882 120B A9 3E		        LDA     #<NTRDCB
  2883 120D A0 12		        LDY     #>NTRDCB
  2884 120F 20 A5 07		        JSR     DOSIOV
  2885 1212 4C A4 0A		        JMP     PRINT_ERROR
  2886
  2887 1215			NTRANS_ERROR:
  2888 1215 A9 1C		        LDA     #<NTRANS_ERROR_STR
  2889 1217 A0 12		        LDY     #>NTRANS_ERROR_STR
  2890 1219 4C 89 0A		        JMP     PRINT_STRING
  2891
  2892 121C			NTRANS_ERROR_STR:
  2893 121C 4D 4F 44 45 3F 20 +         .BYTE   'MODE? 0=NONE, 1=CR, 2=LF, 3=CR/LF',EOL
  2894
  2895 123E			NTRDCB:
  2896 123E 71			        .BYTE   DEVIDN  ; DDEVIC
  2897 123F FF			        .BYTE   $FF     ; DUNIT
  2898 1240 54			        .BYTE   'T'     ; DCOMND
  2899 1241 00			        .BYTE   $00     ; DSTATS
  2900 1242 00			        .BYTE   $00     ; DBUFL
  2901 1243 00			        .BYTE   $00     ; DBUFH
  2902 1244 1F			        .BYTE   $1F     ; DTIMLO
  2903 1245 00			        .BYTE   $00     ; DRESVD
  2904 1246 00			        .BYTE   $00     ; DBYTL
  2905 1247 00			        .BYTE   $00     ; DBYTH
  2906 1248 00			        .BYTE   $00     ; DAUX1
  2907 1249 00			        .BYTE   $00     ; DAUX2
  2908
  2909 				; End of DO_NTRANS
  2910 				;---------------------------------------
  2911
  2912 				;---------------------------------------
  2913 124A			DO_AUTORUN:
  2914 				;---------------------------------------
  2915 				    ; Change URL stored in AUTORUN app key
  2916 				    ;-----------------------------------
  2917 124A AD 70 0C		        LDA     CMDSEP          ; Check if there's any arg
  2918 124D D0 07		        BNE     AUTORUN_NEXT1   ; If arg found, skip ahead
  2919
  2920 				    ; Here if no command line arg found
  2921 				    ; Print error message and exit
  2922 124F A9 97		        LDA     #<AUTORUN_ERROR_STR
  2923 1251 A0 12		        LDY     #>AUTORUN_ERROR_STR
  2924 1253 4C 89 0A		        JMP     PRINT_STRING
  2925
  2926 1256			AUTORUN_NEXT1:
  2927 				    ; Point to start of arg on command line
  2928 1256 18			        CLC
  2929 1257 65 F3		        ADC     INBUFF          ; INBUFF += CMDSEP
  2930 1259 85 F3		        STA     INBUFF
  2931 125B 8D CB 12		        STA     APPKEYWRITEDCB+4
  2932
  2933 				    ; If "AUTORUN ?" Then abuse AUTORUN_SUBMIT to print appkey
  2934 125E A0 00		        LDY     #$00
  2935 1260 A9 3F		        LDA     #'?'
  2936 1262 8D 91 19		        STA     AUTORUN_QUERY_FLG
  2937 1265 D1 F3		        CMP     (INBUFF),Y
  2938 1267 F0 6A		        BEQ     SUBMIT_AUTORUN
  2939
  2940 				    ; Open app key
  2941 1269 A9 01		        LDA     #$01            ; Open for write (1)
  2942 126B 8D 91 19		        STA     AUTORUN_QUERY_FLG
  2943 126E 8D A1 12		        STA     AUTORUN_APPKEY+4
  2944 1271 A9 AF		        LDA     #<APPKEYOPENDCB
  2945 1273 A0 12		        LDY     #>APPKEYOPENDCB
  2946 1275 20 A5 07		        JSR     DOSIOV
  2947
  2948 				    ; Find length of URL (arg1)
  2949 1278 A0 FF		        LDY     #$FF            ; Init strlen
  2950 127A			AUTORUN_LOOP1
  2951 127A C8			        INY                     ; Incr strlen
  2952 127B B1 F3		        LDA     (INBUFF),Y
  2953 127D C9 9B		        CMP     #EOL            ; At end of string?
  2954 127F D0 F9		        BNE     AUTORUN_LOOP1   ; No. Keep counting
  2955
  2956 1281 A9 0A		        LDA     #LF             ; Convert EOL to LF
  2957 1283 91 F3		        STA     (INBUFF),Y
  2958 1285 C8			        INY                     ; One more for strlen
  2959
  2960 1286			AUTORUN_NEXT2: 
  2961 				    ; Write app key
  2962 1286 8C D1 12		        STY     APPKEYWRITEDCB+10   ; Y = strlen
  2963 1289 A9 C7		        LDA     #<APPKEYWRITEDCB
  2964 128B A0 12		        LDY     #>APPKEYWRITEDCB
  2965 128D 20 A5 07		        JSR     DOSIOV
  2966
  2967 				    ; Close app key
  2968 1290 A9 A3		        LDA     #<APPKEYCLOSEDCB
  2969 1292 A0 12		        LDY     #>APPKEYCLOSEDCB
  2970 1294 4C A5 07		        JMP     DOSIOV
  2971
  2972 1297			AUTORUN_ERROR_STR:
  2973 1297 50 41 54 48 3F 9B	        .BYTE   'PATH?',EOL
  2974
  2975 129D			AUTORUN_APPKEY:
  2976 129D 79 DB		        .WORD   $DB79           ; creator ID
  2977 129F 00			        .BYTE   $00             ; app ID
  2978 12A0 00			        .BYTE   $00             ; key ID
  2979 12A1 00			        .BYTE   $00             ; read or write mode
  2980 12A2 00			        .BYTE   $00             ; unused
  2981
  2982 12A3			APPKEYCLOSEDCB:
  2983 12A3 70			        .BYTE   $70             ; DDEVIC
  2984 12A4 01			        .BYTE   $01             ; DUNIT
  2985 12A5 DB			        .BYTE   $DB             ; DCOMND
  2986 12A6 00			        .BYTE   $00             ; DSTATS
  2987 12A7 00			        .BYTE   $00             ; DBUFL
  2988 12A8 00			        .BYTE   $00             ; DBUFH
  2989 12A9 0F			        .BYTE   $0F             ; DTIMLO
  2990 12AA 00			        .BYTE   $00             ; DRESVD
  2991 12AB 00			        .BYTE   $00             ; DBYTL
  2992 12AC 00			        .BYTE   $00             ; DBYTH
  2993 12AD 00			        .BYTE   $00             ; DAUX1
  2994 12AE 00			        .BYTE   $00             ; DAUX2
  2995
  2996 12AF			APPKEYOPENDCB:
  2997 12AF 70			        .BYTE   $70             ; DDEVIC
  2998 12B0 01			        .BYTE   $01             ; DUNIT
  2999 12B1 DC			        .BYTE   $DC             ; DCOMND
  3000 12B2 80			        .BYTE   $80             ; DSTATS
  3001 12B3 9D			        .BYTE   <AUTORUN_APPKEY ; DBUFL
  3002 12B4 12			        .BYTE   >AUTORUN_APPKEY ; DBUFH
  3003 12B5 0F			        .BYTE   $0F             ; DTIMLO
  3004 12B6 00			        .BYTE   $00             ; DRESVD
  3005 12B7 06			        .BYTE   $06             ; DBYTL
  3006 12B8 00			        .BYTE   $00             ; DBYTH
  3007 12B9 00			        .BYTE   $00             ; DAUX1
  3008 12BA 00			        .BYTE   $00             ; DAUX2
  3009
  3010 12BB			APPKEYREADDCB:
  3011 12BB 70			        .BYTE   $70             ; DDEVIC
  3012 12BC 01			        .BYTE   $01             ; DUNIT
  3013 12BD DD			        .BYTE   $DD             ; DCOMND
  3014 12BE 40			        .BYTE   $40             ; DSTATS
  3015 12BF 82			        .BYTE   <LNBUF          ; DBUFL
  3016 12C0 05			        .BYTE   >LNBUF          ; DBUFH
  3017 12C1 01			        .BYTE   $01             ; DTIMLO - minimize timeout
  3018 12C2 00			        .BYTE   $00             ; DRESVD
  3019 12C3 40			        .BYTE   MAX_APPKEY_LEN  ; DBYTL
  3020 12C4 00			        .BYTE   $00             ; DBYTH
  3021 12C5 00			        .BYTE   $00             ; DAUX1
  3022 12C6 00			        .BYTE   $00             ; DAUX2
  3023
  3024 12C7			APPKEYWRITEDCB:
  3025 12C7 70			        .BYTE   $70             ; DDEVIC
  3026 12C8 01			        .BYTE   $01             ; DUNIT
  3027 12C9 DE			        .BYTE   $DE             ; DCOMND
  3028 12CA 80			        .BYTE   $80             ; DSTATS
  3029 12CB FF			        .BYTE   $FF             ; DBUFL
  3030 12CC 05			        .BYTE   $05             ; DBUFH (expect page 5)
  3031 12CD 0F			        .BYTE   $0F             ; DTIMLO
  3032 12CE 00			        .BYTE   $00             ; DRESVD
  3033 12CF 40			        .BYTE   MAX_APPKEY_LEN  ; DBYTL
  3034 12D0 00			        .BYTE   $00             ; DBYTH
  3035 12D1 FF			        .BYTE   $FF             ; DAUX1 (# actual bytes)
  3036 12D2 00			        .BYTE   $00             ; DAUX2
  3037
  3038 				;---------------------------------------
  3039 12D3			SUBMIT_AUTORUN:
  3040 				;---------------------------------------
  3041 				    ; At initial DOS boot, read URL for 
  3042 				    ; app key file from SD card's
  3043 				    ; FujiNet folder.
  3044 				    ;
  3045 				    ; filename: db790000.key
  3046 				    ; contents: url to a batch file
  3047 				    ;---------------------------------------
  3048 12D3 20 72 0A		        JSR     LDBUFA
  3049
  3050 				    ; Open app key
  3051 12D6 A9 00		        LDA     #$00            ; Open for read
  3052 12D8 8D A1 12		        STA     AUTORUN_APPKEY+4
  3053 12DB A9 AF		        LDA     #<APPKEYOPENDCB
  3054 12DD A0 12		        LDY     #>APPKEYOPENDCB
  3055 12DF 20 A5 07		        JSR     DOSIOV
  3056
  3057 12E2 C0 01		        CPY     #$01            ; Was open successful?
  3058 12E4 F0 01		        BEQ     AUTOSUB_NEXT    ; Yes. Continue.
  3059 12E6 60			        RTS                     ; No. Exit
  3060
  3061 12E7			AUTOSUB_NEXT:
  3062 				    ; Read app key
  3063 12E7 A9 BB		        LDA     #<APPKEYREADDCB
  3064 12E9 A0 12		        LDY     #>APPKEYREADDCB
  3065 12EB 20 A5 07		        JSR     DOSIOV
  3066
  3067 				    ; Close app key
  3068 12EE A9 A3		        LDA     #<APPKEYCLOSEDCB
  3069 12F0 A0 12		        LDY     #>APPKEYCLOSEDCB
  3070 12F2 20 A5 07		        JSR     DOSIOV
  3071
  3072 				    ; Does the returned URL contain something?
  3073 12F5 AE 82 05		        LDX     LNBUF           ; X contains strlen of AUTORUN path
  3074 12F8 D0 01		        BNE     AUTORUN_CALL_SUBMIT
  3075
  3076
  3077 12FA			AUTOSUB_DONE:
  3078 12FA 60			        RTS
  3079
  3080 12FB			AUTORUN_CALL_SUBMIT:
  3081 				    ; Replace end-of-line in buffer with null terminator
  3082 12FB CA			        DEX                     ; Move index back 1 position
  3083 12FC A9 00		        LDA     #$00            ;
  3084 12FE 9D 84 05		        STA     LNBUF+2,X       ; Write null-terminator 
  3085 1301 A9 02		        LDA     #$02            ; Change arg1 location...
  3086 1303 8D 70 0C		        STA     CMDSEP          ;  to point to filename
  3087
  3088 				    ;---------------------------------------
  3089 				    ; If here because of "AUTORUN ?", then
  3090 				    ; print contents of appkey file. But first
  3091 				    ; we have to terminate appkey string with EOL
  3092 				    ;---------------------------------------
  3093 1306 AD 91 19		        LDA     AUTORUN_QUERY_FLG
  3094 1309 C9 3F		        CMP     #'?'
  3095 130B D0 18		        BNE     SUBMIT_NEXT1
  3096
  3097 130D A9 9B		        LDA     #EOL            ; Inject EOL to terminate string
  3098 130F 9D 84 05		        STA     LNBUF+2,X
  3099 1312 A9 84		        LDA     #<(LNBUF+2)
  3100 1314 A0 05		        LDY     #>(LNBUF+2)
  3101 1316 4C 89 0A		        JMP     PRINT_STRING    ; Print AUTORUN path and sneak out
  3102
  3103 				;---------------------------------------
  3104 1319			DO_SUBMIT:
  3105 				;---------------------------------------
  3106 1319 AD 70 0C		        LDA     CMDSEP
  3107 131C D0 07		        BNE     SUBMIT_NEXT1
  3108
  3109 				    ; Filename required
  3110 131E A9 7F		        LDA     #<MISSING_FILE_STR
  3111 1320 A0 18		        LDY     #>MISSING_FILE_STR
  3112 1322 4C 89 0A		        JMP     PRINT_STRING
  3113
  3114 1325			SUBMIT_NEXT1:
  3115
  3116 				    ; Default to NOSCREEN
  3117 1325 A9 00		        LDA     #$00
  3118 1327 8D 88 18		        STA     ECHO_FLG
  3119
  3120 				    ; Prep file path
  3121 132A 20 5B 0D		        JSR     GET_DOSDR       ; Get DUNIT
  3122 132D 20 B1 16		        JSR     PREPEND_DRIVE
  3123
  3124 				    ; Assert FILE #1 is closed
  3125 1330 A2 10		        LDX     #$10
  3126 1332 20 BB 09		        JSR     CIOCLOSE
  3127 				        
  3128 				    ; OPEN #1, 4, 0, file path
  3129 1335 A2 10		        LDX     #$10            ; File #1
  3130 1337 A0 04		        LDY     #$04            ; Open for input
  3131 1339 20 C3 09		        JSR     CIOOPEN         ; Open filename @ (INBUFF)
  3132 133C 10 03		        BPL     SUBMIT_NEXT2
  3133 133E 4C A4 0A		        JMP     PRINT_ERROR
  3134
  3135 				    ; Read batch file character by character
  3136 				    ; This allows it be end-of-line agnostic
  3137 				    ; Branch forward when an end-of-line is interpretted.
  3138
  3139 1341			SUBMIT_NEXT2:
  3140 1341 20 72 0A		        JSR     LDBUFA      ; Reset INBUFF to $0580
  3141 1344 C6 F3		        DEC     INBUFF      ; Init 1 byte before buffer
  3142 1346 A9 FF		        LDA     #$FF        ; Clear command
  3143 1348 8D 86 18		        STA     CMD
  3144
  3145 134B			SUBMIT_GETCH:
  3146 134B E6 F3		        INC     INBUFF          ; Advance pointer
  3147 134D D0 02		        BNE     SUBMIT_NEXT3
  3148 134F E6 F4		        INC     INBUFF+1
  3149
  3150 1351			SUBMIT_NEXT3:
  3151 1351 A2 10		        LDX     #$10            ; OPEN #1
  3152 1353 A9 01		        LDA     #$01            ; Get 1 byte
  3153 1355 A0 00		        LDY     #$00            ; ditto
  3154
  3155 1357 20 F0 09		        JSR     CIOGET          ; Get byte from file
  3156 135A A0 00		        LDY     #$00            ;
  3157 135C B1 F3		        LDA     (INBUFF),Y      ; byte will be here
  3158 				        
  3159 135E C9 0D		        CMP     #CR             ; Just skip if Windows CR
  3160 1360 F0 E9		        BEQ     SUBMIT_GETCH
  3161
  3162 1362 C9 0A		        CMP     #LF             ; Convert LF to EOL
  3163 1364 D0 04		        BNE     SUBMIT_EOL
  3164 1366 A9 9B		        LDA     #EOL
  3165 1368 91 F3		        STA     (INBUFF),Y
  3166
  3167 136A			SUBMIT_EOL:
  3168 136A C9 9B		        CMP     #EOL            ; At end of command line?
  3169 136C D0 DD		        BNE     SUBMIT_GETCH    ; No. Get next byte.
  3170
  3171 				    ; Here if we've reached the end of a command line.
  3172 				    ; At end of file?
  3173 136E A2 10		        LDX     #$10            ; Channel #1
  3174 1370 BD 43 03		        LDA     ICSTA,X         ; Inspect return code
  3175 1373 C9 88		        CMP     #EOF
  3176 1375 F0 22		        BEQ     SUBMIT_DONE     ; No error, try parsing cmd
  3177
  3178 1377 AD 88 18		        LDA     ECHO_FLG        ; Skip echo if SCREEN is disabled
  3179 137A F0 11		        BEQ     SUBMIT_NEXT4
  3180 137C AD 82 05		        LDA     LNBUF
  3181 137F C9 40		        CMP     #'@'            ; Skip lines beginning with @
  3182 1381 F0 0A		        BEQ     SUBMIT_NEXT4
  3183
  3184 				    ; Echo commands
  3185 1383 20 72 0A		        JSR     LDBUFA
  3186 1386 A5 F3		        LDA     INBUFF
  3187 1388 A4 F4		        LDY     INBUFF+1
  3188 138A 20 89 0A		        JSR     PRINT_STRING
  3189
  3190 138D			SUBMIT_NEXT4:
  3191 138D 20 1E 0C		        JSR     GETCMDTEST
  3192 1390 20 76 0C		        JSR     PARSECMD
  3193 1393 20 29 0D		        JSR     DOCMD
  3194 1396 38			        SEC
  3195 1397 B0 A8		        BCS     SUBMIT_NEXT2
  3196
  3197 1399			SUBMIT_DONE
  3198 1399 A2 10		        LDX     #$10
  3199 139B 4C BB 09		        JMP     CIOCLOSE
  3200
  3201 				; End of DO_SUBMIT
  3202 				;---------------------------------------
  3203
  3204 				; Open Nn: for read
  3205 				; Open E: or P: for write
  3206 				; Read byte
  3207 				; Write byte
  3208
  3209 				;---------------------------------------
  3210 139E			DO_TYPE:
  3211 				;---------------------------------------
  3212 139E AD 70 0C		        LDA     CMDSEP
  3213 13A1 D0 07		        BNE     TYPE_SKIP
  3214
  3215 13A3			TYPE_USAGE:
  3216 13A3 A9 7F		        LDA     #<MISSING_FILE_STR
  3217 13A5 A0 18		        LDY     #>MISSING_FILE_STR
  3218 13A7 4C 89 0A		        JMP     PRINT_STRING
  3219
  3220 13AA			TYPE_SKIP:
  3221 13AA 20 5B 0D		        JSR     GET_DOSDR       ; Get DUNIT
  3222 13AD 20 B1 16		        JSR     PREPEND_DRIVE
  3223
  3224 				    ; Assert input file closed
  3225 13B0 A2 10		        LDX     #$10            ; File #1
  3226 13B2 20 BB 09		        JSR     CIOCLOSE        ; Assert file #1 is closed
  3227
  3228 				    ; Open input file
  3229 13B5 A2 10		        LDX     #$10            ; File #1
  3230 13B7 A0 04		        LDY     #$04            ; Open for input
  3231 13B9 20 C3 09		        JSR     CIOOPEN         ; Open filename @ (INBUFF)
  3232 13BC 10 08		        BPL     TYPE_NEXT
  3233
  3234 				    ; If open failed, Print error
  3235 13BE A2 10		        LDX     #$10            ; File #1
  3236 13C0 BC 43 03		        LDY     ICSTA,X
  3237 13C3 4C A4 0A		        JMP     PRINT_ERROR
  3238
  3239 13C6			TYPE_NEXT:
  3240
  3241 				    ; Initialize pagination
  3242 13C6 EE A0 18		    INC PRINT_ERR_FLG         ; Are we here from PRINT_ERROR (CMD will now be $00)
  3243 13C9 F0 2A		    BEQ TYPE_READ
  3244 13CB 20 6E 14		        JSR     DO_CLS
  3245 13CE A9 15		        LDA     #21
  3246 13D0 8D BB 02		        STA     SCRFLG
  3247
  3248 13D3			TYPE_LOOP:
  3249 				    ; Bail if ESC key is pressed
  3250 13D3 AD FC 02		        LDA     CH
  3251 13D6 C9 1C		        CMP     #ESC_KEY
  3252 13D8 F0 49		        BEQ     TYPE_DONE
  3253
  3254 				    ; Check if page is full
  3255 13DA AD BB 02		        LDA     SCRFLG
  3256 13DD C9 16		        CMP     #22             ; if SCRFLG < 21
  3257 13DF 90 14		        BCC     TYPE_READ       ; then skip to read
  3258
  3259 				    ; Here if page is full
  3260 				    ; Wait for keypress
  3261 13E1 A9 FF		        LDA     #$FF            ; Clear keypress
  3262 13E3 8D FC 02		        STA     CH
  3263
  3264 13E6			TYPE_WAIT:
  3265 13E6 AE FC 02		        LDX     CH              ; Will be $FF if no keypress
  3266 13E9 E8			        INX                     ; $FF --> $00
  3267 13EA F0 FA		        BEQ     TYPE_WAIT       ; Keep waiting if $00
  3268
  3269 13EC E0 1C		        CPX     #ESC_KEY        ; Leave if ESC key pressed
  3270 13EE F0 33		        BEQ     TYPE_DONE
  3271
  3272 				    ; Reset pagination
  3273 13F0 A9 00		        LDA     #$00
  3274 13F2 8D BB 02		        STA     SCRFLG
  3275
  3276 13F5			TYPE_READ:
  3277 				    ; Read from file
  3278 13F5 A2 10		        LDX     #$10
  3279 13F7 A9 01		        LDA     #$01
  3280 13F9 A0 00		        LDY     #$00
  3281 13FB 20 F0 09		        JSR     CIOGET
  3282
  3283 				    ; Quit if EOF
  3284 13FE A2 10		        LDX     #$10
  3285 1400 BD 43 03		        LDA     ICSTA,X
  3286 1403 C9 88		        CMP     #EOF
  3287 1405 F0 1C		        BEQ     TYPE_DONE
  3288
  3289 				    ; Convert CRLF or LF --> EOL
  3290 1407 A0 00		        LDY     #$00
  3291 1409 B1 F3		        LDA     (INBUFF),Y
  3292 140B C9 0D		        CMP     #CR     ; Skip CR
  3293 140D F0 11		        BEQ     TYPE_NEXT3
  3294 140F C9 0A		        CMP     #LF     ; Convert LF --> EOL
  3295 1411 D0 04		        BNE     TYPE_NEXT2
  3296 1413 A9 9B		        LDA     #EOL
  3297 1415 91 F3		        STA     (INBUFF),Y
  3298
  3299 1417			TYPE_NEXT2:
  3300 				    ; Write to screen
  3301 1417 A2 00		        LDX     #$00
  3302 1419 A9 01		        LDA     #$01
  3303 141B A0 00		        LDY     #$00
  3304 141D 20 0E 0A		        JSR     CIOPUT
  3305
  3306 1420			TYPE_NEXT3:
  3307 				    ; Do next
  3308 1420 4C D3 13		        JMP     TYPE_LOOP
  3309 				        
  3310 1423			TYPE_DONE:
  3311 1423 A9 FF		        LDA     #$FF
  3312 1425 8D FC 02		        STA     CH
  3313 1428 A2 10		        LDX     #$10            ; Close File #1
  3314 142A 4C BB 09		        JMP     CIOCLOSE        ; 
  3315
  3316 142D			TYPE_OPEN_ERR_STR:
  3317 142D 55 4E 41 42 4C 45 +         .BYTE   'UNABLE TO OPEN FILE',EOL
  3318
  3319 				;---------------------------------------
  3320 1441			DO_UNLOCK:
  3321 				;---------------------------------------
  3322 1441 A9 90		        LDA     #$90
  3323 1443 8D C6 02		        STA     COLOR2
  3324 1446 60			        RTS
  3325
  3326 				;---------------------------------------
  3327 1447			DO_CAR:
  3328 				;---------------------------------------
  3329
  3330 				    ;---------------------------------------
  3331 				    ; Is cart address space RAM or ROM?
  3332 				    ;---------------------------------------
  3333 1447 20 8B 0B		        JSR     CHECK_IF_ROM    ; returns Y=1 -> ROM. Y=0 -> RAM.
  3334 144A 98			        TYA                     ; Xfer affects Z flag
  3335 144B D0 07		        BNE     DO_CAR_NEXT     ; if Y=1 (ROM) skip ahead
  3336
  3337 				    ;---------------------------------------
  3338 				    ; RAM found
  3339 				    ;---------------------------------------
  3340 144D A9 61		        LDA     #<DO_CAR_ERR
  3341 144F A0 14		        LDY     #>DO_CAR_ERR
  3342 1451 4C 89 0A		        JMP     PRINT_STRING    ; Print error and bail
  3343
  3344 1454			DO_CAR_NEXT:
  3345 				    ;---------------------------------------
  3346 				    ; Border used to indicate program in ROM
  3347 				    ; Revert border before returning to ROM
  3348 				    ;---------------------------------------
  3349 1454 AD A1 18		        LDA     COLOR4_ORIG     
  3350 1457 8D C8 02		        STA     COLOR4          ; Reset border to orig color
  3351
  3352 				    ;---------------------------------------
  3353 				    ; Warmstart
  3354 				    ;---------------------------------------
  3355 145A A9 FF		        LDA     #$FF
  3356 145C 85 08		        STA     $08
  3357 145E 6C FA BF		        JMP     ($BFFA)         ; Bye
  3358
  3359 1461			DO_CAR_ERR:
  3360 1461 4E 4F 20 43 41 52 +         .BYTE   'NO CARTRIDGE',EOL
  3361
  3362 				;---------------------------------------
  3363 146E			DO_CLS:
  3364 				;---------------------------------------
  3365 146E A9 75		        LDA     #<CLS_STR
  3366 1470 A0 14		        LDY     #>CLS_STR
  3367 1472 4C 89 0A		        JMP     PRINT_STRING
  3368
  3369 1475			CLS_STR:
  3370 1475 7D 9B		        .BYTE   125,EOL
  3371
  3372 				;---------------------------------------
  3373 1477			DO_COLD:
  3374 				;---------------------------------------
  3375 1477 4C 77 E4		        JMP     COLDSV
  3376
  3377 				;---------------------------------------
  3378 147A			DO_HELP:
  3379 				;---------------------------------------
  3380 				    ; Append either "HELP" or arg1 to URL
  3381 147A A2 00		        LDX     #$00        ; index to start of article buf
  3382 147C AC 70 0C		        LDY     CMDSEP      ; index to cmd line arg
  3383 				        
  3384 147F			HELP_LOOP1:
  3385 147F B1 F3		        LDA     (INBUFF),Y
  3386 1481 C9 9B		        CMP     #EOL
  3387 1483 F0 14		        BEQ     HELP_NEXT1  ; Exit loop at end of arg
  3388 1485 E0 16		        CPX     #22
  3389 1487 10 2E		        BPL     HELP_DONE   ; Exit if arg is too long
  3390
  3391 				    ; Convert lower-case to upper-case
  3392 1489 20 60 0A		        JSR     TOUPPER
  3393 148C 9D 13 15		        STA     HELP_ARTICLE,X
  3394 148F E8			        INX
  3395 1490 C8			        INY
  3396 1491 D0 EC		        BNE     HELP_LOOP1  ; Always true
  3397
  3398 				    ; Append .DOC extension to article name
  3399 1493			HELP_EXT:
  3400 1493 2E 44 4F 43 9B 00	        .BYTE   '.DOC',EOL,$00
  3401
  3402 1499			HELP_NEXT1:
  3403 1499 A0 00		        LDY     #$00
  3404
  3405 149B			HELP_LOOP2:
  3406 149B B9 93 14		        LDA     HELP_EXT,Y
  3407 149E 9D 13 15		        STA     HELP_ARTICLE,X  ; Store null term too
  3408 14A1 F0 04		        BEQ     HELP_NEXT2      ; Skip ahead if terminator
  3409 14A3 E8			        INX
  3410 14A4 C8			        INY
  3411 14A5 D0 F4		        BNE     HELP_LOOP2  ; Always true
  3412
  3413 14A7			HELP_NEXT2:
  3414 				    ; Copy URL to LNBUF
  3415 14A7 A2 00		        LDX     #$00    ; Index to start of HELP_URL
  3416 14A9 A0 05		        LDY     #$05    ; Index to start at arg1 for "TYPE "
  3417 				    
  3418 14AB			HELP_LOOP3:
  3419 14AB BD BF 14		        LDA     HELP_URL,X  ; Get source byte
  3420 14AE 99 82 05		        STA     LNBUF,Y     ; Write to target location
  3421 14B1 F0 04		        BEQ     HELP_DONE   ; Exit loop on null terminator
  3422 14B3 E8			        INX                 ; Advance indices
  3423 14B4 C8			        INY
  3424 14B5 D0 F4		        BNE     HELP_LOOP3  ; Always true
  3425 				        
  3426 14B7			HELP_DONE:        
  3427 14B7 A9 05		        LDA     #$05        ; Trick TYPE to look for URL in arg1
  3428 14B9 8D 70 0C		        STA     CMDSEP
  3429 14BC 4C 9E 13		        JMP     DO_TYPE
  3430
  3431 14BF			HELP_URL:
  3432 14BF 4E 38 3A 48 54 54 +         .BYTE   'N8:HTTPS://raw.githubusercontent.com/michaelsternberg/fujinet-nhandler/nos/nos/HELP/'
  3433
  3434 1513			HELP_ARTICLE:
  3435 1513 00 00 00 00 00 00 +     :24 .BYTE   $00
  3436
  3437 				;---------------------------------------
  3438 152B			DO_BASIC:
  3439 				;---------------------------------------
  3440 				    ; Enable or disable BASIC (or, say, U1MB ROM)
  3441 				    ; Usage: [BASIC|ROM] [ON|OFF]
  3442 				    
  3443 				    ; Quit if no internal BASIC
  3444 152B 20 4F 0B		        JSR     CHECK_INTERNAL_BASIC
  3445 152E B0 46		        BCS     BASIC_QUIT
  3446
  3447 				    ; Check for usage. arg (BASIC ON|OFF)
  3448 1530 AE 70 0C		        LDX     CMDSEP
  3449 1533 BD 82 05		        LDA     LNBUF,X
  3450 1536 29 DF		        AND     #%11011111  ; Convert lower to upper
  3451 1538 C9 4F		        CMP     #'O'        ; Is 1st char O? as in ON|OFF
  3452 153A D0 3B		        BNE     BASIC_USAGE
  3453 153C E8			        INX
  3454 153D BD 82 05		        LDA     LNBUF,X
  3455 1540 29 DF		        AND     #%11011111  ; Convert lower to upper
  3456 1542 C9 46		        CMP     #'F'        ; Is 2nd char F? as in OFF?
  3457 1544 F0 22		        BEQ     BASIC_OFF
  3458 1546 C9 4E		        CMP     #'N'        ; Is 2nd char N? as in ON?
  3459 1548 D0 2D		        BNE     BASIC_USAGE
  3460
  3461 				    ;---------------------------------------
  3462 				    ; We are here if BASIC ON or ROM ON was the command. 
  3463 				    ; Do a favor and jump to CAR if ROM is already enabled
  3464 				    ;---------------------------------------
  3465 154A AD 01 D3		        LDA     PORTB
  3466 154D 29 02		        AND     #%00000010
  3467 154F D0 03		        BNE     BASIC_ON
  3468 1551 4C 47 14		        JMP     DO_CAR
  3469
  3470 1554			BASIC_ON:
  3471 				    ;---------------------------------------
  3472 				    ; Source: ANTIC Volume 4 #10 Feb 1986
  3473 				    ; BASIC ON/OFF Switcher [Chadwick]
  3474
  3475 				    ;---------------------------------------
  3476 				    ; Enable BASIC in XL/XE
  3477 				    ;---------------------------------------
  3478 1554 A9 00		        LDA     #$00
  3479 1556 8D F8 03		        STA     BASICF      ; BASIC RAM FLAG
  3480 1559 A9 52		        LDA     #$52
  3481 155B 8D EB 03		        STA     $03EB       ; CARTRIDGE CHECKSUM
  3482
  3483 155E AD 01 D3		        LDA     PORTB
  3484 1561 29 FD		        AND     #%11111101  ; If Bit 1 = 0 then BASIC is enabled
  3485 1563 8D 01 D3		        STA     PORTB       ; BASIC ROM FLAG
  3486 1566 D0 0B		        BNE     BASIC_WARM  ; Always jump
  3487
  3488 1568			BASIC_OFF:
  3489 				    ;---------------------------------------
  3490 				    ; Disable BASIC in XL/XE
  3491 				    ;---------------------------------------
  3492 1568 A9 01		        LDA     #$01
  3493 156A 8D F8 03		        STA     BASICF
  3494 				    ;---------------------------------------
  3495 				    ; Change border color as reminder that
  3496 				    ; we're working with limited addr space
  3497 				    ;---------------------------------------
  3498 156D AD A1 18		        LDA     COLOR4_ORIG
  3499 1570 8D C8 02		        STA     COLOR4      
  3500
  3501 1573			BASIC_WARM:
  3502 1573 4C 74 E4		        JMP     WARMSV  ; XL/XE WARMSTART
  3503
  3504 1576			BASIC_QUIT:
  3505 1576 60			        RTS
  3506
  3507 1577			BASIC_USAGE:
  3508 1577 A9 7E		        LDA     #<BASIC_ERROR
  3509 1579 A0 15		        LDY     #>BASIC_ERROR
  3510 157B 4C 89 0A		        JMP     PRINT_STRING
  3511
  3512 157E			BASIC_ERROR:
  3513 157E 5B 42 41 53 49 43 +         .BYTE   '[BASIC|ROM] [ON|OFF]',EOL
  3514
  3515 				;;---------------------------------------
  3516 				;DO_NOBASIC:
  3517 				;;---------------------------------------
  3518 				;        JSR     CHECK_INTERNAL_BASIC
  3519 				;        BCS     NOBASIC_QUIT
  3520
  3521
  3522 				;---------------------------------------
  3523 1593			DO_NOSCREEN:
  3524 				;---------------------------------------
  3525 1593 A9 00		        LDA     #$00
  3526 1595 8D 88 18		        STA     ECHO_FLG    ; Disable echo in batch processing
  3527 1598 60			        RTS
  3528
  3529 				;---------------------------------------
  3530 1599			DO_SCREEN:
  3531 				;---------------------------------------
  3532 1599 A9 01		        LDA     #$01
  3533 159B 8D 88 18		        STA     ECHO_FLG    ; Enable echo in batch processing
  3534 159E 60			        RTS
  3535
  3536 				;---------------------------------------
  3537 159F			DO_PRINT:
  3538 				;---------------------------------------
  3539 159F AD 70 0C		        LDA     CMDSEP
  3540 15A2 F0 08		        BEQ     PRINT_DONE
  3541
  3542 15A4 18			        CLC
  3543 15A5 65 F3		        ADC     INBUFF
  3544 15A7 A4 F4		        LDY     INBUFF+1
  3545 15A9 4C 89 0A		        JMP     PRINT_STRING
  3546
  3547 15AC			PRINT_DONE:
  3548 15AC 60			        RTS
  3549
  3550 				;---------------------------------------
  3551 15AD			DO_REENTER:
  3552 				;---------------------------------------
  3553 				    ; Jump to the address stored in RUNAD or INITAD
  3554 				    ; Do the one that isn't pointing to R (RUNAD first)
  3555
  3556 				    ; Skip it all if both contain $0000
  3557 15AD AD E2 02		        LDA     INITAD
  3558 15B0 D0 16		        BNE     DO_REENTER_CONT
  3559 15B2 AD E3 02		        LDA     INITAD+1
  3560 15B5 D0 11		        BNE     DO_REENTER_CONT
  3561 15B7 AD E0 02		        LDA     RUNAD
  3562 15BA D0 0C		        BNE     DO_REENTER_CONT
  3563 15BC AD E1 02		        LDA     RUNAD+1
  3564 15BF D0 07		        BNE     DO_REENTER_CONT
  3565
  3566 15C1 A9 DC		        LDA     #<DO_REENTER_ERR
  3567 15C3 A0 15		        LDY     #>DO_REENTER_ERR
  3568 15C5 4C 89 0A		        JMP     PRINT_STRING
  3569
  3570 15C8			DO_REENTER_CONT:
  3571 15C8 AD E0 02		        LDA     RUNAD
  3572 15CB C9 0F		        CMP     #>R
  3573 15CD D0 07		        BNE     DO_REENTER_RUNAD
  3574 15CF AD E1 02		        LDA     RUNAD+1
  3575 15D2 C9 0F		        CMP     #>R
  3576 15D4 F0 03		        BEQ     DO_REENTER_INITAD
  3577
  3578 15D6			DO_REENTER_RUNAD:
  3579 15D6 6C E0 02		        JMP     (RUNAD)     ; Godspeed
  3580
  3581 15D9			DO_REENTER_INITAD:
  3582 15D9 6C E2 02		        JMP     (INITAD)    ; Godspeed
  3583
  3584 15DC			DO_REENTER_ERR:
  3585 15DC 4E 4F 20 41 44 44 +         .BYTE   'NO ADDR IN INITAD OR RUNAD',EOL
  3586
  3587 				;---------------------------------------
  3588 15F7			DO_REM:
  3589 				;---------------------------------------
  3590 15F7 60			        RTS
  3591
  3592 				;---------------------------------------
  3593 15F8			DO_RUN:
  3594 				;---------------------------------------
  3595 15F8 AD 70 0C		        LDA     CMDSEP      ; Get position for address arg
  3596 15FB A8			        TAY                 ; Offset to arg used later
  3597 15FC 18			        CLC
  3598 15FD 69 04		        ADC     #$04
  3599 15FF 8D 00 19		        STA     RBUF
  3600
  3601 1602 20 0A 0B		        JSR     ASCII2ADDR  ; Convert text to an addr
  3602 1605 B0 F0		        BCS     DO_REM      ; Re-use nearby RTS
  3603 				        
  3604 1607 6C F3 00		        JMP     (INBUFF)    ;
  3605
  3606 				;---------------------------------------
  3607 160A			DO_SAVE:
  3608 				;---------------------------------------
  3609 				    ; INBUFF points to Filename
  3610 				    ; LNBUF,Y is start of 4 char ASCII hex string
  3611
  3612 160A A9 B0		        LDA     #$B0
  3613 160C 8D C6 02		        STA     COLOR2
  3614
  3615 				    ; Store address of INBUFF + CMDSEP in STL, STH
  3616 160F 18			        CLC
  3617 1610 A5 F3		        LDA     INBUFF
  3618 1612 6D 70 0C		        ADC     CMDSEP
  3619 1615 8D 80 19		        STA     STL
  3620 1618 A5 F4		        LDA     INBUFF+1
  3621 161A 69 00		        ADC     #$00
  3622 161C 8D 81 19		        STA     STH
  3623
  3624 161F 60			        RTS
  3625 				    ; Loop until comma found, replace it with EOL,
  3626 				    ; and store address in STL, STH
  3627
  3628 				;        LDY     CMDSEP
  3629 				;        DEY
  3630 				;@:      INY
  3631 				;        LDA     #EOL
  3632 				;        INY
  3633 				;        CMP     (INBUFF),Y
  3634 				;        BEQ     SAVE_USAGE
  3635 				;        BNE     @-
  3636 				;        STA
  3637 				;        RTS
  3638 				;
  3639 				;    ; Loop until EOL is found
  3640 				;    ; Move addr args to STL, STH, ..
  3641 				;        LDX     #$00        ; X will hold number of addr args
  3642 				;        LDY     CMDSEP
  3643 				;        CLC
  3644 				;SAVE_LOOP0:
  3645 				;        LDA     (INBUFF),Y
  3646 				;
  3647 				;        CMP     #EOL        ; If EOL then skip ahead
  3648 				;        BEQ     @++
  3649 				;
  3650 				;        CMP     #','
  3651 				;        BNE     @+
  3652 				;        
  3653 				;        INX
  3654 				;        CPX     #$05        ; If number of commas >= 5
  3655 				;        BCS     SAVE_USAGE  ; Then quit
  3656 				;       
  3657 				;        INY
  3658 				;        TYA
  3659 				;        STA     CMPSEP,X
  3660 				;@:      BNE     SAVE_LOOP0  ; Always true
  3661 				;
  3662 				;
  3663 				;    ; Check # of args
  3664 				;@:      CPX     #$03
  3665 				;
  3666 				;    ; Save addresses to TBUF 
  3667 				;    ; Save lo bytes in 1st list
  3668 				;    ; Save hi bytes in 2nd list
  3669 				;SAVE_LOOP1:
  3670 				;        INX
  3671 				;        LDA     CMDSEP,X
  3672 				;        BEQ     SAVE_SKIP1
  3673 				;        JSR     ASCII2ADDR
  3674 				;        LDA     INBUFF          ; Lo byte
  3675 				;        STA     TBUF,X
  3676 				;        LDA     INBUFF+1        ; Hi byte
  3677 				;        STA     TBUF+4,X
  3678 				;SAVE_SKIP1:
  3679 				;        DEX
  3680 				;        DEX
  3681 				;        BNE     SAVE_LOOP1
  3682 				;
  3683 				;        RTS
  3684 1620			SAVE_USAGE:
  3685 1620 A9 27		        LDA     #<SAVE_ERROR_STR
  3686 1622 A0 16		        LDY     #>SAVE_ERROR_STR
  3687 1624 4C 89 0A		        JMP     PRINT_STRING
  3688
  3689 1627			SAVE_ERROR_STR:
  3690 1627 53 41 56 45 20 4E +         .BYTE   'SAVE Nn:FILE,START,END(,INIT)(,RUN)',EOL
  3691 				;
  3692 				; End of DO_SAVE
  3693 				;---------------------------------------
  3694
  3695 				;---------------------------------------
  3696 164B			DO_WARM:
  3697 				;---------------------------------------
  3698 164B 4C 74 E4		        JMP     WARMSV
  3699
  3700 				;---------------------------------------
  3701 164E			DO_XEP:
  3702 				;---------------------------------------
  3703 164E A0 19		        LDY     #$19        ; CMD = $19 (enter 40 col)
  3704 1650 AE 70 0C		        LDX     CMDSEP
  3705 1653 BD 82 05		        LDA     LNBUF,X
  3706 1656 C9 34		        CMP     #'4'
  3707 1658 F0 01		        BEQ     @+
  3708 165A 88			        DEY                 ; CMD = $18 (enter 80 col)
  3709 				@:      
  3710 165B A2 00		        LDX     #$00
  3711 165D 98			        TYA
  3712 165E 9D 42 03		        STA     ICCOM,X
  3713 1661 A9 7B		        LDA     #<EDEV
  3714 1663 9D 44 03		        STA     ICBAL,X
  3715 1666 A9 16		        LDA     #>EDEV
  3716 1668 9D 45 03		        STA     ICBAH,X
  3717 166B A9 2C		        LDA     #$2C
  3718 166D 9D 4A 03		        STA     ICAX1,X
  3719 1670 A9 00		        LDA     #$00
  3720 1672 9D 4B 03		        STA     ICAX2,X
  3721 1675 20 56 E4		        JSR     CIOV
  3722 1678 4C 6E 14		        JMP     DO_CLS
  3723
  3724 167B 25 1A 9B		EDEV:   .BYTE   "E:",EOL
  3725 				        
  3726 				;---------------------------------------
  3727 167E			REMOUNT_DRIVE:
  3728 				;---------------------------------------
  3729
  3730 				    ;---------------------------------------
  3731 				    ; Workaround for timeout issue regarding idempotent commands that
  3732 				    ; unmount the server.  So far, these are DEL and RENAME. This
  3733 				    ; routine, remounts the TNFS URL by calling NPWD and attempts
  3734 				    ; a MKDIR on the returned mount point. Hopefully this is an
  3735 				    ; non-consequential operation since the directory already exists.
  3736 				    ;---------------------------------------
  3737
  3738 167E 20 84 11		        JSR     DO_NPWD         ; Curr dir for drive now in RBUF
  3739
  3740 1681 AD 00 19		        LDA     RBUF            ; Quit if not TNFS. Only TNFS is affected.
  3741 1684 C9 54		        CMP     #'T'            ; TODO More letters needed if...
  3742 1686 D0 28		        BNE     REMOUNT_DONE    ; ...another Txxx protocol exists
  3743
  3744 1688 A9 4E		        LDA     #'N'
  3745 168A 8D 00 19		        STA     RBUF+0
  3746 168D AD 85 18		        LDA     DOSDR           ; Get drive number
  3747 1690 09 30		        ORA     #'0'            ; Convert, say, 1 to '1'
  3748 1692 8D 01 19		        STA     RBUF+1
  3749 1695 A9 3A		        LDA     #':'
  3750 1697 8D 02 19		        STA     RBUF+2
  3751
  3752 169A A9 2A		        LDA     #CMD_MKDIR
  3753 169C 8D E9 0D		        STA     GENDCB+2
  3754 169F A9 00		        LDA     #<RBUF          ; TODO Is this needed
  3755 16A1 8D EB 0D		        STA     GENDCB+4        ; TODO or is it hardcoded in DO_GENERIC?
  3756 16A4 A9 19		        LDA     #>RBUF
  3757 16A6 8D EC 0D		        STA     GENDCB+5
  3758
  3759 16A9 A9 E7		        LDA     #<GENDCB
  3760 16AB A0 0D		        LDY     #>GENDCB
  3761 16AD 4C A5 07		        JMP     DOSIOV
  3762
  3763 16B0			REMOUNT_DONE:
  3764 16B0 60			        RTS
  3765
  3766 				;---------------------------------------
  3767 16B1			PREPEND_DRIVE:
  3768 				;---------------------------------------
  3769 				        ; Inject "Nn:" in front of a plain filename
  3770 				        ; before passing it to the FujiNet
  3771 16B1 A0 00		        LDY     #$00
  3772 16B3 A9 4E		        LDA     #'N'
  3773 16B5 D1 F3		        CMP     (INBUFF),Y  ; Does arg1 already begin with N?
  3774
  3775 16B7 A0 02		        LDY     #$02
  3776 16B9 A9 3A		        LDA     #':'
  3777 16BB D1 F3		        CMP     (INBUFF),Y
  3778 16BD F0 1C		        BEQ     PREPEND_DRIVE_DONE
  3779 16BF 88			        DEY
  3780 16C0 D1 F3		        CMP     (INBUFF),Y
  3781 16C2 F0 17		        BEQ     PREPEND_DRIVE_DONE
  3782
  3783 				        ; Move input buffer pointer back 3 bytes
  3784 16C4 38			        SEC
  3785 16C5 A5 F3		        LDA     INBUFF
  3786 16C7 E9 03		        SBC     #$03
  3787 16C9 85 F3		        STA     INBUFF
  3788 16CB A5 F4		        LDA     INBUFF+1
  3789 16CD E9 00		        SBC     #$00
  3790 16CF 85 F4		        STA     INBUFF+1
  3791
  3792 				        ; Inject PRMPT to front of arg1
  3793 16D1 A0 03		        LDY     #$03
  3794 16D3			PREPEND_DRIVE_LOOP:
  3795 16D3 B9 05 17		        LDA     PRMPT,Y
  3796 16D6 88			        DEY
  3797 16D7 91 F3		        STA     (INBUFF),Y
  3798 16D9 D0 F8		        BNE     PREPEND_DRIVE_LOOP
  3799
  3800 16DB			PREPEND_DRIVE_DONE:
  3801 16DB A0 01		        LDY     #$01
  3802 16DD 60			        RTS             ; Y = $00 here
  3803
  3804 				;---------------------------------------
  3805 16DE			APPEND_SLASH:
  3806 				;---------------------------------------
  3807 				    ;---------------------------------------
  3808 				    ; Skip if relative path (..)
  3809 				    ;---------------------------------------
  3810 16DE A0 00		        LDY     #$00
  3811 16E0 A9 2E		        LDA     #'.'
  3812 16E2 D1 F3		        CMP     (INBUFF),Y
  3813 16E4 F0 1E		        BEQ     APPEND_SLASH_DONE
  3814
  3815 16E6 A0 FF		        LDY     #$FF        ; Iterate thru arg2 until EOF
  3816 16E8			APPEND_SLASH_LOOP:
  3817 16E8 C8			        INY                 ; Zero on 1st pass
  3818 16E9 B1 F3		        LDA     (INBUFF),Y
  3819 16EB C9 9B		        CMP     #EOL
  3820 16ED D0 F9		        BNE     APPEND_SLASH_LOOP
  3821
  3822 16EF 88			        DEY                 ; Move pointer back one character
  3823 16F0 B1 F3		        LDA     (INBUFF),Y
  3824 16F2 C9 2F		        CMP     #'/'        ; If already slash then skip rest
  3825 16F4 F0 0E		        BEQ     APPEND_SLASH_DONE
  3826 16F6 C9 3A		        CMP     #':'        ; If a drive, skip
  3827 16F8 F0 0A		        BEQ     APPEND_SLASH_DONE
  3828
  3829 16FA C8			        INY                 ; Else inject '/' + EOL
  3830 16FB A9 2F		        LDA     #'/'
  3831 16FD 91 F3		        STA     (INBUFF),Y
  3832 16FF C8			        INY
  3833 1700 A9 9B		        LDA     #EOL
  3834 1702 91 F3		        STA     (INBUFF),Y
  3835
  3836 1704			APPEND_SLASH_DONE:
  3837 1704 60			        RTS
  3838
  3839 1705			PRMPT:
  3840 1705 9B 4E 20 3A		        .BYTE   EOL,'N :'
  3841
  3842 				;;; End CP ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  3843 				;;; Variables
  3844
  3845 1709			        .ENUM   CMD_IDX
  3846 				        ;---------------
  3847 = 0000			                NCD                 ;  0
  3848 				;               COPY                ;  1
  3849 = 0001			                DIR                 ;  2
  3850 = 0002			                DEL                 ;  3
  3851 = 0003			                LOAD                ;  4
  3852 = 0004			                LOCK                ;  5
  3853 = 0005			                LPR                 ;  6
  3854 = 0006			                MKDIR               ;  7
  3855 = 0007			                NPWD                ;  8
  3856 = 0008			                NTRANS              ;  9
  3857 = 0009			                PASS                ; 10
  3858 = 000A			                RENAME              ; 11
  3859 = 000B			                RMDIR               ; 12
  3860 = 000C			                SAVE                ; 13
  3861 = 000D			                SUBMIT              ; 14
  3862 = 000E			                TYPE                ; 15
  3863 = 000F			                USER                ; 16
  3864 = 0010			                UNLOCK              ; 17
  3865 = 0011			                AUTORUN             ; 18
  3866 = 0012			                CAR                 ; 19
  3867 = 0013			                CLS                 ; 20
  3868 = 0014			                COLD                ; 21
  3869 = 0015			                HELP                ; 22
  3870 = 0016			                BASIC               ; 23
  3871 = 0017			                NOSCREEN            ; 24
  3872 = 0018			                PRINT               ; 25
  3873 = 0019			                REENTER             ; 26
  3874 = 001A			                REM                 ; 27
  3875 = 001B			                RUN                 ; 28
  3876 = 001C			                SCREEN              ; 29
  3877 = 001D			                WARM                ; 20
  3878 = 001E			                XEP                 ; 31
  3879 = 001F			                DRIVE_CHG           ; 32
  3880 				        .ENDE
  3881
  3882 1709			CMD_DCOMND:
  3883 1709 2C			        .BYTE   CMD_CD              ;  0 NCD
  3884 				;       .BYTE   CMD_COPY            ;  1 COPY
  3885 170A 02			        .BYTE   CMD_DIR             ;  2 DIR
  3886 170B 21			        .BYTE   CMD_DEL             ;  3 DEL
  3887 170C 28			        .BYTE   CMD_LOAD            ;  4 LOAD
  3888 170D 23			        .BYTE   CMD_LOCK            ;  5 LOCK
  3889 170E F0			        .BYTE   CMD_LPR             ;  6 LPR
  3890 170F 2A			        .BYTE   CMD_MKDIR           ;  7 MKDIR
  3891 1710 30			        .BYTE   CMD_NPWD            ;  8 NPWD
  3892 1711 54			        .BYTE   CMD_NTRANS          ;  9 NTRANS
  3893 1712 FE			        .BYTE   CMD_PASS            ; 10 PASS
  3894 1713 20			        .BYTE   CMD_RENAME          ; 11 RENAME
  3895 1714 2B			        .BYTE   CMD_RMDIR           ; 12 RMDIR
  3896 1715 F0			        .BYTE   CMD_SAVE            ; 13 SAVE
  3897 1716 F0			        .BYTE   CMD_SUBMIT          ; 14 SUBMIT
  3898 1717 F0			        .BYTE   CMD_TYPE            ; 15 TYPE
  3899 1718 FD			        .BYTE   CMD_USER            ; 16 USER
  3900 1719 24			        .BYTE   CMD_UNLOCK          ; 17 UNLOCK
  3901 171A F0			        .BYTE   CMD_AUTORUN         ; 18 AUTORUN
  3902 171B F0			        .BYTE   CMD_CAR             ; 19 CAR
  3903 171C F0			        .BYTE   CMD_CLS             ; 20 CLS
  3904 171D F0			        .BYTE   CMD_COLD            ; 21 COLD
  3905 171E F0			        .BYTE   CMD_HELP            ; 22 HELP
  3906 171F F0			        .BYTE   CMD_BASIC           ; 23 BASIC
  3907 1720 F0			        .BYTE   CMD_NOSCREEN        ; 24 NOSCREEN
  3908 1721 F0			        .BYTE   CMD_PRINT           ; 25 PRINT
  3909 1722 F0			        .BYTE   CMD_REENTER         ; 26 REENTER
  3910 1723 F0			        .BYTE   CMD_REM             ; 27 REM
  3911 1724 F0			        .BYTE   CMD_RUN             ; 28 RUN
  3912 1725 F0			        .BYTE   CMD_SCREEN          ; 29 SCREEN
  3913 1726 F0			        .BYTE   CMD_WARM            ; 20 WARM
  3914 1727 F0			        .BYTE   CMD_XEP             ; 31 XEP
  3915 1728 01			        .BYTE   CMD_DRIVE_CHG       ; 32
  3916
  3917 1729			COMMAND:
  3918 1729 4E 43 C4		        .CB     "NCD"               ;  0 NCD
  3919 172C 00			        .BYTE   CMD_IDX.NCD            
  3920
  3921 				;       .CB     "COPY"              ;  1 COPY
  3922 				;       .BYTE   CMD_IDX.COPY           
  3923
  3924 172D 44 49 D2		        .CB     "DIR"               ;  2 DIR
  3925 1730 01			        .BYTE   CMD_IDX.DIR              
  3926
  3927 1731 44 45 CC		        .CB     "DEL"               ;  3 DEL
  3928 1734 02			        .BYTE   CMD_IDX.DEL              
  3929
  3930 1735 4C 4F 41 C4		        .CB     "LOAD"              ;  4 LOAD
  3931 1739 03			        .BYTE   CMD_IDX.LOAD             
  3932
  3933 173A 4C 4F 43 CB		        .CB     "LOCK"              ;  5 LOCK
  3934 173E 04			        .BYTE   CMD_IDX.LOCK             
  3935
  3936 173F 4C 50 D2		        .CB     "LPR"               ;  6 LPR
  3937 1742 05			        .BYTE   CMD_IDX.LPR              
  3938 				                                        
  3939 1743 4D 4B 44 49 D2	        .CB     "MKDIR"             ;  7 MKDIR
  3940 1748 06			        .BYTE   CMD_IDX.MKDIR           
  3941 				                                        
  3942 1749 4E 50 57 C4		        .CB     "NPWD"              ;  8 NPWD
  3943 174D 07			        .BYTE   CMD_IDX.NPWD             
  3944 				                                        
  3945 174E 4E 54 52 41 4E D3	        .CB     "NTRANS"            ;  9 NTRANS
  3946 1754 08			        .BYTE   CMD_IDX.NTRANS            
  3947 				                                        
  3948 1755 50 41 53 D3		        .CB     "PASS"              ; 10 PASS
  3949 1759 09			        .BYTE   CMD_IDX.PASS             
  3950 				                                         
  3951 175A 52 45 4E 41 4D C5	        .CB     "RENAME"            ; 11 RENAME
  3952 1760 0A			        .BYTE   CMD_IDX.RENAME          
  3953 				                                        
  3954 1761 52 4D 44 49 D2	        .CB     "RMDIR"             ; 12 RMDIR
  3955 1766 0B			        .BYTE   CMD_IDX.RMDIR           
  3956 				                                        
  3957 1767 53 41 56 C5		        .CB     "SAVE"              ; 13 SAVE
  3958 176B 0C			        .BYTE   CMD_IDX.SAVE            
  3959 				                                         
  3960 176C 53 55 42 4D 49 D4	        .CB     "SUBMIT"            ; 14 SUBMIT
  3961 1772 0D			        .BYTE   CMD_IDX.SUBMIT             
  3962 				                                        
  3963 1773 54 59 50 C5		        .CB     "TYPE"              ; 15 TYPE
  3964 1777 0E			        .BYTE   CMD_IDX.TYPE                
  3965 				                                          
  3966 1778 55 53 45 D2		        .CB     "USER"              ;  16 USER
  3967 177C 0F			        .BYTE   CMD_IDX.USER              
  3968 				                                        
  3969 177D 55 4E 4C 4F 43 CB	        .CB     "UNLOCK"            ; 17 UNLOCK
  3970 1783 10			        .BYTE   CMD_IDX.UNLOCK            
  3971 				                                        
  3972 1784 41 55 54 4F 52 55 +         .CB     "AUTORUN"           ; 18 AUTORUN
  3973 178B 11			        .BYTE   CMD_IDX.AUTORUN           
  3974 				                                          
  3975 178C 43 41 D2		        .CB     "CAR"               ; 19 CAR
  3976 178F 12			        .BYTE   CMD_IDX.CAR             
  3977 				                                        
  3978 1790 43 4C D3		        .CB     "CLS"               ; 20 CLS
  3979 1793 13			        .BYTE   CMD_IDX.CLS             
  3980 				                                        
  3981 1794 43 4F 4C C4		        .CB     "COLD"              ; 21 COLD
  3982 1798 14			        .BYTE   CMD_IDX.COLD              
  3983 				                                        
  3984 1799 48 45 4C D0		        .CB     "HELP"              ; 22 HELP
  3985 179D 15			        .BYTE   CMD_IDX.HELP               
  3986
  3987 179E 42 41 53 49 C3	        .CB     "BASIC"             ; 23 NOBASIC
  3988 17A3 16			        .BYTE   CMD_IDX.BASIC           
  3989 				                                        
  3990 17A4 40 4E 4F 53 43 52 +         .CB     "@NOSCREEN"         ; 24 @NOSCREEN
  3991 17AD 17			        .BYTE   CMD_IDX.NOSCREEN       
  3992 				                                      
  3993 17AE 50 52 49 4E D4	        .CB     "PRINT"             ; 25 PRINT
  3994 17B3 18			        .BYTE   CMD_IDX.PRINT           
  3995 				                                        
  3996 17B4 52 45 45 4E 54 45 +         .CB     "REENTER"           ; 26 REENTER
  3997 17BB 19			        .BYTE   CMD_IDX.REENTER         
  3998 				                                        
  3999 17BC 52 45 CD		        .CB     "REM"               ; 27 REM
  4000 17BF 1A			        .BYTE   CMD_IDX.REM             
  4001 				                                        
  4002 17C0 52 55 CE		        .CB     "RUN"               ; 28 RUN
  4003 17C3 1B			        .BYTE   CMD_IDX.RUN             
  4004 				                                        
  4005 17C4 40 53 43 52 45 45 +         .CB     "@SCREEN"           ; 29 @SCREEN
  4006 17CB 1C			        .BYTE   CMD_IDX.SCREEN          
  4007 				                                        
  4008 17CC 57 41 52 CD		        .CB     "WARM"              ; 30 WARM
  4009 17D0 1D			        .BYTE   CMD_IDX.WARM           
  4010 				                                       
  4011 17D1 58 45 D0		        .CB     "XEP"               ; 31 XEP
  4012 17D4 1E			        .BYTE   CMD_IDX.XEP            
  4013 				                                        
  4014 				        ; Drive Change intentionally omitted
  4015
  4016 				; Aliases
  4017 17D5 43 C4		        .CB     "CD"                ; CD = NCD
  4018 17D7 00			        .BYTE   CMD_IDX.NCD           
  4019
  4020 17D8 43 57 C4		        .CB     "CWD"               ; CWD = NCD
  4021 17DB 00			        .BYTE   CMD_IDX.NCD           
  4022
  4023 17DC 45 52 41 53 C5	        .CB     "ERASE"             ; ERASE = DEL
  4024 17E1 02			        .BYTE   CMD_IDX.DEL           
  4025
  4026 17E2 45 52 C1		        .CB     "ERA"               ; ERA = DEL
  4027 17E5 02			        .BYTE   CMD_IDX.DEL           
  4028
  4029 17E6 D8			        .CB     "X"                 ; X = LOAD
  4030 17E7 03			        .BYTE   CMD_IDX.LOAD
  4031
  4032 17E8 50 57 C4		        .CB     "PWD"               ; PWD = NPWD
  4033 17EB 07			        .BYTE   CMD_IDX.NPWD             
  4034
  4035 17EC 52 45 C5		        .CB     "REE"               ; R = REENTER
  4036 17EF 19			        .BYTE   CMD_IDX.REENTER             
  4037
  4038 17F0 52 45 CE		        .CB     "REN"               ; REN = RENAME
  4039 17F3 0A			        .BYTE   CMD_IDX.RENAME
  4040
  4041 17F4 53 4F 55 52 43 C5	        .CB     "SOURCE"            ; SOURCE = SUBMIT
  4042 17FA 0D			        .BYTE   CMD_IDX.SUBMIT
  4043
  4044 17FB C0			        .CB     "@"                 ; @ = SUBMIT
  4045 17FC 0D			        .BYTE   CMD_IDX.SUBMIT
  4046
  4047 17FD A3			        .CB     "#"                 ; # = REM
  4048 17FE 1A			        .BYTE   CMD_IDX.REM
  4049
  4050 17FF A7			        .CB     "'"                 ; ' = REM
  4051 1800 1A			        .BYTE   CMD_IDX.REM
  4052
  4053 				        ; With U1MB, a non-BASIC program might reside
  4054 				        ; in ROM, then BASIC and NOBASIC feel awkward.
  4055 				        ; So, ROMON and ROMOFF. (I know. Inconsistent.)
  4056
  4057 1801 52 4F CD		        .CB     "ROM"               ; ROMON = BASIC
  4058 1804 16			        .BYTE   CMD_IDX.BASIC      
  4059
  4060 = 00DB			COMMAND_SIZE = * - COMMAND - 1
  4061 1805 FF			        .BYTE   $FF
  4062
  4063 1806			CMD_TAB_L:
  4064 1806 7D			        .BYTE   <(DO_GENERIC-1)     ;  0 NCD
  4065 				;       .BYTE   <(DO_COPY-1)        ;  1 COPY
  4066 1807 F2			        .BYTE   <(DO_DIR-1)         ;  2 DIR
  4067 1808 7D			        .BYTE   <(DO_GENERIC-1)     ;  3 DEL
  4068 1809 DC			        .BYTE   <(DO_LOAD-1)        ;  4 LOAD
  4069 180A 7D			        .BYTE   <(DO_GENERIC-1)     ;  5 LOCK
  4070 180B 7D			        .BYTE   <(DO_LPR-1)         ;  6 LPR
  4071 180C 7D			        .BYTE   <(DO_GENERIC-1)     ;  7 MKDIR
  4072 180D 83			        .BYTE   <(DO_NPWD-1)        ;  8 NPWD
  4073 180E C6			        .BYTE   <(DO_NTRANS-1)      ;  9 NTRANS
  4074 180F 7D			        .BYTE   <(DO_GENERIC-1)     ; 10 PASS
  4075 1810 7D			        .BYTE   <(DO_GENERIC-1)     ; 11 RENAME
  4076 1811 7D			        .BYTE   <(DO_GENERIC-1)     ; 12 RMDIR
  4077 1812 09			        .BYTE   <(DO_SAVE-1)        ; 13 SAVE
  4078 1813 18			        .BYTE   <(DO_SUBMIT-1)      ; 14 SUBMIT
  4079 1814 9D			        .BYTE   <(DO_TYPE-1)        ; 15 TYPE
  4080 1815 7D			        .BYTE   <(DO_GENERIC-1)     ; 16 USER
  4081 1816 7D			        .BYTE   <(DO_GENERIC-1)     ; 17 UNLOCK
  4082 1817 49			        .BYTE   <(DO_AUTORUN-1)     ; 18 AUTORUN
  4083 1818 46			        .BYTE   <(DO_CAR-1)         ; 19 CAR
  4084 1819 6D			        .BYTE   <(DO_CLS-1)         ; 20 CLS
  4085 181A 76			        .BYTE   <(DO_COLD-1)        ; 21 COLD
  4086 181B 79			        .BYTE   <(DO_HELP-1)        ; 22 HELP
  4087 181C 2A			        .BYTE   <(DO_BASIC-1)       ; 23 BASIC
  4088 181D 92			        .BYTE   <(DO_NOSCREEN-1)    ; 24 NOSCREEN
  4089 181E 9E			        .BYTE   <(DO_PRINT-1)       ; 25 PRINT
  4090 181F AC			        .BYTE   <(DO_REENTER-1)     ; 26 REENTER
  4091 1820 F6			        .BYTE   <(DO_REM-1)         ; 27 REM
  4092 1821 F7			        .BYTE   <(DO_RUN-1)         ; 28 RUN
  4093 1822 98			        .BYTE   <(DO_SCREEN-1)      ; 29 SCREEN
  4094 1823 4A			        .BYTE   <(DO_WARM-1)        ; 20 WARM
  4095 1824 4D			        .BYTE   <(DO_XEP-1)         ; 31 XEP
  4096 1825 36			        .BYTE   <(DO_DRIVE_CHG-1)   ; 32
  4097
  4098 1826			CMD_TAB_H:
  4099 1826 0D			        .BYTE   >(DO_GENERIC-1)     ;  0 NCD
  4100 				;       .BYTE   >(DO_COPY-1)        ;  1 COPY
  4101 1827 0D			        .BYTE   >(DO_DIR-1)         ;  2 DIR
  4102 1828 0D			        .BYTE   >(DO_GENERIC-1)     ;  3 DEL
  4103 1829 0E			        .BYTE   >(DO_LOAD-1)        ;  4 LOAD
  4104 182A 0D			        .BYTE   >(DO_GENERIC-1)     ;  5 LOCK
  4105 182B 11			        .BYTE   >(DO_LPR-1)         ;  6 LPR
  4106 182C 0D			        .BYTE   >(DO_GENERIC-1)     ;  7 MKDIR
  4107 182D 11			        .BYTE   >(DO_NPWD-1)        ;  8 NPWD
  4108 182E 11			        .BYTE   >(DO_NTRANS-1)      ;  9 NTRANS
  4109 182F 0D			        .BYTE   >(DO_GENERIC-1)     ; 10 PASS
  4110 1830 0D			        .BYTE   >(DO_GENERIC-1)     ; 11 RENAME
  4111 1831 0D			        .BYTE   >(DO_GENERIC-1)     ; 12 RMDIR
  4112 1832 16			        .BYTE   >(DO_SAVE-1)        ; 13 SAVE
  4113 1833 13			        .BYTE   >(DO_SUBMIT-1)      ; 14 SUBMIT
  4114 1834 13			        .BYTE   >(DO_TYPE-1)        ; 15 TYPE
  4115 1835 0D			        .BYTE   >(DO_GENERIC-1)     ; 16 USER
  4116 1836 0D			        .BYTE   >(DO_GENERIC-1)     ; 17 UNLOCK
  4117 1837 12			        .BYTE   >(DO_AUTORUN-1)     ; 18 AUTORUN
  4118 1838 14			        .BYTE   >(DO_CAR-1)         ; 19 CAR
  4119 1839 14			        .BYTE   >(DO_CLS-1)         ; 20 CLS
  4120 183A 14			        .BYTE   >(DO_COLD-1)        ; 21 COLD
  4121 183B 14			        .BYTE   >(DO_HELP-1)        ; 22 HELP
  4122 183C 15			        .BYTE   >(DO_BASIC-1)       ; 23 BASIC
  4123 183D 15			        .BYTE   >(DO_NOSCREEN-1)    ; 24 NOSCREEN
  4124 183E 15			        .BYTE   >(DO_PRINT-1)       ; 25 PRINT
  4125 183F 15			        .BYTE   >(DO_REENTER-1)     ; 26 REENTER
  4126 1840 15			        .BYTE   >(DO_REM-1)         ; 27 REM
  4127 1841 15			        .BYTE   >(DO_RUN-1)         ; 28 RUN
  4128 1842 15			        .BYTE   >(DO_SCREEN-1)      ; 29 SCREEN
  4129 1843 16			        .BYTE   >(DO_WARM-1)        ; 20 WARM
  4130 1844 16			        .BYTE   >(DO_XEP-1)         ; 31 XEP
  4131 1845 0D			        .BYTE   >(DO_DRIVE_CHG-1)   ; 32
  4132
  4133 				        ; DEVHDL TABLE FOR N:
  4134
  4135 1846 BD 07		CIOHND  .WORD   OPEN-1
  4136 1848 0B 08		        .WORD   CLOSE-1
  4137 184A 2C 08		        .WORD   GET-1
  4138 184C 8D 08		        .WORD   PUT-1
  4139 184E ED 08		        .WORD   STATUS-1
  4140 1850 53 09		        .WORD   SPEC-1
  4141
  4142 				       ; BANNERS
  4143
  4144 1852 23 46 55 4A 49 4E + BREADY  .BYTE   '#FUJINET NOS v0.5.1-alpha',EOL
  4145 186C 23 46 55 4A 49 4E + BERROR  .BYTE   '#FUJINET ERROR',EOL
  4146
  4147 				        ; MESSAGES
  4148
  4149 187B 4E 6E 3F 9B		CDERR   .BYTE   'Nn?',EOL
  4150
  4151 				        ; STRING CONSTANTS
  4152
  4153 187F			MISSING_FILE_STR:
  4154 187F 46 49 4C 45 3F 9B	        .BYTE   'FILE?',EOL
  4155
  4156 				        ; VARIABLES
  4157
  4158 1885 01			DOSDR       .BYTE   $01     ; DOS DRIVE
  4159 1886 01			CMD         .BYTE   $01
  4160 1887 01			CMDPRV      .BYTE   $01
  4161 1888 01			ECHO_FLG    .BYTE   $01     ; Echo batch cmds (1=enabled,0=disabled)
  4162 1889 00			AUTORUN_FLG .BYTE   $00     ; Checked at DOS entry. Runs only on first pass
  4163
  4164 188A 01			TRIP        .BYTE   $01     ; INTR FLAG
  4165 188B 00 00 00 00		RLEN    :MAXDEV .BYTE $00   ; RCV LEN
  4166 188F 00 00 00 00		ROFF    :MAXDEV .BYTE $00   ; RCV OFFSET
  4167 1893 00 00 00 00		TOFF    :MAXDEV .BYTE $00   ; TRX OFFSET
  4168 1897 01			INQDS       .BYTE   $01     ; DSTATS INQ
  4169
  4170 1898 00 00 00 00		DVS2    :MAXDEV .BYTE $00   ; DVSTAT+2 SAVE
  4171 189C 00 00 00 00		DVS3    :MAXDEV .BYTE $00   ; DVSTAT+3 SAVE
  4172
  4173 18A0 00			PRINT_ERR_FLG   .BYTE $00
  4174
  4175 18A1 00			COLOR4_ORIG .BYTE   $00     ; Hold prev border color
  4176
  4177 				       ; BUFFERS (PAGE ALIGNED)
  4178 18A2 00 00 00 00 00 00 +         .ALIGN  $100, $00
  4179 1900			BOOTEND:
  4180
  4181 1900 00 00 00 00 00 00 + RBUF:   :$80 .BYTE $00      ; 128 bytes
  4182 1980 00 00 00 00 00 00 + TBUF:   :$80 .BYTE $00      ; 128 bytes
  4183
  4184 				; Binary loader working variables
  4185 = 1900			BAL     = RBUF
  4186 = 1901			BAH     = RBUF+1    ;
  4187 = 1980			STL     = TBUF      ; Payload Start address
  4188 = 1981			STH     = TBUF+1
  4189 = 1982			ENL     = TBUF+2    ; Payload End address
  4190 = 1983			ENH     = TBUF+3
  4191 = 1984			BLL     = TBUF+4    ; Payload Buffer Length
  4192 = 1985			BLH     = TBUF+5
  4193 = 1986			HEADL   = TBUF+6    ; Bytes read from existing cache
  4194 = 1987			HEADH   = TBUF+7
  4195 = 1988			BODYL   = TBUF+8    ; Total bytes read in contiguous 512-byte blocks
  4196 = 1989			BODYH   = TBUF+9
  4197 = 198A			TAILL   = TBUF+10   ; Bytes read from last cache
  4198 = 198B			TAILH   = TBUF+11
  4199 = 198C			BODYSZL = TBUF+12   ; # Bytes to read at a time in Body
  4200 = 198D			BODYSZH = TBUF+13
  4201 = 198E			STL2    = TBUF+14   ; Payload Start address (working var)
  4202 = 198F			STH2    = TBUF+15
  4203 = 1990			BIN_1ST = TBUF+16   ; Flag for binary loader signature (FF -> 1st pass)
  4204 = 1991			AUTORUN_QUERY_FLG = TBUF+17   ; Flag for printing contents of autorun appkey
  4205
  4206 = 1A00			PGEND   = *
  4207
  4208 				; =================================================================
  4209 				; VTOC and Directory
  4210 				;
  4211
  4212 				; $10 is the added ATR-header
  4213 1A00 00 00 00 00 00 00 + :($B390-*+HDR-$10) DTA $00
  4214 BA80			VTOCSTA:
  4215 BA80 02 BD 02		    DTA $02,$BD,$02
  4216 BA83			VTOCEND:
  4217
  4218 				; Fill the remaining bytes of the VTOC sector
  4219 BA83 00 00 00 00 00 00 +     :($80+VTOCSTA-VTOCEND) DTA $00
  4220
  4221 BB00			DIRSTA:
  4222 BB00 60 C3 02 04 00 30 +     DTA $60,$C3,$02,$04,$00,C"0**********"
  4223 BB10 60 C3 02 04 00 31 +     DTA $60,$C3,$02,$04,$00,C"1 FujiNet  "
  4224 BB20 60 C3 02 04 00 32 +     DTA $60,$C3,$02,$04,$00,C"2 Network  "
  4225 BB30 60 C3 02 04 00 33 +     DTA $60,$C3,$02,$04,$00,C"3   OS     "
  4226 BB40 60 C3 02 04 00 34 +     DTA $60,$C3,$02,$04,$00,C"4          "
  4227 BB50 60 C3 02 04 00 35 +     DTA $60,$C3,$02,$04,$00,C"5 v0.5.1   "
  4228 BB60 60 C3 02 04 00 36 +     DTA $60,$C3,$02,$04,$00,C"6  alpha   "
  4229 BB70 60 C3 02 04 00 37 +     DTA $60,$C3,$02,$04,$00,C"7**********"
  4230 BB80 C0			    DTA $C0
  4231 BB81			DIREND:
  4232
  4233 				; Fill the remaining sectors of the directory
  4234 BB81 00 00 00 00 00 00 +     :($400+DIRSTA-DIREND) DTA $00
  4235
  4236 				; Sectors behind directory
  4237 BF00 00 00 00 00 00 00 +     :($80*352) DTA $00
  4238
  4239 				       END
